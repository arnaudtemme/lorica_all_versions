

// HydroLorica v1.0 by W.M. van der Meij and A.J.A.M. Temme, 2020
// Based on Lorica by Vanwalleghem and Temme 2016
// Based on MILESD 2011 by Vanwalleghem et al and on LAPSUS by Temme, Schoorl and colleagues (2006-2011)
// 
// Credits to T.J. Coulthard for interface coding template (the CAESAR model, www.coulthard.org.uk)

//This program is free software; you can redistribute it and/or modify it under the terms of the 
//GNU General Public License as published by the Free Software Foundation;  
//This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
//without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
//See the GNU General Public License (http://www.gnu.org/copyleft/gpl.html) for more details. 
//You should have received a copy of the GNU General Public License along with this program; 
//if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
//MA 02110-1301, USA.

// June 2020


using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Net;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Numerics;
using MathNet.Numerics;
using MathNet.Numerics.IntegralTransforms;


namespace LORICA4
{
    /// <summary>
    /// Main LORICA interface
    /// </summary>
    public class Mother_form : System.Windows.Forms.Form
    {
        [DllImport("msvcrt")]
        static extern int _getch();


        #region global interface parameters
        private TabControl Process_tabs;
        private TabPage Water;
        private TextBox parameter_n_textbox;
        private TextBox parameter_conv_textbox;
        private TextBox parameter_K_textbox;
        private TextBox parameter_m_textbox;
        private CheckBox only_waterflow_checkbox;
        private PictureBox pictureBox1;
        private Label label12;
        private Label label11;
        private Label label10;
        private Label label9;
        private CheckBox Water_ero_checkbox;
        private TabPage Tillage;
        private PictureBox pictureBox2;
        private Label label20;
        private Label trte;
        private TextBox parameter_tillage_constant_textbox;
        private TextBox parameter_ploughing_depth_textbox;
        private CheckBox Tillage_checkbox;
        private TabPage Creeper;
        private PictureBox pictureBox3;
        private Label label19;
        private TextBox parameter_diffusivity_textbox;
        private CheckBox creep_active_checkbox;
        private Label label36;
        private RadioButton radio_ls_fraction;
        private RadioButton radio_ls_absolute;
        private Label label35;
        private Label label34;
        private TextBox text_ls_rel_rain_intens;
        private TextBox textBox_ls_trans;
        private TextBox textBox_ls_bd;
        private TextBox textBox_ls_ifr;
        private TextBox textBox_ls_coh;
        private TextBox text_ls_abs_rain_intens;
        private Label label32;
        private Label label31;
        private Label label30;
        private Label label22;
        private Label label18;
        private PictureBox pictureBox4;
        private CheckBox Landslide_checkbox;
        private TabPage Solifluction;
        private PictureBox pictureBox5;
        private CheckBox Solifluction_checkbox;
        private TabPage Rock_weathering;
        private PictureBox pictureBox6;
        private GroupBox groupBox10;
        private CheckBox Frost_weathering_checkbox;
        private GroupBox groupBox9;
        private TextBox parameter_k1_textbox;
        private Label label24;
        private Label label26;
        private Label label27;
        private Label label28;
        private TextBox parameter_k2_textbox;
        private TextBox parameter_Pa_textbox;
        private TextBox parameter_P0_textbox;
        private Label label21;
        private CheckBox Biological_weathering_checkbox;
        private TabPage Tectonics;
        private GroupBox groupBox14;
        private GroupBox groupBox16;
        private TextBox text_lift_col_less;
        private TextBox text_lift_col_more;
        private TextBox text_lift_row_less;
        private TextBox text_lift_row_more;
        private RadioButton radio_lift_col_less_than;
        private RadioButton radio_lift_row_more_than;
        private RadioButton radio_lift_col_more_than;
        private RadioButton radio_lift_row_less_than;
        private TextBox Uplift_rate_textbox;
        private CheckBox uplift_active_checkbox;
        private Label label39;
        private GroupBox groupBox4;
        private Label label38;
        private TextBox Tilting_rate_textbox;
        private GroupBox groupBox15;
        private RadioButton radio_tilt_col_max;
        private RadioButton radio_tilt_row_zero;
        private RadioButton radio_tilt_col_zero;
        private RadioButton radio_tilt_row_max;
        private CheckBox tilting_active_checkbox;
        private TabPage tabPage1;
        private TabControl tabControl2;
        private TabPage physical;
        private TabPage chemical;
        private TabPage clay;
        private TabPage bioturbation;
        private CheckBox soil_phys_weath_checkbox;
        private CheckBox soil_chem_weath_checkbox;
        private CheckBox soil_clay_transloc_checkbox;
        private CheckBox soil_bioturb_checkbox;
        private TextBox upper_particle_fine_clay_textbox;
        private TextBox upper_particle_clay_textbox;
        private TextBox upper_particle_silt_textbox;
        private TextBox upper_particle_sand_textbox;
        private TextBox upper_particle_coarse_textbox;
        private TextBox physical_weath_constant2;
        private TextBox physical_weath_constant1;
        private TextBox Physical_weath_C1_textbox;
        private TextBox chem_weath_specific_coefficient_textbox;
        private TextBox chem_weath_depth_constant_textbox;
        private TextBox chem_weath_rate_constant_textbox;
        private TextBox specific_area_fine_clay_textbox;
        private TextBox specific_area_clay_textbox;
        private TextBox specific_area_silt_textbox;
        private TextBox specific_area_sand_textbox;
        private TextBox specific_area_coarse_textbox;
        private TextBox clay_neoform_C2_textbox;
        private TextBox clay_neoform_C1_textbox;
        private TextBox clay_neoform_constant_textbox;
        private TextBox eluviation_coefficient_textbox;
        private TextBox maximum_eluviation_textbox;
        private TextBox bioturbation_depth_decay_textbox;
        private TextBox potential_bioturbation_textbox;
        private TabPage carbon;
        private TextBox carbon_y_depth_decay_textbox;
        private TextBox carbon_humification_fraction_textbox;
        private TextBox carbon_depth_decay_textbox;
        private TextBox carbon_input_textbox;
        private CheckBox soil_carbon_cycle_checkbox;
        private TextBox carbon_o_twi_decay_textbox;
        private TextBox carbon_y_twi_decay_textbox;
        private TextBox carbon_o_depth_decay_textbox;
        private TextBox carbon_o_decomp_rate_textbox;
        private TextBox carbon_y_decomp_rate_textbox;


        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.MenuItem menuItemConfigFile;
        private System.Windows.Forms.MenuItem menuItemConfigFileOpen;
        private System.Windows.Forms.MenuItem menuItemConfigFileSave;
        private System.Windows.Forms.MenuItem menuItemConfigFileSaveAs;
        private System.Windows.Forms.StatusBar statusBar1;
        private System.Windows.Forms.StatusBarPanel TimeStatusPanel;
        private System.Windows.Forms.StatusBarPanel ProcessStatusPanel;
        private System.Windows.Forms.StatusBarPanel InfoStatusPanel;
        private System.Windows.Forms.Button start_button;
        private System.Windows.Forms.Button End_button;
        private System.Windows.Forms.ToolTip toolTip1;
        private OpenFileDialog openFileDialog1;
        private Label label1;
        private Button button6;
        private TextBox textBox1;
        private TextBox textBox2;
        private Label label2;
        private StatusBarPanel out_sed_statuspanel;
        private StatusBarPanel total_tillage_statuspanel;
        private TabPage Output;
        private GroupBox groupBox6;
        private GroupBox groupBox1;
        private CheckBox water_output_checkbox;
        private CheckBox depressions_output_checkbox;
        private CheckBox all_process_output_checkbox;
        private CheckBox Soildepth_output_checkbox;
        private CheckBox Alt_change_output_checkbox;
        private CheckBox Altitude_output_checkbox;
        private CheckedListBox checkedListBox1;
        private CheckBox Regular_output_checkbox;
        private CheckBox Final_output_checkbox;
        private TextBox Box_years_output;
        private GroupBox groupBox5;
        private GroupBox UTMgroupBox;
        private TextBox textBox6;
        private CheckBox UTMsouthcheck;
        private TextBox UTMzonebox;
        private CheckBox UTMgridcheckbox;
        private TextBox textBox4;
        private TextBox googleBeginDate;
        private TextBox googAnimationSaveInterval;
        private TextBox googleAnimationTextBox;
        private TextBox saveintervalbox;
        private TextBox textBoxAVIFile;
        private Label label78;
        private Label label79;
        private CheckBox googleAnimationCheckbox;
        private Label label33;
        private CheckBox checkBoxGenerateAVIFile;
        private TabPage Run;
        private GroupBox groupBox7;
        private RadioButton runs_checkbox;
        private Label label16;
        private TextBox Number_runs_textbox;
        private TabPage Input;
        private TextBox tillfields_constant_textbox;
        private TextBox tillfields_input_filename_textbox;
        private TextBox evap_constant_value_box;
        private TextBox evap_input_filename_textbox;
        private TextBox infil_constant_value_box;
        private TextBox infil_input_filename_textbox;
        private TextBox rainfall_constant_value_box;
        private TextBox landuse_constant_value_box;
        private TextBox soildepth_constant_value_box;
        private TextBox landuse_input_filename_textbox;
        private TextBox soildepth_input_filename_textbox;
        private TextBox rain_input_filename_textbox;
        private TextBox dtm_input_filename_textbox;
        private GroupBox groupBox8;
        private CheckBox fill_sinks_before_checkbox;
        private CheckBox check_space_evap;
        private CheckBox check_space_infil;
        private CheckBox check_space_rain;
        private CheckBox check_space_till_fields;
        private CheckBox check_space_landuse;
        private CheckBox check_space_soildepth;
        private Label label17;
        private Label label15;
        private Label label14;
        private Label label7;
        private Label label5;
        private Label label4;
        private Label label3;
        private Label label25;
        private Label label23;
        private TabPage Processes;
        private CheckBox Creep_Checkbox;
        private TabControl tabControl1;
        private GroupBox groupBox12;
        private GroupBox groupBox11;
        private Label label8;
        private RadioButton annual_output_checkbox;
        private RadioButton cumulative_output_checkbox;
        private GroupBox groupBox13;
        private CheckBox fill_sinks_during_checkbox;
        private CheckBox check_space_DTM;
        private CheckBox check_time_evap;
        private CheckBox check_time_infil;
        private CheckBox check_time_rain;
        private CheckBox check_time_till_fields;
        private CheckBox check_time_landuse;
        private Label label29;
        private Button explain_input_button;
        private MenuItem Menu_About_box;
        private Button timeseries_form_button;
        private Button button2;
        private Button button3;
        private Button button1;
        private Label label37;
        private TextBox outputcode_textbox;
        private CheckBox diagnostic_output_checkbox;
        private GroupBox groupBox3;
        private Button landuse_determinator_button;
        #endregion

        #region global model parameters
        private Label label87;
        private TextBox selectivity_constant_textbox;
        private TextBox bio_protection_constant_textbox;
        private TextBox erosion_threshold_textbox;
        private TextBox rock_protection_constant_textbox;
        private Label label90;
        private Label label91;
        private Label label92;
        private Label label88;
        private Button soil_specify_button;
        private CheckBox Ik_ben_Marijn;
        private CheckBox CT_depth_decay_checkbox;
        private TextBox ct_depth_decay;
        private CheckBox calibration;
        private CheckBox creep_testing;
        private ComboBox rockweath_method;
        private CheckBox daily_water;
        private TabPage decalcification;
        private CheckBox decalcification_checkbox;
        private Label label94;
        private TextBox ini_CaCO3_content;
        private TabPage treefall;
        private CheckBox treefall_checkbox;
        private bool merely_calculating_derivatives;
        private Label label98;
        private TextBox temp_input_filename_textbox;
        private TextBox temp_constant_value_box;
        private Label label99;
        private CheckBox check_time_T;
        private TabPage tabPage2;
        private Label label105;
        private TextBox snowmelt_factor_textbox;
        private Label label104;
        private TextBox latitude_min;
        private Label label103;
        private TextBox latitude_deg;
        private Label label100;
        private Label label101;
        private Label label102;
        private TextBox dailyT_min;
        private TextBox dailyT_max;
        private TextBox dailyT_avg;
        private Label label97;
        private TextBox daily_n;
        private Label label96;
        private Label label93;
        private Label label89;
        private Label label40;
        private TextBox dailyET0;
        private TextBox dailyD;
        private TextBox dailyP;
        private Label label106;
        private TextBox snow_threshold_textbox;
        private TextBox ct_v0_Jagercikova;
        private TextBox ct_dd_Jagercikova;
        private System.Windows.Forms.Timer timer1;
        private Label label109;
        private Label label108;
        private CheckBox ct_Jagercikova;
        private CheckBox check_scaling_daily_weather;
        private TextBox tf_D;
        private Label label95;
        private Label label107;
        private TextBox tf_W;
        private TextBox tf_growth;
        private Label label110;
        private TextBox tf_age;
        private Label label111;
        private TextBox tf_freq;
        private Label label112;
        private GroupBox groupBox2;
        private Label label118;
        private Label label117;
        private Label label115;
        private Label label114;
        private RadioButton Sensitivity_button;
        private RadioButton Calibration_button;
        private Label label113;
        private TextBox calibration_ratios_textbox;
        private TextBox calibration_levels_textbox;
        private Label label116;
        private TextBox calibration_ratio_reduction_parameter_textbox;
        private Label label119;
        private Label label120;
        private CheckBox version_lux_checkbox;
        private Button button4;
        int save_interval2 = 0;



        private System.ComponentModel.IContainer components;
        Stopwatch stopwatch;
        TimeSpan geo_t, pedo_t, hydro_t, ponding_t;
        double[,,,]    //4D matrix for soil texture masses in different x,y and z for t texture classes (x,y,z,t)
                    texture_kg;                //mass in kg (per voxel = layer * thickness)

        double[,,]     //3D matrices for properties of soil layers in different x y (x,y,z)
                    layerthickness_m,         // : thickness in m 
                    young_SOM_kg,         // : OM mass in kgrams (per voxel = layer * thickness)
                    old_SOM_kg,         // : OM mass in kgrams (per voxel = layer * thickness) 
                    bulkdensity;            // : bulkdensity in kg/m3 (over the voxel = layer * thickness)


        double[,,] sediment_in_transport_kg,         // sediment mass in kg in transport per texture class
                    litter_kg;                     // Litter contents (Luxembourg case study)

        double[,]   // double matrices - these are huge memory-eaters and should be minimized 
                    // they only get that memory later, and only when needed
                    original_dtm,       //where sealevel interactions are used
                    dtm,                //altitude matrix
                    dtmchange,  	    //change in altitude matrix
                    dtmfill_A,
                    dz_soil,
                    waterflow_m3,        //discharge matrix
                    K_fac,
                    P_fac,
                    infil,              //infiltration matrix
                    dz_ero_m,             //altitude change due to erosion  (negative values)
                    dz_sed_m,             //altitude change due to sedimentation   (positive values)
                    soildepth_m,
                    young_SOM_in_transport_kg,
                    old_SOM_in_transport_kg,
                    creep,
                    bedrock_weathering_m,
                    frost_weathering,
                    solif,
                    till_result,
                    dz_till_bd,
                    dz_treefall,        // elevation change by tree fall
                    aspect,             //aspect for calculation of hillshade
                    slopeAnalysis,      //for calculation of hillshade
                    Tau,                //for graphics
                    hillshade,          //for graphics
                    sum_water_erosion,
                    sum_biological_weathering,
                    sum_frost_weathering,
                    sum_creep_grid,
                    sum_solifluction,
                    sum_tillage,
                    sum_landsliding,
                    sum_uplift,
                    sum_tilting,
                    veg,
                    evapotranspiration,
                    stslope,		    // matrix with steepest descent local slope [rad]
                    crrain,             // matrix with critical steady state rainfall for landsliding [m/d]
                    camf,               // matrix with number of contributing draining cells, multiple flow [-]
                    T_fac,              // matrix with transmissivity [m/d] values
                    C_fac,              // matrix with combined cohesion [-] values
                    Cs_fac,             // matrix with soil cohesion [kPa] values
                    bulkd,              // matrix with bulk density values [g/cm3]
                    intfr,              // matrix with angle of internal friction values [rad]
                    reserv,
                    ero_slid,
                    cel_dist,
                    sed_slid,
                    sed_bud,
                    dh_slid,
                    lake_sed_m,         //the thickness of lake sediment
                    rain,
                    timeseries_matrix,
                    lessivage_errors, // for calibration of lessivage
                    tpi,            //topographic position index
                    hornbeam_cover_fraction;   //hornbeam fraction 


        int[,]  // integer matrices
                    status_map,         //geeft aan of een cel een sink, een zadel, een flat of een top is
                    depression,         //geeft aan of een cel bij een meer hoort, en welk meer
                    slidemap,
                    soilmap,            // integer numbers for soil map
                    watsh,              // watershed;
                    landuse,            //landuse in classes
                    tillfields,         //fields for tillage 
                    treefall_count,     // count number of tree falls
                    vegetation_type;
        int[,] OSL_age;            // keeps track of the last moment of surfacing: dim1: [nr * nc * nlayers * ngrains]; dim2: [5] row, col, layer, depo age, stab age
                                   // Memory restrictions: length of each dimension cannot exceed 2^31 - 1 units (~2.15*10^9). 
                                   // Limits on memory size depends on properties of system and settings for simulations


        int[,]
        drainingoutlet_row = new int[numberofsinks, 5],
        drainingoutlet_col = new int[numberofsinks, 5];

        int[] row_index, col_index;  // for sorting the DEM from high to low
        string[] rowcol_index;
        double[] index;

        //sinks and depression parameters:
        //the constant values below may have to be increased for large or strange landscapes and studies
        const int numberofsinks = 10000;           // run the program once to find out the number of sinks. The exact number and any higher number will do....
        const double tangent_of_delta = 0.005;
        const int maxlowestnbs = 100000;
        const double epsilon = 0.000001;
        const double root = 7.07;
        int max_soil_layers = 5;
        int ngrains = 100; // For OSL calculations
        double[] local_s_i_t_kg = new double[] { 0, 0, 0, 0, 0 };

        // for constant layer thicknesses
        double dz_standard = 0.1;
        double tolerance = 0.55;

        int n_texture_classes = 5;

        double soildepth_error;

        int[] rainfall_record, evap_record, infil_record, till_record, temp_record;
        int[] rainfall_record_d, evap_record_d, duration_record_d;
        int[] zonesize = new int[22], zoneprogress = new int[22];
        int[]
        iloedge = new int[numberofsinks],
        jloedge = new int[numberofsinks],
        iupedge = new int[numberofsinks],
        jupedge = new int[numberofsinks],
        depressionsize = new int[numberofsinks],
        depressionconsidered = new int[numberofsinks],
        rowlowestnb = new int[maxlowestnbs],
        collowestnb = new int[maxlowestnbs];
        double available_for_delta_kg = 0;
        double available_for_delta_m = 0;


        int t, t_intervene, scenario, number_of_data_cells, run_number;
        bool crashed,
            creep_active,
            water_ero_active,
            tillage_active,
            landslide_active,
            bedrock_weathering_active,
            frost_weathering_active,
            tilting_active,
            uplift_active,
            soil_phys_weath_active,
            soil_chem_weath_active,
            soil_bioturb_active,
            soil_clay_transloc_active,
            soil_carbon_active,
            input_data_error,
            memory_records,
            memory_records_d;

        int num_out,
                ntr,				//WVG 22-10-2010 number of rows (timesteps) in profile timeseries matrices			
                cross1, 			//WVG 22-10-2010 rows (or in the future columns) of which profiles are wanted
                cross2,
                cross3,
                test,
                numfile,
                nr,
                nc,
                row,
                col,
                i,
                j,
                matrixresult,
                er_ifile,
                flat,
                low,
                high,
                equal,
                alpha,
                beta,
                temp,
                num_str,
                numsinks,
                nb_ok,
                direct,
                round,
                s_ch,
                numtel,
                S1_error,
                S2_error,
                cell_lock,
                tel1,
                tel2,
                tel3,
                tel4,
                depressions_delta,
                depressions_alone,
                depressions_filled,  //counters for logging and reporting # of depressions filled/sedimented into/left alone
                rr,
                rrr,
                cc,
                ccc,
                ii,
                jj,
                twoequals,      // the -equals are counters for different types of sinks
                threeequals,
                moreequals,
                nb_check,
                depressionnumber = 0,
                maxdepressionnumber,
                depressionready,
                iloradius, iupradius,
                jloradius, jupradius,
                nbismemberofdepression,
                z,
                otherdepression,
                otherdepressionsize,
                totaldepressions,
                totaldepressionsize,
                maxsize,
                lowestneighbourcounter,
                numberoflowestneighbours,
                depressionreallyready,
                depressiondrainsout,
                largestdepression,
                rememberrow,
                remembercol,
                search,
                twice_dtm_fill,
                once_dtm_fill,
                three_dtm_fill,
                xrow, xcol, xxrow, xxcol,
                landuse_value,
                graphics_scale = 2,
                number_of_outputs = 0,
                wet_cells, eroded_cells, deposited_cells,
                P_scen;
        //calibration globals
        int maxruns, best_run, calib_levels, user_specified_number_of_calibration_parameters, user_specified_number_of_ratios;
        double reduction_factor, best_error;
        //USER INPUT NEEDED: establish best versions of parameters varied in calibration:
        double[] best_parameters;
        double[,] calib_ratios;
        private TabPage tabPage3;
        private CheckBox blocks_active_checkbox;
        private Label label121;
        private Label label63;
        private Label label62;
        private TextBox hardlayerdensity_textbox;
        private TextBox hardlayerweath_textbox;
        private TextBox hardlayerelevation_textbox;
        private TextBox hardlayerthickness_textbox;
        private Label label61;
        private Label label122;
        private Label label123;
        private TextBox blockweath_textbox;
        private TextBox blocksize_textbox;
        double[] original_ratios;

        private void rain_input_filename_textbox_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void tillfields_input_filename_textbox_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void label93_Click(object sender, EventArgs e)
        {

        }

        private void comboBox2_SelectedIndexChanged(object sender, EventArgs e)
        {

        }

        // tectonics
        int lift_type, lift_location, tilt_location;
        int[] timeseries_order = new int[26];
        long scan_lon, scan_cnt, NRO, NCO;

        private void soil_chem_weath_checkbox_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void decalcification_checkbox_CheckedChanged(object sender, EventArgs e)
        {

        }

        private void checkBox1_CheckedChanged_2(object sender, EventArgs e)
        {

        }

        private void label95_Click(object sender, EventArgs e)
        {

        }

        double
                diffusivity_creep,
                plough_depth,
                annual_weathering,
                dh, diff, dh1, dh_maxi,
                scan_do, dcount, powered_slope_sum,
                dmax, dmin,
                max_allowed_erosion,			// maximum erosion down to neighbour
                maximum_allowed_deposition, dhtemp,
                CSIZE,
                transport_capacity_kg,			// Capacity 
                detachment_rate,
                settlement_rate,
                frac_sed,   // fraction of landslide deposition into lower grids
                frac_bud,
                startsed,
                strsed,     // sediment delivered to streams
                T_act,         // Transmissivity
                bulkd_act,     // Bulk Density
                intfr_act,     // Internal Friction
                C_act,         // Combined Cohesion
                erotot,      // total landslide erosion
                sedtot,     // total landslide deposition;
                a_ifr, a_coh, a_bd, a_T,  // parameters parent material 1
                b_coh, b_ifr, b_bd, b_T,  // parameters parent material 2
                c_coh, c_ifr, c_bd, c_T,  // parameters parent material 3
                d_coh, d_ifr, d_bd, d_T,  // parameters parent material 4
                e_coh, e_ifr, e_bd, e_T,  // parameters parent material 5
                slopelim,       // slope limit for landslide erosion                          FACTOR 1
                celfrac,        // fraction used in calculation of celdistance (0.4 default)  FACTOR 2
                streamca,       // contributing area, number of cells, for stream development FACTOR 3
                rainfall_intensity,      // threshold critical rainfall value for landslide scenario   FACTOR 4
                slide_tot,
                dh_tot,
                tra_di,
                set_di,
                dx, dy,	  		// grid size in both row and col
                xcoord, ycoord,
                d_x, dh_tol,
                dt = 1,				// time step
                actual_t,      // Time counter for loop
                end_time,      // Total end time of loop
                out_t,
                total_altitude,
                total_average_altitude,
                total_rain, total_evap, total_infil, total_outflow,
                //WVG
                total_sed_export_up, total_sed_export_mid, total_sed_export_low,
                total_sed_prod_up, total_sed_prod_mid, total_sed_prod_low,
                total_sed_dep_up, total_sed_dep_mid, total_sed_dep_low;  // counters for logging and reporting through time


        private void button4_Click(object sender, EventArgs e)
        {
            Debug.Write(" merely_calculating_derivatives");
            merely_calculating_derivatives = true;
            try { calculate_terrain_derivatives(); MessageBox.Show("terrain derivatives calculation succeeded"); }
            catch { MessageBox.Show("terrain derivatives calculation failed"); }
        }

        private void radioButton1_CheckedChanged(object sender, EventArgs e)
        {
            if (Calibration_button.Checked == true) { Sensitivity_button.Checked = false; }
        }

        private void radioButton2_CheckedChanged(object sender, EventArgs e)
        {
            if (Sensitivity_button.Checked == true) { Calibration_button.Checked = false; }
        }

        private void dailyT_max_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_max.Text = openFileDialog1.FileName;
            }

        }

        private void dailyT_min_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_min.Text = openFileDialog1.FileName;
            }

        }

        private void dailyT_avg_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_avg.Text = openFileDialog1.FileName;
            }

        }

        private void dailyP_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void textBox3_TextChanged_2(object sender, EventArgs e)
        {

        }

        private void textBox3_TextChanged_1(object sender, EventArgs e)
        {

        }

        private void label98_Click(object sender, EventArgs e)
        {

        }

        private void daily_water_CheckedChanged(object sender, EventArgs e)
        {
            dailyP.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyET0.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyD.Enabled = (daily_water.CheckState == CheckState.Checked);
            daily_n.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_avg.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_min.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_max.Enabled = (daily_water.CheckState == CheckState.Checked);
            temp_constant_value_box.Enabled = (daily_water.CheckState == CheckState.Checked);
            temp_input_filename_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);
            check_time_T.Enabled = (daily_water.CheckState == CheckState.Checked);
            latitude_deg.Enabled = (daily_water.CheckState == CheckState.Checked);
            latitude_min.Enabled = (daily_water.CheckState == CheckState.Checked);
            snowmelt_factor_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);
            snow_threshold_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);

        }


        //soil timeseries_variables
        double total_average_soilthickness_m,
            total_phys_weathered_mass_kg,
            total_chem_weathered_mass_kg,
            total_fine_neoformed_mass_kg,
            total_fine_eluviated_mass_kg,
            total_mass_bioturbed_kg,
            total_OM_input_kg,
        local_soil_depth_m,
        local_soil_mass_kg;
        int number_soil_thicker_than,
        number_soil_coarser_than;



        // Water erosion and deposition parameters
        double
        advection_erodibility,
        P_act,
        m, n,				        // capacity slope and discharge exponents
        erosion_threshold_kg,
        rock_protection_constant,
        bio_protection_constant,
        constant_selective_transcap,
        Slope,			            // Gradient
        conv_fac,		            // convergence/divergence factor
        dS, desired_change, dztot,	// Difference in sediment/deposition/erosion
        sedtr_loc,                  // Local sediment transport rate
        all_grids,
        fraction,	                // fraction slope by slopesum
        frac_dis,	                // fraction of discharge into lower grid
        sediment_transported,		// fraction of transport rate
        water_out,
        unfulfilled_change, dz_left1, actual_change, 	// unfulfilled sedimentation
        dz_min, mmin,
        dz_max, maxx,		        // maximum lowest neighbour, steepest descent
        dz_bal, dz_bal2,		    // dz balans counter
        sedbal, sedbal2,
        erobal, erobal2,
        erobalto, sedbalto,
        erocnt,
        sedcnt,
        sediment_exported,		        // sediment out of our system
        total_Bolsena_sed_influx,

        // Biological weathering parameters  see Minasny and McBratney 2006 Geoderma 133
        P0,                         // m t-1  // weathering rate constant
        k1,                         // t-1
        k2,                         // t-1
        Pa,                         // m t-1  // weathering rate when soildepth = 0

        // Tilting and Uplift parameters
        tilt_intensity, lift_intensity,

        // Tillage parameter
        tilc;

        // Tree fall parameters
        double W_m_max, D_m_max, W_m, D_m, tf_frequency;
        int growth_a_max, age_a_max;

        //Soil physical weathering parameters
        double physical_weathering_constant, weathered_mass_kg, Cone, Ctwo;
        double[] upper_particle_size = new double[5];

        //Soil chemical weathering parameters
        double chemical_weathering_constant, Cthree, Cfour, Cfive, Csix, neoform_constant;
        double[] specific_area = new double[5];

        //Clay translocation parameters
        double max_eluviation, Cclay, ct_depthdec;

        //Bioturbation parameters
        double potential_bioturbation_kg;
        double bioturbation_depth_decay_constant;

        //Carbon cycle parameters
        double potential_OM_input,
               OM_input_depth_decay_constant,
               humification_fraction,
               potential_young_decomp_rate,
               potential_old_decomp_rate,
               young_depth_decay_constant,
               old_CTI_decay_constant,
               old_depth_decay_constant,
               young_CTI_decay_constant;

        // Decalcification parameters
        double[,,] CO3_kg;   // CaCO3, to track decalcification speed. Does not contribute to texture or soil mass (yet) MM
        double ini_CO3_content_frac;



        double noval,
        sediment_filled_m, depressionvolume_filled_m, sediment_delta_m,   // counters for logging and reporting the filling of depressions
        altidiff, minaltidiff,
        totaldepressionvolume,
        infil_value_m, evap_value_m, rain_value_m, soildepth_value,
        volume_eroded, volume_deposited,
        sum_normalweathered, sum_frostweathered, sum_soildepth, sum_creep, sum_solif, avg_solif, avg_creep, avg_soildepth,
        sum_ls, total_sum_tillage, total_sum_uplift, total_sum_tilting, total_sed_export;  // counters for logging and reporting through time

        int temp_value_C;

        double depressionsum_sediment_m, depressionsum_water_m, depressionsum_YOM_kg, depressionsum_OOM_kg;
        double[] depressionsum_texture_kg;
        double needed_to_fill_depression_m, dhoblique, dhobliquemax1, dhobliquemax2, firstalt, secondalt, dtmlowestnb;
        int dhmax_errors, readynum = 0, memberdepressionnotconsidered, depressionnum = 0, currentdepression;
        int lower_nb_exists, breaker = 0, rowlowestobnb, collowestobnb, II = 0, JJ = 0;
        int startrow, startcol, iloradius2, iupradius2, jupradius2, jloradius2, deltasize;
        int readysearching, iloradius3, iupradius3, jupradius3, jloradius3, couldbesink, omikron, omega;
        int tempx, tempy, obnbchanged;
        double sed_delta_size1 = 0, sed_delta_size2 = 0, sed_delta_size3 = 0;

        //  variables for displaying purposes // straight from Tom Coulthard
        double hue = 360.0;		// Ranges between 0 and 360 degrees
        double sat = 0.90;		// Ranges between 0 and 1.0 (where 1 is 100%)
        double val = 1.0;		// Ranges between 0 and 1.0 (where 1 is 100%)
        double red = 0.0;
        double green = 0.0;
        double blue = 0.0;

        string basetext = "LORICA Landscape Evolution Model";
        string cfgname = null;  //Config file name
        // string workdir = "D:\\PhD\\projects\\1g_basic LORICA development\\";
        string workdir = "D:\\PhD\\projects\\2g_clorpt effects on soil landscape diversity\\";
        string timeseries_string = null;

        double[] depressionlevel = new double[numberofsinks],
                    depressionvolume_m = new double[numberofsinks];
        //double SuperMEF = 0, SuperMEF2 = 0;
        double s_tempfactor, s_D, V_factor;
        double c_D;
        double w_P0, w_k1, w_k2, w_Pa;
        double f_soilrate, f_Tmax, f_Tmin, f_max;

        double mem_m;  //the height by which all cells of a current delta need to be raised in order to get rid of the remaining amount of sediment for that delta

        string str, filename, logname, recordname, outfile, f_name, ch, chs;

        string[] inputheader = new string[6];
        double[,] climate_data;

        int diagnostic_mode = 0;

        //HARDLAYER AND BLOCK GLOBALS
        int blocks_active = 1;
        int nhardlayers = 1;
        int hardlayerthickness_m = 1;
        int hardlayerelevation_m = 151;
        int hardlayerdensity_kg_m3 = 2500;
        double hardlayer_weath_contrast = 0.2;
        float blockweatheringratio = 0.999f;
        float blocksizethreshold_m = 0.1f;

        //tracking parameters
        double topoconttoroll = 0, creepconttoroll = 0;
        double blocksrolled = 0, blocksproduced = 0;

        //needs to be initialized:
        float[,] hardlayeropenness_fraction;

        public class Block
        {
            public float Y_row { get; set; }
            public float X_col { get; set; }
            public float Size_m { get; set; }
            public double Accumulated_creep_m_0 { get; set; }
            public double Accumulated_creep_m_1 { get; set; }
            public double Accumulated_creep_m_2 { get; set; }
            public double Accumulated_creep_m_3 { get; set; }
            public double Accumulated_creep_m_4 { get; set; }
            public double Accumulated_creep_m_5 { get; set; }
            public double Accumulated_creep_m_6 { get; set; }
            public double Accumulated_creep_m_7 { get; set; }
            //defined with 0 = north, 1 = northeast etc

            public Block(float y_row, float x_col, float size_m,
                double accumulated_creep_m_0,
                double accumulated_creep_m_1,
                double accumulated_creep_m_2,
                double accumulated_creep_m_3,
                double accumulated_creep_m_4,
                double accumulated_creep_m_5,
                double accumulated_creep_m_6,
                double accumulated_creep_m_7)
            {
                Y_row = y_row; X_col = x_col; Size_m = size_m;
                Accumulated_creep_m_0 = accumulated_creep_m_0;
                Accumulated_creep_m_1 = accumulated_creep_m_1;
                Accumulated_creep_m_2 = accumulated_creep_m_2;
                Accumulated_creep_m_3 = accumulated_creep_m_3;
                Accumulated_creep_m_4 = accumulated_creep_m_4; 
                Accumulated_creep_m_5 = accumulated_creep_m_5;
                Accumulated_creep_m_6 = accumulated_creep_m_6; 
                Accumulated_creep_m_7 = accumulated_creep_m_7;
            }
        }

        List<Block> Blocklist = new List<Block>();

        #endregion

        public Mother_form()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
        }

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.Label label6;
            System.Windows.Forms.TabPage Landsliding;
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Mother_form));
            System.Windows.Forms.Label label41;
            System.Windows.Forms.Label label42;
            System.Windows.Forms.Label label43;
            System.Windows.Forms.Label label44;
            System.Windows.Forms.Label label45;
            System.Windows.Forms.Label label46;
            System.Windows.Forms.Label label47;
            System.Windows.Forms.Label label48;
            System.Windows.Forms.Label label49;
            System.Windows.Forms.Label label50;
            System.Windows.Forms.Label label51;
            System.Windows.Forms.Label label52;
            System.Windows.Forms.Label label53;
            System.Windows.Forms.Label label54;
            System.Windows.Forms.Label label55;
            System.Windows.Forms.Label label56;
            System.Windows.Forms.Label label57;
            System.Windows.Forms.Label label58;
            System.Windows.Forms.Label label59;
            System.Windows.Forms.Label label64;
            System.Windows.Forms.Label label65;
            System.Windows.Forms.Label label66;
            System.Windows.Forms.Label label67;
            System.Windows.Forms.Label label60;
            System.Windows.Forms.Label label69;
            System.Windows.Forms.Label label70;
            System.Windows.Forms.Label eluviation_rate_constant;
            System.Windows.Forms.Label label72;
            System.Windows.Forms.Label label68;
            System.Windows.Forms.Label label71;
            System.Windows.Forms.Label label73;
            System.Windows.Forms.Label label74;
            System.Windows.Forms.Label label75;
            System.Windows.Forms.Label label76;
            System.Windows.Forms.Label label77;
            System.Windows.Forms.Label label81;
            System.Windows.Forms.Label label80;
            System.Windows.Forms.Label label82;
            System.Windows.Forms.Label label83;
            System.Windows.Forms.Label label84;
            System.Windows.Forms.Label label85;
            System.Windows.Forms.Label label86;
            System.Windows.Forms.Label label13;
            this.label36 = new System.Windows.Forms.Label();
            this.radio_ls_fraction = new System.Windows.Forms.RadioButton();
            this.radio_ls_absolute = new System.Windows.Forms.RadioButton();
            this.label35 = new System.Windows.Forms.Label();
            this.label34 = new System.Windows.Forms.Label();
            this.text_ls_rel_rain_intens = new System.Windows.Forms.TextBox();
            this.textBox_ls_trans = new System.Windows.Forms.TextBox();
            this.textBox_ls_bd = new System.Windows.Forms.TextBox();
            this.textBox_ls_ifr = new System.Windows.Forms.TextBox();
            this.textBox_ls_coh = new System.Windows.Forms.TextBox();
            this.text_ls_abs_rain_intens = new System.Windows.Forms.TextBox();
            this.label32 = new System.Windows.Forms.Label();
            this.label31 = new System.Windows.Forms.Label();
            this.label30 = new System.Windows.Forms.Label();
            this.label22 = new System.Windows.Forms.Label();
            this.label18 = new System.Windows.Forms.Label();
            this.pictureBox4 = new System.Windows.Forms.PictureBox();
            this.Landslide_checkbox = new System.Windows.Forms.CheckBox();
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.menuItemConfigFile = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileOpen = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileSaveAs = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileSave = new System.Windows.Forms.MenuItem();
            this.Menu_About_box = new System.Windows.Forms.MenuItem();
            this.statusBar1 = new System.Windows.Forms.StatusBar();
            this.InfoStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.TimeStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.ProcessStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.out_sed_statuspanel = new System.Windows.Forms.StatusBarPanel();
            this.total_tillage_statuspanel = new System.Windows.Forms.StatusBarPanel();
            this.start_button = new System.Windows.Forms.Button();
            this.End_button = new System.Windows.Forms.Button();
            this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
            this.label2 = new System.Windows.Forms.Label();
            this.checkBoxGenerateAVIFile = new System.Windows.Forms.CheckBox();
            this.label33 = new System.Windows.Forms.Label();
            this.googleAnimationCheckbox = new System.Windows.Forms.CheckBox();
            this.label79 = new System.Windows.Forms.Label();
            this.textBoxAVIFile = new System.Windows.Forms.TextBox();
            this.googleAnimationTextBox = new System.Windows.Forms.TextBox();
            this.UTMzonebox = new System.Windows.Forms.TextBox();
            this.label25 = new System.Windows.Forms.Label();
            this.label14 = new System.Windows.Forms.Label();
            this.label15 = new System.Windows.Forms.Label();
            this.label17 = new System.Windows.Forms.Label();
            this.fill_sinks_before_checkbox = new System.Windows.Forms.CheckBox();
            this.label8 = new System.Windows.Forms.Label();
            this.fill_sinks_during_checkbox = new System.Windows.Forms.CheckBox();
            this.groupBox13 = new System.Windows.Forms.GroupBox();
            this.label7 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label29 = new System.Windows.Forms.Label();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.landuse_determinator_button = new System.Windows.Forms.Button();
            this.groupBox9 = new System.Windows.Forms.GroupBox();
            this.parameter_k1_textbox = new System.Windows.Forms.TextBox();
            this.label24 = new System.Windows.Forms.Label();
            this.label26 = new System.Windows.Forms.Label();
            this.label27 = new System.Windows.Forms.Label();
            this.label28 = new System.Windows.Forms.Label();
            this.parameter_k2_textbox = new System.Windows.Forms.TextBox();
            this.parameter_Pa_textbox = new System.Windows.Forms.TextBox();
            this.parameter_P0_textbox = new System.Windows.Forms.TextBox();
            this.label21 = new System.Windows.Forms.Label();
            this.Biological_weathering_checkbox = new System.Windows.Forms.CheckBox();
            this.label98 = new System.Windows.Forms.Label();
            this.label99 = new System.Windows.Forms.Label();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.label1 = new System.Windows.Forms.Label();
            this.button6 = new System.Windows.Forms.Button();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.Output = new System.Windows.Forms.TabPage();
            this.groupBox6 = new System.Windows.Forms.GroupBox();
            this.groupBox12 = new System.Windows.Forms.GroupBox();
            this.annual_output_checkbox = new System.Windows.Forms.RadioButton();
            this.cumulative_output_checkbox = new System.Windows.Forms.RadioButton();
            this.groupBox11 = new System.Windows.Forms.GroupBox();
            this.Regular_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Final_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Box_years_output = new System.Windows.Forms.TextBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.diagnostic_output_checkbox = new System.Windows.Forms.CheckBox();
            this.label37 = new System.Windows.Forms.Label();
            this.outputcode_textbox = new System.Windows.Forms.TextBox();
            this.water_output_checkbox = new System.Windows.Forms.CheckBox();
            this.depressions_output_checkbox = new System.Windows.Forms.CheckBox();
            this.all_process_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Soildepth_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Alt_change_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Altitude_output_checkbox = new System.Windows.Forms.CheckBox();
            this.checkedListBox1 = new System.Windows.Forms.CheckedListBox();
            this.groupBox5 = new System.Windows.Forms.GroupBox();
            this.button3 = new System.Windows.Forms.Button();
            this.button1 = new System.Windows.Forms.Button();
            this.button2 = new System.Windows.Forms.Button();
            this.timeseries_form_button = new System.Windows.Forms.Button();
            this.UTMgroupBox = new System.Windows.Forms.GroupBox();
            this.textBox6 = new System.Windows.Forms.TextBox();
            this.UTMsouthcheck = new System.Windows.Forms.CheckBox();
            this.UTMgridcheckbox = new System.Windows.Forms.CheckBox();
            this.textBox4 = new System.Windows.Forms.TextBox();
            this.googleBeginDate = new System.Windows.Forms.TextBox();
            this.googAnimationSaveInterval = new System.Windows.Forms.TextBox();
            this.saveintervalbox = new System.Windows.Forms.TextBox();
            this.label78 = new System.Windows.Forms.Label();
            this.Run = new System.Windows.Forms.TabPage();
            this.button4 = new System.Windows.Forms.Button();
            this.version_lux_checkbox = new System.Windows.Forms.CheckBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.label120 = new System.Windows.Forms.Label();
            this.calibration_ratio_reduction_parameter_textbox = new System.Windows.Forms.TextBox();
            this.label119 = new System.Windows.Forms.Label();
            this.calibration_levels_textbox = new System.Windows.Forms.TextBox();
            this.label116 = new System.Windows.Forms.Label();
            this.label118 = new System.Windows.Forms.Label();
            this.label117 = new System.Windows.Forms.Label();
            this.label115 = new System.Windows.Forms.Label();
            this.label114 = new System.Windows.Forms.Label();
            this.Sensitivity_button = new System.Windows.Forms.RadioButton();
            this.Calibration_button = new System.Windows.Forms.RadioButton();
            this.label113 = new System.Windows.Forms.Label();
            this.calibration_ratios_textbox = new System.Windows.Forms.TextBox();
            this.calibration = new System.Windows.Forms.CheckBox();
            this.Ik_ben_Marijn = new System.Windows.Forms.CheckBox();
            this.groupBox7 = new System.Windows.Forms.GroupBox();
            this.runs_checkbox = new System.Windows.Forms.RadioButton();
            this.label16 = new System.Windows.Forms.Label();
            this.Number_runs_textbox = new System.Windows.Forms.TextBox();
            this.Input = new System.Windows.Forms.TabPage();
            this.check_time_T = new System.Windows.Forms.CheckBox();
            this.temp_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.temp_constant_value_box = new System.Windows.Forms.TextBox();
            this.soil_specify_button = new System.Windows.Forms.Button();
            this.label88 = new System.Windows.Forms.Label();
            this.explain_input_button = new System.Windows.Forms.Button();
            this.check_time_evap = new System.Windows.Forms.CheckBox();
            this.check_time_infil = new System.Windows.Forms.CheckBox();
            this.check_time_rain = new System.Windows.Forms.CheckBox();
            this.check_time_till_fields = new System.Windows.Forms.CheckBox();
            this.check_time_landuse = new System.Windows.Forms.CheckBox();
            this.check_space_DTM = new System.Windows.Forms.CheckBox();
            this.tillfields_constant_textbox = new System.Windows.Forms.TextBox();
            this.tillfields_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.evap_constant_value_box = new System.Windows.Forms.TextBox();
            this.evap_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.infil_constant_value_box = new System.Windows.Forms.TextBox();
            this.infil_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.rainfall_constant_value_box = new System.Windows.Forms.TextBox();
            this.landuse_constant_value_box = new System.Windows.Forms.TextBox();
            this.soildepth_constant_value_box = new System.Windows.Forms.TextBox();
            this.landuse_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.soildepth_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.rain_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.dtm_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.groupBox8 = new System.Windows.Forms.GroupBox();
            this.check_space_evap = new System.Windows.Forms.CheckBox();
            this.check_space_infil = new System.Windows.Forms.CheckBox();
            this.check_space_rain = new System.Windows.Forms.CheckBox();
            this.check_space_till_fields = new System.Windows.Forms.CheckBox();
            this.check_space_landuse = new System.Windows.Forms.CheckBox();
            this.check_space_soildepth = new System.Windows.Forms.CheckBox();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label23 = new System.Windows.Forms.Label();
            this.Processes = new System.Windows.Forms.TabPage();
            this.Process_tabs = new System.Windows.Forms.TabControl();
            this.Water = new System.Windows.Forms.TabPage();
            this.daily_water = new System.Windows.Forms.CheckBox();
            this.label87 = new System.Windows.Forms.Label();
            this.selectivity_constant_textbox = new System.Windows.Forms.TextBox();
            this.bio_protection_constant_textbox = new System.Windows.Forms.TextBox();
            this.erosion_threshold_textbox = new System.Windows.Forms.TextBox();
            this.rock_protection_constant_textbox = new System.Windows.Forms.TextBox();
            this.label90 = new System.Windows.Forms.Label();
            this.label91 = new System.Windows.Forms.Label();
            this.label92 = new System.Windows.Forms.Label();
            this.parameter_n_textbox = new System.Windows.Forms.TextBox();
            this.parameter_conv_textbox = new System.Windows.Forms.TextBox();
            this.parameter_K_textbox = new System.Windows.Forms.TextBox();
            this.parameter_m_textbox = new System.Windows.Forms.TextBox();
            this.only_waterflow_checkbox = new System.Windows.Forms.CheckBox();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.label12 = new System.Windows.Forms.Label();
            this.label11 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.Water_ero_checkbox = new System.Windows.Forms.CheckBox();
            this.Tillage = new System.Windows.Forms.TabPage();
            this.pictureBox2 = new System.Windows.Forms.PictureBox();
            this.label20 = new System.Windows.Forms.Label();
            this.trte = new System.Windows.Forms.Label();
            this.parameter_tillage_constant_textbox = new System.Windows.Forms.TextBox();
            this.parameter_ploughing_depth_textbox = new System.Windows.Forms.TextBox();
            this.Tillage_checkbox = new System.Windows.Forms.CheckBox();
            this.Creeper = new System.Windows.Forms.TabPage();
            this.creep_testing = new System.Windows.Forms.CheckBox();
            this.pictureBox3 = new System.Windows.Forms.PictureBox();
            this.label19 = new System.Windows.Forms.Label();
            this.parameter_diffusivity_textbox = new System.Windows.Forms.TextBox();
            this.creep_active_checkbox = new System.Windows.Forms.CheckBox();
            this.Solifluction = new System.Windows.Forms.TabPage();
            this.pictureBox5 = new System.Windows.Forms.PictureBox();
            this.Solifluction_checkbox = new System.Windows.Forms.CheckBox();
            this.Rock_weathering = new System.Windows.Forms.TabPage();
            this.rockweath_method = new System.Windows.Forms.ComboBox();
            this.pictureBox6 = new System.Windows.Forms.PictureBox();
            this.groupBox10 = new System.Windows.Forms.GroupBox();
            this.Frost_weathering_checkbox = new System.Windows.Forms.CheckBox();
            this.Tectonics = new System.Windows.Forms.TabPage();
            this.groupBox14 = new System.Windows.Forms.GroupBox();
            this.groupBox16 = new System.Windows.Forms.GroupBox();
            this.text_lift_col_less = new System.Windows.Forms.TextBox();
            this.text_lift_col_more = new System.Windows.Forms.TextBox();
            this.text_lift_row_less = new System.Windows.Forms.TextBox();
            this.text_lift_row_more = new System.Windows.Forms.TextBox();
            this.radio_lift_col_less_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_row_more_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_col_more_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_row_less_than = new System.Windows.Forms.RadioButton();
            this.Uplift_rate_textbox = new System.Windows.Forms.TextBox();
            this.uplift_active_checkbox = new System.Windows.Forms.CheckBox();
            this.label39 = new System.Windows.Forms.Label();
            this.groupBox4 = new System.Windows.Forms.GroupBox();
            this.label38 = new System.Windows.Forms.Label();
            this.Tilting_rate_textbox = new System.Windows.Forms.TextBox();
            this.groupBox15 = new System.Windows.Forms.GroupBox();
            this.radio_tilt_col_max = new System.Windows.Forms.RadioButton();
            this.radio_tilt_row_zero = new System.Windows.Forms.RadioButton();
            this.radio_tilt_col_zero = new System.Windows.Forms.RadioButton();
            this.radio_tilt_row_max = new System.Windows.Forms.RadioButton();
            this.tilting_active_checkbox = new System.Windows.Forms.CheckBox();
            this.treefall = new System.Windows.Forms.TabPage();
            this.tf_freq = new System.Windows.Forms.TextBox();
            this.label112 = new System.Windows.Forms.Label();
            this.tf_age = new System.Windows.Forms.TextBox();
            this.label111 = new System.Windows.Forms.Label();
            this.tf_growth = new System.Windows.Forms.TextBox();
            this.label110 = new System.Windows.Forms.Label();
            this.tf_D = new System.Windows.Forms.TextBox();
            this.label95 = new System.Windows.Forms.Label();
            this.label107 = new System.Windows.Forms.Label();
            this.tf_W = new System.Windows.Forms.TextBox();
            this.treefall_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage3 = new System.Windows.Forms.TabPage();
            this.label122 = new System.Windows.Forms.Label();
            this.label123 = new System.Windows.Forms.Label();
            this.blockweath_textbox = new System.Windows.Forms.TextBox();
            this.blocksize_textbox = new System.Windows.Forms.TextBox();
            this.label121 = new System.Windows.Forms.Label();
            this.label63 = new System.Windows.Forms.Label();
            this.label62 = new System.Windows.Forms.Label();
            this.hardlayerdensity_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerweath_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerelevation_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerthickness_textbox = new System.Windows.Forms.TextBox();
            this.label61 = new System.Windows.Forms.Label();
            this.blocks_active_checkbox = new System.Windows.Forms.CheckBox();
            this.Creep_Checkbox = new System.Windows.Forms.CheckBox();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.tabControl2 = new System.Windows.Forms.TabControl();
            this.physical = new System.Windows.Forms.TabPage();
            this.upper_particle_fine_clay_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_clay_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_silt_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_sand_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_coarse_textbox = new System.Windows.Forms.TextBox();
            this.physical_weath_constant2 = new System.Windows.Forms.TextBox();
            this.physical_weath_constant1 = new System.Windows.Forms.TextBox();
            this.Physical_weath_C1_textbox = new System.Windows.Forms.TextBox();
            this.soil_phys_weath_checkbox = new System.Windows.Forms.CheckBox();
            this.chemical = new System.Windows.Forms.TabPage();
            this.specific_area_fine_clay_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_clay_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_silt_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_sand_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_coarse_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_specific_coefficient_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_depth_constant_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_rate_constant_textbox = new System.Windows.Forms.TextBox();
            this.soil_chem_weath_checkbox = new System.Windows.Forms.CheckBox();
            this.clay = new System.Windows.Forms.TabPage();
            this.ct_Jagercikova = new System.Windows.Forms.CheckBox();
            this.label109 = new System.Windows.Forms.Label();
            this.label108 = new System.Windows.Forms.Label();
            this.ct_dd_Jagercikova = new System.Windows.Forms.TextBox();
            this.ct_v0_Jagercikova = new System.Windows.Forms.TextBox();
            this.ct_depth_decay = new System.Windows.Forms.TextBox();
            this.CT_depth_decay_checkbox = new System.Windows.Forms.CheckBox();
            this.eluviation_coefficient_textbox = new System.Windows.Forms.TextBox();
            this.maximum_eluviation_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_C2_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_C1_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_constant_textbox = new System.Windows.Forms.TextBox();
            this.soil_clay_transloc_checkbox = new System.Windows.Forms.CheckBox();
            this.bioturbation = new System.Windows.Forms.TabPage();
            this.bioturbation_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.potential_bioturbation_textbox = new System.Windows.Forms.TextBox();
            this.soil_bioturb_checkbox = new System.Windows.Forms.CheckBox();
            this.carbon = new System.Windows.Forms.TabPage();
            this.carbon_o_decomp_rate_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_decomp_rate_textbox = new System.Windows.Forms.TextBox();
            this.carbon_o_twi_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_twi_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_o_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_humification_fraction_textbox = new System.Windows.Forms.TextBox();
            this.carbon_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_input_textbox = new System.Windows.Forms.TextBox();
            this.soil_carbon_cycle_checkbox = new System.Windows.Forms.CheckBox();
            this.decalcification = new System.Windows.Forms.TabPage();
            this.label94 = new System.Windows.Forms.Label();
            this.ini_CaCO3_content = new System.Windows.Forms.TextBox();
            this.decalcification_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.check_scaling_daily_weather = new System.Windows.Forms.CheckBox();
            this.label106 = new System.Windows.Forms.Label();
            this.snow_threshold_textbox = new System.Windows.Forms.TextBox();
            this.label105 = new System.Windows.Forms.Label();
            this.snowmelt_factor_textbox = new System.Windows.Forms.TextBox();
            this.label104 = new System.Windows.Forms.Label();
            this.latitude_min = new System.Windows.Forms.TextBox();
            this.label103 = new System.Windows.Forms.Label();
            this.latitude_deg = new System.Windows.Forms.TextBox();
            this.label100 = new System.Windows.Forms.Label();
            this.label101 = new System.Windows.Forms.Label();
            this.label102 = new System.Windows.Forms.Label();
            this.dailyT_min = new System.Windows.Forms.TextBox();
            this.dailyT_max = new System.Windows.Forms.TextBox();
            this.dailyT_avg = new System.Windows.Forms.TextBox();
            this.label97 = new System.Windows.Forms.Label();
            this.daily_n = new System.Windows.Forms.TextBox();
            this.label96 = new System.Windows.Forms.Label();
            this.label93 = new System.Windows.Forms.Label();
            this.label89 = new System.Windows.Forms.Label();
            this.label40 = new System.Windows.Forms.Label();
            this.dailyET0 = new System.Windows.Forms.TextBox();
            this.dailyD = new System.Windows.Forms.TextBox();
            this.dailyP = new System.Windows.Forms.TextBox();
            this.timer1 = new System.Windows.Forms.Timer(this.components);
            label6 = new System.Windows.Forms.Label();
            Landsliding = new System.Windows.Forms.TabPage();
            label41 = new System.Windows.Forms.Label();
            label42 = new System.Windows.Forms.Label();
            label43 = new System.Windows.Forms.Label();
            label44 = new System.Windows.Forms.Label();
            label45 = new System.Windows.Forms.Label();
            label46 = new System.Windows.Forms.Label();
            label47 = new System.Windows.Forms.Label();
            label48 = new System.Windows.Forms.Label();
            label49 = new System.Windows.Forms.Label();
            label50 = new System.Windows.Forms.Label();
            label51 = new System.Windows.Forms.Label();
            label52 = new System.Windows.Forms.Label();
            label53 = new System.Windows.Forms.Label();
            label54 = new System.Windows.Forms.Label();
            label55 = new System.Windows.Forms.Label();
            label56 = new System.Windows.Forms.Label();
            label57 = new System.Windows.Forms.Label();
            label58 = new System.Windows.Forms.Label();
            label59 = new System.Windows.Forms.Label();
            label64 = new System.Windows.Forms.Label();
            label65 = new System.Windows.Forms.Label();
            label66 = new System.Windows.Forms.Label();
            label67 = new System.Windows.Forms.Label();
            label60 = new System.Windows.Forms.Label();
            label69 = new System.Windows.Forms.Label();
            label70 = new System.Windows.Forms.Label();
            eluviation_rate_constant = new System.Windows.Forms.Label();
            label72 = new System.Windows.Forms.Label();
            label68 = new System.Windows.Forms.Label();
            label71 = new System.Windows.Forms.Label();
            label73 = new System.Windows.Forms.Label();
            label74 = new System.Windows.Forms.Label();
            label75 = new System.Windows.Forms.Label();
            label76 = new System.Windows.Forms.Label();
            label77 = new System.Windows.Forms.Label();
            label81 = new System.Windows.Forms.Label();
            label80 = new System.Windows.Forms.Label();
            label82 = new System.Windows.Forms.Label();
            label83 = new System.Windows.Forms.Label();
            label84 = new System.Windows.Forms.Label();
            label85 = new System.Windows.Forms.Label();
            label86 = new System.Windows.Forms.Label();
            label13 = new System.Windows.Forms.Label();
            Landsliding.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.InfoStatusPanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.TimeStatusPanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.ProcessStatusPanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.out_sed_statuspanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.total_tillage_statuspanel)).BeginInit();
            this.groupBox13.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.groupBox9.SuspendLayout();
            this.Output.SuspendLayout();
            this.groupBox6.SuspendLayout();
            this.groupBox12.SuspendLayout();
            this.groupBox11.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.groupBox5.SuspendLayout();
            this.UTMgroupBox.SuspendLayout();
            this.Run.SuspendLayout();
            this.groupBox2.SuspendLayout();
            this.groupBox7.SuspendLayout();
            this.Input.SuspendLayout();
            this.groupBox8.SuspendLayout();
            this.Processes.SuspendLayout();
            this.Process_tabs.SuspendLayout();
            this.Water.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.Tillage.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();
            this.Creeper.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).BeginInit();
            this.Solifluction.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).BeginInit();
            this.Rock_weathering.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).BeginInit();
            this.groupBox10.SuspendLayout();
            this.Tectonics.SuspendLayout();
            this.groupBox14.SuspendLayout();
            this.groupBox16.SuspendLayout();
            this.groupBox4.SuspendLayout();
            this.groupBox15.SuspendLayout();
            this.treefall.SuspendLayout();
            this.tabPage3.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.tabControl2.SuspendLayout();
            this.physical.SuspendLayout();
            this.chemical.SuspendLayout();
            this.clay.SuspendLayout();
            this.bioturbation.SuspendLayout();
            this.carbon.SuspendLayout();
            this.decalcification.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.SuspendLayout();
            // 
            // label6
            // 
            label6.Location = new System.Drawing.Point(179, 22);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(41, 24);
            label6.TabIndex = 109;
            label6.Text = "f(x,y)";
            label6.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(label6, "Check this for spatially variable inputs");
            // 
            // Landsliding
            // 
            Landsliding.Controls.Add(this.label36);
            Landsliding.Controls.Add(this.radio_ls_fraction);
            Landsliding.Controls.Add(this.radio_ls_absolute);
            Landsliding.Controls.Add(this.label35);
            Landsliding.Controls.Add(this.label34);
            Landsliding.Controls.Add(this.text_ls_rel_rain_intens);
            Landsliding.Controls.Add(this.textBox_ls_trans);
            Landsliding.Controls.Add(this.textBox_ls_bd);
            Landsliding.Controls.Add(this.textBox_ls_ifr);
            Landsliding.Controls.Add(this.textBox_ls_coh);
            Landsliding.Controls.Add(this.text_ls_abs_rain_intens);
            Landsliding.Controls.Add(this.label32);
            Landsliding.Controls.Add(this.label31);
            Landsliding.Controls.Add(this.label30);
            Landsliding.Controls.Add(this.label22);
            Landsliding.Controls.Add(this.label18);
            Landsliding.Controls.Add(this.pictureBox4);
            Landsliding.Controls.Add(this.Landslide_checkbox);
            Landsliding.Location = new System.Drawing.Point(4, 22);
            Landsliding.Name = "Landsliding";
            Landsliding.Size = new System.Drawing.Size(732, 250);
            Landsliding.TabIndex = 2;
            Landsliding.Text = "Landsliding";
            Landsliding.UseVisualStyleBackColor = true;
            // 
            // label36
            // 
            this.label36.AutoSize = true;
            this.label36.Location = new System.Drawing.Point(49, 115);
            this.label36.Name = "label36";
            this.label36.Size = new System.Drawing.Size(236, 13);
            this.label36.TabIndex = 30;
            this.label36.Text = "Parameters for critical rainfall intensity calculation";
            // 
            // radio_ls_fraction
            // 
            this.radio_ls_fraction.AutoSize = true;
            this.radio_ls_fraction.Checked = true;
            this.radio_ls_fraction.Location = new System.Drawing.Point(53, 83);
            this.radio_ls_fraction.Name = "radio_ls_fraction";
            this.radio_ls_fraction.Size = new System.Drawing.Size(14, 13);
            this.radio_ls_fraction.TabIndex = 29;
            this.radio_ls_fraction.TabStop = true;
            this.radio_ls_fraction.UseVisualStyleBackColor = true;
            // 
            // radio_ls_absolute
            // 
            this.radio_ls_absolute.AutoSize = true;
            this.radio_ls_absolute.Location = new System.Drawing.Point(53, 57);
            this.radio_ls_absolute.Name = "radio_ls_absolute";
            this.radio_ls_absolute.Size = new System.Drawing.Size(14, 13);
            this.radio_ls_absolute.TabIndex = 28;
            this.radio_ls_absolute.UseVisualStyleBackColor = true;
            // 
            // label35
            // 
            this.label35.AutoSize = true;
            this.label35.Enabled = false;
            this.label35.Location = new System.Drawing.Point(138, 57);
            this.label35.Name = "label35";
            this.label35.Size = new System.Drawing.Size(105, 13);
            this.label35.TabIndex = 27;
            this.label35.Text = "Absolute value [m/d]";
            // 
            // label34
            // 
            this.label34.AutoSize = true;
            this.label34.Location = new System.Drawing.Point(138, 83);
            this.label34.Name = "label34";
            this.label34.Size = new System.Drawing.Size(270, 13);
            this.label34.TabIndex = 26;
            this.label34.Text = "Fraction of total annual rainfall [between 1 and 0.00274]";
            // 
            // text_ls_rel_rain_intens
            // 
            this.text_ls_rel_rain_intens.Location = new System.Drawing.Point(79, 80);
            this.text_ls_rel_rain_intens.Name = "text_ls_rel_rain_intens";
            this.text_ls_rel_rain_intens.Size = new System.Drawing.Size(53, 20);
            this.text_ls_rel_rain_intens.TabIndex = 25;
            this.text_ls_rel_rain_intens.Text = "0.1";
            // 
            // textBox_ls_trans
            // 
            this.textBox_ls_trans.Location = new System.Drawing.Point(52, 210);
            this.textBox_ls_trans.Name = "textBox_ls_trans";
            this.textBox_ls_trans.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_trans.TabIndex = 23;
            this.textBox_ls_trans.Text = "15";
            // 
            // textBox_ls_bd
            // 
            this.textBox_ls_bd.Location = new System.Drawing.Point(52, 184);
            this.textBox_ls_bd.Name = "textBox_ls_bd";
            this.textBox_ls_bd.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_bd.TabIndex = 21;
            this.textBox_ls_bd.Text = "1.4";
            // 
            // textBox_ls_ifr
            // 
            this.textBox_ls_ifr.Location = new System.Drawing.Point(52, 158);
            this.textBox_ls_ifr.Name = "textBox_ls_ifr";
            this.textBox_ls_ifr.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_ifr.TabIndex = 19;
            this.textBox_ls_ifr.Text = "0.7";
            // 
            // textBox_ls_coh
            // 
            this.textBox_ls_coh.Location = new System.Drawing.Point(52, 131);
            this.textBox_ls_coh.Name = "textBox_ls_coh";
            this.textBox_ls_coh.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_coh.TabIndex = 17;
            this.textBox_ls_coh.Text = "0.15";
            // 
            // text_ls_abs_rain_intens
            // 
            this.text_ls_abs_rain_intens.Enabled = false;
            this.text_ls_abs_rain_intens.Location = new System.Drawing.Point(79, 54);
            this.text_ls_abs_rain_intens.Name = "text_ls_abs_rain_intens";
            this.text_ls_abs_rain_intens.Size = new System.Drawing.Size(53, 20);
            this.text_ls_abs_rain_intens.TabIndex = 15;
            this.text_ls_abs_rain_intens.Text = "0.1";
            // 
            // label32
            // 
            this.label32.AutoSize = true;
            this.label32.Location = new System.Drawing.Point(111, 213);
            this.label32.Name = "label32";
            this.label32.Size = new System.Drawing.Size(169, 13);
            this.label32.TabIndex = 24;
            this.label32.Text = "Saturated soil transmissivity [m2/d]";
            // 
            // label31
            // 
            this.label31.AutoSize = true;
            this.label31.Location = new System.Drawing.Point(111, 187);
            this.label31.Name = "label31";
            this.label31.Size = new System.Drawing.Size(105, 13);
            this.label31.TabIndex = 22;
            this.label31.Text = "Bulk density [kg m-3]";
            // 
            // label30
            // 
            this.label30.AutoSize = true;
            this.label30.Location = new System.Drawing.Point(111, 161);
            this.label30.Name = "label30";
            this.label30.Size = new System.Drawing.Size(152, 13);
            this.label30.TabIndex = 20;
            this.label30.Text = "Internal friction angle [degrees]";
            // 
            // label22
            // 
            this.label22.AutoSize = true;
            this.label22.Location = new System.Drawing.Point(111, 134);
            this.label22.Name = "label22";
            this.label22.Size = new System.Drawing.Size(112, 13);
            this.label22.TabIndex = 18;
            this.label22.Text = "Combined cohesion [-]";
            // 
            // label18
            // 
            this.label18.AutoSize = true;
            this.label18.Location = new System.Drawing.Point(50, 38);
            this.label18.Name = "label18";
            this.label18.Size = new System.Drawing.Size(117, 13);
            this.label18.TabIndex = 16;
            this.label18.Text = "Critical rainfall threshold";
            // 
            // pictureBox4
            // 
            this.pictureBox4.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox4.Image")));
            this.pictureBox4.Location = new System.Drawing.Point(480, 57);
            this.pictureBox4.Name = "pictureBox4";
            this.pictureBox4.Size = new System.Drawing.Size(180, 137);
            this.pictureBox4.TabIndex = 14;
            this.pictureBox4.TabStop = false;
            // 
            // Landslide_checkbox
            // 
            this.Landslide_checkbox.AutoSize = true;
            this.Landslide_checkbox.Location = new System.Drawing.Point(26, 14);
            this.Landslide_checkbox.Name = "Landslide_checkbox";
            this.Landslide_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Landslide_checkbox.TabIndex = 1;
            this.Landslide_checkbox.Text = "Activate this process";
            this.Landslide_checkbox.UseVisualStyleBackColor = true;
            // 
            // label41
            // 
            label41.AutoSize = true;
            label41.Location = new System.Drawing.Point(142, 49);
            label41.Name = "label41";
            label41.Size = new System.Drawing.Size(147, 13);
            label41.TabIndex = 10;
            label41.Text = "weathering rate constant [y-1]";
            // 
            // label42
            // 
            label42.AutoSize = true;
            label42.Location = new System.Drawing.Point(142, 72);
            label42.Name = "label42";
            label42.Size = new System.Drawing.Size(136, 13);
            label42.TabIndex = 11;
            label42.Text = "depth decay constant [m-1]";
            // 
            // label43
            // 
            label43.AutoSize = true;
            label43.Location = new System.Drawing.Point(142, 98);
            label43.Name = "label43";
            label43.Size = new System.Drawing.Size(123, 13);
            label43.TabIndex = 12;
            label43.Text = "particle size constant [m]";
            // 
            // label44
            // 
            label44.AutoSize = true;
            label44.Location = new System.Drawing.Point(409, 49);
            label44.Name = "label44";
            label44.Size = new System.Drawing.Size(77, 13);
            label44.TabIndex = 13;
            label44.Text = "coarse fraction";
            // 
            // label45
            // 
            label45.AutoSize = true;
            label45.Location = new System.Drawing.Point(409, 72);
            label45.Name = "label45";
            label45.Size = new System.Drawing.Size(68, 13);
            label45.TabIndex = 14;
            label45.Text = "sand fraction";
            // 
            // label46
            // 
            label46.AutoSize = true;
            label46.Location = new System.Drawing.Point(409, 98);
            label46.Name = "label46";
            label46.Size = new System.Drawing.Size(57, 13);
            label46.TabIndex = 15;
            label46.Text = "silt fraction";
            // 
            // label47
            // 
            label47.AutoSize = true;
            label47.Location = new System.Drawing.Point(409, 124);
            label47.Name = "label47";
            label47.Size = new System.Drawing.Size(64, 13);
            label47.TabIndex = 16;
            label47.Text = "clay fraction";
            // 
            // label48
            // 
            label48.AutoSize = true;
            label48.Location = new System.Drawing.Point(409, 150);
            label48.Name = "label48";
            label48.Size = new System.Drawing.Size(84, 13);
            label48.TabIndex = 17;
            label48.Text = "fine clay fraction";
            // 
            // label49
            // 
            label49.AutoSize = true;
            label49.Location = new System.Drawing.Point(300, 27);
            label49.Name = "label49";
            label49.Size = new System.Drawing.Size(229, 13);
            label49.TabIndex = 18;
            label49.Text = "upper limit of particle size for texture classes [m]";
            // 
            // label50
            // 
            label50.AutoSize = true;
            label50.Location = new System.Drawing.Point(136, 93);
            label50.Name = "label50";
            label50.Size = new System.Drawing.Size(0, 13);
            label50.TabIndex = 18;
            // 
            // label51
            // 
            label51.AutoSize = true;
            label51.Location = new System.Drawing.Point(136, 67);
            label51.Name = "label51";
            label51.Size = new System.Drawing.Size(136, 13);
            label51.TabIndex = 17;
            label51.Text = "depth decay constant [m-1]";
            // 
            // label52
            // 
            label52.AutoSize = true;
            label52.Location = new System.Drawing.Point(136, 38);
            label52.Name = "label52";
            label52.Size = new System.Drawing.Size(268, 13);
            label52.TabIndex = 16;
            label52.Text = "weathering rate constant [kg / m2 mineral surface area]";
            // 
            // label53
            // 
            label53.AutoSize = true;
            label53.Location = new System.Drawing.Point(135, 97);
            label53.Name = "label53";
            label53.Size = new System.Drawing.Size(131, 13);
            label53.TabIndex = 19;
            label53.Text = "specific area coefficient [-]";
            // 
            // label54
            // 
            label54.AutoSize = true;
            label54.Location = new System.Drawing.Point(417, 22);
            label54.Name = "label54";
            label54.Size = new System.Drawing.Size(239, 13);
            label54.TabIndex = 30;
            label54.Text = "specific surface area for texture classes [m2 / kg]";
            // 
            // label55
            // 
            label55.AutoSize = true;
            label55.Location = new System.Drawing.Point(526, 145);
            label55.Name = "label55";
            label55.Size = new System.Drawing.Size(84, 13);
            label55.TabIndex = 29;
            label55.Text = "fine clay fraction";
            // 
            // label56
            // 
            label56.AutoSize = true;
            label56.Location = new System.Drawing.Point(526, 119);
            label56.Name = "label56";
            label56.Size = new System.Drawing.Size(64, 13);
            label56.TabIndex = 28;
            label56.Text = "clay fraction";
            // 
            // label57
            // 
            label57.AutoSize = true;
            label57.Location = new System.Drawing.Point(526, 93);
            label57.Name = "label57";
            label57.Size = new System.Drawing.Size(57, 13);
            label57.TabIndex = 27;
            label57.Text = "silt fraction";
            // 
            // label58
            // 
            label58.AutoSize = true;
            label58.Location = new System.Drawing.Point(526, 67);
            label58.Name = "label58";
            label58.Size = new System.Drawing.Size(68, 13);
            label58.TabIndex = 26;
            label58.Text = "sand fraction";
            // 
            // label59
            // 
            label59.AutoSize = true;
            label59.Location = new System.Drawing.Point(526, 44);
            label59.Name = "label59";
            label59.Size = new System.Drawing.Size(77, 13);
            label59.TabIndex = 25;
            label59.Text = "coarse fraction";
            // 
            // label64
            // 
            label64.AutoSize = true;
            label64.Location = new System.Drawing.Point(131, 134);
            label64.Name = "label64";
            label64.Size = new System.Drawing.Size(83, 13);
            label64.TabIndex = 46;
            label64.Text = "constant 2 [m-1]";
            // 
            // label65
            // 
            label65.AutoSize = true;
            label65.Location = new System.Drawing.Point(132, 130);
            label65.Name = "label65";
            label65.Size = new System.Drawing.Size(0, 13);
            label65.TabIndex = 45;
            // 
            // label66
            // 
            label66.AutoSize = true;
            label66.Location = new System.Drawing.Point(132, 104);
            label66.Name = "label66";
            label66.Size = new System.Drawing.Size(60, 13);
            label66.TabIndex = 44;
            label66.Text = "constant 1 ";
            // 
            // label67
            // 
            label67.AutoSize = true;
            label67.Location = new System.Drawing.Point(132, 75);
            label67.Name = "label67";
            label67.Size = new System.Drawing.Size(121, 13);
            label67.TabIndex = 43;
            label67.Text = "neoformation constant []";
            // 
            // label60
            // 
            label60.AutoSize = true;
            label60.Location = new System.Drawing.Point(23, 59);
            label60.Name = "label60";
            label60.Size = new System.Drawing.Size(110, 13);
            label60.TabIndex = 39;
            label60.Text = "fine clay neoformation";
            // 
            // label69
            // 
            label69.AutoSize = true;
            label69.Location = new System.Drawing.Point(411, 130);
            label69.Name = "label69";
            label69.Size = new System.Drawing.Size(0, 13);
            label69.TabIndex = 53;
            // 
            // label70
            // 
            label70.AutoSize = true;
            label70.Location = new System.Drawing.Point(411, 104);
            label70.Name = "label70";
            label70.Size = new System.Drawing.Size(97, 13);
            label70.TabIndex = 52;
            label70.Text = "saturation constant";
            // 
            // eluviation_rate_constant
            // 
            eluviation_rate_constant.AutoSize = true;
            eluviation_rate_constant.Location = new System.Drawing.Point(411, 75);
            eluviation_rate_constant.Name = "eluviation_rate_constant";
            eluviation_rate_constant.Size = new System.Drawing.Size(119, 13);
            eluviation_rate_constant.TabIndex = 51;
            eluviation_rate_constant.Text = "maximum eluviation [kg]";
            // 
            // label72
            // 
            label72.AutoSize = true;
            label72.Location = new System.Drawing.Point(302, 59);
            label72.Name = "label72";
            label72.Size = new System.Drawing.Size(109, 13);
            label72.TabIndex = 47;
            label72.Text = "fine clay translocation";
            // 
            // label68
            // 
            label68.AutoSize = true;
            label68.Location = new System.Drawing.Point(133, 103);
            label68.Name = "label68";
            label68.Size = new System.Drawing.Size(0, 13);
            label68.TabIndex = 59;
            // 
            // label71
            // 
            label71.AutoSize = true;
            label71.Location = new System.Drawing.Point(133, 77);
            label71.Name = "label71";
            label71.Size = new System.Drawing.Size(99, 13);
            label71.TabIndex = 58;
            label71.Text = "depth decay rate [-]";
            // 
            // label73
            // 
            label73.AutoSize = true;
            label73.Location = new System.Drawing.Point(133, 48);
            label73.Name = "label73";
            label73.Size = new System.Drawing.Size(167, 13);
            label73.TabIndex = 57;
            label73.Text = "potential bioturbation [kg / m2 / y]";
            // 
            // label74
            // 
            label74.AutoSize = true;
            label74.Location = new System.Drawing.Point(130, 117);
            label74.Name = "label74";
            label74.Size = new System.Drawing.Size(0, 13);
            label74.TabIndex = 64;
            // 
            // label75
            // 
            label75.AutoSize = true;
            label75.Location = new System.Drawing.Point(130, 91);
            label75.Name = "label75";
            label75.Size = new System.Drawing.Size(124, 13);
            label75.TabIndex = 63;
            label75.Text = "depth limitation rate [m-1]";
            // 
            // label76
            // 
            label76.AutoSize = true;
            label76.Location = new System.Drawing.Point(130, 62);
            label76.Name = "label76";
            label76.Size = new System.Drawing.Size(205, 13);
            label76.TabIndex = 62;
            label76.Text = "potential organic matter input [kg / m2 / y]";
            // 
            // label77
            // 
            label77.AutoSize = true;
            label77.Location = new System.Drawing.Point(130, 172);
            label77.Name = "label77";
            label77.Size = new System.Drawing.Size(0, 13);
            label77.TabIndex = 69;
            // 
            // label81
            // 
            label81.AutoSize = true;
            label81.Location = new System.Drawing.Point(130, 117);
            label81.Name = "label81";
            label81.Size = new System.Drawing.Size(113, 13);
            label81.TabIndex = 67;
            label81.Text = "humification fraction [-]";
            // 
            // label80
            // 
            label80.AutoSize = true;
            label80.Location = new System.Drawing.Point(381, 62);
            label80.Name = "label80";
            label80.Size = new System.Drawing.Size(133, 26);
            label80.TabIndex = 70;
            label80.Text = "decomposition parameters \r\nfor two OM pools:";
            // 
            // label82
            // 
            label82.AutoSize = true;
            label82.Location = new System.Drawing.Point(382, 94);
            label82.Name = "label82";
            label82.Size = new System.Drawing.Size(36, 13);
            label82.TabIndex = 71;
            label82.Text = "young";
            // 
            // label83
            // 
            label83.AutoSize = true;
            label83.Location = new System.Drawing.Point(496, 94);
            label83.Name = "label83";
            label83.Size = new System.Drawing.Size(21, 13);
            label83.TabIndex = 72;
            label83.Text = "old";
            // 
            // label84
            // 
            label84.AutoSize = true;
            label84.Location = new System.Drawing.Point(558, 140);
            label84.Name = "label84";
            label84.Size = new System.Drawing.Size(136, 13);
            label84.TabIndex = 74;
            label84.Text = "depth decay constant [m-1]";
            // 
            // label85
            // 
            label85.AutoSize = true;
            label85.Location = new System.Drawing.Point(558, 166);
            label85.Name = "label85";
            label85.Size = new System.Drawing.Size(116, 13);
            label85.TabIndex = 77;
            label85.Text = "TWI decay constant [-]";
            // 
            // label86
            // 
            label86.AutoSize = true;
            label86.Location = new System.Drawing.Point(558, 114);
            label86.Name = "label86";
            label86.Size = new System.Drawing.Size(115, 13);
            label86.TabIndex = 80;
            label86.Text = "decomposition rate [/y]";
            // 
            // label13
            // 
            label13.AutoSize = true;
            label13.Location = new System.Drawing.Point(410, 172);
            label13.Name = "label13";
            label13.Size = new System.Drawing.Size(112, 13);
            label13.TabIndex = 56;
            label13.Text = "Depth decay constant";
            // 
            // mainMenu1
            // 
            this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItemConfigFile,
            this.Menu_About_box});
            // 
            // menuItemConfigFile
            // 
            this.menuItemConfigFile.Index = 0;
            this.menuItemConfigFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItemConfigFileOpen,
            this.menuItemConfigFileSaveAs,
            this.menuItemConfigFileSave});
            this.menuItemConfigFile.Text = "&RunFile";
            // 
            // menuItemConfigFileOpen
            // 
            this.menuItemConfigFileOpen.Index = 0;
            this.menuItemConfigFileOpen.Text = "&Open";
            this.menuItemConfigFileOpen.Click += new System.EventHandler(this.menuItemConfigFileOpen_Click);
            // 
            // menuItemConfigFileSaveAs
            // 
            this.menuItemConfigFileSaveAs.Index = 1;
            this.menuItemConfigFileSaveAs.Text = "Save &As";
            this.menuItemConfigFileSaveAs.Click += new System.EventHandler(this.menuItemConfigFileSave_Click);
            // 
            // menuItemConfigFileSave
            // 
            this.menuItemConfigFileSave.Index = 2;
            this.menuItemConfigFileSave.Text = "&Save";
            this.menuItemConfigFileSave.Click += new System.EventHandler(this.menuItemConfigFileSave_Click);
            // 
            // Menu_About_box
            // 
            this.Menu_About_box.Index = 1;
            this.Menu_About_box.Text = "&About";
            this.Menu_About_box.Click += new System.EventHandler(this.Menu_aboutbox_Click);
            // 
            // statusBar1
            // 
            this.statusBar1.Location = new System.Drawing.Point(0, 475);
            this.statusBar1.Name = "statusBar1";
            this.statusBar1.Panels.AddRange(new System.Windows.Forms.StatusBarPanel[] {
            this.InfoStatusPanel,
            this.TimeStatusPanel,
            this.ProcessStatusPanel,
            this.out_sed_statuspanel,
            this.total_tillage_statuspanel});
            this.statusBar1.ShowPanels = true;
            this.statusBar1.Size = new System.Drawing.Size(1174, 22);
            this.statusBar1.SizingGrip = false;
            this.statusBar1.TabIndex = 144;
            this.statusBar1.Text = "statusBar1";
            this.statusBar1.PanelClick += new System.Windows.Forms.StatusBarPanelClickEventHandler(this.statusBar1_PanelClick);
            // 
            // InfoStatusPanel
            // 
            this.InfoStatusPanel.Name = "InfoStatusPanel";
            this.InfoStatusPanel.Text = "info";
            this.InfoStatusPanel.Width = 200;
            // 
            // TimeStatusPanel
            // 
            this.TimeStatusPanel.Name = "TimeStatusPanel";
            this.TimeStatusPanel.Text = "time";
            this.TimeStatusPanel.Width = 80;
            // 
            // ProcessStatusPanel
            // 
            this.ProcessStatusPanel.Name = "ProcessStatusPanel";
            this.ProcessStatusPanel.Text = "processes";
            this.ProcessStatusPanel.Width = 120;
            // 
            // out_sed_statuspanel
            // 
            this.out_sed_statuspanel.Name = "out_sed_statuspanel";
            this.out_sed_statuspanel.Text = "sed export";
            this.out_sed_statuspanel.Width = 140;
            // 
            // total_tillage_statuspanel
            // 
            this.total_tillage_statuspanel.Name = "total_tillage_statuspanel";
            this.total_tillage_statuspanel.Text = "tillage volume";
            this.total_tillage_statuspanel.Width = 140;
            // 
            // start_button
            // 
            this.start_button.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.start_button.Location = new System.Drawing.Point(9, 419);
            this.start_button.Name = "start_button";
            this.start_button.Size = new System.Drawing.Size(88, 27);
            this.start_button.TabIndex = 146;
            this.start_button.Text = "Start";
            this.start_button.Click += new System.EventHandler(this.main_loop);
            // 
            // End_button
            // 
            this.End_button.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.End_button.Location = new System.Drawing.Point(103, 419);
            this.End_button.Name = "End_button";
            this.End_button.Size = new System.Drawing.Size(100, 27);
            this.End_button.TabIndex = 147;
            this.End_button.Text = "Quit";
            this.End_button.Click += new System.EventHandler(this.End_button_Click);
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(19, 121);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(104, 24);
            this.label2.TabIndex = 97;
            this.label2.Text = "Rainfall data file";
            this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.toolTip1.SetToolTip(this.label2, "Hourly rainfall data - in an ascii format");
            // 
            // checkBoxGenerateAVIFile
            // 
            this.checkBoxGenerateAVIFile.Location = new System.Drawing.Point(18, 26);
            this.checkBoxGenerateAVIFile.Name = "checkBoxGenerateAVIFile";
            this.checkBoxGenerateAVIFile.Size = new System.Drawing.Size(128, 24);
            this.checkBoxGenerateAVIFile.TabIndex = 200;
            this.checkBoxGenerateAVIFile.Text = "Generate Avi File";
            this.toolTip1.SetToolTip(this.checkBoxGenerateAVIFile, "Check to generate a movie file of the screen display");
            // 
            // label33
            // 
            this.label33.Location = new System.Drawing.Point(18, 53);
            this.label33.Name = "label33";
            this.label33.Size = new System.Drawing.Size(131, 25);
            this.label33.TabIndex = 203;
            this.label33.Text = "Save map every * years";
            this.label33.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.toolTip1.SetToolTip(this.label33, "How often the avi file AND the other data files are saved");
            // 
            // googleAnimationCheckbox
            // 
            this.googleAnimationCheckbox.Location = new System.Drawing.Point(18, 86);
            this.googleAnimationCheckbox.Name = "googleAnimationCheckbox";
            this.googleAnimationCheckbox.Size = new System.Drawing.Size(195, 24);
            this.googleAnimationCheckbox.TabIndex = 210;
            this.googleAnimationCheckbox.Text = "Google Earth Animation ";
            this.toolTip1.SetToolTip(this.googleAnimationCheckbox, "Check to generate a movie file of the screen display");
            // 
            // label79
            // 
            this.label79.Location = new System.Drawing.Point(15, 111);
            this.label79.Name = "label79";
            this.label79.Size = new System.Drawing.Size(134, 25);
            this.label79.TabIndex = 213;
            this.label79.Text = "Save map every * years";
            this.label79.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.toolTip1.SetToolTip(this.label79, "How often the avi file AND the other data files are saved");
            // 
            // textBoxAVIFile
            // 
            this.textBoxAVIFile.Location = new System.Drawing.Point(165, 29);
            this.textBoxAVIFile.Name = "textBoxAVIFile";
            this.textBoxAVIFile.Size = new System.Drawing.Size(112, 20);
            this.textBoxAVIFile.TabIndex = 199;
            this.textBoxAVIFile.Text = "out.avi";
            this.toolTip1.SetToolTip(this.textBoxAVIFile, "File name for avi file");
            // 
            // googleAnimationTextBox
            // 
            this.googleAnimationTextBox.Location = new System.Drawing.Point(165, 88);
            this.googleAnimationTextBox.Name = "googleAnimationTextBox";
            this.googleAnimationTextBox.Size = new System.Drawing.Size(112, 20);
            this.googleAnimationTextBox.TabIndex = 211;
            this.googleAnimationTextBox.Text = "animation.kmz";
            this.toolTip1.SetToolTip(this.googleAnimationTextBox, "File name for avi file");
            // 
            // UTMzonebox
            // 
            this.UTMzonebox.Location = new System.Drawing.Point(99, 16);
            this.UTMzonebox.Name = "UTMzonebox";
            this.UTMzonebox.Size = new System.Drawing.Size(39, 20);
            this.UTMzonebox.TabIndex = 194;
            this.UTMzonebox.Tag = "UTM zone";
            this.toolTip1.SetToolTip(this.UTMzonebox, "Enter the UTM zone");
            // 
            // label25
            // 
            this.label25.Location = new System.Drawing.Point(19, 164);
            this.label25.Name = "label25";
            this.label25.Size = new System.Drawing.Size(143, 24);
            this.label25.TabIndex = 97;
            this.label25.Text = "mean annual rainfall [m]";
            this.label25.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label25, "Hourly rainfall data - in an ascii format");
            // 
            // label14
            // 
            this.label14.Location = new System.Drawing.Point(19, 190);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(143, 24);
            this.label14.TabIndex = 115;
            this.label14.Text = "mean annual infiltration [m]";
            this.label14.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label14, "Hourly rainfall data - in an ascii format");
            // 
            // label15
            // 
            this.label15.Location = new System.Drawing.Point(19, 216);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(151, 24);
            this.label15.TabIndex = 118;
            this.label15.Text = "mean annual evaporation [m]";
            this.label15.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label15, "Hourly rainfall data - in an ascii format");
            // 
            // label17
            // 
            this.label17.Location = new System.Drawing.Point(19, 140);
            this.label17.Name = "label17";
            this.label17.Size = new System.Drawing.Size(143, 24);
            this.label17.TabIndex = 121;
            this.label17.Text = "tillage fields [1/-9999]";
            this.label17.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label17, "Hourly rainfall data - in an ascii format");
            // 
            // fill_sinks_before_checkbox
            // 
            this.fill_sinks_before_checkbox.AutoSize = true;
            this.fill_sinks_before_checkbox.Location = new System.Drawing.Point(11, 22);
            this.fill_sinks_before_checkbox.Name = "fill_sinks_before_checkbox";
            this.fill_sinks_before_checkbox.Size = new System.Drawing.Size(131, 17);
            this.fill_sinks_before_checkbox.TabIndex = 132;
            this.fill_sinks_before_checkbox.Text = "remove sinks and flats";
            this.toolTip1.SetToolTip(this.fill_sinks_before_checkbox, resources.GetString("fill_sinks_before_checkbox.ToolTip"));
            this.fill_sinks_before_checkbox.UseVisualStyleBackColor = true;
            // 
            // label8
            // 
            this.label8.Location = new System.Drawing.Point(110, 31);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(54, 25);
            this.label8.TabIndex = 222;
            this.label8.Text = "timesteps";
            this.label8.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label8, "How often the avi file AND the other data files are saved");
            // 
            // fill_sinks_during_checkbox
            // 
            this.fill_sinks_during_checkbox.AutoSize = true;
            this.fill_sinks_during_checkbox.Location = new System.Drawing.Point(11, 25);
            this.fill_sinks_during_checkbox.Name = "fill_sinks_during_checkbox";
            this.fill_sinks_during_checkbox.Size = new System.Drawing.Size(131, 17);
            this.fill_sinks_during_checkbox.TabIndex = 132;
            this.fill_sinks_during_checkbox.Text = "remove sinks and flats";
            this.toolTip1.SetToolTip(this.fill_sinks_during_checkbox, resources.GetString("fill_sinks_during_checkbox.ToolTip"));
            this.fill_sinks_during_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox13
            // 
            this.groupBox13.Controls.Add(this.fill_sinks_during_checkbox);
            this.groupBox13.Location = new System.Drawing.Point(589, 91);
            this.groupBox13.Name = "groupBox13";
            this.groupBox13.Size = new System.Drawing.Size(158, 55);
            this.groupBox13.TabIndex = 135;
            this.groupBox13.TabStop = false;
            this.groupBox13.Text = "while running: ";
            this.toolTip1.SetToolTip(this.groupBox13, "LORICA");
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(407, 22);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(134, 24);
            this.label7.TabIndex = 110;
            this.label7.Text = " constant value";
            this.label7.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label7, "\"constant value\" is only available for some inputs and only \r\nwhen neither f(t) n" +
        "or f(x,y) are checked");
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(258, 23);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(51, 24);
            this.label5.TabIndex = 108;
            this.label5.Text = "filename";
            this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label5, resources.GetString("label5.ToolTip"));
            // 
            // label29
            // 
            this.label29.Location = new System.Drawing.Point(217, 22);
            this.label29.Name = "label29";
            this.label29.Size = new System.Drawing.Size(24, 24);
            this.label29.TabIndex = 139;
            this.label29.Text = "f(t)";
            this.label29.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label29, "Check this for temporally variable inputs");
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.landuse_determinator_button);
            this.groupBox3.Location = new System.Drawing.Point(589, 152);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(158, 55);
            this.groupBox3.TabIndex = 136;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "for landuse: ";
            this.toolTip1.SetToolTip(this.groupBox3, "LORICA");
            // 
            // landuse_determinator_button
            // 
            this.landuse_determinator_button.Location = new System.Drawing.Point(11, 19);
            this.landuse_determinator_button.Name = "landuse_determinator_button";
            this.landuse_determinator_button.Size = new System.Drawing.Size(122, 23);
            this.landuse_determinator_button.TabIndex = 0;
            this.landuse_determinator_button.Text = "determine effects";
            this.landuse_determinator_button.UseVisualStyleBackColor = true;
            this.landuse_determinator_button.Click += new System.EventHandler(this.landuse_determinator_button_Click);
            // 
            // groupBox9
            // 
            this.groupBox9.Controls.Add(this.parameter_k1_textbox);
            this.groupBox9.Controls.Add(this.label24);
            this.groupBox9.Controls.Add(this.label26);
            this.groupBox9.Controls.Add(this.label27);
            this.groupBox9.Controls.Add(this.label28);
            this.groupBox9.Controls.Add(this.parameter_k2_textbox);
            this.groupBox9.Controls.Add(this.parameter_Pa_textbox);
            this.groupBox9.Controls.Add(this.parameter_P0_textbox);
            this.groupBox9.Controls.Add(this.label21);
            this.groupBox9.Controls.Add(this.Biological_weathering_checkbox);
            this.groupBox9.Location = new System.Drawing.Point(12, 13);
            this.groupBox9.Name = "groupBox9";
            this.groupBox9.Size = new System.Drawing.Size(222, 180);
            this.groupBox9.TabIndex = 5;
            this.groupBox9.TabStop = false;
            this.groupBox9.Text = "Biological weathering (humped model)";
            this.toolTip1.SetToolTip(this.groupBox9, resources.GetString("groupBox9.ToolTip"));
            // 
            // parameter_k1_textbox
            // 
            this.parameter_k1_textbox.Location = new System.Drawing.Point(14, 80);
            this.parameter_k1_textbox.Name = "parameter_k1_textbox";
            this.parameter_k1_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_k1_textbox.TabIndex = 20;
            this.parameter_k1_textbox.Text = "0.1";
            // 
            // label24
            // 
            this.label24.AutoSize = true;
            this.label24.Location = new System.Drawing.Point(89, 135);
            this.label24.Name = "label24";
            this.label24.Size = new System.Drawing.Size(52, 13);
            this.label24.TabIndex = 19;
            this.label24.Text = "Pa (m t-1)";
            // 
            // label26
            // 
            this.label26.AutoSize = true;
            this.label26.Location = new System.Drawing.Point(89, 109);
            this.label26.Name = "label26";
            this.label26.Size = new System.Drawing.Size(40, 13);
            this.label26.TabIndex = 18;
            this.label26.Text = "k2 (t-1)";
            // 
            // label27
            // 
            this.label27.AutoSize = true;
            this.label27.Location = new System.Drawing.Point(89, 83);
            this.label27.Name = "label27";
            this.label27.Size = new System.Drawing.Size(40, 13);
            this.label27.TabIndex = 17;
            this.label27.Text = "k1 (t-1)";
            // 
            // label28
            // 
            this.label28.AutoSize = true;
            this.label28.Location = new System.Drawing.Point(89, 57);
            this.label28.Name = "label28";
            this.label28.Size = new System.Drawing.Size(52, 13);
            this.label28.TabIndex = 16;
            this.label28.Text = "P0 (m t-1)";
            // 
            // parameter_k2_textbox
            // 
            this.parameter_k2_textbox.Location = new System.Drawing.Point(14, 106);
            this.parameter_k2_textbox.Name = "parameter_k2_textbox";
            this.parameter_k2_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_k2_textbox.TabIndex = 14;
            this.parameter_k2_textbox.Text = "6";
            // 
            // parameter_Pa_textbox
            // 
            this.parameter_Pa_textbox.Location = new System.Drawing.Point(14, 132);
            this.parameter_Pa_textbox.Name = "parameter_Pa_textbox";
            this.parameter_Pa_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_Pa_textbox.TabIndex = 13;
            this.parameter_Pa_textbox.Text = "0.00002";
            // 
            // parameter_P0_textbox
            // 
            this.parameter_P0_textbox.Location = new System.Drawing.Point(14, 54);
            this.parameter_P0_textbox.Name = "parameter_P0_textbox";
            this.parameter_P0_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_P0_textbox.TabIndex = 12;
            this.parameter_P0_textbox.Text = "0.000033";
            // 
            // label21
            // 
            this.label21.AutoSize = true;
            this.label21.Location = new System.Drawing.Point(11, 11);
            this.label21.Name = "label21";
            this.label21.Size = new System.Drawing.Size(0, 13);
            this.label21.TabIndex = 4;
            // 
            // Biological_weathering_checkbox
            // 
            this.Biological_weathering_checkbox.AutoSize = true;
            this.Biological_weathering_checkbox.Location = new System.Drawing.Point(14, 19);
            this.Biological_weathering_checkbox.Name = "Biological_weathering_checkbox";
            this.Biological_weathering_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Biological_weathering_checkbox.TabIndex = 3;
            this.Biological_weathering_checkbox.Text = "Activate this process";
            this.Biological_weathering_checkbox.UseVisualStyleBackColor = true;
            // 
            // label98
            // 
            this.label98.Location = new System.Drawing.Point(19, 245);
            this.label98.Name = "label98";
            this.label98.Size = new System.Drawing.Size(151, 24);
            this.label98.TabIndex = 152;
            this.label98.Text = "mean annual temperature [C]";
            this.label98.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label98, "Hourly rainfall data - in an ascii format");
            this.label98.Click += new System.EventHandler(this.label98_Click);
            // 
            // label99
            // 
            this.label99.Location = new System.Drawing.Point(52, 269);
            this.label99.Name = "label99";
            this.label99.Size = new System.Drawing.Size(151, 24);
            this.label99.TabIndex = 153;
            this.label99.Text = "Only with daily water balance";
            this.label99.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label99, "Hourly rainfall data - in an ascii format");
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.FileName = "openFileDialog1";
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(19, 49);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(104, 24);
            this.label1.TabIndex = 56;
            this.label1.Text = "DEM (.asc format)";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // button6
            // 
            this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button6.Location = new System.Drawing.Point(132, 235);
            this.button6.Name = "button6";
            this.button6.Size = new System.Drawing.Size(100, 24);
            this.button6.TabIndex = 7;
            this.button6.Text = "test data";
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(131, 121);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(120, 20);
            this.textBox1.TabIndex = 103;
            this.textBox1.Text = "null";
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(131, 49);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(120, 20);
            this.textBox2.TabIndex = 100;
            this.textBox2.Text = "whole9.dat";
            // 
            // Output
            // 
            this.Output.Controls.Add(this.groupBox6);
            this.Output.Controls.Add(this.groupBox5);
            this.Output.Location = new System.Drawing.Point(4, 22);
            this.Output.Name = "Output";
            this.Output.Size = new System.Drawing.Size(803, 293);
            this.Output.TabIndex = 7;
            this.Output.Text = "Output";
            this.Output.UseVisualStyleBackColor = true;
            // 
            // groupBox6
            // 
            this.groupBox6.Controls.Add(this.groupBox12);
            this.groupBox6.Controls.Add(this.groupBox11);
            this.groupBox6.Controls.Add(this.groupBox1);
            this.groupBox6.Controls.Add(this.checkedListBox1);
            this.groupBox6.Location = new System.Drawing.Point(8, 16);
            this.groupBox6.Name = "groupBox6";
            this.groupBox6.Size = new System.Drawing.Size(294, 258);
            this.groupBox6.TabIndex = 222;
            this.groupBox6.TabStop = false;
            this.groupBox6.Text = "Normal outputs (ascii grids)";
            // 
            // groupBox12
            // 
            this.groupBox12.Controls.Add(this.annual_output_checkbox);
            this.groupBox12.Controls.Add(this.cumulative_output_checkbox);
            this.groupBox12.Location = new System.Drawing.Point(181, 19);
            this.groupBox12.Name = "groupBox12";
            this.groupBox12.Size = new System.Drawing.Size(102, 63);
            this.groupBox12.TabIndex = 227;
            this.groupBox12.TabStop = false;
            // 
            // annual_output_checkbox
            // 
            this.annual_output_checkbox.AutoSize = true;
            this.annual_output_checkbox.Location = new System.Drawing.Point(5, 35);
            this.annual_output_checkbox.Name = "annual_output_checkbox";
            this.annual_output_checkbox.Size = new System.Drawing.Size(57, 17);
            this.annual_output_checkbox.TabIndex = 1;
            this.annual_output_checkbox.Text = "annual";
            this.annual_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // cumulative_output_checkbox
            // 
            this.cumulative_output_checkbox.AutoSize = true;
            this.cumulative_output_checkbox.Checked = true;
            this.cumulative_output_checkbox.Location = new System.Drawing.Point(5, 12);
            this.cumulative_output_checkbox.Name = "cumulative_output_checkbox";
            this.cumulative_output_checkbox.Size = new System.Drawing.Size(76, 17);
            this.cumulative_output_checkbox.TabIndex = 0;
            this.cumulative_output_checkbox.TabStop = true;
            this.cumulative_output_checkbox.Text = "cumulative";
            this.cumulative_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox11
            // 
            this.groupBox11.Controls.Add(this.label8);
            this.groupBox11.Controls.Add(this.Regular_output_checkbox);
            this.groupBox11.Controls.Add(this.Final_output_checkbox);
            this.groupBox11.Controls.Add(this.Box_years_output);
            this.groupBox11.Location = new System.Drawing.Point(6, 19);
            this.groupBox11.Name = "groupBox11";
            this.groupBox11.Size = new System.Drawing.Size(166, 63);
            this.groupBox11.TabIndex = 226;
            this.groupBox11.TabStop = false;
            // 
            // Regular_output_checkbox
            // 
            this.Regular_output_checkbox.AutoSize = true;
            this.Regular_output_checkbox.Location = new System.Drawing.Point(6, 36);
            this.Regular_output_checkbox.Name = "Regular_output_checkbox";
            this.Regular_output_checkbox.Size = new System.Drawing.Size(55, 17);
            this.Regular_output_checkbox.TabIndex = 221;
            this.Regular_output_checkbox.Text = "every ";
            this.Regular_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Final_output_checkbox
            // 
            this.Final_output_checkbox.AutoSize = true;
            this.Final_output_checkbox.Checked = true;
            this.Final_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Final_output_checkbox.Location = new System.Drawing.Point(6, 13);
            this.Final_output_checkbox.Name = "Final_output_checkbox";
            this.Final_output_checkbox.Size = new System.Drawing.Size(81, 17);
            this.Final_output_checkbox.TabIndex = 220;
            this.Final_output_checkbox.Text = "when ready";
            this.Final_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Box_years_output
            // 
            this.Box_years_output.AcceptsTab = true;
            this.Box_years_output.Location = new System.Drawing.Point(67, 34);
            this.Box_years_output.Name = "Box_years_output";
            this.Box_years_output.Size = new System.Drawing.Size(44, 20);
            this.Box_years_output.TabIndex = 1;
            this.Box_years_output.Text = "3";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.diagnostic_output_checkbox);
            this.groupBox1.Controls.Add(this.label37);
            this.groupBox1.Controls.Add(this.outputcode_textbox);
            this.groupBox1.Controls.Add(this.water_output_checkbox);
            this.groupBox1.Controls.Add(this.depressions_output_checkbox);
            this.groupBox1.Controls.Add(this.all_process_output_checkbox);
            this.groupBox1.Controls.Add(this.Soildepth_output_checkbox);
            this.groupBox1.Controls.Add(this.Alt_change_output_checkbox);
            this.groupBox1.Controls.Add(this.Altitude_output_checkbox);
            this.groupBox1.Location = new System.Drawing.Point(6, 85);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(277, 167);
            this.groupBox1.TabIndex = 225;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Outputs:";
            // 
            // diagnostic_output_checkbox
            // 
            this.diagnostic_output_checkbox.AutoSize = true;
            this.diagnostic_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.diagnostic_output_checkbox.Location = new System.Drawing.Point(125, 141);
            this.diagnostic_output_checkbox.Name = "diagnostic_output_checkbox";
            this.diagnostic_output_checkbox.Size = new System.Drawing.Size(81, 17);
            this.diagnostic_output_checkbox.TabIndex = 230;
            this.diagnostic_output_checkbox.Text = "Diagnostics";
            this.diagnostic_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // label37
            // 
            this.label37.AutoSize = true;
            this.label37.Location = new System.Drawing.Point(153, 31);
            this.label37.Name = "label37";
            this.label37.Size = new System.Drawing.Size(69, 13);
            this.label37.TabIndex = 229;
            this.label37.Text = "Output code:";
            // 
            // outputcode_textbox
            // 
            this.outputcode_textbox.Location = new System.Drawing.Point(156, 47);
            this.outputcode_textbox.Name = "outputcode_textbox";
            this.outputcode_textbox.Size = new System.Drawing.Size(100, 20);
            this.outputcode_textbox.TabIndex = 228;
            // 
            // water_output_checkbox
            // 
            this.water_output_checkbox.AutoSize = true;
            this.water_output_checkbox.Checked = true;
            this.water_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.water_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.water_output_checkbox.Location = new System.Drawing.Point(24, 118);
            this.water_output_checkbox.Name = "water_output_checkbox";
            this.water_output_checkbox.Size = new System.Drawing.Size(74, 17);
            this.water_output_checkbox.TabIndex = 227;
            this.water_output_checkbox.Text = "Waterflow";
            this.water_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // depressions_output_checkbox
            // 
            this.depressions_output_checkbox.AutoSize = true;
            this.depressions_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.depressions_output_checkbox.Location = new System.Drawing.Point(24, 141);
            this.depressions_output_checkbox.Name = "depressions_output_checkbox";
            this.depressions_output_checkbox.Size = new System.Drawing.Size(84, 17);
            this.depressions_output_checkbox.TabIndex = 226;
            this.depressions_output_checkbox.Text = "Depressions";
            this.depressions_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // all_process_output_checkbox
            // 
            this.all_process_output_checkbox.AutoSize = true;
            this.all_process_output_checkbox.Checked = true;
            this.all_process_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.all_process_output_checkbox.Location = new System.Drawing.Point(24, 95);
            this.all_process_output_checkbox.Name = "all_process_output_checkbox";
            this.all_process_output_checkbox.Size = new System.Drawing.Size(134, 17);
            this.all_process_output_checkbox.TabIndex = 225;
            this.all_process_output_checkbox.Text = "Indiv. process volumes";
            this.all_process_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Soildepth_output_checkbox
            // 
            this.Soildepth_output_checkbox.AutoSize = true;
            this.Soildepth_output_checkbox.Checked = true;
            this.Soildepth_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Soildepth_output_checkbox.Location = new System.Drawing.Point(24, 72);
            this.Soildepth_output_checkbox.Name = "Soildepth_output_checkbox";
            this.Soildepth_output_checkbox.Size = new System.Drawing.Size(70, 17);
            this.Soildepth_output_checkbox.TabIndex = 224;
            this.Soildepth_output_checkbox.Text = "Soildepth";
            this.Soildepth_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Alt_change_output_checkbox
            // 
            this.Alt_change_output_checkbox.AutoSize = true;
            this.Alt_change_output_checkbox.Checked = true;
            this.Alt_change_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Alt_change_output_checkbox.Location = new System.Drawing.Point(24, 49);
            this.Alt_change_output_checkbox.Name = "Alt_change_output_checkbox";
            this.Alt_change_output_checkbox.Size = new System.Drawing.Size(100, 17);
            this.Alt_change_output_checkbox.TabIndex = 223;
            this.Alt_change_output_checkbox.Text = "Altitude change";
            this.Alt_change_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Altitude_output_checkbox
            // 
            this.Altitude_output_checkbox.AutoSize = true;
            this.Altitude_output_checkbox.Checked = true;
            this.Altitude_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Altitude_output_checkbox.Location = new System.Drawing.Point(24, 26);
            this.Altitude_output_checkbox.Name = "Altitude_output_checkbox";
            this.Altitude_output_checkbox.Size = new System.Drawing.Size(61, 17);
            this.Altitude_output_checkbox.TabIndex = 222;
            this.Altitude_output_checkbox.Text = "Altitude";
            this.Altitude_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // checkedListBox1
            // 
            this.checkedListBox1.FormattingEnabled = true;
            this.checkedListBox1.Items.AddRange(new object[] {
            "altitude",
            "altitude change",
            "soildepth",
            "soildepth change",
            "redistribution all processes",
            "redistribution per process",
            "weathering all processes",
            "weathering per process"});
            this.checkedListBox1.Location = new System.Drawing.Point(119, 96);
            this.checkedListBox1.Name = "checkedListBox1";
            this.checkedListBox1.Size = new System.Drawing.Size(152, 34);
            this.checkedListBox1.TabIndex = 0;
            this.checkedListBox1.Visible = false;
            // 
            // groupBox5
            // 
            this.groupBox5.Controls.Add(this.button3);
            this.groupBox5.Controls.Add(this.button1);
            this.groupBox5.Controls.Add(this.button2);
            this.groupBox5.Controls.Add(this.timeseries_form_button);
            this.groupBox5.Controls.Add(this.UTMgroupBox);
            this.groupBox5.Controls.Add(this.UTMgridcheckbox);
            this.groupBox5.Controls.Add(this.textBox4);
            this.groupBox5.Controls.Add(this.googleBeginDate);
            this.groupBox5.Controls.Add(this.googAnimationSaveInterval);
            this.groupBox5.Controls.Add(this.googleAnimationTextBox);
            this.groupBox5.Controls.Add(this.saveintervalbox);
            this.groupBox5.Controls.Add(this.textBoxAVIFile);
            this.groupBox5.Controls.Add(this.label78);
            this.groupBox5.Controls.Add(this.label79);
            this.groupBox5.Controls.Add(this.googleAnimationCheckbox);
            this.groupBox5.Controls.Add(this.label33);
            this.groupBox5.Controls.Add(this.checkBoxGenerateAVIFile);
            this.groupBox5.Location = new System.Drawing.Point(308, 15);
            this.groupBox5.Name = "groupBox5";
            this.groupBox5.Size = new System.Drawing.Size(464, 259);
            this.groupBox5.TabIndex = 221;
            this.groupBox5.TabStop = false;
            this.groupBox5.Text = "Other outputs";
            // 
            // button3
            // 
            this.button3.Location = new System.Drawing.Point(175, 218);
            this.button3.Name = "button3";
            this.button3.Size = new System.Drawing.Size(142, 24);
            this.button3.TabIndex = 222;
            this.button3.Text = "Google Earth output..";
            this.button3.UseVisualStyleBackColor = true;
            this.button3.Visible = false;
            // 
            // button1
            // 
            this.button1.Location = new System.Drawing.Point(175, 189);
            this.button1.Name = "button1";
            this.button1.Size = new System.Drawing.Size(142, 24);
            this.button1.TabIndex = 221;
            this.button1.Text = "video output..";
            this.button1.UseVisualStyleBackColor = true;
            this.button1.Visible = false;
            // 
            // button2
            // 
            this.button2.Location = new System.Drawing.Point(18, 218);
            this.button2.Name = "button2";
            this.button2.Size = new System.Drawing.Size(142, 24);
            this.button2.TabIndex = 220;
            this.button2.Text = "profile outputs..";
            this.button2.UseVisualStyleBackColor = true;
            this.button2.Click += new System.EventHandler(this.profiles_button_Click);
            // 
            // timeseries_form_button
            // 
            this.timeseries_form_button.Location = new System.Drawing.Point(18, 188);
            this.timeseries_form_button.Name = "timeseries_form_button";
            this.timeseries_form_button.Size = new System.Drawing.Size(142, 24);
            this.timeseries_form_button.TabIndex = 219;
            this.timeseries_form_button.Text = "timeseries outputs..";
            this.timeseries_form_button.UseVisualStyleBackColor = true;
            this.timeseries_form_button.Click += new System.EventHandler(this.timeseries_button_Click);
            // 
            // UTMgroupBox
            // 
            this.UTMgroupBox.Controls.Add(this.textBox6);
            this.UTMgroupBox.Controls.Add(this.UTMsouthcheck);
            this.UTMgroupBox.Controls.Add(this.UTMzonebox);
            this.UTMgroupBox.Location = new System.Drawing.Point(293, 131);
            this.UTMgroupBox.Name = "UTMgroupBox";
            this.UTMgroupBox.Size = new System.Drawing.Size(144, 65);
            this.UTMgroupBox.TabIndex = 218;
            this.UTMgroupBox.TabStop = false;
            this.UTMgroupBox.Visible = false;
            // 
            // textBox6
            // 
            this.textBox6.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.textBox6.Location = new System.Drawing.Point(6, 17);
            this.textBox6.Multiline = true;
            this.textBox6.Name = "textBox6";
            this.textBox6.ReadOnly = true;
            this.textBox6.Size = new System.Drawing.Size(87, 22);
            this.textBox6.TabIndex = 196;
            this.textBox6.Text = "UTM zone (1-60)";
            // 
            // UTMsouthcheck
            // 
            this.UTMsouthcheck.AutoSize = true;
            this.UTMsouthcheck.Location = new System.Drawing.Point(6, 42);
            this.UTMsouthcheck.Name = "UTMsouthcheck";
            this.UTMsouthcheck.Size = new System.Drawing.Size(128, 17);
            this.UTMsouthcheck.TabIndex = 197;
            this.UTMsouthcheck.Text = "Southern Hemisphere";
            this.UTMsouthcheck.UseVisualStyleBackColor = true;
            // 
            // UTMgridcheckbox
            // 
            this.UTMgridcheckbox.AutoSize = true;
            this.UTMgridcheckbox.Location = new System.Drawing.Point(293, 108);
            this.UTMgridcheckbox.Name = "UTMgridcheckbox";
            this.UTMgridcheckbox.Size = new System.Drawing.Size(82, 17);
            this.UTMgridcheckbox.TabIndex = 217;
            this.UTMgridcheckbox.Text = "Grid is UTM";
            this.UTMgridcheckbox.UseVisualStyleBackColor = true;
            this.UTMgridcheckbox.CheckedChanged += new System.EventHandler(this.UTMgridcheckbox_CheckedChanged);
            // 
            // textBox4
            // 
            this.textBox4.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.textBox4.Location = new System.Drawing.Point(293, 75);
            this.textBox4.Multiline = true;
            this.textBox4.Name = "textBox4";
            this.textBox4.ReadOnly = true;
            this.textBox4.Size = new System.Drawing.Size(138, 35);
            this.textBox4.TabIndex = 216;
            this.textBox4.Text = "only for British National Grid or UTM WGS84";
            // 
            // googleBeginDate
            // 
            this.googleBeginDate.AcceptsTab = true;
            this.googleBeginDate.Location = new System.Drawing.Point(165, 140);
            this.googleBeginDate.Name = "googleBeginDate";
            this.googleBeginDate.Size = new System.Drawing.Size(100, 20);
            this.googleBeginDate.TabIndex = 215;
            // 
            // googAnimationSaveInterval
            // 
            this.googAnimationSaveInterval.Location = new System.Drawing.Point(165, 114);
            this.googAnimationSaveInterval.Name = "googAnimationSaveInterval";
            this.googAnimationSaveInterval.Size = new System.Drawing.Size(56, 20);
            this.googAnimationSaveInterval.TabIndex = 212;
            this.googAnimationSaveInterval.Text = "1000";
            // 
            // saveintervalbox
            // 
            this.saveintervalbox.Location = new System.Drawing.Point(165, 56);
            this.saveintervalbox.Name = "saveintervalbox";
            this.saveintervalbox.Size = new System.Drawing.Size(56, 20);
            this.saveintervalbox.TabIndex = 201;
            this.saveintervalbox.Text = "1000";
            // 
            // label78
            // 
            this.label78.AutoSize = true;
            this.label78.Location = new System.Drawing.Point(29, 143);
            this.label78.Name = "label78";
            this.label78.Size = new System.Drawing.Size(120, 13);
            this.label78.TabIndex = 214;
            this.label78.Text = "begin date (yyyy-mm-dd)";
            // 
            // Run
            // 
            this.Run.Controls.Add(this.button4);
            this.Run.Controls.Add(this.version_lux_checkbox);
            this.Run.Controls.Add(this.groupBox2);
            this.Run.Controls.Add(this.calibration);
            this.Run.Controls.Add(this.Ik_ben_Marijn);
            this.Run.Controls.Add(this.groupBox7);
            this.Run.Location = new System.Drawing.Point(4, 22);
            this.Run.Name = "Run";
            this.Run.Size = new System.Drawing.Size(803, 293);
            this.Run.TabIndex = 8;
            this.Run.Text = "Run";
            this.Run.UseVisualStyleBackColor = true;
            // 
            // button4
            // 
            this.button4.Location = new System.Drawing.Point(102, 228);
            this.button4.Name = "button4";
            this.button4.Size = new System.Drawing.Size(163, 41);
            this.button4.TabIndex = 7;
            this.button4.Text = "now purely calculate terrain derivatives";
            this.button4.UseVisualStyleBackColor = true;
            this.button4.Click += new System.EventHandler(this.button4_Click);
            // 
            // version_lux_checkbox
            // 
            this.version_lux_checkbox.AutoSize = true;
            this.version_lux_checkbox.Location = new System.Drawing.Point(102, 167);
            this.version_lux_checkbox.Name = "version_lux_checkbox";
            this.version_lux_checkbox.Size = new System.Drawing.Size(115, 17);
            this.version_lux_checkbox.TabIndex = 6;
            this.version_lux_checkbox.Text = "Luxemburg version";
            this.version_lux_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.label120);
            this.groupBox2.Controls.Add(this.calibration_ratio_reduction_parameter_textbox);
            this.groupBox2.Controls.Add(this.label119);
            this.groupBox2.Controls.Add(this.calibration_levels_textbox);
            this.groupBox2.Controls.Add(this.label116);
            this.groupBox2.Controls.Add(this.label118);
            this.groupBox2.Controls.Add(this.label117);
            this.groupBox2.Controls.Add(this.label115);
            this.groupBox2.Controls.Add(this.label114);
            this.groupBox2.Controls.Add(this.Sensitivity_button);
            this.groupBox2.Controls.Add(this.Calibration_button);
            this.groupBox2.Controls.Add(this.label113);
            this.groupBox2.Controls.Add(this.calibration_ratios_textbox);
            this.groupBox2.Location = new System.Drawing.Point(346, 32);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(422, 237);
            this.groupBox2.TabIndex = 4;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Calibration / sensitivity options";
            // 
            // label120
            // 
            this.label120.AutoSize = true;
            this.label120.Location = new System.Drawing.Point(39, 210);
            this.label120.Name = "label120";
            this.label120.Size = new System.Drawing.Size(199, 13);
            this.label120.TabIndex = 13;
            this.label120.Text = "1. describe the parameter values in code";
            // 
            // calibration_ratio_reduction_parameter_textbox
            // 
            this.calibration_ratio_reduction_parameter_textbox.Location = new System.Drawing.Point(338, 148);
            this.calibration_ratio_reduction_parameter_textbox.Name = "calibration_ratio_reduction_parameter_textbox";
            this.calibration_ratio_reduction_parameter_textbox.Size = new System.Drawing.Size(66, 20);
            this.calibration_ratio_reduction_parameter_textbox.TabIndex = 12;
            this.calibration_ratio_reduction_parameter_textbox.Text = "1.5";
            // 
            // label119
            // 
            this.label119.AutoSize = true;
            this.label119.Location = new System.Drawing.Point(39, 151);
            this.label119.Name = "label119";
            this.label119.Size = new System.Drawing.Size(208, 13);
            this.label119.TabIndex = 11;
            this.label119.Text = "5. reduction of variations per level (if smart)";
            // 
            // calibration_levels_textbox
            // 
            this.calibration_levels_textbox.Location = new System.Drawing.Point(338, 124);
            this.calibration_levels_textbox.Name = "calibration_levels_textbox";
            this.calibration_levels_textbox.Size = new System.Drawing.Size(66, 20);
            this.calibration_levels_textbox.TabIndex = 10;
            this.calibration_levels_textbox.Text = "3";
            // 
            // label116
            // 
            this.label116.AutoSize = true;
            this.label116.Location = new System.Drawing.Point(194, 35);
            this.label116.Name = "label116";
            this.label116.Size = new System.Drawing.Size(210, 13);
            this.label116.TabIndex = 9;
            this.label116.Text = "The optimal set of parameters will be stored";
            // 
            // label118
            // 
            this.label118.AutoSize = true;
            this.label118.Location = new System.Drawing.Point(39, 127);
            this.label118.Name = "label118";
            this.label118.Size = new System.Drawing.Size(97, 13);
            this.label118.TabIndex = 8;
            this.label118.Text = "4. levels (iterations)";
            // 
            // label117
            // 
            this.label117.AutoSize = true;
            this.label117.Location = new System.Drawing.Point(39, 80);
            this.label117.Name = "label117";
            this.label117.Size = new System.Drawing.Size(207, 13);
            this.label117.TabIndex = 7;
            this.label117.Text = "2. describe parameters to calibrate in code";
            // 
            // label115
            // 
            this.label115.AutoSize = true;
            this.label115.Location = new System.Drawing.Point(39, 56);
            this.label115.Name = "label115";
            this.label115.Size = new System.Drawing.Size(191, 13);
            this.label115.TabIndex = 5;
            this.label115.Text = "1. define the objective function in code";
            // 
            // label114
            // 
            this.label114.AutoSize = true;
            this.label114.Location = new System.Drawing.Point(39, 102);
            this.label114.Name = "label114";
            this.label114.Size = new System.Drawing.Size(132, 13);
            this.label114.TabIndex = 4;
            this.label114.Text = "3. variations per parameter";
            // 
            // Sensitivity_button
            // 
            this.Sensitivity_button.AutoSize = true;
            this.Sensitivity_button.Location = new System.Drawing.Point(22, 179);
            this.Sensitivity_button.Name = "Sensitivity_button";
            this.Sensitivity_button.Size = new System.Drawing.Size(200, 17);
            this.Sensitivity_button.TabIndex = 3;
            this.Sensitivity_button.Text = "Run sensitivity analysis (non-iterative)";
            this.Sensitivity_button.UseVisualStyleBackColor = true;
            this.Sensitivity_button.CheckedChanged += new System.EventHandler(this.radioButton2_CheckedChanged);
            // 
            // Calibration_button
            // 
            this.Calibration_button.AutoSize = true;
            this.Calibration_button.Location = new System.Drawing.Point(22, 33);
            this.Calibration_button.Name = "Calibration_button";
            this.Calibration_button.Size = new System.Drawing.Size(142, 17);
            this.Calibration_button.TabIndex = 2;
            this.Calibration_button.Text = "Run calibration (iterative)";
            this.Calibration_button.UseVisualStyleBackColor = true;
            this.Calibration_button.CheckedChanged += new System.EventHandler(this.radioButton1_CheckedChanged);
            // 
            // label113
            // 
            this.label113.AutoSize = true;
            this.label113.Location = new System.Drawing.Point(73, 39);
            this.label113.Name = "label113";
            this.label113.Size = new System.Drawing.Size(0, 13);
            this.label113.TabIndex = 1;
            // 
            // calibration_ratios_textbox
            // 
            this.calibration_ratios_textbox.Location = new System.Drawing.Point(218, 99);
            this.calibration_ratios_textbox.Name = "calibration_ratios_textbox";
            this.calibration_ratios_textbox.Size = new System.Drawing.Size(186, 20);
            this.calibration_ratios_textbox.TabIndex = 0;
            this.calibration_ratios_textbox.Text = "0.25;0.5;1;2;4";
            // 
            // calibration
            // 
            this.calibration.AutoSize = true;
            this.calibration.Location = new System.Drawing.Point(102, 190);
            this.calibration.Name = "calibration";
            this.calibration.Size = new System.Drawing.Size(125, 17);
            this.calibration.TabIndex = 5;
            this.calibration.Text = "Lessivage calibration";
            this.calibration.UseVisualStyleBackColor = true;
            this.calibration.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged_1);
            // 
            // Ik_ben_Marijn
            // 
            this.Ik_ben_Marijn.AutoSize = true;
            this.Ik_ben_Marijn.Location = new System.Drawing.Point(102, 146);
            this.Ik_ben_Marijn.Name = "Ik_ben_Marijn";
            this.Ik_ben_Marijn.Size = new System.Drawing.Size(87, 17);
            this.Ik_ben_Marijn.TabIndex = 4;
            this.Ik_ben_Marijn.Text = "Ik ben Marijn";
            this.Ik_ben_Marijn.UseVisualStyleBackColor = true;
            // 
            // groupBox7
            // 
            this.groupBox7.Controls.Add(this.runs_checkbox);
            this.groupBox7.Controls.Add(this.label16);
            this.groupBox7.Controls.Add(this.Number_runs_textbox);
            this.groupBox7.Location = new System.Drawing.Point(48, 32);
            this.groupBox7.Name = "groupBox7";
            this.groupBox7.Size = new System.Drawing.Size(277, 69);
            this.groupBox7.TabIndex = 3;
            this.groupBox7.TabStop = false;
            this.groupBox7.Text = "Please specify  the number of timesteps per run";
            // 
            // runs_checkbox
            // 
            this.runs_checkbox.AutoSize = true;
            this.runs_checkbox.Checked = true;
            this.runs_checkbox.Location = new System.Drawing.Point(54, 33);
            this.runs_checkbox.Name = "runs_checkbox";
            this.runs_checkbox.Size = new System.Drawing.Size(79, 17);
            this.runs_checkbox.TabIndex = 2;
            this.runs_checkbox.TabStop = true;
            this.runs_checkbox.Text = "runs (years)";
            this.runs_checkbox.UseVisualStyleBackColor = true;
            // 
            // label16
            // 
            this.label16.AutoSize = true;
            this.label16.Location = new System.Drawing.Point(73, 39);
            this.label16.Name = "label16";
            this.label16.Size = new System.Drawing.Size(0, 13);
            this.label16.TabIndex = 1;
            // 
            // Number_runs_textbox
            // 
            this.Number_runs_textbox.Location = new System.Drawing.Point(190, 30);
            this.Number_runs_textbox.Name = "Number_runs_textbox";
            this.Number_runs_textbox.Size = new System.Drawing.Size(55, 20);
            this.Number_runs_textbox.TabIndex = 0;
            this.Number_runs_textbox.Text = "1";
            // 
            // Input
            // 
            this.Input.Controls.Add(this.check_time_T);
            this.Input.Controls.Add(this.label99);
            this.Input.Controls.Add(this.label98);
            this.Input.Controls.Add(this.temp_input_filename_textbox);
            this.Input.Controls.Add(this.temp_constant_value_box);
            this.Input.Controls.Add(this.soil_specify_button);
            this.Input.Controls.Add(this.label88);
            this.Input.Controls.Add(this.groupBox3);
            this.Input.Controls.Add(this.explain_input_button);
            this.Input.Controls.Add(this.check_time_evap);
            this.Input.Controls.Add(this.check_time_infil);
            this.Input.Controls.Add(this.check_time_rain);
            this.Input.Controls.Add(this.check_time_till_fields);
            this.Input.Controls.Add(this.check_time_landuse);
            this.Input.Controls.Add(this.label29);
            this.Input.Controls.Add(this.check_space_DTM);
            this.Input.Controls.Add(this.groupBox13);
            this.Input.Controls.Add(this.tillfields_constant_textbox);
            this.Input.Controls.Add(this.tillfields_input_filename_textbox);
            this.Input.Controls.Add(this.evap_constant_value_box);
            this.Input.Controls.Add(this.evap_input_filename_textbox);
            this.Input.Controls.Add(this.infil_constant_value_box);
            this.Input.Controls.Add(this.infil_input_filename_textbox);
            this.Input.Controls.Add(this.rainfall_constant_value_box);
            this.Input.Controls.Add(this.landuse_constant_value_box);
            this.Input.Controls.Add(this.soildepth_constant_value_box);
            this.Input.Controls.Add(this.landuse_input_filename_textbox);
            this.Input.Controls.Add(this.soildepth_input_filename_textbox);
            this.Input.Controls.Add(this.rain_input_filename_textbox);
            this.Input.Controls.Add(this.dtm_input_filename_textbox);
            this.Input.Controls.Add(this.groupBox8);
            this.Input.Controls.Add(this.check_space_evap);
            this.Input.Controls.Add(this.check_space_infil);
            this.Input.Controls.Add(this.check_space_rain);
            this.Input.Controls.Add(this.check_space_till_fields);
            this.Input.Controls.Add(this.check_space_landuse);
            this.Input.Controls.Add(this.check_space_soildepth);
            this.Input.Controls.Add(this.label17);
            this.Input.Controls.Add(this.label15);
            this.Input.Controls.Add(this.label14);
            this.Input.Controls.Add(this.label7);
            this.Input.Controls.Add(label6);
            this.Input.Controls.Add(this.label5);
            this.Input.Controls.Add(this.label4);
            this.Input.Controls.Add(this.label3);
            this.Input.Controls.Add(this.label25);
            this.Input.Controls.Add(this.label23);
            this.Input.Location = new System.Drawing.Point(4, 22);
            this.Input.Name = "Input";
            this.Input.Size = new System.Drawing.Size(803, 293);
            this.Input.TabIndex = 0;
            this.Input.Text = "Inputs";
            this.Input.UseVisualStyleBackColor = true;
            // 
            // check_time_T
            // 
            this.check_time_T.AutoSize = true;
            this.check_time_T.Enabled = false;
            this.check_time_T.Location = new System.Drawing.Point(220, 251);
            this.check_time_T.Name = "check_time_T";
            this.check_time_T.Size = new System.Drawing.Size(15, 14);
            this.check_time_T.TabIndex = 154;
            this.check_time_T.UseVisualStyleBackColor = true;
            // 
            // temp_input_filename_textbox
            // 
            this.temp_input_filename_textbox.Enabled = false;
            this.temp_input_filename_textbox.Location = new System.Drawing.Point(258, 245);
            this.temp_input_filename_textbox.Name = "temp_input_filename_textbox";
            this.temp_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.temp_input_filename_textbox.TabIndex = 151;
            this.temp_input_filename_textbox.Text = "..";
            this.temp_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // temp_constant_value_box
            // 
            this.temp_constant_value_box.Enabled = false;
            this.temp_constant_value_box.Location = new System.Drawing.Point(410, 245);
            this.temp_constant_value_box.Name = "temp_constant_value_box";
            this.temp_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.temp_constant_value_box.TabIndex = 150;
            this.temp_constant_value_box.Text = "10";
            this.temp_constant_value_box.TextChanged += new System.EventHandler(this.textBox3_TextChanged_1);
            // 
            // soil_specify_button
            // 
            this.soil_specify_button.Location = new System.Drawing.Point(188, 95);
            this.soil_specify_button.Name = "soil_specify_button";
            this.soil_specify_button.Size = new System.Drawing.Size(63, 20);
            this.soil_specify_button.TabIndex = 149;
            this.soil_specify_button.Text = "specify ..";
            this.soil_specify_button.UseVisualStyleBackColor = true;
            this.soil_specify_button.Click += new System.EventHandler(this.soil_specify_button_Click);
            // 
            // label88
            // 
            this.label88.Location = new System.Drawing.Point(19, 95);
            this.label88.Name = "label88";
            this.label88.Size = new System.Drawing.Size(104, 24);
            this.label88.TabIndex = 148;
            this.label88.Text = "soilproperties";
            this.label88.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // explain_input_button
            // 
            this.explain_input_button.Location = new System.Drawing.Point(315, 25);
            this.explain_input_button.Name = "explain_input_button";
            this.explain_input_button.Size = new System.Drawing.Size(63, 20);
            this.explain_input_button.TabIndex = 147;
            this.explain_input_button.Text = "explain..";
            this.explain_input_button.UseVisualStyleBackColor = true;
            this.explain_input_button.Click += new System.EventHandler(this.button8_Click);
            // 
            // check_time_evap
            // 
            this.check_time_evap.AutoSize = true;
            this.check_time_evap.Location = new System.Drawing.Point(220, 222);
            this.check_time_evap.Name = "check_time_evap";
            this.check_time_evap.Size = new System.Drawing.Size(15, 14);
            this.check_time_evap.TabIndex = 145;
            this.check_time_evap.UseVisualStyleBackColor = true;
            this.check_time_evap.CheckedChanged += new System.EventHandler(this.check_time_evap_CheckedChanged);
            // 
            // check_time_infil
            // 
            this.check_time_infil.AutoSize = true;
            this.check_time_infil.Location = new System.Drawing.Point(220, 198);
            this.check_time_infil.Name = "check_time_infil";
            this.check_time_infil.Size = new System.Drawing.Size(15, 14);
            this.check_time_infil.TabIndex = 144;
            this.check_time_infil.UseVisualStyleBackColor = true;
            this.check_time_infil.CheckedChanged += new System.EventHandler(this.check_time_infil_CheckedChanged);
            // 
            // check_time_rain
            // 
            this.check_time_rain.AutoSize = true;
            this.check_time_rain.Location = new System.Drawing.Point(220, 174);
            this.check_time_rain.Name = "check_time_rain";
            this.check_time_rain.Size = new System.Drawing.Size(15, 14);
            this.check_time_rain.TabIndex = 143;
            this.check_time_rain.UseVisualStyleBackColor = true;
            this.check_time_rain.CheckedChanged += new System.EventHandler(this.check_time_rain_CheckedChanged);
            // 
            // check_time_till_fields
            // 
            this.check_time_till_fields.AutoSize = true;
            this.check_time_till_fields.Location = new System.Drawing.Point(220, 150);
            this.check_time_till_fields.Name = "check_time_till_fields";
            this.check_time_till_fields.Size = new System.Drawing.Size(15, 14);
            this.check_time_till_fields.TabIndex = 142;
            this.check_time_till_fields.UseVisualStyleBackColor = true;
            this.check_time_till_fields.CheckedChanged += new System.EventHandler(this.check_time_tillage_CheckedChanged);
            // 
            // check_time_landuse
            // 
            this.check_time_landuse.AutoSize = true;
            this.check_time_landuse.Location = new System.Drawing.Point(220, 123);
            this.check_time_landuse.Name = "check_time_landuse";
            this.check_time_landuse.Size = new System.Drawing.Size(15, 14);
            this.check_time_landuse.TabIndex = 141;
            this.check_time_landuse.UseVisualStyleBackColor = true;
            this.check_time_landuse.CheckedChanged += new System.EventHandler(this.check_time_landuse_CheckedChanged);
            // 
            // check_space_DTM
            // 
            this.check_space_DTM.AutoSize = true;
            this.check_space_DTM.Checked = true;
            this.check_space_DTM.CheckState = System.Windows.Forms.CheckState.Checked;
            this.check_space_DTM.Enabled = false;
            this.check_space_DTM.Location = new System.Drawing.Point(188, 51);
            this.check_space_DTM.Name = "check_space_DTM";
            this.check_space_DTM.Size = new System.Drawing.Size(15, 14);
            this.check_space_DTM.TabIndex = 138;
            this.check_space_DTM.UseVisualStyleBackColor = true;
            // 
            // tillfields_constant_textbox
            // 
            this.tillfields_constant_textbox.Location = new System.Drawing.Point(410, 145);
            this.tillfields_constant_textbox.Name = "tillfields_constant_textbox";
            this.tillfields_constant_textbox.ReadOnly = true;
            this.tillfields_constant_textbox.Size = new System.Drawing.Size(120, 20);
            this.tillfields_constant_textbox.TabIndex = 123;
            this.tillfields_constant_textbox.Text = "1";
            // 
            // tillfields_input_filename_textbox
            // 
            this.tillfields_input_filename_textbox.Enabled = false;
            this.tillfields_input_filename_textbox.Location = new System.Drawing.Point(258, 145);
            this.tillfields_input_filename_textbox.Name = "tillfields_input_filename_textbox";
            this.tillfields_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.tillfields_input_filename_textbox.TabIndex = 122;
            this.tillfields_input_filename_textbox.Text = "..";
            this.tillfields_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.tillfields_input_filename_textbox.Click += new System.EventHandler(this.tillfields_input_filename_textbox_TextChanged);
            this.tillfields_input_filename_textbox.TextChanged += new System.EventHandler(this.tillfields_input_filename_textbox_TextChanged_1);
            // 
            // evap_constant_value_box
            // 
            this.evap_constant_value_box.Location = new System.Drawing.Point(410, 219);
            this.evap_constant_value_box.Name = "evap_constant_value_box";
            this.evap_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.evap_constant_value_box.TabIndex = 120;
            this.evap_constant_value_box.Text = "0.35";
            // 
            // evap_input_filename_textbox
            // 
            this.evap_input_filename_textbox.Enabled = false;
            this.evap_input_filename_textbox.Location = new System.Drawing.Point(258, 219);
            this.evap_input_filename_textbox.Name = "evap_input_filename_textbox";
            this.evap_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.evap_input_filename_textbox.TabIndex = 119;
            this.evap_input_filename_textbox.Text = "..";
            this.evap_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.evap_input_filename_textbox.Click += new System.EventHandler(this.evap_input_filename_textbox_TextChanged);
            // 
            // infil_constant_value_box
            // 
            this.infil_constant_value_box.Location = new System.Drawing.Point(410, 193);
            this.infil_constant_value_box.Name = "infil_constant_value_box";
            this.infil_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.infil_constant_value_box.TabIndex = 117;
            this.infil_constant_value_box.Text = "0.150";
            // 
            // infil_input_filename_textbox
            // 
            this.infil_input_filename_textbox.Enabled = false;
            this.infil_input_filename_textbox.Location = new System.Drawing.Point(258, 193);
            this.infil_input_filename_textbox.Name = "infil_input_filename_textbox";
            this.infil_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.infil_input_filename_textbox.TabIndex = 116;
            this.infil_input_filename_textbox.Text = "..";
            this.infil_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.infil_input_filename_textbox.Click += new System.EventHandler(this.infil_input_filename_textbox_TextChanged);
            // 
            // rainfall_constant_value_box
            // 
            this.rainfall_constant_value_box.Location = new System.Drawing.Point(410, 169);
            this.rainfall_constant_value_box.Name = "rainfall_constant_value_box";
            this.rainfall_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.rainfall_constant_value_box.TabIndex = 114;
            this.rainfall_constant_value_box.Text = "0.700";
            // 
            // landuse_constant_value_box
            // 
            this.landuse_constant_value_box.Location = new System.Drawing.Point(410, 120);
            this.landuse_constant_value_box.Name = "landuse_constant_value_box";
            this.landuse_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.landuse_constant_value_box.TabIndex = 113;
            this.landuse_constant_value_box.Text = "1";
            // 
            // soildepth_constant_value_box
            // 
            this.soildepth_constant_value_box.Location = new System.Drawing.Point(410, 76);
            this.soildepth_constant_value_box.Name = "soildepth_constant_value_box";
            this.soildepth_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.soildepth_constant_value_box.TabIndex = 112;
            this.soildepth_constant_value_box.Text = "100";
            // 
            // landuse_input_filename_textbox
            // 
            this.landuse_input_filename_textbox.Location = new System.Drawing.Point(258, 118);
            this.landuse_input_filename_textbox.Name = "landuse_input_filename_textbox";
            this.landuse_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.landuse_input_filename_textbox.TabIndex = 107;
            this.landuse_input_filename_textbox.Text = "..";
            this.landuse_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.landuse_input_filename_textbox.Click += new System.EventHandler(this.landuse_input_filename_textbox_TextChanged);
            // 
            // soildepth_input_filename_textbox
            // 
            this.soildepth_input_filename_textbox.Location = new System.Drawing.Point(258, 76);
            this.soildepth_input_filename_textbox.Name = "soildepth_input_filename_textbox";
            this.soildepth_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.soildepth_input_filename_textbox.TabIndex = 105;
            this.soildepth_input_filename_textbox.Text = "..";
            this.soildepth_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.soildepth_input_filename_textbox.Click += new System.EventHandler(this.soildepth_input_filename_textbox_TextChanged);
            // 
            // rain_input_filename_textbox
            // 
            this.rain_input_filename_textbox.Enabled = false;
            this.rain_input_filename_textbox.Location = new System.Drawing.Point(258, 169);
            this.rain_input_filename_textbox.Name = "rain_input_filename_textbox";
            this.rain_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.rain_input_filename_textbox.TabIndex = 103;
            this.rain_input_filename_textbox.Text = "..";
            this.rain_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.rain_input_filename_textbox.Click += new System.EventHandler(this.rain_input_filename_textbox_TextChanged);
            this.rain_input_filename_textbox.TextChanged += new System.EventHandler(this.rain_input_filename_textbox_TextChanged_1);
            // 
            // dtm_input_filename_textbox
            // 
            this.dtm_input_filename_textbox.Location = new System.Drawing.Point(258, 50);
            this.dtm_input_filename_textbox.Name = "dtm_input_filename_textbox";
            this.dtm_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.dtm_input_filename_textbox.TabIndex = 100;
            this.dtm_input_filename_textbox.Text = "..";
            this.dtm_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.dtm_input_filename_textbox.Click += new System.EventHandler(this.dtm_input_filename_textbox_Click);
            // 
            // groupBox8
            // 
            this.groupBox8.Controls.Add(this.fill_sinks_before_checkbox);
            this.groupBox8.Location = new System.Drawing.Point(589, 37);
            this.groupBox8.Name = "groupBox8";
            this.groupBox8.Size = new System.Drawing.Size(158, 48);
            this.groupBox8.TabIndex = 134;
            this.groupBox8.TabStop = false;
            this.groupBox8.Text = "before running: ";
            // 
            // check_space_evap
            // 
            this.check_space_evap.AutoSize = true;
            this.check_space_evap.Location = new System.Drawing.Point(188, 222);
            this.check_space_evap.Name = "check_space_evap";
            this.check_space_evap.Size = new System.Drawing.Size(15, 14);
            this.check_space_evap.TabIndex = 130;
            this.check_space_evap.UseVisualStyleBackColor = true;
            this.check_space_evap.CheckedChanged += new System.EventHandler(this.check_cnst_evap_CheckedChanged);
            // 
            // check_space_infil
            // 
            this.check_space_infil.AutoSize = true;
            this.check_space_infil.Location = new System.Drawing.Point(188, 198);
            this.check_space_infil.Name = "check_space_infil";
            this.check_space_infil.Size = new System.Drawing.Size(15, 14);
            this.check_space_infil.TabIndex = 129;
            this.check_space_infil.UseVisualStyleBackColor = true;
            this.check_space_infil.CheckedChanged += new System.EventHandler(this.check_cnst_infil_CheckedChanged);
            // 
            // check_space_rain
            // 
            this.check_space_rain.AutoSize = true;
            this.check_space_rain.Location = new System.Drawing.Point(188, 174);
            this.check_space_rain.Name = "check_space_rain";
            this.check_space_rain.Size = new System.Drawing.Size(15, 14);
            this.check_space_rain.TabIndex = 128;
            this.check_space_rain.UseVisualStyleBackColor = true;
            this.check_space_rain.CheckedChanged += new System.EventHandler(this.check_cnst_rain_CheckedChanged_1);
            // 
            // check_space_till_fields
            // 
            this.check_space_till_fields.AutoSize = true;
            this.check_space_till_fields.Location = new System.Drawing.Point(188, 150);
            this.check_space_till_fields.Name = "check_space_till_fields";
            this.check_space_till_fields.Size = new System.Drawing.Size(15, 14);
            this.check_space_till_fields.TabIndex = 127;
            this.check_space_till_fields.UseVisualStyleBackColor = true;
            this.check_space_till_fields.CheckedChanged += new System.EventHandler(this.check_cnst_till_fields_CheckedChanged);
            // 
            // check_space_landuse
            // 
            this.check_space_landuse.AutoSize = true;
            this.check_space_landuse.Location = new System.Drawing.Point(188, 123);
            this.check_space_landuse.Name = "check_space_landuse";
            this.check_space_landuse.Size = new System.Drawing.Size(15, 14);
            this.check_space_landuse.TabIndex = 126;
            this.check_space_landuse.UseVisualStyleBackColor = true;
            this.check_space_landuse.CheckedChanged += new System.EventHandler(this.check_cnst_landuse_CheckedChanged_1);
            // 
            // check_space_soildepth
            // 
            this.check_space_soildepth.AutoSize = true;
            this.check_space_soildepth.Location = new System.Drawing.Point(188, 76);
            this.check_space_soildepth.Name = "check_space_soildepth";
            this.check_space_soildepth.Size = new System.Drawing.Size(15, 14);
            this.check_space_soildepth.TabIndex = 125;
            this.check_space_soildepth.UseVisualStyleBackColor = true;
            this.check_space_soildepth.CheckedChanged += new System.EventHandler(this.check_cnst_soildepth_CheckedChanged_1);
            // 
            // label4
            // 
            this.label4.Location = new System.Drawing.Point(19, 116);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(104, 24);
            this.label4.TabIndex = 106;
            this.label4.Text = "landuse (classes)";
            this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(19, 71);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(104, 24);
            this.label3.TabIndex = 104;
            this.label3.Text = "soildepth [m]";
            this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label23
            // 
            this.label23.Location = new System.Drawing.Point(19, 45);
            this.label23.Name = "label23";
            this.label23.Size = new System.Drawing.Size(134, 24);
            this.label23.TabIndex = 56;
            this.label23.Text = "Digital Elevation Model [m]";
            this.label23.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // Processes
            // 
            this.Processes.Controls.Add(this.Process_tabs);
            this.Processes.Location = new System.Drawing.Point(4, 22);
            this.Processes.Name = "Processes";
            this.Processes.Size = new System.Drawing.Size(803, 293);
            this.Processes.TabIndex = 6;
            this.Processes.Text = "Geomorphic processes";
            this.Processes.UseVisualStyleBackColor = true;
            // 
            // Process_tabs
            // 
            this.Process_tabs.Controls.Add(this.Water);
            this.Process_tabs.Controls.Add(this.Tillage);
            this.Process_tabs.Controls.Add(this.Creeper);
            this.Process_tabs.Controls.Add(Landsliding);
            this.Process_tabs.Controls.Add(this.Solifluction);
            this.Process_tabs.Controls.Add(this.Rock_weathering);
            this.Process_tabs.Controls.Add(this.Tectonics);
            this.Process_tabs.Controls.Add(this.treefall);
            this.Process_tabs.Controls.Add(this.tabPage3);
            this.Process_tabs.Location = new System.Drawing.Point(8, 14);
            this.Process_tabs.MaximumSize = new System.Drawing.Size(740, 276);
            this.Process_tabs.MinimumSize = new System.Drawing.Size(740, 276);
            this.Process_tabs.Name = "Process_tabs";
            this.Process_tabs.SelectedIndex = 0;
            this.Process_tabs.Size = new System.Drawing.Size(740, 276);
            this.Process_tabs.TabIndex = 0;
            // 
            // Water
            // 
            this.Water.Controls.Add(this.daily_water);
            this.Water.Controls.Add(this.label87);
            this.Water.Controls.Add(this.selectivity_constant_textbox);
            this.Water.Controls.Add(this.bio_protection_constant_textbox);
            this.Water.Controls.Add(this.erosion_threshold_textbox);
            this.Water.Controls.Add(this.rock_protection_constant_textbox);
            this.Water.Controls.Add(this.label90);
            this.Water.Controls.Add(this.label91);
            this.Water.Controls.Add(this.label92);
            this.Water.Controls.Add(this.parameter_n_textbox);
            this.Water.Controls.Add(this.parameter_conv_textbox);
            this.Water.Controls.Add(this.parameter_K_textbox);
            this.Water.Controls.Add(this.parameter_m_textbox);
            this.Water.Controls.Add(this.only_waterflow_checkbox);
            this.Water.Controls.Add(this.pictureBox1);
            this.Water.Controls.Add(this.label12);
            this.Water.Controls.Add(this.label11);
            this.Water.Controls.Add(this.label10);
            this.Water.Controls.Add(this.label9);
            this.Water.Controls.Add(this.Water_ero_checkbox);
            this.Water.Location = new System.Drawing.Point(4, 22);
            this.Water.Name = "Water";
            this.Water.Padding = new System.Windows.Forms.Padding(3);
            this.Water.Size = new System.Drawing.Size(732, 250);
            this.Water.TabIndex = 0;
            this.Water.Text = "Water erosion and deposition";
            this.Water.UseVisualStyleBackColor = true;
            // 
            // daily_water
            // 
            this.daily_water.AutoSize = true;
            this.daily_water.Location = new System.Drawing.Point(392, 16);
            this.daily_water.Name = "daily_water";
            this.daily_water.Size = new System.Drawing.Size(100, 17);
            this.daily_water.TabIndex = 29;
            this.daily_water.Text = "Daily water flow";
            this.daily_water.UseVisualStyleBackColor = true;
            this.daily_water.CheckedChanged += new System.EventHandler(this.daily_water_CheckedChanged);
            // 
            // label87
            // 
            this.label87.AutoSize = true;
            this.label87.Location = new System.Drawing.Point(101, 228);
            this.label87.Name = "label87";
            this.label87.Size = new System.Drawing.Size(136, 13);
            this.label87.TabIndex = 28;
            this.label87.Text = "selectivity change constant";
            // 
            // selectivity_constant_textbox
            // 
            this.selectivity_constant_textbox.Location = new System.Drawing.Point(26, 225);
            this.selectivity_constant_textbox.Name = "selectivity_constant_textbox";
            this.selectivity_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.selectivity_constant_textbox.TabIndex = 27;
            this.selectivity_constant_textbox.Text = "0";
            // 
            // bio_protection_constant_textbox
            // 
            this.bio_protection_constant_textbox.Location = new System.Drawing.Point(26, 199);
            this.bio_protection_constant_textbox.Name = "bio_protection_constant_textbox";
            this.bio_protection_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.bio_protection_constant_textbox.TabIndex = 21;
            this.bio_protection_constant_textbox.Text = "1";
            // 
            // erosion_threshold_textbox
            // 
            this.erosion_threshold_textbox.Location = new System.Drawing.Point(26, 147);
            this.erosion_threshold_textbox.Name = "erosion_threshold_textbox";
            this.erosion_threshold_textbox.Size = new System.Drawing.Size(53, 20);
            this.erosion_threshold_textbox.TabIndex = 20;
            this.erosion_threshold_textbox.Text = "0.01";
            // 
            // rock_protection_constant_textbox
            // 
            this.rock_protection_constant_textbox.Location = new System.Drawing.Point(26, 173);
            this.rock_protection_constant_textbox.Name = "rock_protection_constant_textbox";
            this.rock_protection_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.rock_protection_constant_textbox.TabIndex = 17;
            this.rock_protection_constant_textbox.Text = "1";
            // 
            // label90
            // 
            this.label90.AutoSize = true;
            this.label90.Location = new System.Drawing.Point(101, 150);
            this.label90.Name = "label90";
            this.label90.Size = new System.Drawing.Size(87, 13);
            this.label90.TabIndex = 24;
            this.label90.Text = "erosion threshold";
            // 
            // label91
            // 
            this.label91.AutoSize = true;
            this.label91.Location = new System.Drawing.Point(101, 202);
            this.label91.Name = "label91";
            this.label91.Size = new System.Drawing.Size(115, 13);
            this.label91.TabIndex = 23;
            this.label91.Text = "bio protection constant";
            // 
            // label92
            // 
            this.label92.AutoSize = true;
            this.label92.Location = new System.Drawing.Point(101, 176);
            this.label92.Name = "label92";
            this.label92.Size = new System.Drawing.Size(122, 13);
            this.label92.TabIndex = 22;
            this.label92.Text = "rock protection constant";
            // 
            // parameter_n_textbox
            // 
            this.parameter_n_textbox.Location = new System.Drawing.Point(26, 96);
            this.parameter_n_textbox.Name = "parameter_n_textbox";
            this.parameter_n_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_n_textbox.TabIndex = 7;
            this.parameter_n_textbox.Text = "1.3";
            // 
            // parameter_conv_textbox
            // 
            this.parameter_conv_textbox.Location = new System.Drawing.Point(26, 47);
            this.parameter_conv_textbox.Name = "parameter_conv_textbox";
            this.parameter_conv_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_conv_textbox.TabIndex = 6;
            this.parameter_conv_textbox.Text = "2";
            this.parameter_conv_textbox.TextChanged += new System.EventHandler(this.parameter_conv_textbox_TextChanged);
            // 
            // parameter_K_textbox
            // 
            this.parameter_K_textbox.Location = new System.Drawing.Point(26, 121);
            this.parameter_K_textbox.Name = "parameter_K_textbox";
            this.parameter_K_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_K_textbox.TabIndex = 5;
            this.parameter_K_textbox.Text = "0.0003";
            // 
            // parameter_m_textbox
            // 
            this.parameter_m_textbox.Location = new System.Drawing.Point(26, 70);
            this.parameter_m_textbox.Name = "parameter_m_textbox";
            this.parameter_m_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_m_textbox.TabIndex = 1;
            this.parameter_m_textbox.Text = "1.67";
            // 
            // only_waterflow_checkbox
            // 
            this.only_waterflow_checkbox.AutoSize = true;
            this.only_waterflow_checkbox.Location = new System.Drawing.Point(156, 16);
            this.only_waterflow_checkbox.Name = "only_waterflow_checkbox";
            this.only_waterflow_checkbox.Size = new System.Drawing.Size(219, 17);
            this.only_waterflow_checkbox.TabIndex = 14;
            this.only_waterflow_checkbox.Text = "Only calculate waterflow, no ero and dep";
            this.only_waterflow_checkbox.UseVisualStyleBackColor = true;
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(266, 53);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(180, 137);
            this.pictureBox1.TabIndex = 13;
            this.pictureBox1.TabStop = false;
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Location = new System.Drawing.Point(101, 124);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(66, 13);
            this.label12.TabIndex = 11;
            this.label12.Text = "K (erodibility)";
            // 
            // label11
            // 
            this.label11.AutoSize = true;
            this.label11.Location = new System.Drawing.Point(101, 50);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(109, 13);
            this.label11.TabIndex = 10;
            this.label11.Text = "p (multiple flow factor)";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(101, 99);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(106, 13);
            this.label10.TabIndex = 9;
            this.label10.Text = "n (exponent of slope)";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(101, 73);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(146, 13);
            this.label9.TabIndex = 8;
            this.label9.Text = "m (exponent of overland flow)";
            // 
            // Water_ero_checkbox
            // 
            this.Water_ero_checkbox.AutoSize = true;
            this.Water_ero_checkbox.Checked = true;
            this.Water_ero_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Water_ero_checkbox.Location = new System.Drawing.Point(26, 16);
            this.Water_ero_checkbox.Name = "Water_ero_checkbox";
            this.Water_ero_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Water_ero_checkbox.TabIndex = 0;
            this.Water_ero_checkbox.Text = "Activate this process";
            this.Water_ero_checkbox.UseVisualStyleBackColor = true;
            this.Water_ero_checkbox.CheckedChanged += new System.EventHandler(this.Water_ero_checkbox_CheckedChanged);
            // 
            // Tillage
            // 
            this.Tillage.Controls.Add(this.pictureBox2);
            this.Tillage.Controls.Add(this.label20);
            this.Tillage.Controls.Add(this.trte);
            this.Tillage.Controls.Add(this.parameter_tillage_constant_textbox);
            this.Tillage.Controls.Add(this.parameter_ploughing_depth_textbox);
            this.Tillage.Controls.Add(this.Tillage_checkbox);
            this.Tillage.Location = new System.Drawing.Point(4, 22);
            this.Tillage.Name = "Tillage";
            this.Tillage.Padding = new System.Windows.Forms.Padding(3);
            this.Tillage.Size = new System.Drawing.Size(732, 250);
            this.Tillage.TabIndex = 1;
            this.Tillage.Text = "Tillage";
            this.Tillage.UseVisualStyleBackColor = true;
            // 
            // pictureBox2
            // 
            this.pictureBox2.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox2.Image")));
            this.pictureBox2.Location = new System.Drawing.Point(276, 57);
            this.pictureBox2.Name = "pictureBox2";
            this.pictureBox2.Size = new System.Drawing.Size(180, 137);
            this.pictureBox2.TabIndex = 20;
            this.pictureBox2.TabStop = false;
            // 
            // label20
            // 
            this.label20.AutoSize = true;
            this.label20.Location = new System.Drawing.Point(128, 87);
            this.label20.Name = "label20";
            this.label20.Size = new System.Drawing.Size(78, 13);
            this.label20.TabIndex = 19;
            this.label20.Text = "tillage constant";
            // 
            // trte
            // 
            this.trte.AutoSize = true;
            this.trte.Location = new System.Drawing.Point(128, 61);
            this.trte.Name = "trte";
            this.trte.Size = new System.Drawing.Size(83, 13);
            this.trte.TabIndex = 18;
            this.trte.Text = "ploughing depth";
            // 
            // parameter_tillage_constant_textbox
            // 
            this.parameter_tillage_constant_textbox.Location = new System.Drawing.Point(53, 84);
            this.parameter_tillage_constant_textbox.Name = "parameter_tillage_constant_textbox";
            this.parameter_tillage_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_tillage_constant_textbox.TabIndex = 17;
            this.parameter_tillage_constant_textbox.Text = "0.08";
            // 
            // parameter_ploughing_depth_textbox
            // 
            this.parameter_ploughing_depth_textbox.AcceptsTab = true;
            this.parameter_ploughing_depth_textbox.Location = new System.Drawing.Point(53, 58);
            this.parameter_ploughing_depth_textbox.Name = "parameter_ploughing_depth_textbox";
            this.parameter_ploughing_depth_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_ploughing_depth_textbox.TabIndex = 13;
            this.parameter_ploughing_depth_textbox.Text = "0.45";
            // 
            // Tillage_checkbox
            // 
            this.Tillage_checkbox.AutoSize = true;
            this.Tillage_checkbox.Location = new System.Drawing.Point(26, 16);
            this.Tillage_checkbox.Name = "Tillage_checkbox";
            this.Tillage_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Tillage_checkbox.TabIndex = 1;
            this.Tillage_checkbox.Text = "Activate this process";
            this.Tillage_checkbox.UseVisualStyleBackColor = true;
            // 
            // Creeper
            // 
            this.Creeper.Controls.Add(this.creep_testing);
            this.Creeper.Controls.Add(this.pictureBox3);
            this.Creeper.Controls.Add(this.label19);
            this.Creeper.Controls.Add(this.parameter_diffusivity_textbox);
            this.Creeper.Controls.Add(this.creep_active_checkbox);
            this.Creeper.Location = new System.Drawing.Point(4, 22);
            this.Creeper.Name = "Creeper";
            this.Creeper.Size = new System.Drawing.Size(732, 250);
            this.Creeper.TabIndex = 6;
            this.Creeper.Text = "Creep";
            this.Creeper.UseVisualStyleBackColor = true;
            // 
            // creep_testing
            // 
            this.creep_testing.AutoSize = true;
            this.creep_testing.Location = new System.Drawing.Point(26, 108);
            this.creep_testing.Name = "creep_testing";
            this.creep_testing.Size = new System.Drawing.Size(88, 17);
            this.creep_testing.TabIndex = 26;
            this.creep_testing.Text = "Creep testing";
            this.creep_testing.UseVisualStyleBackColor = true;
            // 
            // pictureBox3
            // 
            this.pictureBox3.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox3.Image")));
            this.pictureBox3.Location = new System.Drawing.Point(276, 57);
            this.pictureBox3.Name = "pictureBox3";
            this.pictureBox3.Size = new System.Drawing.Size(180, 137);
            this.pictureBox3.TabIndex = 25;
            this.pictureBox3.TabStop = false;
            // 
            // label19
            // 
            this.label19.AutoSize = true;
            this.label19.Location = new System.Drawing.Point(128, 63);
            this.label19.Name = "label19";
            this.label19.Size = new System.Drawing.Size(50, 13);
            this.label19.TabIndex = 23;
            this.label19.Text = "diffusivity";
            // 
            // parameter_diffusivity_textbox
            // 
            this.parameter_diffusivity_textbox.AcceptsTab = true;
            this.parameter_diffusivity_textbox.Location = new System.Drawing.Point(53, 60);
            this.parameter_diffusivity_textbox.Name = "parameter_diffusivity_textbox";
            this.parameter_diffusivity_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_diffusivity_textbox.TabIndex = 21;
            this.parameter_diffusivity_textbox.Text = "0.05";
            // 
            // creep_active_checkbox
            // 
            this.creep_active_checkbox.AutoSize = true;
            this.creep_active_checkbox.Location = new System.Drawing.Point(26, 18);
            this.creep_active_checkbox.Name = "creep_active_checkbox";
            this.creep_active_checkbox.Size = new System.Drawing.Size(124, 17);
            this.creep_active_checkbox.TabIndex = 20;
            this.creep_active_checkbox.Text = "Activate this process";
            this.creep_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // Solifluction
            // 
            this.Solifluction.Controls.Add(this.pictureBox5);
            this.Solifluction.Controls.Add(this.Solifluction_checkbox);
            this.Solifluction.Location = new System.Drawing.Point(4, 22);
            this.Solifluction.Name = "Solifluction";
            this.Solifluction.Size = new System.Drawing.Size(732, 250);
            this.Solifluction.TabIndex = 4;
            this.Solifluction.Text = "Solifluction";
            this.Solifluction.UseVisualStyleBackColor = true;
            // 
            // pictureBox5
            // 
            this.pictureBox5.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox5.Image")));
            this.pictureBox5.Location = new System.Drawing.Point(276, 57);
            this.pictureBox5.Name = "pictureBox5";
            this.pictureBox5.Size = new System.Drawing.Size(180, 137);
            this.pictureBox5.TabIndex = 14;
            this.pictureBox5.TabStop = false;
            // 
            // Solifluction_checkbox
            // 
            this.Solifluction_checkbox.AutoSize = true;
            this.Solifluction_checkbox.Enabled = false;
            this.Solifluction_checkbox.Location = new System.Drawing.Point(36, 24);
            this.Solifluction_checkbox.Name = "Solifluction_checkbox";
            this.Solifluction_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Solifluction_checkbox.TabIndex = 2;
            this.Solifluction_checkbox.Text = "Activate this process";
            this.Solifluction_checkbox.UseVisualStyleBackColor = true;
            // 
            // Rock_weathering
            // 
            this.Rock_weathering.Controls.Add(this.rockweath_method);
            this.Rock_weathering.Controls.Add(this.pictureBox6);
            this.Rock_weathering.Controls.Add(this.groupBox10);
            this.Rock_weathering.Controls.Add(this.groupBox9);
            this.Rock_weathering.Location = new System.Drawing.Point(4, 22);
            this.Rock_weathering.Name = "Rock_weathering";
            this.Rock_weathering.Size = new System.Drawing.Size(732, 250);
            this.Rock_weathering.TabIndex = 5;
            this.Rock_weathering.Text = "Rock weathering";
            this.Rock_weathering.UseVisualStyleBackColor = true;
            // 
            // rockweath_method
            // 
            this.rockweath_method.AllowDrop = true;
            this.rockweath_method.FormattingEnabled = true;
            this.rockweath_method.Items.AddRange(new object[] {
            "Humped",
            "Exponential (-P0 exp(-k1*dsoil))",
            "Function of infiltration (only with daily water flow)"});
            this.rockweath_method.Location = new System.Drawing.Point(26, 200);
            this.rockweath_method.Name = "rockweath_method";
            this.rockweath_method.Size = new System.Drawing.Size(121, 21);
            this.rockweath_method.TabIndex = 15;
            this.rockweath_method.Text = "Humped";
            this.rockweath_method.SelectedIndexChanged += new System.EventHandler(this.comboBox2_SelectedIndexChanged);
            // 
            // pictureBox6
            // 
            this.pictureBox6.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox6.Image")));
            this.pictureBox6.Location = new System.Drawing.Point(276, 57);
            this.pictureBox6.Name = "pictureBox6";
            this.pictureBox6.Size = new System.Drawing.Size(180, 137);
            this.pictureBox6.TabIndex = 14;
            this.pictureBox6.TabStop = false;
            // 
            // groupBox10
            // 
            this.groupBox10.Controls.Add(this.Frost_weathering_checkbox);
            this.groupBox10.Enabled = false;
            this.groupBox10.Location = new System.Drawing.Point(250, 14);
            this.groupBox10.Name = "groupBox10";
            this.groupBox10.Size = new System.Drawing.Size(222, 179);
            this.groupBox10.TabIndex = 6;
            this.groupBox10.TabStop = false;
            this.groupBox10.Text = "Frost weathering ";
            this.groupBox10.Visible = false;
            // 
            // Frost_weathering_checkbox
            // 
            this.Frost_weathering_checkbox.AutoSize = true;
            this.Frost_weathering_checkbox.Enabled = false;
            this.Frost_weathering_checkbox.Location = new System.Drawing.Point(14, 19);
            this.Frost_weathering_checkbox.Name = "Frost_weathering_checkbox";
            this.Frost_weathering_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Frost_weathering_checkbox.TabIndex = 3;
            this.Frost_weathering_checkbox.Text = "Activate this process";
            this.Frost_weathering_checkbox.UseVisualStyleBackColor = true;
            // 
            // Tectonics
            // 
            this.Tectonics.Controls.Add(this.groupBox14);
            this.Tectonics.Controls.Add(this.groupBox4);
            this.Tectonics.Location = new System.Drawing.Point(4, 22);
            this.Tectonics.Name = "Tectonics";
            this.Tectonics.Padding = new System.Windows.Forms.Padding(3);
            this.Tectonics.Size = new System.Drawing.Size(732, 250);
            this.Tectonics.TabIndex = 7;
            this.Tectonics.Text = "Tectonics";
            this.Tectonics.UseVisualStyleBackColor = true;
            // 
            // groupBox14
            // 
            this.groupBox14.Controls.Add(this.groupBox16);
            this.groupBox14.Controls.Add(this.Uplift_rate_textbox);
            this.groupBox14.Controls.Add(this.uplift_active_checkbox);
            this.groupBox14.Controls.Add(this.label39);
            this.groupBox14.Location = new System.Drawing.Point(176, 16);
            this.groupBox14.Name = "groupBox14";
            this.groupBox14.Size = new System.Drawing.Size(158, 209);
            this.groupBox14.TabIndex = 4;
            this.groupBox14.TabStop = false;
            this.groupBox14.Text = "Vertical uplift";
            // 
            // groupBox16
            // 
            this.groupBox16.Controls.Add(this.text_lift_col_less);
            this.groupBox16.Controls.Add(this.text_lift_col_more);
            this.groupBox16.Controls.Add(this.text_lift_row_less);
            this.groupBox16.Controls.Add(this.text_lift_row_more);
            this.groupBox16.Controls.Add(this.radio_lift_col_less_than);
            this.groupBox16.Controls.Add(this.radio_lift_row_more_than);
            this.groupBox16.Controls.Add(this.radio_lift_col_more_than);
            this.groupBox16.Controls.Add(this.radio_lift_row_less_than);
            this.groupBox16.Location = new System.Drawing.Point(13, 51);
            this.groupBox16.Name = "groupBox16";
            this.groupBox16.Size = new System.Drawing.Size(129, 105);
            this.groupBox16.TabIndex = 7;
            this.groupBox16.TabStop = false;
            this.groupBox16.Text = "For cells with:";
            // 
            // text_lift_col_less
            // 
            this.text_lift_col_less.Location = new System.Drawing.Point(63, 75);
            this.text_lift_col_less.Name = "text_lift_col_less";
            this.text_lift_col_less.Size = new System.Drawing.Size(54, 20);
            this.text_lift_col_less.TabIndex = 9;
            // 
            // text_lift_col_more
            // 
            this.text_lift_col_more.Location = new System.Drawing.Point(63, 56);
            this.text_lift_col_more.Name = "text_lift_col_more";
            this.text_lift_col_more.Size = new System.Drawing.Size(54, 20);
            this.text_lift_col_more.TabIndex = 8;
            // 
            // text_lift_row_less
            // 
            this.text_lift_row_less.Location = new System.Drawing.Point(63, 36);
            this.text_lift_row_less.Name = "text_lift_row_less";
            this.text_lift_row_less.Size = new System.Drawing.Size(54, 20);
            this.text_lift_row_less.TabIndex = 7;
            // 
            // text_lift_row_more
            // 
            this.text_lift_row_more.Location = new System.Drawing.Point(63, 16);
            this.text_lift_row_more.Name = "text_lift_row_more";
            this.text_lift_row_more.Size = new System.Drawing.Size(54, 20);
            this.text_lift_row_more.TabIndex = 6;
            // 
            // radio_lift_col_less_than
            // 
            this.radio_lift_col_less_than.AutoSize = true;
            this.radio_lift_col_less_than.Location = new System.Drawing.Point(6, 75);
            this.radio_lift_col_less_than.Name = "radio_lift_col_less_than";
            this.radio_lift_col_less_than.Size = new System.Drawing.Size(48, 17);
            this.radio_lift_col_less_than.TabIndex = 5;
            this.radio_lift_col_less_than.TabStop = true;
            this.radio_lift_col_less_than.Text = "col <";
            this.radio_lift_col_less_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_row_more_than
            // 
            this.radio_lift_row_more_than.AutoSize = true;
            this.radio_lift_row_more_than.Location = new System.Drawing.Point(6, 16);
            this.radio_lift_row_more_than.Name = "radio_lift_row_more_than";
            this.radio_lift_row_more_than.Size = new System.Drawing.Size(51, 17);
            this.radio_lift_row_more_than.TabIndex = 4;
            this.radio_lift_row_more_than.TabStop = true;
            this.radio_lift_row_more_than.Text = "row >";
            this.radio_lift_row_more_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_col_more_than
            // 
            this.radio_lift_col_more_than.AutoSize = true;
            this.radio_lift_col_more_than.Location = new System.Drawing.Point(6, 56);
            this.radio_lift_col_more_than.Name = "radio_lift_col_more_than";
            this.radio_lift_col_more_than.Size = new System.Drawing.Size(48, 17);
            this.radio_lift_col_more_than.TabIndex = 3;
            this.radio_lift_col_more_than.TabStop = true;
            this.radio_lift_col_more_than.Text = "col >";
            this.radio_lift_col_more_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_row_less_than
            // 
            this.radio_lift_row_less_than.AutoSize = true;
            this.radio_lift_row_less_than.Location = new System.Drawing.Point(6, 36);
            this.radio_lift_row_less_than.Name = "radio_lift_row_less_than";
            this.radio_lift_row_less_than.Size = new System.Drawing.Size(51, 17);
            this.radio_lift_row_less_than.TabIndex = 2;
            this.radio_lift_row_less_than.TabStop = true;
            this.radio_lift_row_less_than.Text = "row <";
            this.radio_lift_row_less_than.UseVisualStyleBackColor = true;
            // 
            // Uplift_rate_textbox
            // 
            this.Uplift_rate_textbox.Location = new System.Drawing.Point(13, 184);
            this.Uplift_rate_textbox.Name = "Uplift_rate_textbox";
            this.Uplift_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.Uplift_rate_textbox.TabIndex = 3;
            // 
            // uplift_active_checkbox
            // 
            this.uplift_active_checkbox.AutoSize = true;
            this.uplift_active_checkbox.Location = new System.Drawing.Point(13, 19);
            this.uplift_active_checkbox.Name = "uplift_active_checkbox";
            this.uplift_active_checkbox.Size = new System.Drawing.Size(65, 17);
            this.uplift_active_checkbox.TabIndex = 1;
            this.uplift_active_checkbox.Text = "Activate";
            this.uplift_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // label39
            // 
            this.label39.AutoSize = true;
            this.label39.Location = new System.Drawing.Point(10, 168);
            this.label39.Name = "label39";
            this.label39.Size = new System.Drawing.Size(83, 13);
            this.label39.TabIndex = 2;
            this.label39.Text = "Uplift rate [m/a]:";
            // 
            // groupBox4
            // 
            this.groupBox4.Controls.Add(this.label38);
            this.groupBox4.Controls.Add(this.Tilting_rate_textbox);
            this.groupBox4.Controls.Add(this.groupBox15);
            this.groupBox4.Controls.Add(this.tilting_active_checkbox);
            this.groupBox4.Location = new System.Drawing.Point(13, 16);
            this.groupBox4.Name = "groupBox4";
            this.groupBox4.Size = new System.Drawing.Size(153, 210);
            this.groupBox4.TabIndex = 3;
            this.groupBox4.TabStop = false;
            this.groupBox4.Text = "Tilting";
            // 
            // label38
            // 
            this.label38.AutoSize = true;
            this.label38.Location = new System.Drawing.Point(9, 168);
            this.label38.Name = "label38";
            this.label38.Size = new System.Drawing.Size(114, 13);
            this.label38.TabIndex = 8;
            this.label38.Text = "Max alt change [m/a]: ";
            // 
            // Tilting_rate_textbox
            // 
            this.Tilting_rate_textbox.Location = new System.Drawing.Point(6, 184);
            this.Tilting_rate_textbox.Name = "Tilting_rate_textbox";
            this.Tilting_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.Tilting_rate_textbox.TabIndex = 7;
            // 
            // groupBox15
            // 
            this.groupBox15.Controls.Add(this.radio_tilt_col_max);
            this.groupBox15.Controls.Add(this.radio_tilt_row_zero);
            this.groupBox15.Controls.Add(this.radio_tilt_col_zero);
            this.groupBox15.Controls.Add(this.radio_tilt_row_max);
            this.groupBox15.Location = new System.Drawing.Point(6, 51);
            this.groupBox15.Name = "groupBox15";
            this.groupBox15.Size = new System.Drawing.Size(113, 105);
            this.groupBox15.TabIndex = 6;
            this.groupBox15.TabStop = false;
            this.groupBox15.Text = "Stability along:";
            // 
            // radio_tilt_col_max
            // 
            this.radio_tilt_col_max.AutoSize = true;
            this.radio_tilt_col_max.Location = new System.Drawing.Point(6, 79);
            this.radio_tilt_col_max.Name = "radio_tilt_col_max";
            this.radio_tilt_col_max.Size = new System.Drawing.Size(87, 17);
            this.radio_tilt_col_max.TabIndex = 5;
            this.radio_tilt_col_max.TabStop = true;
            this.radio_tilt_col_max.Text = "col = max col";
            this.radio_tilt_col_max.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_row_zero
            // 
            this.radio_tilt_row_zero.AutoSize = true;
            this.radio_tilt_row_zero.Location = new System.Drawing.Point(6, 16);
            this.radio_tilt_row_zero.Name = "radio_tilt_row_zero";
            this.radio_tilt_row_zero.Size = new System.Drawing.Size(60, 17);
            this.radio_tilt_row_zero.TabIndex = 4;
            this.radio_tilt_row_zero.TabStop = true;
            this.radio_tilt_row_zero.Text = "row = 0";
            this.radio_tilt_row_zero.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_col_zero
            // 
            this.radio_tilt_col_zero.AutoSize = true;
            this.radio_tilt_col_zero.Location = new System.Drawing.Point(6, 56);
            this.radio_tilt_col_zero.Name = "radio_tilt_col_zero";
            this.radio_tilt_col_zero.Size = new System.Drawing.Size(57, 17);
            this.radio_tilt_col_zero.TabIndex = 3;
            this.radio_tilt_col_zero.TabStop = true;
            this.radio_tilt_col_zero.Text = "col = 0";
            this.radio_tilt_col_zero.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_row_max
            // 
            this.radio_tilt_row_max.AutoSize = true;
            this.radio_tilt_row_max.Location = new System.Drawing.Point(6, 36);
            this.radio_tilt_row_max.Name = "radio_tilt_row_max";
            this.radio_tilt_row_max.Size = new System.Drawing.Size(93, 17);
            this.radio_tilt_row_max.TabIndex = 2;
            this.radio_tilt_row_max.TabStop = true;
            this.radio_tilt_row_max.Text = "row = max row";
            this.radio_tilt_row_max.UseVisualStyleBackColor = true;
            // 
            // tilting_active_checkbox
            // 
            this.tilting_active_checkbox.AutoSize = true;
            this.tilting_active_checkbox.Location = new System.Drawing.Point(6, 19);
            this.tilting_active_checkbox.Name = "tilting_active_checkbox";
            this.tilting_active_checkbox.Size = new System.Drawing.Size(65, 17);
            this.tilting_active_checkbox.TabIndex = 0;
            this.tilting_active_checkbox.Text = "Activate";
            this.tilting_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // treefall
            // 
            this.treefall.Controls.Add(this.tf_freq);
            this.treefall.Controls.Add(this.label112);
            this.treefall.Controls.Add(this.tf_age);
            this.treefall.Controls.Add(this.label111);
            this.treefall.Controls.Add(this.tf_growth);
            this.treefall.Controls.Add(this.label110);
            this.treefall.Controls.Add(this.tf_D);
            this.treefall.Controls.Add(this.label95);
            this.treefall.Controls.Add(this.label107);
            this.treefall.Controls.Add(this.tf_W);
            this.treefall.Controls.Add(this.treefall_checkbox);
            this.treefall.Location = new System.Drawing.Point(4, 22);
            this.treefall.Name = "treefall";
            this.treefall.Size = new System.Drawing.Size(732, 250);
            this.treefall.TabIndex = 8;
            this.treefall.Text = "Tree fall";
            this.treefall.UseVisualStyleBackColor = true;
            // 
            // tf_freq
            // 
            this.tf_freq.Location = new System.Drawing.Point(25, 162);
            this.tf_freq.Name = "tf_freq";
            this.tf_freq.Size = new System.Drawing.Size(53, 20);
            this.tf_freq.TabIndex = 30;
            this.tf_freq.Text = "0.00002";
            this.tf_freq.TextChanged += new System.EventHandler(this.textBox3_TextChanged_4);
            // 
            // label112
            // 
            this.label112.AutoSize = true;
            this.label112.Location = new System.Drawing.Point(100, 165);
            this.label112.Name = "label112";
            this.label112.Size = new System.Drawing.Size(132, 13);
            this.label112.TabIndex = 29;
            this.label112.Text = "fall frequency [trees/m2/a]";
            // 
            // tf_age
            // 
            this.tf_age.Location = new System.Drawing.Point(25, 131);
            this.tf_age.Name = "tf_age";
            this.tf_age.Size = new System.Drawing.Size(53, 20);
            this.tf_age.TabIndex = 28;
            this.tf_age.Text = "300";
            // 
            // label111
            // 
            this.label111.AutoSize = true;
            this.label111.Location = new System.Drawing.Point(100, 134);
            this.label111.Name = "label111";
            this.label111.Size = new System.Drawing.Size(119, 13);
            this.label111.TabIndex = 27;
            this.label111.Text = "maximum age of tree [a]";
            // 
            // tf_growth
            // 
            this.tf_growth.Location = new System.Drawing.Point(25, 103);
            this.tf_growth.Name = "tf_growth";
            this.tf_growth.Size = new System.Drawing.Size(53, 20);
            this.tf_growth.TabIndex = 26;
            this.tf_growth.Text = "150";
            // 
            // label110
            // 
            this.label110.AutoSize = true;
            this.label110.Location = new System.Drawing.Point(100, 106);
            this.label110.Name = "label110";
            this.label110.Size = new System.Drawing.Size(204, 13);
            this.label110.TabIndex = 25;
            this.label110.Text = "time it takes to reach these dimensions [a]";
            // 
            // tf_D
            // 
            this.tf_D.Location = new System.Drawing.Point(25, 77);
            this.tf_D.Name = "tf_D";
            this.tf_D.Size = new System.Drawing.Size(53, 20);
            this.tf_D.TabIndex = 24;
            this.tf_D.Text = "0.7";
            // 
            // label95
            // 
            this.label95.AutoSize = true;
            this.label95.Location = new System.Drawing.Point(100, 80);
            this.label95.Name = "label95";
            this.label95.Size = new System.Drawing.Size(145, 13);
            this.label95.TabIndex = 23;
            this.label95.Text = "maximum depth root mass [m]";
            // 
            // label107
            // 
            this.label107.AutoSize = true;
            this.label107.Location = new System.Drawing.Point(100, 54);
            this.label107.Name = "label107";
            this.label107.Size = new System.Drawing.Size(158, 13);
            this.label107.TabIndex = 22;
            this.label107.Text = "maximum diameter root mass [m]";
            // 
            // tf_W
            // 
            this.tf_W.Location = new System.Drawing.Point(25, 51);
            this.tf_W.Name = "tf_W";
            this.tf_W.Size = new System.Drawing.Size(53, 20);
            this.tf_W.TabIndex = 21;
            this.tf_W.Text = "4";
            // 
            // treefall_checkbox
            // 
            this.treefall_checkbox.AutoSize = true;
            this.treefall_checkbox.Location = new System.Drawing.Point(25, 16);
            this.treefall_checkbox.Name = "treefall_checkbox";
            this.treefall_checkbox.Size = new System.Drawing.Size(124, 17);
            this.treefall_checkbox.TabIndex = 0;
            this.treefall_checkbox.Text = "Activate this process";
            this.treefall_checkbox.UseVisualStyleBackColor = true;
            this.treefall_checkbox.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged_2);
            // 
            // tabPage3
            // 
            this.tabPage3.Controls.Add(this.label122);
            this.tabPage3.Controls.Add(this.label123);
            this.tabPage3.Controls.Add(this.blockweath_textbox);
            this.tabPage3.Controls.Add(this.blocksize_textbox);
            this.tabPage3.Controls.Add(this.label121);
            this.tabPage3.Controls.Add(this.label63);
            this.tabPage3.Controls.Add(this.label62);
            this.tabPage3.Controls.Add(this.hardlayerdensity_textbox);
            this.tabPage3.Controls.Add(this.hardlayerweath_textbox);
            this.tabPage3.Controls.Add(this.hardlayerelevation_textbox);
            this.tabPage3.Controls.Add(this.hardlayerthickness_textbox);
            this.tabPage3.Controls.Add(this.label61);
            this.tabPage3.Controls.Add(this.blocks_active_checkbox);
            this.tabPage3.Location = new System.Drawing.Point(4, 22);
            this.tabPage3.Name = "tabPage3";
            this.tabPage3.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage3.Size = new System.Drawing.Size(732, 250);
            this.tabPage3.TabIndex = 9;
            this.tabPage3.Text = "Blocks";
            this.tabPage3.UseVisualStyleBackColor = true;
            // 
            // label122
            // 
            this.label122.AutoSize = true;
            this.label122.Location = new System.Drawing.Point(142, 213);
            this.label122.Name = "label122";
            this.label122.Size = new System.Drawing.Size(115, 13);
            this.label122.TabIndex = 13;
            this.label122.Text = "Minimum block size (m)";
            // 
            // label123
            // 
            this.label123.AutoSize = true;
            this.label123.Location = new System.Drawing.Point(142, 187);
            this.label123.Name = "label123";
            this.label123.Size = new System.Drawing.Size(139, 13);
            this.label123.TabIndex = 12;
            this.label123.Text = "Block weathering fraction (-)";
            // 
            // blockweath_textbox
            // 
            this.blockweath_textbox.Location = new System.Drawing.Point(19, 184);
            this.blockweath_textbox.Name = "blockweath_textbox";
            this.blockweath_textbox.Size = new System.Drawing.Size(100, 20);
            this.blockweath_textbox.TabIndex = 11;
            // 
            // blocksize_textbox
            // 
            this.blocksize_textbox.Location = new System.Drawing.Point(19, 210);
            this.blocksize_textbox.Name = "blocksize_textbox";
            this.blocksize_textbox.Size = new System.Drawing.Size(100, 20);
            this.blocksize_textbox.TabIndex = 10;
            // 
            // label121
            // 
            this.label121.AutoSize = true;
            this.label121.Location = new System.Drawing.Point(142, 138);
            this.label121.Name = "label121";
            this.label121.Size = new System.Drawing.Size(183, 13);
            this.label121.TabIndex = 9;
            this.label121.Text = "Relative rate of hard layer weathering";
            // 
            // label63
            // 
            this.label63.AutoSize = true;
            this.label63.Location = new System.Drawing.Point(142, 112);
            this.label63.Name = "label63";
            this.label63.Size = new System.Drawing.Size(131, 13);
            this.label63.TabIndex = 8;
            this.label63.Text = "Hard layer density (kg/m3)";
            // 
            // label62
            // 
            this.label62.AutoSize = true;
            this.label62.Location = new System.Drawing.Point(142, 86);
            this.label62.Name = "label62";
            this.label62.Size = new System.Drawing.Size(118, 13);
            this.label62.TabIndex = 7;
            this.label62.Text = "Hard layer elevation (m)";
            // 
            // hardlayerdensity_textbox
            // 
            this.hardlayerdensity_textbox.Location = new System.Drawing.Point(19, 109);
            this.hardlayerdensity_textbox.Name = "hardlayerdensity_textbox";
            this.hardlayerdensity_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerdensity_textbox.TabIndex = 6;
            // 
            // hardlayerweath_textbox
            // 
            this.hardlayerweath_textbox.Location = new System.Drawing.Point(19, 135);
            this.hardlayerweath_textbox.Name = "hardlayerweath_textbox";
            this.hardlayerweath_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerweath_textbox.TabIndex = 5;
            // 
            // hardlayerelevation_textbox
            // 
            this.hardlayerelevation_textbox.Location = new System.Drawing.Point(19, 83);
            this.hardlayerelevation_textbox.Name = "hardlayerelevation_textbox";
            this.hardlayerelevation_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerelevation_textbox.TabIndex = 4;
            // 
            // hardlayerthickness_textbox
            // 
            this.hardlayerthickness_textbox.Location = new System.Drawing.Point(19, 57);
            this.hardlayerthickness_textbox.Name = "hardlayerthickness_textbox";
            this.hardlayerthickness_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerthickness_textbox.TabIndex = 3;
            // 
            // label61
            // 
            this.label61.AutoSize = true;
            this.label61.Location = new System.Drawing.Point(142, 60);
            this.label61.Name = "label61";
            this.label61.Size = new System.Drawing.Size(120, 13);
            this.label61.TabIndex = 2;
            this.label61.Text = "Hard layer thickness (m)";
            // 
            // blocks_active_checkbox
            // 
            this.blocks_active_checkbox.AutoSize = true;
            this.blocks_active_checkbox.Location = new System.Drawing.Point(19, 20);
            this.blocks_active_checkbox.Name = "blocks_active_checkbox";
            this.blocks_active_checkbox.Size = new System.Drawing.Size(124, 17);
            this.blocks_active_checkbox.TabIndex = 1;
            this.blocks_active_checkbox.Text = "Activate this process";
            this.blocks_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // Creep_Checkbox
            // 
            this.Creep_Checkbox.AutoSize = true;
            this.Creep_Checkbox.Enabled = false;
            this.Creep_Checkbox.Location = new System.Drawing.Point(26, 16);
            this.Creep_Checkbox.Name = "Creep_Checkbox";
            this.Creep_Checkbox.Size = new System.Drawing.Size(124, 17);
            this.Creep_Checkbox.TabIndex = 1;
            this.Creep_Checkbox.Text = "Activate this process";
            this.Creep_Checkbox.UseVisualStyleBackColor = true;
            // 
            // tabControl1
            // 
            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControl1.Controls.Add(this.Processes);
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Controls.Add(this.Input);
            this.tabControl1.Controls.Add(this.Run);
            this.tabControl1.Controls.Add(this.Output);
            this.tabControl1.Location = new System.Drawing.Point(4, 12);
            this.tabControl1.MaximumSize = new System.Drawing.Size(811, 319);
            this.tabControl1.MinimumSize = new System.Drawing.Size(811, 319);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(811, 319);
            this.tabControl1.TabIndex = 143;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.tabControl2);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Size = new System.Drawing.Size(803, 293);
            this.tabPage1.TabIndex = 9;
            this.tabPage1.Text = "Soil forming processes";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabControl2
            // 
            this.tabControl2.Controls.Add(this.physical);
            this.tabControl2.Controls.Add(this.chemical);
            this.tabControl2.Controls.Add(this.clay);
            this.tabControl2.Controls.Add(this.bioturbation);
            this.tabControl2.Controls.Add(this.carbon);
            this.tabControl2.Controls.Add(this.decalcification);
            this.tabControl2.Location = new System.Drawing.Point(16, 15);
            this.tabControl2.Name = "tabControl2";
            this.tabControl2.SelectedIndex = 0;
            this.tabControl2.Size = new System.Drawing.Size(759, 261);
            this.tabControl2.TabIndex = 0;
            // 
            // physical
            // 
            this.physical.Controls.Add(label49);
            this.physical.Controls.Add(label48);
            this.physical.Controls.Add(label47);
            this.physical.Controls.Add(label46);
            this.physical.Controls.Add(label45);
            this.physical.Controls.Add(label44);
            this.physical.Controls.Add(label43);
            this.physical.Controls.Add(label42);
            this.physical.Controls.Add(label41);
            this.physical.Controls.Add(this.upper_particle_fine_clay_textbox);
            this.physical.Controls.Add(this.upper_particle_clay_textbox);
            this.physical.Controls.Add(this.upper_particle_silt_textbox);
            this.physical.Controls.Add(this.upper_particle_sand_textbox);
            this.physical.Controls.Add(this.upper_particle_coarse_textbox);
            this.physical.Controls.Add(this.physical_weath_constant2);
            this.physical.Controls.Add(this.physical_weath_constant1);
            this.physical.Controls.Add(this.Physical_weath_C1_textbox);
            this.physical.Controls.Add(this.soil_phys_weath_checkbox);
            this.physical.Location = new System.Drawing.Point(4, 22);
            this.physical.Name = "physical";
            this.physical.Padding = new System.Windows.Forms.Padding(3);
            this.physical.Size = new System.Drawing.Size(751, 235);
            this.physical.TabIndex = 0;
            this.physical.Text = "Physical weathering";
            this.physical.UseVisualStyleBackColor = true;
            // 
            // upper_particle_fine_clay_textbox
            // 
            this.upper_particle_fine_clay_textbox.Location = new System.Drawing.Point(303, 147);
            this.upper_particle_fine_clay_textbox.Name = "upper_particle_fine_clay_textbox";
            this.upper_particle_fine_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_fine_clay_textbox.TabIndex = 9;
            this.upper_particle_fine_clay_textbox.Text = "0.0000001";
            // 
            // upper_particle_clay_textbox
            // 
            this.upper_particle_clay_textbox.Location = new System.Drawing.Point(303, 121);
            this.upper_particle_clay_textbox.Name = "upper_particle_clay_textbox";
            this.upper_particle_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_clay_textbox.TabIndex = 8;
            this.upper_particle_clay_textbox.Text = "0.000002";
            // 
            // upper_particle_silt_textbox
            // 
            this.upper_particle_silt_textbox.Location = new System.Drawing.Point(303, 95);
            this.upper_particle_silt_textbox.Name = "upper_particle_silt_textbox";
            this.upper_particle_silt_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_silt_textbox.TabIndex = 7;
            this.upper_particle_silt_textbox.Text = "0.00005";
            // 
            // upper_particle_sand_textbox
            // 
            this.upper_particle_sand_textbox.Location = new System.Drawing.Point(303, 69);
            this.upper_particle_sand_textbox.Name = "upper_particle_sand_textbox";
            this.upper_particle_sand_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_sand_textbox.TabIndex = 6;
            this.upper_particle_sand_textbox.Text = "0.002";
            // 
            // upper_particle_coarse_textbox
            // 
            this.upper_particle_coarse_textbox.Location = new System.Drawing.Point(303, 43);
            this.upper_particle_coarse_textbox.Name = "upper_particle_coarse_textbox";
            this.upper_particle_coarse_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_coarse_textbox.TabIndex = 5;
            this.upper_particle_coarse_textbox.Text = "0.01";
            // 
            // physical_weath_constant2
            // 
            this.physical_weath_constant2.Location = new System.Drawing.Point(35, 95);
            this.physical_weath_constant2.Name = "physical_weath_constant2";
            this.physical_weath_constant2.Size = new System.Drawing.Size(100, 20);
            this.physical_weath_constant2.TabIndex = 4;
            this.physical_weath_constant2.Text = "5";
            // 
            // physical_weath_constant1
            // 
            this.physical_weath_constant1.Location = new System.Drawing.Point(35, 69);
            this.physical_weath_constant1.Name = "physical_weath_constant1";
            this.physical_weath_constant1.Size = new System.Drawing.Size(100, 20);
            this.physical_weath_constant1.TabIndex = 3;
            this.physical_weath_constant1.Text = "0.5";
            // 
            // Physical_weath_C1_textbox
            // 
            this.Physical_weath_C1_textbox.Location = new System.Drawing.Point(35, 43);
            this.Physical_weath_C1_textbox.Name = "Physical_weath_C1_textbox";
            this.Physical_weath_C1_textbox.Size = new System.Drawing.Size(100, 20);
            this.Physical_weath_C1_textbox.TabIndex = 2;
            this.Physical_weath_C1_textbox.Text = "0.000000004";
            // 
            // soil_phys_weath_checkbox
            // 
            this.soil_phys_weath_checkbox.AutoSize = true;
            this.soil_phys_weath_checkbox.Checked = true;
            this.soil_phys_weath_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_phys_weath_checkbox.Location = new System.Drawing.Point(21, 6);
            this.soil_phys_weath_checkbox.Name = "soil_phys_weath_checkbox";
            this.soil_phys_weath_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_phys_weath_checkbox.TabIndex = 1;
            this.soil_phys_weath_checkbox.Text = "Activate this process";
            this.soil_phys_weath_checkbox.UseVisualStyleBackColor = true;
            // 
            // chemical
            // 
            this.chemical.Controls.Add(label54);
            this.chemical.Controls.Add(label55);
            this.chemical.Controls.Add(label56);
            this.chemical.Controls.Add(label57);
            this.chemical.Controls.Add(label58);
            this.chemical.Controls.Add(label59);
            this.chemical.Controls.Add(this.specific_area_fine_clay_textbox);
            this.chemical.Controls.Add(this.specific_area_clay_textbox);
            this.chemical.Controls.Add(this.specific_area_silt_textbox);
            this.chemical.Controls.Add(this.specific_area_sand_textbox);
            this.chemical.Controls.Add(this.specific_area_coarse_textbox);
            this.chemical.Controls.Add(label53);
            this.chemical.Controls.Add(label50);
            this.chemical.Controls.Add(label51);
            this.chemical.Controls.Add(label52);
            this.chemical.Controls.Add(this.chem_weath_specific_coefficient_textbox);
            this.chemical.Controls.Add(this.chem_weath_depth_constant_textbox);
            this.chemical.Controls.Add(this.chem_weath_rate_constant_textbox);
            this.chemical.Controls.Add(this.soil_chem_weath_checkbox);
            this.chemical.Location = new System.Drawing.Point(4, 22);
            this.chemical.Name = "chemical";
            this.chemical.Padding = new System.Windows.Forms.Padding(3);
            this.chemical.Size = new System.Drawing.Size(751, 235);
            this.chemical.TabIndex = 1;
            this.chemical.Text = "Chemical weathering";
            this.chemical.UseVisualStyleBackColor = true;
            // 
            // specific_area_fine_clay_textbox
            // 
            this.specific_area_fine_clay_textbox.Location = new System.Drawing.Point(420, 142);
            this.specific_area_fine_clay_textbox.Name = "specific_area_fine_clay_textbox";
            this.specific_area_fine_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_fine_clay_textbox.TabIndex = 24;
            this.specific_area_fine_clay_textbox.Text = "100000";
            // 
            // specific_area_clay_textbox
            // 
            this.specific_area_clay_textbox.Location = new System.Drawing.Point(420, 116);
            this.specific_area_clay_textbox.Name = "specific_area_clay_textbox";
            this.specific_area_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_clay_textbox.TabIndex = 23;
            this.specific_area_clay_textbox.Text = "50000";
            // 
            // specific_area_silt_textbox
            // 
            this.specific_area_silt_textbox.Location = new System.Drawing.Point(420, 90);
            this.specific_area_silt_textbox.Name = "specific_area_silt_textbox";
            this.specific_area_silt_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_silt_textbox.TabIndex = 22;
            this.specific_area_silt_textbox.Text = "1000";
            // 
            // specific_area_sand_textbox
            // 
            this.specific_area_sand_textbox.Location = new System.Drawing.Point(420, 64);
            this.specific_area_sand_textbox.Name = "specific_area_sand_textbox";
            this.specific_area_sand_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_sand_textbox.TabIndex = 21;
            this.specific_area_sand_textbox.Text = "100";
            // 
            // specific_area_coarse_textbox
            // 
            this.specific_area_coarse_textbox.Location = new System.Drawing.Point(420, 38);
            this.specific_area_coarse_textbox.Name = "specific_area_coarse_textbox";
            this.specific_area_coarse_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_coarse_textbox.TabIndex = 20;
            this.specific_area_coarse_textbox.Text = "10";
            // 
            // chem_weath_specific_coefficient_textbox
            // 
            this.chem_weath_specific_coefficient_textbox.Location = new System.Drawing.Point(29, 90);
            this.chem_weath_specific_coefficient_textbox.Name = "chem_weath_specific_coefficient_textbox";
            this.chem_weath_specific_coefficient_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_specific_coefficient_textbox.TabIndex = 15;
            this.chem_weath_specific_coefficient_textbox.Text = "1";
            // 
            // chem_weath_depth_constant_textbox
            // 
            this.chem_weath_depth_constant_textbox.Location = new System.Drawing.Point(29, 64);
            this.chem_weath_depth_constant_textbox.Name = "chem_weath_depth_constant_textbox";
            this.chem_weath_depth_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_depth_constant_textbox.TabIndex = 14;
            this.chem_weath_depth_constant_textbox.Text = "2.5";
            // 
            // chem_weath_rate_constant_textbox
            // 
            this.chem_weath_rate_constant_textbox.Location = new System.Drawing.Point(29, 38);
            this.chem_weath_rate_constant_textbox.Name = "chem_weath_rate_constant_textbox";
            this.chem_weath_rate_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_rate_constant_textbox.TabIndex = 13;
            this.chem_weath_rate_constant_textbox.Text = "0.000000004";
            // 
            // soil_chem_weath_checkbox
            // 
            this.soil_chem_weath_checkbox.AutoSize = true;
            this.soil_chem_weath_checkbox.Checked = true;
            this.soil_chem_weath_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_chem_weath_checkbox.Location = new System.Drawing.Point(29, 6);
            this.soil_chem_weath_checkbox.Name = "soil_chem_weath_checkbox";
            this.soil_chem_weath_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_chem_weath_checkbox.TabIndex = 1;
            this.soil_chem_weath_checkbox.Text = "Activate this process";
            this.soil_chem_weath_checkbox.UseVisualStyleBackColor = true;
            this.soil_chem_weath_checkbox.CheckedChanged += new System.EventHandler(this.soil_chem_weath_checkbox_CheckedChanged);
            // 
            // clay
            // 
            this.clay.Controls.Add(this.ct_Jagercikova);
            this.clay.Controls.Add(this.label109);
            this.clay.Controls.Add(this.label108);
            this.clay.Controls.Add(this.ct_dd_Jagercikova);
            this.clay.Controls.Add(this.ct_v0_Jagercikova);
            this.clay.Controls.Add(label13);
            this.clay.Controls.Add(this.ct_depth_decay);
            this.clay.Controls.Add(this.CT_depth_decay_checkbox);
            this.clay.Controls.Add(label69);
            this.clay.Controls.Add(label70);
            this.clay.Controls.Add(eluviation_rate_constant);
            this.clay.Controls.Add(this.eluviation_coefficient_textbox);
            this.clay.Controls.Add(this.maximum_eluviation_textbox);
            this.clay.Controls.Add(label72);
            this.clay.Controls.Add(label64);
            this.clay.Controls.Add(label65);
            this.clay.Controls.Add(label66);
            this.clay.Controls.Add(label67);
            this.clay.Controls.Add(this.clay_neoform_C2_textbox);
            this.clay.Controls.Add(this.clay_neoform_C1_textbox);
            this.clay.Controls.Add(this.clay_neoform_constant_textbox);
            this.clay.Controls.Add(label60);
            this.clay.Controls.Add(this.soil_clay_transloc_checkbox);
            this.clay.Location = new System.Drawing.Point(4, 22);
            this.clay.Name = "clay";
            this.clay.Size = new System.Drawing.Size(751, 235);
            this.clay.TabIndex = 2;
            this.clay.Text = "Clay dynamics";
            this.clay.UseVisualStyleBackColor = true;
            // 
            // ct_Jagercikova
            // 
            this.ct_Jagercikova.AutoSize = true;
            this.ct_Jagercikova.Location = new System.Drawing.Point(540, 52);
            this.ct_Jagercikova.Name = "ct_Jagercikova";
            this.ct_Jagercikova.Size = new System.Drawing.Size(179, 17);
            this.ct_Jagercikova.TabIndex = 62;
            this.ct_Jagercikova.Text = "Advection equation Jagercikova";
            this.ct_Jagercikova.UseVisualStyleBackColor = true;
            // 
            // label109
            // 
            this.label109.AutoSize = true;
            this.label109.Location = new System.Drawing.Point(602, 108);
            this.label109.Name = "label109";
            this.label109.Size = new System.Drawing.Size(98, 13);
            this.label109.TabIndex = 61;
            this.label109.Text = "depth decay [cm-1]";
            // 
            // label108
            // 
            this.label108.AutoSize = true;
            this.label108.Location = new System.Drawing.Point(597, 78);
            this.label108.Name = "label108";
            this.label108.Size = new System.Drawing.Size(148, 13);
            this.label108.TabIndex = 60;
            this.label108.Text = "surface advection v0 [cm a-1]";
            // 
            // ct_dd_Jagercikova
            // 
            this.ct_dd_Jagercikova.Location = new System.Drawing.Point(540, 104);
            this.ct_dd_Jagercikova.Name = "ct_dd_Jagercikova";
            this.ct_dd_Jagercikova.Size = new System.Drawing.Size(51, 20);
            this.ct_dd_Jagercikova.TabIndex = 58;
            this.ct_dd_Jagercikova.Text = "0.09";
            // 
            // ct_v0_Jagercikova
            // 
            this.ct_v0_Jagercikova.Location = new System.Drawing.Point(540, 75);
            this.ct_v0_Jagercikova.Name = "ct_v0_Jagercikova";
            this.ct_v0_Jagercikova.Size = new System.Drawing.Size(51, 20);
            this.ct_v0_Jagercikova.TabIndex = 57;
            this.ct_v0_Jagercikova.Text = "0.18";
            // 
            // ct_depth_decay
            // 
            this.ct_depth_decay.Location = new System.Drawing.Point(303, 169);
            this.ct_depth_decay.Name = "ct_depth_decay";
            this.ct_depth_decay.Size = new System.Drawing.Size(100, 20);
            this.ct_depth_decay.TabIndex = 55;
            this.ct_depth_decay.Text = "2";
            // 
            // CT_depth_decay_checkbox
            // 
            this.CT_depth_decay_checkbox.AutoSize = true;
            this.CT_depth_decay_checkbox.Checked = true;
            this.CT_depth_decay_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.CT_depth_decay_checkbox.Location = new System.Drawing.Point(304, 146);
            this.CT_depth_decay_checkbox.Name = "CT_depth_decay_checkbox";
            this.CT_depth_decay_checkbox.Size = new System.Drawing.Size(137, 17);
            this.CT_depth_decay_checkbox.TabIndex = 54;
            this.CT_depth_decay_checkbox.Text = "Depth decay constant?";
            this.CT_depth_decay_checkbox.UseVisualStyleBackColor = true;
            // 
            // eluviation_coefficient_textbox
            // 
            this.eluviation_coefficient_textbox.Location = new System.Drawing.Point(304, 101);
            this.eluviation_coefficient_textbox.Name = "eluviation_coefficient_textbox";
            this.eluviation_coefficient_textbox.Size = new System.Drawing.Size(100, 20);
            this.eluviation_coefficient_textbox.TabIndex = 49;
            this.eluviation_coefficient_textbox.Text = "2";
            // 
            // maximum_eluviation_textbox
            // 
            this.maximum_eluviation_textbox.Location = new System.Drawing.Point(304, 75);
            this.maximum_eluviation_textbox.Name = "maximum_eluviation_textbox";
            this.maximum_eluviation_textbox.Size = new System.Drawing.Size(100, 20);
            this.maximum_eluviation_textbox.TabIndex = 48;
            this.maximum_eluviation_textbox.Text = "0.007";
            // 
            // clay_neoform_C2_textbox
            // 
            this.clay_neoform_C2_textbox.Location = new System.Drawing.Point(25, 127);
            this.clay_neoform_C2_textbox.Name = "clay_neoform_C2_textbox";
            this.clay_neoform_C2_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_C2_textbox.TabIndex = 42;
            this.clay_neoform_C2_textbox.Text = "20";
            // 
            // clay_neoform_C1_textbox
            // 
            this.clay_neoform_C1_textbox.Location = new System.Drawing.Point(25, 101);
            this.clay_neoform_C1_textbox.Name = "clay_neoform_C1_textbox";
            this.clay_neoform_C1_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_C1_textbox.TabIndex = 41;
            this.clay_neoform_C1_textbox.Text = "1";
            // 
            // clay_neoform_constant_textbox
            // 
            this.clay_neoform_constant_textbox.Location = new System.Drawing.Point(25, 75);
            this.clay_neoform_constant_textbox.Name = "clay_neoform_constant_textbox";
            this.clay_neoform_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_constant_textbox.TabIndex = 40;
            this.clay_neoform_constant_textbox.Text = "0.5";
            // 
            // soil_clay_transloc_checkbox
            // 
            this.soil_clay_transloc_checkbox.AutoSize = true;
            this.soil_clay_transloc_checkbox.Checked = true;
            this.soil_clay_transloc_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_clay_transloc_checkbox.Location = new System.Drawing.Point(26, 12);
            this.soil_clay_transloc_checkbox.Name = "soil_clay_transloc_checkbox";
            this.soil_clay_transloc_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_clay_transloc_checkbox.TabIndex = 1;
            this.soil_clay_transloc_checkbox.Text = "Activate this process";
            this.soil_clay_transloc_checkbox.UseVisualStyleBackColor = true;
            // 
            // bioturbation
            // 
            this.bioturbation.Controls.Add(label68);
            this.bioturbation.Controls.Add(label71);
            this.bioturbation.Controls.Add(label73);
            this.bioturbation.Controls.Add(this.bioturbation_depth_decay_textbox);
            this.bioturbation.Controls.Add(this.potential_bioturbation_textbox);
            this.bioturbation.Controls.Add(this.soil_bioturb_checkbox);
            this.bioturbation.Location = new System.Drawing.Point(4, 22);
            this.bioturbation.Name = "bioturbation";
            this.bioturbation.Size = new System.Drawing.Size(751, 235);
            this.bioturbation.TabIndex = 3;
            this.bioturbation.Text = "Bioturbation";
            this.bioturbation.UseVisualStyleBackColor = true;
            // 
            // bioturbation_depth_decay_textbox
            // 
            this.bioturbation_depth_decay_textbox.Location = new System.Drawing.Point(26, 74);
            this.bioturbation_depth_decay_textbox.Name = "bioturbation_depth_decay_textbox";
            this.bioturbation_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.bioturbation_depth_decay_textbox.TabIndex = 56;
            this.bioturbation_depth_decay_textbox.Text = "2.5";
            // 
            // potential_bioturbation_textbox
            // 
            this.potential_bioturbation_textbox.Location = new System.Drawing.Point(26, 48);
            this.potential_bioturbation_textbox.Name = "potential_bioturbation_textbox";
            this.potential_bioturbation_textbox.Size = new System.Drawing.Size(100, 20);
            this.potential_bioturbation_textbox.TabIndex = 55;
            this.potential_bioturbation_textbox.Text = "6";
            // 
            // soil_bioturb_checkbox
            // 
            this.soil_bioturb_checkbox.AutoSize = true;
            this.soil_bioturb_checkbox.Checked = true;
            this.soil_bioturb_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_bioturb_checkbox.Location = new System.Drawing.Point(26, 12);
            this.soil_bioturb_checkbox.Name = "soil_bioturb_checkbox";
            this.soil_bioturb_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_bioturb_checkbox.TabIndex = 1;
            this.soil_bioturb_checkbox.Text = "Activate this process";
            this.soil_bioturb_checkbox.UseVisualStyleBackColor = true;
            // 
            // carbon
            // 
            this.carbon.Controls.Add(this.carbon_o_decomp_rate_textbox);
            this.carbon.Controls.Add(label86);
            this.carbon.Controls.Add(this.carbon_y_decomp_rate_textbox);
            this.carbon.Controls.Add(this.carbon_o_twi_decay_textbox);
            this.carbon.Controls.Add(label85);
            this.carbon.Controls.Add(this.carbon_y_twi_decay_textbox);
            this.carbon.Controls.Add(this.carbon_o_depth_decay_textbox);
            this.carbon.Controls.Add(label84);
            this.carbon.Controls.Add(this.carbon_y_depth_decay_textbox);
            this.carbon.Controls.Add(label83);
            this.carbon.Controls.Add(label82);
            this.carbon.Controls.Add(label80);
            this.carbon.Controls.Add(label77);
            this.carbon.Controls.Add(label81);
            this.carbon.Controls.Add(this.carbon_humification_fraction_textbox);
            this.carbon.Controls.Add(label74);
            this.carbon.Controls.Add(label75);
            this.carbon.Controls.Add(label76);
            this.carbon.Controls.Add(this.carbon_depth_decay_textbox);
            this.carbon.Controls.Add(this.carbon_input_textbox);
            this.carbon.Controls.Add(this.soil_carbon_cycle_checkbox);
            this.carbon.Location = new System.Drawing.Point(4, 22);
            this.carbon.Name = "carbon";
            this.carbon.Size = new System.Drawing.Size(751, 235);
            this.carbon.TabIndex = 4;
            this.carbon.Text = "Carbon Cycle";
            this.carbon.UseVisualStyleBackColor = true;
            // 
            // carbon_o_decomp_rate_textbox
            // 
            this.carbon_o_decomp_rate_textbox.Location = new System.Drawing.Point(453, 111);
            this.carbon_o_decomp_rate_textbox.Name = "carbon_o_decomp_rate_textbox";
            this.carbon_o_decomp_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_decomp_rate_textbox.TabIndex = 81;
            this.carbon_o_decomp_rate_textbox.Text = "0.005";
            // 
            // carbon_y_decomp_rate_textbox
            // 
            this.carbon_y_decomp_rate_textbox.Location = new System.Drawing.Point(347, 111);
            this.carbon_y_decomp_rate_textbox.Name = "carbon_y_decomp_rate_textbox";
            this.carbon_y_decomp_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_decomp_rate_textbox.TabIndex = 79;
            this.carbon_y_decomp_rate_textbox.Text = "0.01";
            // 
            // carbon_o_twi_decay_textbox
            // 
            this.carbon_o_twi_decay_textbox.Location = new System.Drawing.Point(453, 163);
            this.carbon_o_twi_decay_textbox.Name = "carbon_o_twi_decay_textbox";
            this.carbon_o_twi_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_twi_decay_textbox.TabIndex = 78;
            this.carbon_o_twi_decay_textbox.Text = "0.03";
            // 
            // carbon_y_twi_decay_textbox
            // 
            this.carbon_y_twi_decay_textbox.Location = new System.Drawing.Point(347, 163);
            this.carbon_y_twi_decay_textbox.Name = "carbon_y_twi_decay_textbox";
            this.carbon_y_twi_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_twi_decay_textbox.TabIndex = 76;
            this.carbon_y_twi_decay_textbox.Text = "0.03";
            // 
            // carbon_o_depth_decay_textbox
            // 
            this.carbon_o_depth_decay_textbox.Location = new System.Drawing.Point(453, 137);
            this.carbon_o_depth_decay_textbox.Name = "carbon_o_depth_decay_textbox";
            this.carbon_o_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_depth_decay_textbox.TabIndex = 75;
            this.carbon_o_depth_decay_textbox.Text = "8";
            // 
            // carbon_y_depth_decay_textbox
            // 
            this.carbon_y_depth_decay_textbox.Location = new System.Drawing.Point(347, 137);
            this.carbon_y_depth_decay_textbox.Name = "carbon_y_depth_decay_textbox";
            this.carbon_y_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_depth_decay_textbox.TabIndex = 73;
            this.carbon_y_depth_decay_textbox.Text = "8";
            // 
            // carbon_humification_fraction_textbox
            // 
            this.carbon_humification_fraction_textbox.Location = new System.Drawing.Point(23, 117);
            this.carbon_humification_fraction_textbox.Name = "carbon_humification_fraction_textbox";
            this.carbon_humification_fraction_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_humification_fraction_textbox.TabIndex = 65;
            this.carbon_humification_fraction_textbox.Text = "0.8";
            // 
            // carbon_depth_decay_textbox
            // 
            this.carbon_depth_decay_textbox.Location = new System.Drawing.Point(23, 88);
            this.carbon_depth_decay_textbox.Name = "carbon_depth_decay_textbox";
            this.carbon_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_depth_decay_textbox.TabIndex = 61;
            this.carbon_depth_decay_textbox.Text = "8";
            // 
            // carbon_input_textbox
            // 
            this.carbon_input_textbox.Location = new System.Drawing.Point(23, 62);
            this.carbon_input_textbox.Name = "carbon_input_textbox";
            this.carbon_input_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_input_textbox.TabIndex = 60;
            this.carbon_input_textbox.Text = "1.5";
            // 
            // soil_carbon_cycle_checkbox
            // 
            this.soil_carbon_cycle_checkbox.AutoSize = true;
            this.soil_carbon_cycle_checkbox.Checked = true;
            this.soil_carbon_cycle_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_carbon_cycle_checkbox.Location = new System.Drawing.Point(25, 14);
            this.soil_carbon_cycle_checkbox.Name = "soil_carbon_cycle_checkbox";
            this.soil_carbon_cycle_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_carbon_cycle_checkbox.TabIndex = 2;
            this.soil_carbon_cycle_checkbox.Text = "Activate this process";
            this.soil_carbon_cycle_checkbox.UseVisualStyleBackColor = true;
            // 
            // decalcification
            // 
            this.decalcification.Controls.Add(this.label94);
            this.decalcification.Controls.Add(this.ini_CaCO3_content);
            this.decalcification.Controls.Add(this.decalcification_checkbox);
            this.decalcification.Location = new System.Drawing.Point(4, 22);
            this.decalcification.Name = "decalcification";
            this.decalcification.Size = new System.Drawing.Size(751, 235);
            this.decalcification.TabIndex = 5;
            this.decalcification.Text = "Decalcification";
            this.decalcification.UseVisualStyleBackColor = true;
            // 
            // label94
            // 
            this.label94.AutoSize = true;
            this.label94.Location = new System.Drawing.Point(138, 42);
            this.label94.Name = "label94";
            this.label94.Size = new System.Drawing.Size(107, 13);
            this.label94.TabIndex = 2;
            this.label94.Text = "Initial CaCO3 content";
            // 
            // ini_CaCO3_content
            // 
            this.ini_CaCO3_content.Location = new System.Drawing.Point(32, 39);
            this.ini_CaCO3_content.Name = "ini_CaCO3_content";
            this.ini_CaCO3_content.Size = new System.Drawing.Size(100, 20);
            this.ini_CaCO3_content.TabIndex = 1;
            this.ini_CaCO3_content.Text = "0.1";
            // 
            // decalcification_checkbox
            // 
            this.decalcification_checkbox.AutoSize = true;
            this.decalcification_checkbox.Location = new System.Drawing.Point(32, 15);
            this.decalcification_checkbox.Name = "decalcification_checkbox";
            this.decalcification_checkbox.Size = new System.Drawing.Size(124, 17);
            this.decalcification_checkbox.TabIndex = 0;
            this.decalcification_checkbox.Text = "Activate this process";
            this.decalcification_checkbox.UseVisualStyleBackColor = true;
            this.decalcification_checkbox.CheckedChanged += new System.EventHandler(this.decalcification_checkbox_CheckedChanged);
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.check_scaling_daily_weather);
            this.tabPage2.Controls.Add(this.label106);
            this.tabPage2.Controls.Add(this.snow_threshold_textbox);
            this.tabPage2.Controls.Add(this.label105);
            this.tabPage2.Controls.Add(this.snowmelt_factor_textbox);
            this.tabPage2.Controls.Add(this.label104);
            this.tabPage2.Controls.Add(this.latitude_min);
            this.tabPage2.Controls.Add(this.label103);
            this.tabPage2.Controls.Add(this.latitude_deg);
            this.tabPage2.Controls.Add(this.label100);
            this.tabPage2.Controls.Add(this.label101);
            this.tabPage2.Controls.Add(this.label102);
            this.tabPage2.Controls.Add(this.dailyT_min);
            this.tabPage2.Controls.Add(this.dailyT_max);
            this.tabPage2.Controls.Add(this.dailyT_avg);
            this.tabPage2.Controls.Add(this.label97);
            this.tabPage2.Controls.Add(this.daily_n);
            this.tabPage2.Controls.Add(this.label96);
            this.tabPage2.Controls.Add(this.label93);
            this.tabPage2.Controls.Add(this.label89);
            this.tabPage2.Controls.Add(this.label40);
            this.tabPage2.Controls.Add(this.dailyET0);
            this.tabPage2.Controls.Add(this.dailyD);
            this.tabPage2.Controls.Add(this.dailyP);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Size = new System.Drawing.Size(803, 293);
            this.tabPage2.TabIndex = 10;
            this.tabPage2.Text = "Hydrological parameters";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // check_scaling_daily_weather
            // 
            this.check_scaling_daily_weather.AutoSize = true;
            this.check_scaling_daily_weather.Location = new System.Drawing.Point(125, 227);
            this.check_scaling_daily_weather.Name = "check_scaling_daily_weather";
            this.check_scaling_daily_weather.Size = new System.Drawing.Size(230, 17);
            this.check_scaling_daily_weather.TabIndex = 71;
            this.check_scaling_daily_weather.Text = "Scale daily weather with annual timeseries?";
            this.check_scaling_daily_weather.UseVisualStyleBackColor = true;
            // 
            // label106
            // 
            this.label106.AutoSize = true;
            this.label106.Location = new System.Drawing.Point(394, 114);
            this.label106.Name = "label106";
            this.label106.Size = new System.Drawing.Size(236, 13);
            this.label106.TabIndex = 70;
            this.label106.Text = "Snowfall and snowmelt temperature threshold [C]";
            // 
            // snow_threshold_textbox
            // 
            this.snow_threshold_textbox.Enabled = false;
            this.snow_threshold_textbox.Location = new System.Drawing.Point(340, 111);
            this.snow_threshold_textbox.Name = "snow_threshold_textbox";
            this.snow_threshold_textbox.Size = new System.Drawing.Size(40, 20);
            this.snow_threshold_textbox.TabIndex = 69;
            this.snow_threshold_textbox.Text = "0";
            this.snow_threshold_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label105
            // 
            this.label105.AutoSize = true;
            this.label105.Location = new System.Drawing.Point(394, 76);
            this.label105.Name = "label105";
            this.label105.Size = new System.Drawing.Size(174, 13);
            this.label105.TabIndex = 68;
            this.label105.Text = "Snowmelt factor [m degree-1 day-1]";
            // 
            // snowmelt_factor_textbox
            // 
            this.snowmelt_factor_textbox.Enabled = false;
            this.snowmelt_factor_textbox.Location = new System.Drawing.Point(340, 73);
            this.snowmelt_factor_textbox.Name = "snowmelt_factor_textbox";
            this.snowmelt_factor_textbox.Size = new System.Drawing.Size(40, 20);
            this.snowmelt_factor_textbox.TabIndex = 67;
            this.snowmelt_factor_textbox.Text = "0.004";
            this.snowmelt_factor_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label104
            // 
            this.label104.AutoSize = true;
            this.label104.Location = new System.Drawing.Point(333, 15);
            this.label104.Name = "label104";
            this.label104.Size = new System.Drawing.Size(118, 13);
            this.label104.TabIndex = 66;
            this.label104.Text = "Properties of study area";
            // 
            // latitude_min
            // 
            this.latitude_min.Enabled = false;
            this.latitude_min.Location = new System.Drawing.Point(397, 35);
            this.latitude_min.Name = "latitude_min";
            this.latitude_min.Size = new System.Drawing.Size(44, 20);
            this.latitude_min.TabIndex = 65;
            this.latitude_min.Text = "22";
            this.latitude_min.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label103
            // 
            this.label103.AutoSize = true;
            this.label103.Location = new System.Drawing.Point(446, 38);
            this.label103.Name = "label103";
            this.label103.Size = new System.Drawing.Size(100, 13);
            this.label103.TabIndex = 64;
            this.label103.Text = "Latitude [deg], [min]";
            // 
            // latitude_deg
            // 
            this.latitude_deg.Enabled = false;
            this.latitude_deg.Location = new System.Drawing.Point(340, 35);
            this.latitude_deg.Name = "latitude_deg";
            this.latitude_deg.Size = new System.Drawing.Size(40, 20);
            this.latitude_deg.TabIndex = 63;
            this.latitude_deg.Text = "53";
            this.latitude_deg.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label100
            // 
            this.label100.AutoSize = true;
            this.label100.Location = new System.Drawing.Point(143, 148);
            this.label100.Name = "label100";
            this.label100.Size = new System.Drawing.Size(59, 13);
            this.label100.TabIndex = 62;
            this.label100.Text = "Daily T min";
            // 
            // label101
            // 
            this.label101.AutoSize = true;
            this.label101.Location = new System.Drawing.Point(143, 174);
            this.label101.Name = "label101";
            this.label101.Size = new System.Drawing.Size(62, 13);
            this.label101.TabIndex = 61;
            this.label101.Text = "Daily T max";
            // 
            // label102
            // 
            this.label102.AutoSize = true;
            this.label102.Location = new System.Drawing.Point(143, 117);
            this.label102.Name = "label102";
            this.label102.Size = new System.Drawing.Size(82, 13);
            this.label102.TabIndex = 60;
            this.label102.Text = "Daily T average";
            // 
            // dailyT_min
            // 
            this.dailyT_min.Enabled = false;
            this.dailyT_min.Location = new System.Drawing.Point(37, 145);
            this.dailyT_min.Name = "dailyT_min";
            this.dailyT_min.Size = new System.Drawing.Size(100, 20);
            this.dailyT_min.TabIndex = 59;
            this.dailyT_min.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tminday_grunow.csv" +
    "";
            this.dailyT_min.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyT_max
            // 
            this.dailyT_max.Enabled = false;
            this.dailyT_max.Location = new System.Drawing.Point(37, 171);
            this.dailyT_max.Name = "dailyT_max";
            this.dailyT_max.Size = new System.Drawing.Size(100, 20);
            this.dailyT_max.TabIndex = 58;
            this.dailyT_max.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tmaxday_grunow.csv" +
    "";
            this.dailyT_max.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyT_avg
            // 
            this.dailyT_avg.Enabled = false;
            this.dailyT_avg.Location = new System.Drawing.Point(37, 114);
            this.dailyT_avg.Name = "dailyT_avg";
            this.dailyT_avg.Size = new System.Drawing.Size(100, 20);
            this.dailyT_avg.TabIndex = 57;
            this.dailyT_avg.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tavgday_grunow.csv" +
    "";
            this.dailyT_avg.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label97
            // 
            this.label97.AutoSize = true;
            this.label97.Location = new System.Drawing.Point(142, 204);
            this.label97.Name = "label97";
            this.label97.Size = new System.Drawing.Size(83, 13);
            this.label97.TabIndex = 56;
            this.label97.Text = "Amount of years";
            // 
            // daily_n
            // 
            this.daily_n.Enabled = false;
            this.daily_n.Location = new System.Drawing.Point(36, 201);
            this.daily_n.Name = "daily_n";
            this.daily_n.Size = new System.Drawing.Size(100, 20);
            this.daily_n.TabIndex = 55;
            this.daily_n.Text = "6";
            this.daily_n.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label96
            // 
            this.label96.AutoSize = true;
            this.label96.Location = new System.Drawing.Point(20, 15);
            this.label96.Name = "label96";
            this.label96.Size = new System.Drawing.Size(229, 13);
            this.label96.TabIndex = 54;
            this.label96.Text = "Insert a series of yearly records of the following:";
            // 
            // label93
            // 
            this.label93.AutoSize = true;
            this.label93.Location = new System.Drawing.Point(142, 65);
            this.label93.Name = "label93";
            this.label93.Size = new System.Drawing.Size(53, 13);
            this.label93.TabIndex = 53;
            this.label93.Text = "Daily ET0";
            // 
            // label89
            // 
            this.label89.AutoSize = true;
            this.label89.Location = new System.Drawing.Point(142, 91);
            this.label89.Name = "label89";
            this.label89.Size = new System.Drawing.Size(71, 13);
            this.label89.TabIndex = 52;
            this.label89.Text = "Daily duration";
            // 
            // label40
            // 
            this.label40.AutoSize = true;
            this.label40.Location = new System.Drawing.Point(142, 34);
            this.label40.Name = "label40";
            this.label40.Size = new System.Drawing.Size(40, 13);
            this.label40.TabIndex = 51;
            this.label40.Text = "Daily P";
            // 
            // dailyET0
            // 
            this.dailyET0.Enabled = false;
            this.dailyET0.Location = new System.Drawing.Point(36, 62);
            this.dailyET0.Name = "dailyET0";
            this.dailyET0.Size = new System.Drawing.Size(100, 20);
            this.dailyET0.TabIndex = 50;
            this.dailyET0.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\ET0day_grunow.csv";
            this.dailyET0.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyD
            // 
            this.dailyD.Enabled = false;
            this.dailyD.Location = new System.Drawing.Point(36, 88);
            this.dailyD.Name = "dailyD";
            this.dailyD.Size = new System.Drawing.Size(100, 20);
            this.dailyD.TabIndex = 49;
            this.dailyD.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Dday_grunow.csv";
            this.dailyD.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyP
            // 
            this.dailyP.Enabled = false;
            this.dailyP.Location = new System.Drawing.Point(36, 31);
            this.dailyP.Name = "dailyP";
            this.dailyP.Size = new System.Drawing.Size(100, 20);
            this.dailyP.TabIndex = 48;
            this.dailyP.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Pday_grunow.csv";
            this.dailyP.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // Mother_form
            // 
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoScroll = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(1174, 497);
            this.Controls.Add(this.End_button);
            this.Controls.Add(this.start_button);
            this.Controls.Add(this.tabControl1);
            this.Controls.Add(this.statusBar1);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximumSize = new System.Drawing.Size(1200, 700);
            this.Menu = this.mainMenu1;
            this.MinimumSize = new System.Drawing.Size(823, 530);
            this.Name = "Mother_form";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "LORICA - Soilscape Evolution Model ";
            this.Load += new System.EventHandler(this.Form1_Load);
            Landsliding.ResumeLayout(false);
            Landsliding.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.InfoStatusPanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.TimeStatusPanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.ProcessStatusPanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.out_sed_statuspanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.total_tillage_statuspanel)).EndInit();
            this.groupBox13.ResumeLayout(false);
            this.groupBox13.PerformLayout();
            this.groupBox3.ResumeLayout(false);
            this.groupBox9.ResumeLayout(false);
            this.groupBox9.PerformLayout();
            this.Output.ResumeLayout(false);
            this.groupBox6.ResumeLayout(false);
            this.groupBox12.ResumeLayout(false);
            this.groupBox12.PerformLayout();
            this.groupBox11.ResumeLayout(false);
            this.groupBox11.PerformLayout();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.groupBox5.ResumeLayout(false);
            this.groupBox5.PerformLayout();
            this.UTMgroupBox.ResumeLayout(false);
            this.UTMgroupBox.PerformLayout();
            this.Run.ResumeLayout(false);
            this.Run.PerformLayout();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.groupBox7.ResumeLayout(false);
            this.groupBox7.PerformLayout();
            this.Input.ResumeLayout(false);
            this.Input.PerformLayout();
            this.groupBox8.ResumeLayout(false);
            this.groupBox8.PerformLayout();
            this.Processes.ResumeLayout(false);
            this.Process_tabs.ResumeLayout(false);
            this.Water.ResumeLayout(false);
            this.Water.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.Tillage.ResumeLayout(false);
            this.Tillage.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
            this.Creeper.ResumeLayout(false);
            this.Creeper.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).EndInit();
            this.Solifluction.ResumeLayout(false);
            this.Solifluction.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).EndInit();
            this.Rock_weathering.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).EndInit();
            this.groupBox10.ResumeLayout(false);
            this.groupBox10.PerformLayout();
            this.Tectonics.ResumeLayout(false);
            this.groupBox14.ResumeLayout(false);
            this.groupBox14.PerformLayout();
            this.groupBox16.ResumeLayout(false);
            this.groupBox16.PerformLayout();
            this.groupBox4.ResumeLayout(false);
            this.groupBox4.PerformLayout();
            this.groupBox15.ResumeLayout(false);
            this.groupBox15.PerformLayout();
            this.treefall.ResumeLayout(false);
            this.treefall.PerformLayout();
            this.tabPage3.ResumeLayout(false);
            this.tabPage3.PerformLayout();
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabControl2.ResumeLayout(false);
            this.physical.ResumeLayout(false);
            this.physical.PerformLayout();
            this.chemical.ResumeLayout(false);
            this.chemical.PerformLayout();
            this.clay.ResumeLayout(false);
            this.clay.PerformLayout();
            this.bioturbation.ResumeLayout(false);
            this.bioturbation.PerformLayout();
            this.carbon.ResumeLayout(false);
            this.carbon.PerformLayout();
            this.decalcification.ResumeLayout(false);
            this.decalcification.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.tabPage2.PerformLayout();
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.Run(new Mother_form());
        }   // creates the forms

        LORICA4.Output_timeseries timeseries = new LORICA4.Output_timeseries();
        LORICA4.Output_profile profile = new LORICA4.Output_profile();
        LORICA4.Landuse_determinator landuse_determinator = new LORICA4.Landuse_determinator();
        LORICA4.About_LORICA aboutbox = new LORICA4.About_LORICA();
        public LORICA4.Soil_specifier soildata = new LORICA4.Soil_specifier();


        #region memory, reading and writing utilities

        private void timeseries_output()
        {
            int step;
            string FILENAME = workdir + "\\timeseries.log";
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                //geomprph centred
                if (timeseries.timeseries_cell_waterflow_check.Checked) { sw.Write("cell_waterflow "); }
                if (timeseries.timeseries_cell_altitude_check.Checked) { sw.Write("cell_altitude "); }
                if (timeseries.timeseries_net_ero_check.Checked) { sw.Write("net_erosion "); }
                if (timeseries.timeseries_number_dep_check.Checked) { sw.Write("deposited_cells "); }
                if (timeseries.timeseries_number_erosion_check.Checked) { sw.Write("eroded_cells "); }
                if (timeseries.timeseries_number_waterflow_check.Checked) { sw.Write("wet_cells "); }
                if (timeseries.timeseries_SDR_check.Checked) { sw.Write("SDR "); }
                if (timeseries.timeseries_total_average_alt_check.Checked) { sw.Write("average_alt "); }
                if (timeseries.timeseries_total_dep_check.Checked) { sw.Write("total_dep "); }
                if (timeseries.timeseries_total_ero_check.Checked) { sw.Write("total_ero "); }
                if (timeseries.timeseries_total_evap_check.Checked) { sw.Write("total_evap "); }
                if (timeseries.timeseries_total_infil_check.Checked) { sw.Write("total_infil "); }
                if (timeseries.timeseries_total_outflow_check.Checked) { sw.Write("total_outflow "); }
                if (timeseries.timeseries_total_rain_check.Checked) { sw.Write("total_rain "); }
                //soil_centred
                if (timeseries.total_phys_weath_checkbox.Checked) { sw.Write("phys_weath "); }
                if (timeseries.total_chem_weath_checkbox.Checked) { sw.Write("chem_weath "); }
                if (timeseries.total_fine_formed_checkbox.Checked) { sw.Write("fine_clay_formed "); }
                if (timeseries.total_fine_eluviated_checkbox.Checked) { sw.Write("fine_clay_eluviated "); }
                if (timeseries.total_mass_bioturbed_checkbox.Checked) { sw.Write("mass_bioturbed "); }
                if (timeseries.total_OM_input_checkbox.Checked) { sw.Write("OM_input "); }
                if (timeseries.total_average_soilthickness_checkbox.Checked) { sw.Write("average_soilthickness "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_thicker "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_coarser "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_thickness "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_mass "); }
                sw.Write("\r\n");
                for (step = 0; step <= end_time - 1; step++)
                {
                    if (timeseries.timeseries_cell_waterflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[1]]); sw.Write(" "); }
                    if (timeseries.timeseries_cell_altitude_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[2]]); sw.Write(" "); }
                    if (timeseries.timeseries_net_ero_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[3]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_dep_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[4]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_erosion_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[5]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_waterflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[6]]); sw.Write(" "); }
                    if (timeseries.timeseries_SDR_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[7]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_average_alt_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[8]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_dep_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[9]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_ero_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[10]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_evap_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[11]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_infil_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[12]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_outflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[13]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_rain_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[14]]); sw.Write(" "); }
                    //soil_centred
                    if (timeseries.total_phys_weath_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[15]]); sw.Write(" "); }
                    if (timeseries.total_chem_weath_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[16]]); sw.Write(" "); }
                    if (timeseries.total_fine_formed_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[17]]); sw.Write(" "); }
                    if (timeseries.total_fine_eluviated_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[18]]); sw.Write(" "); }
                    if (timeseries.total_mass_bioturbed_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[19]]); sw.Write(" "); }
                    if (timeseries.total_OM_input_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[20]]); sw.Write(" "); }
                    if (timeseries.total_average_soilthickness_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[21]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[22]]); sw.Write(" "); }
                    if (timeseries.timeseries_coarser_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[23]]); sw.Write(" "); }
                    if (timeseries.timeseries_soil_depth_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[24]]); sw.Write(" "); }
                    if (timeseries.timeseries_soil_mass_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[25]]); }
                    sw.Write("\r\n");
                }
            }
        }

        int makematrices()
        {
            // Debug.WriteLine("assigning memory");
            // status grids
            if (this.Ik_ben_Marijn.Checked == true) { original_dtm = new double[nr, nc]; }
            dtm = new double[nr, nc];
            if (merely_calculating_derivatives == false)
            {
                OSL_age = new int[nr * nc * max_soil_layers * ngrains, 5];
                soildepth_m = new double[nr, nc];
                dtmchange = new double[nr, nc];
                dz_soil = new double[nr, nc];
                // climate grids
                if (check_space_evap.Checked == true) { evapotranspiration = new double[nr, nc]; }
                if (check_space_infil.Checked == true) { infil = new double[nr, nc]; }
                if (check_space_rain.Checked == true) { rain = new double[nr, nc]; }
                veg = new double[nr, nc];
                // categorical grids
                if (check_space_landuse.Checked == true) { landuse = new int[nr, nc]; }
            }
            status_map = new int[nr, nc];
            //sorting arrays
            index = new double[nr * nc];
            row_index = new int[nr * nc];
            col_index = new int[nr * nc];
            rowcol_index = new string[nr * nc];
            //others
            depression = new int[nr, nc];
            dtmfill_A = new double[nr, nc];
            if (merely_calculating_derivatives == false)
            {
                if (1 == 1)
                {
                    texture_kg = new double[nr, nc, max_soil_layers, n_texture_classes];    //: mass in kg (per voxel = layer * thickness)
                    layerthickness_m = new double[nr, nc, max_soil_layers];        // : thickness in m 
                    young_SOM_kg = new double[nr, nc, max_soil_layers];         // : OM mass in kg (per voxel = layer * thickness)
                    old_SOM_kg = new double[nr, nc, max_soil_layers];
                    bulkdensity = new double[nr, nc, max_soil_layers];            // : bulkdensity in kg/m3 (over the voxel = layer * thickness)
                }

                if (Water_ero_checkbox.Checked)
                {
                    //doubles
                    waterflow_m3 = new double[nr, nc];
                    if (only_waterflow_checkbox.Checked == false)
                    {
                        K_fac = new double[nr, nc];
                        P_fac = new double[nr, nc];
                        sediment_in_transport_kg = new double[nr, nc, n_texture_classes];
                        young_SOM_in_transport_kg = new double[nr, nc];
                        old_SOM_in_transport_kg = new double[nr, nc];
                        sum_water_erosion = new double[nr, nc];
                        dz_ero_m = new double[nr, nc];
                        dz_sed_m = new double[nr, nc];
                        lake_sed_m = new double[nr, nc];
                        depressionsum_texture_kg = new double[n_texture_classes];

                    }

                }
                if (Tillage_checkbox.Checked)
                {
                    till_result = new double[nr, nc];
                    sum_tillage = new double[nr, nc];
                    tillfields = new int[nr, nc];
                    dz_till_bd = new double[nr, nc];
                }

                if (treefall_checkbox.Checked)
                {
                    treefall_count = new int[nr, nc];
                    dz_treefall = new double[nr, nc];
                }

                if (version_lux_checkbox.Checked)
                {
                    tpi = new double[nr, nc];
                    hornbeam_cover_fraction = new double[nr, nc];
                    litter_kg = new double[nr, nc, 2];
                }

                if (Solifluction_checkbox.Checked)
                {
                    solif = new double[nr, nc];
                    sum_solifluction = new double[nr, nc];
                }
                if (creep_active_checkbox.Checked)
                {
                    creep = new double[nr, nc];
                    sum_creep_grid = new double[nr, nc];
                }
                if (Landslide_checkbox.Checked)
                {
                    //doubles
                    stslope = new double[nr, nc];
                    crrain = new double[nr, nc];
                    camf = new double[nr, nc];
                    T_fac = new double[nr, nc];
                    C_fac = new double[nr, nc];
                    Cs_fac = new double[nr, nc];
                    bulkd = new double[nr, nc];
                    intfr = new double[nr, nc];
                    reserv = new double[nr, nc];
                    ero_slid = new double[nr, nc];
                    cel_dist = new double[nr, nc];
                    sed_slid = new double[nr, nc];
                    sed_bud = new double[nr, nc];
                    dh_slid = new double[nr, nc];
                    sum_landsliding = new double[nr, nc];
                    //integers
                    slidemap = new int[nr, nc];
                    watsh = new int[nr, nc];
                }
                if (Biological_weathering_checkbox.Checked)
                {
                    bedrock_weathering_m = new double[nr, nc];
                    sum_biological_weathering = new double[nr, nc];
                }
                if (Frost_weathering_checkbox.Checked)
                {
                    frost_weathering = new double[nr, nc];
                    sum_frost_weathering = new double[nr, nc];
                }
                if (tilting_active_checkbox.Checked)
                {
                    sum_tilting = new double[nr, nc];
                }
                if (uplift_active_checkbox.Checked)
                {
                    sum_uplift = new double[nr, nc];
                }
                if (decalcification_checkbox.Checked)
                {
                    CO3_kg = new double[nr, nc, max_soil_layers];
                }
                if (blocks_active == 1)
                {
                    hardlayeropenness_fraction = new float[nr, nc];
                }


            }
            aspect = new double[nr, nc];
            slopeAnalysis = new double[nr, nc];
            hillshade = new double[nr, nc];
            Tau = new double[nr, nc];
            // Debug.WriteLine("memory assigned succesfully");
            return 1;
        }

        void makerecords(string filename)
        {
            string FILE_NAME = filename;
            string input;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            int recordsize = 0;
            try { recordsize = System.Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }
            if (check_time_rain.Checked) { rainfall_record = new int[recordsize]; }
            if (check_time_evap.Checked) { evap_record = new int[recordsize]; }
            if (check_time_infil.Checked) { infil_record = new int[recordsize]; }
            if (check_time_T.Checked) { temp_record = new int[recordsize]; }
            if (check_time_till_fields.Checked) { till_record = new int[recordsize]; }

            memory_records = true;
        }

        void makedailyrecords(string filename)
        {
            string FILE_NAME = filename;
            string input;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            int recordsize = 0;
            try { recordsize = System.Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }


            P_all = new int[recordsize];
            ET0_all = new int[recordsize];
            D_all = new int[recordsize];
            Tavg_all = new int[recordsize];
            Tmin_all = new int[recordsize];
            Tmax_all = new int[recordsize];


            memory_records_d = true;
        }

        void dtm_file(string name1)
        {

            string FILE_NAME = name1;
            int z, dem_integer_error = 1;
            string[] lineArray2;
            int sp;
            Debug.WriteLine("Opening DEM" + FILE_NAME);
            //MessageBox.Show("Directory " + Directory.GetCurrentDirectory() );

            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such DEM data file..");
                input_data_error = true;
                return;
            }

            try
            {

                //read headers
                StreamReader sr = File.OpenText(FILE_NAME);
                for (z = 1; z <= 6; z++)
                {
                    inputheader[z - 1] = sr.ReadLine();
                    Debug.WriteLine(inputheader[z - 1]);
                }
                sr.Close();

                // get nc, nr and dx from input headers

                lineArray2 = inputheader[0].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                nc = int.Parse(lineArray2[sp]);

                lineArray2 = inputheader[1].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                nr = int.Parse(lineArray2[sp]);

                lineArray2 = inputheader[2].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                xcoord = double.Parse(lineArray2[sp]);

                lineArray2 = inputheader[3].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                ycoord = double.Parse(lineArray2[sp]);

                lineArray2 = inputheader[4].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                dx = double.Parse(lineArray2[sp]);

                Debug.WriteLine("read DEM: nr = " + nr + " nc = " + nc);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("There is a problem with the header of the DEM file");
                input_data_error = true;
                return;

            }
            int ok = makematrices();
            if (ok == 1)
            { // we have now succesfully made memory reservations for all data layers in the model 

            }
            else
            {
                MessageBox.Show("There is not enough memory for LORICA to run with these settings");
            }
            {

                int col, row, colcounter;
                String input;
                double tttt = 0.00;

                // load dem again

                if (!File.Exists(FILE_NAME))
                {
                    Debug.WriteLine("No such DEM data file..");
                    input_data_error = true;
                    return;
                }

                StreamReader sr = File.OpenText(FILE_NAME);

                //now skip over the headers.
                for (z = 1; z <= 6; z++)
                {
                    input = sr.ReadLine();
                }
                row = 0;
                while ((input = sr.ReadLine()) != null)  // so not until nr is reached, but until the file is empty
                {
                    //Debug.WriteLine("Line " + row);
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });   // so we split the string that we read (readline) from file into an array of strings that each contain a number
                    col = 0;
                    for (colcounter = 0; colcounter <= (lineArray.Length - 1); colcounter++)  // the length of LineArray should equal nc, and therefore run from 0 to nc-1
                    {

                        //Debug.WriteLine("Col " + col);
                        if (lineArray[colcounter] != "" && col < nc) // but just to make sure, col counts only the non-empty strings in LineArrary (handy for instance when files are double-spaced)
                        {
                            tttt = double.Parse(lineArray[colcounter]);
                            if (Ik_ben_Marijn.Checked == true) { original_dtm[row, col] = tttt; dtm[row, col] = -9999; }
                            else { dtm[row, col] = tttt; }
                            col++;
                            if (double.Parse(lineArray[colcounter]) - Math.Round(double.Parse(lineArray[colcounter])) != 0)
                            {
                                dem_integer_error = 0;
                            }
                        }
                    }
                    row++;


                }
                sr.Close();
                if (dem_integer_error == 1) { MessageBox.Show("Warning: Digital Elevation Model may only contain integer values\n LORICA can proceed, but may experience problems"); }

            }
        }

        void read_double(string name2, double[,] map1)
        {
            string FILE_NAME = name2;
            string input;
            double tttt = 0.00;
            int x, y, xcounter;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such double data file " + FILE_NAME);
                input_data_error = true;
                return;
            }

            StreamReader sr = File.OpenText(FILE_NAME);

            //read headers
            for (z = 1; z <= 6; z++)
            {
                input = sr.ReadLine();
            }
            y = 0;

            while ((input = sr.ReadLine()) != null)
            {
                string[] lineArray;
                lineArray = input.Split(new char[] { ' ' });
                xcounter = 0;
                for (x = 0; x <= (lineArray.Length - 1); x++)
                {

                    if (lineArray[x] != "" && xcounter < nc)
                    {


                        try
                        {
                            tttt = double.Parse(lineArray[x]);
                        }
                        catch
                        {
                            MessageBox.Show("Incorrect content " + lineArray[x] + " in file " + FILE_NAME);
                            input_data_error = true;
                            return;
                        }
                        map1[y, xcounter] = tttt;
                        xcounter++;
                    }
                }
                y++;

            }
            sr.Close();
        } // end read_double()

        void read_integer(string name2, int[,] map1)
        {
            string FILE_NAME = name2;
            string input;
            int tttt = 0;
            int x, y, xcounter;
            Debug.WriteLine(" Reading " + FILE_NAME + " from " + Directory.GetCurrentDirectory());
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            StreamReader sr = File.OpenText(FILE_NAME);

            //read headers
            for (z = 1; z <= 6; z++)
            {
                input = sr.ReadLine();
                /*if (z == 1)
                {
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });
                    Debug.WriteLine(input + " here " + lineArray[1] + " there " );
                    if (int.Parse(lineArray[1]) != nc)
                    {
                        Debug.WriteLine(filename + " has different cols than the DEM ");
                    }
                }
                if (z == 2)
                {
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });
                    Debug.WriteLine(lineArray[1]);
                    if (int.Parse(lineArray[1]) != nr)
                    {
                        Debug.WriteLine(filename + " has different rows than the DEM ");
                    }
                } */
            }
            y = 0;
            while ((input = sr.ReadLine()) != null)
            {
                string[] lineArray;
                lineArray = input.Split(new char[] { ' ' });
                xcounter = 0;
                for (x = 0; x <= (lineArray.Length - 1); x++)
                {

                    if (lineArray[x] != "" && xcounter < nc)
                    {
                        try
                        {
                            tttt = int.Parse(lineArray[x]);
                        }
                        catch
                        {
                            MessageBox.Show("Incorrect content " + lineArray[x] + " in file " + FILE_NAME);
                            input_data_error = true;
                            return;
                        }
                        map1[y, xcounter] = tttt;
                        xcounter++;
                    }
                }
                y++;

            }
            sr.Close();
            //Debug.WriteLine("completed reading file" + FILE_NAME);
        } // end read_integer()

        void read_record(string filename, int[] record)
        {
            string FILE_NAME = filename;
            string input;
            int tttt = 0;
            int y;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            // Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            y = 0;
            int recordsize = 0;
            try { recordsize = System.Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }


            // Debug.WriteLine("reading " + filename + " into record of size " + record.Length);

            // the record size is read from the first line and not necessarily equal to the number of timesteps. 
            // Runs will start from beginning of record and repeat when necessary
            while ((input = sr.ReadLine()) != null)
            {
                if (y >= recordsize)
                {
                    MessageBox.Show("record " + FILE_NAME + " contains more values than expected. Extras are ignored");
                    break;
                }

                try { tttt = int.Parse(input); }
                catch
                {
                    MessageBox.Show("Incorrect content " + input + " in file " + FILE_NAME);
                    input_data_error = true;
                    return;
                }
                record[y] = tttt;
                //Debug.WriteLine("value " + y + " in record is " + record[y]);
                y++;
            }
            sr.Close();

        }

        void out_double(string name4, double[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");
                for (nn = 2; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\r\n");
                    //MessageBox.Show(inputheader[nn]);
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        sw.Write("{0:F6}", output[row, col]);
                        sw.Write(" ");

                    }
                    sw.Write("\r\n");
                }
                sw.Close();
            }

        } 

        void out_float(string name4, float[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");
                for (nn = 2; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\r\n");
                    //MessageBox.Show(inputheader[nn]);
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        sw.Write("{0:F6}", output[row, col]);
                        sw.Write(" ");

                    }
                    sw.Write("\r\n");
                }
                sw.Close();
            }

        } 

        void out_blocks(string name4)
        {
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                int blocknr = 0;
                sw.WriteLine("blocknr x y size row col");
                foreach(var Block in Blocklist)
                {
                    sw.WriteLine(blocknr + " " + (Block.X_col * dx + xcoord) + " " + (Block.Y_row * dx + ycoord) + " " + Block.Size_m + " " + Math.Floor(Block.Y_row) + " " + Math.Floor(Block.X_col));
                    blocknr++;
                }
                sw.Close();
            }
            Debug.WriteLine(" wrote block locations and sizes to file " + name4);
        } //end out_double

        void out_mf(string name4, double[,,] output)
        {
            int row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("In n1 n2 n3 n4 n5 n6 n7 n8");
                sw.Write("\r\n");
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        for (int dir = 0; dir < 9; dir++)
                        {
                            sw.Write(OFy_m[row, col, dir]);
                            sw.Write(" ");
                        }
                        sw.Write("\r\n");
                    }
                }

                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");

                sw.Close();
            }
        }

        void out_integer(string name4, int[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                for (nn = 0; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\n");
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {

                        sw.Write(output[row, col]);
                        sw.Write(" ");
                    }

                    sw.Write("\n");
                }
                sw.Close();
            }
        } //end out_integer

        void out_profile(string name5, double[,] output, bool row_is_fixed, int row_or_col)
        {
            // WVG 20-10-2010 output a profile file for benefit glorious model of LORICA
            int row, col;
            string FILENAME = name5;
            using (StreamWriter sw = new StreamWriter(FILENAME))

                try
                {
                    if (row_is_fixed)
                    {
                        try
                        {
                            for (col = 0; col < nc; col++)// WVG the number of columns is equal to nc
                            {
                                sw.WriteLine(output[row_or_col, col]);
                            }
                        }
                        catch { Debug.WriteLine("out_profile: error "); }
                    }
                    else  // apparently column is fixed
                    {
                        try
                        {
                            for (row = 0; row < nr; row++)// WVG the number of columns is equal to nc
                            {
                                sw.WriteLine(output[row, row_or_col]);
                            }
                        }
                        catch { Debug.WriteLine("out_profile: error "); }
                    }
                    sw.Close();
                }
                catch { Debug.WriteLine("Profile could not be written"); }

        } //WVG end out_profile

        void writesoil(int row, int col)
        {
            int layer;
            double cumthick, midthick;
            string FILENAME = string.Format("{0}\\t{1}_r{2}_c{3}_out_soil.csv", workdir, t + 1, row, col);
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("row, col, t, cumth_m, thick_m, midthick_m, coarse_kg, sand_kg, silt_kg, clay_kg, fine_kg, YOM_kg, OOM_kg, YOM/OOM, f_coarse, f_sand, f_silt, f_clay, f_fineclay");
                sw.Write("\r\n");
                cumthick = 0;
                midthick = 0;
                int t_out = t + 1;
                for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
                {
                    if (layerthickness_m[row, col, layer] > 0)
                    {
                        cumthick += layerthickness_m[row, col, layer];
                        midthick += layerthickness_m[row, col, layer] / 2;
                        double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                        sw.Write(row + "," + col + "," + t_out + "," + cumthick + "," + layerthickness_m[row, col, layer] + "," + midthick + "," + texture_kg[row, col, layer, 0] + "," + texture_kg[row, col, layer, 1] + "," + texture_kg[row, col, layer, 2] + "," + texture_kg[row, col, layer, 3] + "," + texture_kg[row, col, layer, 4] + "," + young_SOM_kg[row, col, layer] + "," + old_SOM_kg[row, col, layer] + "," + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + "," + texture_kg[row, col, layer, 0] / totalweight + "," + texture_kg[row, col, layer, 1] / totalweight + "," + texture_kg[row, col, layer, 2] / totalweight + "," + texture_kg[row, col, layer, 3] / totalweight + "," + texture_kg[row, col, layer, 4] / totalweight);
                        sw.Write("\r\n");
                        midthick += layerthickness_m[row, col, layer] / 2;
                    }

                }
                sw.Close();
            }
        }// end writesoil

        void writeallsoils()
        {
            int layer;
            double cumthick, midthick, z_layer;
            string FILENAME = string.Format("{0}\\t{1}_out_allsoils.csv", workdir, t + 1);
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("row, col, t, nlayer, cumth_m, thick_m, midthick_m, z, coarse_kg, sand_kg, silt_kg, clay_kg, fine_kg, YOM_kg, OOM_kg, YOM/OOM, f_coarse, f_sand, f_silt, f_clay, f_fineclay, ftotal_clay, f_OM, BD");
                sw.Write("\r\n");
                int t_out = t + 1;
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            cumthick = 0;
                            midthick = 0;
                            z_layer = dtm[row, col];
                            for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
                            {
                                if (layerthickness_m[row, col, layer] > 0)
                                {
                                    cumthick += layerthickness_m[row, col, layer];
                                    midthick += layerthickness_m[row, col, layer] / 2;
                                    double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    double totalweight_tex = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4];
                                    sw.Write(row + "," + col + "," + t_out + "," + layer + "," + cumthick + "," + layerthickness_m[row, col, layer] + "," + midthick + "," + z_layer + "," + texture_kg[row, col, layer, 0] + "," + texture_kg[row, col, layer, 1] + "," + texture_kg[row, col, layer, 2] + "," + texture_kg[row, col, layer, 3] + "," + texture_kg[row, col, layer, 4] + "," + young_SOM_kg[row, col, layer] + "," + old_SOM_kg[row, col, layer] + "," + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + "," + texture_kg[row, col, layer, 0] / totalweight_tex + "," + texture_kg[row, col, layer, 1] / totalweight_tex + "," + texture_kg[row, col, layer, 2] / totalweight_tex + "," + texture_kg[row, col, layer, 3] / totalweight_tex + "," + texture_kg[row, col, layer, 4] / totalweight_tex + "," + (texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight_tex + "," + (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) / (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer] + totalweight_tex) + "," + bulkdensity[row, col, layer]);
                                    sw.Write("\r\n");
                                    midthick += layerthickness_m[row, col, layer] / 2;
                                    z_layer -= layerthickness_m[row, col, layer];
                                }

                            }

                        }
                    }
                }
                sw.Close();
            }

        }// end writeallsoils

        void write_longitudinal_profile(int startrow, int startcol, string name4)
        {

            // writes a longitudinal steepest-descent profile starting from a given begin r,c 
            double altidiff, non_lake_altidiff, maxaltidiff;
            int row, col, i, j, non_lake_maxi, non_lake_maxj, maxi, maxj, profilesize = 1000, step;
            double[] profile;
            profile = new double[1000];
            row = startrow;
            col = startcol;
            step = 0;
            string FILENAME = name4;

            while (row - 1 >= 0 && row + 1 < nr && col - 1 >= 0 && col + 1 < nc)
            {   // as long as we have not reached the edge
                Debug.WriteLine("profile now at row %d col %d, alt %.4f\n", row, col, dtm[row, col]);
                altidiff = -9999; non_lake_altidiff = 0; maxaltidiff = 0; non_lake_maxi = 0; non_lake_maxj = 0; maxi = 0; maxj = 0;
                for (i = -1; i <= 1; i++)
                {
                    for (j = -1; j <= 1; j++)
                    {
                        altidiff = dtm[row, col] - dtm[row + i, col + j];
                        //Debug.WriteLine(" profile : nb %d %d, diff %.3f\n",row+i,col+j,altidiff);
                        if (altidiff > maxaltidiff)
                        {
                            maxaltidiff = altidiff; maxi = i; maxj = j;
                        }
                        if (altidiff > non_lake_altidiff && depression[row + i, col + j] == 0)
                        {
                            non_lake_altidiff = altidiff; non_lake_maxi = i; non_lake_maxj = j;
                        }
                    }
                }
                Debug.WriteLine("profile : found lowest nb at %d %d, diff %.3f\n", row + maxi, col + maxj, maxaltidiff);
                if (non_lake_altidiff != 0) { row += non_lake_maxi; col += non_lake_maxj; } //avoid depressions if you can and prevent from falling back
                else { row += maxi; col += maxj; }
                if (maxi == 0 && maxj == 0 || maxaltidiff == 0)
                {
                    Debug.WriteLine("warning : no profile-progress due to sink?\n"); // go straight to the outlet of this depression and count the number of cells in between
                    //break;
                    maxi = drainingoutlet_row[depression[row, col], 0] - row;
                    maxj = drainingoutlet_col[depression[row, col], 0] - col;
                    for (i = 1; i <= (Math.Abs(maxi) + Math.Abs(maxj)); i++)
                    {
                        profile[step] = dtm[row, col] + (i / (Math.Abs(maxi) + Math.Abs(maxj))) * (depressionlevel[depression[row, col]] - dtm[row, col]);
                        Debug.WriteLine("profile %d now %.6f\n", step, profile[step]);
                        step++;
                    }
                    row += maxi;
                    col += maxj;
                }
                else
                {
                    profile[step] = dtm[row, col];
                    step++;
                    if (step > profilesize - 3) { Debug.WriteLine("warning : profilerecord may be too small\n"); break; }
                }
            }

            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                for (i = 0; i < step + 1; i++)
                {
                    Debug.WriteLine(profile[i]);
                    sw.Write("{0:F6}", profile[i]);
                }
                sw.Write("\r\n");
            }
            Debug.WriteLine("profile contains %d values\n", step);
        } // end write_profile() 

        void write_full_output(string filecore, int rows, int cols, int layers, int t)
        {
            int layer, row, col;
            string filename = workdir + "\\" + filecore + t + ".lrc";
            //Debug.WriteLine("attempting to write output " + filename + " at t " + t);
            using (StreamWriter sw = new StreamWriter(filename))
            {
                try
                {
                    sw.WriteLine("Lorica output header");
                    sw.WriteLine("year " + t);
                    sw.WriteLine("years " + end_time + " every " + int.Parse(Box_years_output.Text));
                    sw.WriteLine("rows " + rows + " cellsize " + dx + " yllcoord " + ycoord);
                    sw.WriteLine("cols " + cols + " xllcoord " + xcoord);
                    sw.WriteLine("layers " + layers);
                    sw.WriteLine("properties 10");
                    sw.WriteLine("propnames elevation thickness_m density_kg_m3 coarse_kg sand_kg silt_kg clay_kg fineclay_kg youngom_kg oldom_kg");
                    sw.WriteLine("Lorica output content");
                }
                catch { Debug.WriteLine(" issue with writing the header of the full output file for this timestep"); }
                try
                {
                    for (row = 0; row < rows; row++)
                    {
                        for (col = 0; col < cols; col++)
                        {
                            for (layer = 0; layer < layers; layer++)
                            {
                                sw.Write(dtm[row, col]
                                    + "_" + layerthickness_m[row, col, layer]
                                    + "_" + bulkdensity[row, col, layer]
                                    + "_" + texture_kg[row, col, layer, 0]
                                    + "_" + texture_kg[row, col, layer, 1]
                                    + "_" + texture_kg[row, col, layer, 2]
                                    + "_" + texture_kg[row, col, layer, 3]
                                    + "_" + texture_kg[row, col, layer, 4]
                                    + "_" + young_SOM_kg[row, col, layer]
                                    + "_" + old_SOM_kg[row, col, layer]
                                    + ",");
                            }
                            sw.Write("\n");
                        }
                    }
                }
                catch { Debug.WriteLine(" issue with writing the content of the full output file for this timestep"); }
                sw.Close();
            }
        }

        private void menuItemConfigFileOpen_Click(object sender, System.EventArgs e)
        {
            //opens a runfile
            XmlTextReader xreader;
            int read_error = 0;
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "cfg files (*.xml)|*.xml|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                cfgname = openFileDialog1.FileName;

                xreader = new XmlTextReader(cfgname);

                //Read the file
                if (xreader != null)
                {
                    try { xreader.ReadStartElement("Parms"); }
                    catch { read_error = 1; }
                    try { xreader.ReadStartElement("Processes"); }
                    catch { read_error = 1; }
                    try { xreader.ReadStartElement("Water_erosion"); }
                    catch { read_error = 1; }
                    try { Water_ero_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("water_active")); }
                    catch { read_error = 1; }
                    try { parameter_m_textbox.Text = xreader.ReadElementString("para_m"); }
                    catch { read_error = 1; }
                    try { parameter_n_textbox.Text = xreader.ReadElementString("para_n"); }
                    catch { read_error = 1; }
                    try { parameter_conv_textbox.Text = xreader.ReadElementString("para_p"); }
                    catch { read_error = 1; }
                    try { parameter_K_textbox.Text = xreader.ReadElementString("para_K"); }
                    catch { read_error = 1; }
                    try { erosion_threshold_textbox.Text = xreader.ReadElementString("para_ero_threshold"); }
                    catch { read_error = 1; }
                    try { rock_protection_constant_textbox.Text = xreader.ReadElementString("para_rock_protection_const"); }
                    catch { read_error = 1; }
                    try { bio_protection_constant_textbox.Text = xreader.ReadElementString("para_bio_protection_const"); }
                    catch { read_error = 1; }
                    try { selectivity_constant_textbox.Text = xreader.ReadElementString("para_selectivity"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Tillage"); }
                    catch { read_error = 1; }
                    try { Tillage_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("tillage_active")); }
                    catch { read_error = 1; }
                    try { parameter_ploughing_depth_textbox.Text = xreader.ReadElementString("para_plough_depth"); }
                    catch { read_error = 1; }
                    try { parameter_tillage_constant_textbox.Text = xreader.ReadElementString("para_tillage_constant"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Weathering"); }
                    catch { read_error = 1; }
                    try { Biological_weathering_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("bio_weathering_active")); }
                    catch { read_error = 1; }
                    try { parameter_P0_textbox.Text = xreader.ReadElementString("para_P0"); }
                    catch { read_error = 1; }
                    try { parameter_k1_textbox.Text = xreader.ReadElementString("para_k1"); }
                    catch { read_error = 1; }
                    try { parameter_k2_textbox.Text = xreader.ReadElementString("para_k2"); }
                    catch { read_error = 1; }
                    try { parameter_Pa_textbox.Text = xreader.ReadElementString("para_Pa"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Landsliding"); }
                    catch { read_error = 1; }
                    try { Landslide_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("landsliding_active")); }
                    catch { read_error = 1; }
                    try { radio_ls_absolute.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("radio_ls_absolute")); }
                    catch { read_error = 1; }
                    try { radio_ls_fraction.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("radio_ls_fraction")); }
                    catch { read_error = 1; }
                    try { text_ls_abs_rain_intens.Text = xreader.ReadElementString("para_absolute_rain_intens"); }
                    catch { read_error = 1; }
                    try { text_ls_rel_rain_intens.Text = xreader.ReadElementString("para_relative_rain_intens"); }
                    catch { read_error = 1; }
                    try { textBox_ls_coh.Text = xreader.ReadElementString("para_cohesion"); }
                    catch { read_error = 1; }
                    try { textBox_ls_ifr.Text = xreader.ReadElementString("para_friction"); }
                    catch { read_error = 1; }
                    try { textBox_ls_bd.Text = xreader.ReadElementString("para_density"); }
                    catch { read_error = 1; }
                    try { textBox_ls_trans.Text = xreader.ReadElementString("para_transmissivity"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Creep"); }
                    catch { read_error = 1; }
                    try { creep_active_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("creep_active")); }
                    catch { read_error = 1; }
                    try { parameter_diffusivity_textbox.Text = xreader.ReadElementString("para_diffusivity"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Tree_fall"); }
                    catch { read_error = 1; }
                    try { treefall_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("treefall_active")); }
                    catch { read_error = 1; }
                    try { tf_W.Text = xreader.ReadElementString("tf_width"); }
                    catch { read_error = 1; }
                    try { tf_D.Text = xreader.ReadElementString("tf_depth"); }
                    catch { read_error = 1; }
                    try { tf_growth.Text = xreader.ReadElementString("tf_growth"); }
                    catch { read_error = 1; }
                    try { tf_age.Text = xreader.ReadElementString("tf_age"); }
                    catch { read_error = 1; }
                    try { tf_freq.Text = xreader.ReadElementString("tf_freq"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }


                    try { xreader.ReadStartElement("Soil_forming_processes"); }
                    catch { read_error = 1; }
                    try { xreader.ReadStartElement("Physical_weathering"); }
                    catch { read_error = 1; }
                    try { soil_phys_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("phys_weath_active")); }
                    catch { read_error = 1; }
                    try { Physical_weath_C1_textbox.Text = xreader.ReadElementString("weath_rate_constant"); }
                    catch { read_error = 1; }
                    try { physical_weath_constant1.Text = xreader.ReadElementString("constant1"); }
                    catch { read_error = 1; }
                    try { physical_weath_constant2.Text = xreader.ReadElementString("constant2"); }
                    catch { read_error = 1; }
                    try { upper_particle_coarse_textbox.Text = xreader.ReadElementString("size_coarse"); }
                    catch { read_error = 1; }
                    try { upper_particle_sand_textbox.Text = xreader.ReadElementString("size_sand"); }
                    catch { read_error = 1; }
                    try { upper_particle_silt_textbox.Text = xreader.ReadElementString("size_silt"); }
                    catch { read_error = 1; }
                    try { upper_particle_clay_textbox.Text = xreader.ReadElementString("size_clay"); }
                    catch { read_error = 1; }
                    try { upper_particle_fine_clay_textbox.Text = xreader.ReadElementString("size_fine"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Chemical_weathering"); }
                    catch { read_error = 1; }
                    try { soil_chem_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("chem_weath_active")); }
                    catch { read_error = 1; }
                    try { chem_weath_rate_constant_textbox.Text = xreader.ReadElementString("weath_rate_constant"); }
                    catch { read_error = 1; }
                    try { chem_weath_depth_constant_textbox.Text = xreader.ReadElementString("constant3"); }
                    catch { read_error = 1; }
                    try { chem_weath_specific_coefficient_textbox.Text = xreader.ReadElementString("constant4"); }
                    catch { read_error = 1; }
                    try { specific_area_coarse_textbox.Text = xreader.ReadElementString("surface_coarse"); }
                    catch { read_error = 1; }
                    try { specific_area_sand_textbox.Text = xreader.ReadElementString("surface_sand"); }
                    catch { read_error = 1; }
                    try { specific_area_silt_textbox.Text = xreader.ReadElementString("surface_silt"); }
                    catch { read_error = 1; }
                    try { specific_area_clay_textbox.Text = xreader.ReadElementString("surface_clay"); }
                    catch { read_error = 1; }
                    try { specific_area_fine_clay_textbox.Text = xreader.ReadElementString("surface_fine_clay"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Clay_dynamics"); }
                    catch { read_error = 1; }
                    try { soil_clay_transloc_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("clay_dynamics_active")); }
                    catch { read_error = 1; }
                    try { clay_neoform_constant_textbox.Text = xreader.ReadElementString("neoform_rate_constant"); }
                    catch { read_error = 1; }
                    try { clay_neoform_C1_textbox.Text = xreader.ReadElementString("constant5"); }
                    catch { read_error = 1; }
                    try { clay_neoform_C2_textbox.Text = xreader.ReadElementString("constant6"); }
                    catch { read_error = 1; }
                    try { maximum_eluviation_textbox.Text = xreader.ReadElementString("max_eluviation"); }
                    catch { read_error = 1; }
                    try { eluviation_coefficient_textbox.Text = xreader.ReadElementString("eluviation_coefficient"); }
                    catch { read_error = 1; Debug.WriteLine("xml1"); }
                    try { ct_Jagercikova.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("ct_Jagercikova_active")); } //MMxml
                    catch { read_error = 1; }
                    try { ct_v0_Jagercikova.Text = xreader.ReadElementString("ct_v0_Jagercikova"); } //MMxml
                    catch { read_error = 2; Debug.WriteLine("xml2"); }
                    try { ct_dd_Jagercikova.Text = xreader.ReadElementString("ct_dd_Jagercikova"); } //MMxml
                    catch { read_error = 2; Debug.WriteLine("xml3"); }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Bioturbation"); }
                    catch { read_error = 1; }
                    try { soil_bioturb_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("bioturbation_active")); }
                    catch { read_error = 1; }
                    try { potential_bioturbation_textbox.Text = xreader.ReadElementString("potential_bioturb"); }
                    catch { read_error = 1; }
                    try { bioturbation_depth_decay_textbox.Text = xreader.ReadElementString("bioturb_depth_decay"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Carboncycle"); }
                    catch { read_error = 1; }
                    try { soil_carbon_cycle_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("carboncycle_active")); }
                    catch { read_error = 1; }
                    try { carbon_input_textbox.Text = xreader.ReadElementString("carbon_input"); }
                    catch { read_error = 1; }
                    try { carbon_depth_decay_textbox.Text = xreader.ReadElementString("carbon_depth_decay"); }
                    catch { read_error = 1; }
                    try { carbon_humification_fraction_textbox.Text = xreader.ReadElementString("carbon_hum_fraction"); }
                    catch { read_error = 1; }
                    try { carbon_y_decomp_rate_textbox.Text = xreader.ReadElementString("carbon_y_decomp"); }
                    catch { read_error = 1; }
                    try { carbon_y_depth_decay_textbox.Text = xreader.ReadElementString("carbon_y_depth_decay"); }
                    catch { read_error = 1; }
                    try { carbon_y_twi_decay_textbox.Text = xreader.ReadElementString("carbon_y_twi_decay"); }
                    catch { read_error = 1; }
                    try { carbon_o_decomp_rate_textbox.Text = xreader.ReadElementString("carbon_o_decomp"); }
                    catch { read_error = 1; }
                    try { carbon_o_depth_decay_textbox.Text = xreader.ReadElementString("carbon_o_depth_decay"); }
                    catch { read_error = 1; }
                    try { carbon_o_twi_decay_textbox.Text = xreader.ReadElementString("carbon_o_twi_decay"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Inputs"); }
                    catch { read_error = 1; }
                    try { check_space_DTM.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_DTM")); }
                    catch { read_error = 1; }
                    try { check_space_soildepth.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_soil")); }
                    catch { read_error = 1; }
                    try { check_space_landuse.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_landuse")); }
                    catch { read_error = 1; }
                    try { check_space_till_fields.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_tillfields")); }
                    catch { read_error = 1; }
                    try { check_space_rain.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_rain")); }
                    catch { read_error = 1; }
                    try { check_space_infil.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_infil")); }
                    catch { read_error = 1; }
                    try { check_space_evap.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_evap")); }
                    catch { read_error = 1; }
                    try { check_time_landuse.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_landuse")); }
                    catch { read_error = 1; }
                    try { check_time_till_fields.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_tillfields")); }
                    catch { read_error = 1; }
                    try { check_time_rain.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_rain")); }
                    catch { read_error = 1; }
                    try { check_time_infil.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_infil")); }
                    catch { read_error = 1; }
                    try { check_time_evap.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_evap")); }
                    catch { read_error = 1; }

                    try { daily_water.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("dailywater")); } //MMxml
                    catch { read_error = 1; }
                    try { dailyP.Text = xreader.ReadElementString("dailyP"); }//MMxml
                    catch { read_error = 1; Debug.WriteLine("xml4"); }
                    try { dailyET0.Text = xreader.ReadElementString("dailyET0"); }//MMxml
                    catch { read_error = 1; }
                    try { dailyD.Text = xreader.ReadElementString("dailyD"); }//MMxml
                    catch { read_error = 1; }
                    try { dailyT_avg.Text = xreader.ReadElementString("dailyT_avg"); }//MMxml
                    catch { read_error = 1; }
                    try { dailyT_min.Text = xreader.ReadElementString("dailyT_min"); }//MMxml
                    catch { read_error = 1; Debug.WriteLine("xml5"); }
                    try { dailyT_max.Text = xreader.ReadElementString("dailyT_max"); }//MMxml
                    catch { read_error = 1; }
                    try { latitude_deg.Text = xreader.ReadElementString("latitude_deg"); }//MMxml
                    catch { read_error = 1; }
                    try { latitude_min.Text = xreader.ReadElementString("latitude_min"); }//MMxml
                    catch { read_error = 1; Debug.WriteLine("xml6"); }
                    try { snowmelt_factor_textbox.Text = xreader.ReadElementString("snowmelt_factor"); }//MMxml
                    catch { read_error = 1; }
                    try { snow_threshold_textbox.Text = xreader.ReadElementString("snowmelt_threshold"); }//MMxml
                    catch { read_error = 1; Debug.WriteLine("xml7"); }
                    try { daily_n.Text = xreader.ReadElementString("daily_n_years"); }//MMxml
                    catch { read_error = 1; Debug.WriteLine("xml7.1"); }
                    try { check_scaling_daily_weather.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("scaledailyweather")); } //MMxml
                    catch { read_error = 1; Debug.WriteLine("xml7.2"); }



                    try { dtm_input_filename_textbox.Text = xreader.ReadElementString("dtm_input_filename"); }
                    catch { read_error = 1; }
                    try { soildepth_input_filename_textbox.Text = xreader.ReadElementString("soildepth_input_filename"); }
                    catch { read_error = 1; }
                    try { landuse_input_filename_textbox.Text = xreader.ReadElementString("landuse_input_filename"); }
                    catch { read_error = 1; }
                    try { tillfields_input_filename_textbox.Text = xreader.ReadElementString("tillfields_input_filename"); }
                    catch { read_error = 1; }
                    try { rain_input_filename_textbox.Text = xreader.ReadElementString("rain_input_filename"); }
                    catch { read_error = 1; }
                    try { infil_input_filename_textbox.Text = xreader.ReadElementString("infil_input_filename"); }
                    catch { read_error = 1; Debug.WriteLine("xml8"); }
                    try { evap_input_filename_textbox.Text = xreader.ReadElementString("evap_input_filename"); }
                    catch { read_error = 1; }

                    try { soildepth_constant_value_box.Text = xreader.ReadElementString("soildepth_constant_value"); }
                    catch { read_error = 1; }
                    try { landuse_constant_value_box.Text = xreader.ReadElementString("landuse_constant_value"); }
                    catch { read_error = 1; }
                    try { tillfields_constant_textbox.Text = xreader.ReadElementString("tillfields_constant_value"); }
                    catch { read_error = 1; }
                    try { rainfall_constant_value_box.Text = xreader.ReadElementString("rain_constant_value"); }
                    catch { read_error = 1; }
                    try { infil_constant_value_box.Text = xreader.ReadElementString("infil_constant_value"); }
                    catch { read_error = 1; }
                    try { evap_constant_value_box.Text = xreader.ReadElementString("evap_constant_value"); }
                    catch { read_error = 1; }

                    try { fill_sinks_before_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_fill_sinks_before")); }
                    catch { read_error = 1; Debug.WriteLine("xml9"); }
                    try { fill_sinks_during_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_fill_sinks_during")); }
                    catch { read_error = 1; }

                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; Debug.WriteLine("xm20"); }

                    try { xreader.ReadStartElement("Run"); }
                    catch { read_error = 1; Debug.WriteLine("xm21"); }
                    try { runs_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("runs_radiobutton")); }
                    catch { read_error = 1; Debug.WriteLine("xm22"); }
                    try { Number_runs_textbox.Text = xreader.ReadElementString("number_runs"); }
                    catch { read_error = 1; Debug.WriteLine("xm23"); }


                    try { xreader.ReadStartElement("Specialsettings"); }
                    catch { read_error = 1; Debug.WriteLine("xm24"); }
                    try { Ik_ben_Marijn.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Spitsbergen")); }
                    catch { read_error = 1; Debug.WriteLine("xm25"); }
                    try { version_lux_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Luxembourg")); }
                    catch { read_error = 1; Debug.WriteLine("xm26"); }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; Debug.WriteLine("xm27"); }

                    try { xreader.ReadStartElement("CalibrationSensitivity"); }
                    catch { read_error = 2; }
                    try
                    {
                        Calibration_button.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("calibration_active_button"));
                        calibration_ratios_textbox.Text = xreader.ReadElementString("calibration_ratios_string");
                        calibration_levels_textbox.Text = xreader.ReadElementString("calibration_levels");
                        calibration_ratio_reduction_parameter_textbox.Text = xreader.ReadElementString("calibration_ratio_reduction_per_level");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 2; Debug.WriteLine("xm28"); }

                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Output"); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("File_Output"); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Moment_of_Output"); }
                    catch { read_error = 1; }
                    try { Final_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("final_output_checkbox")); }
                    catch { read_error = 1; }
                    try { Regular_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("regular_output_checkbox")); }
                    catch { read_error = 1; }
                    try { Box_years_output.Text = xreader.ReadElementString("years_between_outputs"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Type_of_Output"); }
                    catch { read_error = 1; }
                    try { cumulative_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cumulative")); }
                    catch { read_error = 1; }
                    try { annual_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("annual")); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Maps_to_Output"); }
                    catch { read_error = 1; }
                    try { Altitude_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("alti")); }
                    catch { read_error = 1; }
                    try { Alt_change_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("altichange")); }
                    catch { read_error = 1; }
                    try { Soildepth_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("soildepth")); }
                    catch { read_error = 1; }
                    try { all_process_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("all_processes")); }
                    catch { read_error = 1; }
                    try { water_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("waterflow")); }
                    catch { read_error = 1; }
                    try { depressions_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("depressions")); }
                    catch { read_error = 1; }
                    try { diagnostic_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("diagnostics")); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Other_outputs"); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Avi_Animation"); }
                    catch { read_error = 1; }
                    try { checkBoxGenerateAVIFile.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Save_as_AVI")); }
                    catch { read_error = 1; }
                    try { textBoxAVIFile.Text = xreader.ReadElementString("AVIfilename"); }
                    catch { read_error = 1; }
                    try { saveintervalbox.Text = xreader.ReadElementString("years_between_AVI_outputs"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Google_Animation"); }
                    catch { read_error = 1; }
                    try { googleAnimationCheckbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Save_as_Google")); }
                    catch { read_error = 1; }
                    try { googleAnimationTextBox.Text = xreader.ReadElementString("Google_filename"); }
                    catch { read_error = 1; }
                    try { googAnimationSaveInterval.Text = xreader.ReadElementString("years_between_Google_outputs"); }
                    catch { read_error = 1; }
                    try { googleBeginDate.Text = xreader.ReadElementString("begindate"); }
                    catch { read_error = 1; }
                    try { UTMgridcheckbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("UTM")); }
                    catch { read_error = 1; }
                    try { UTMsouthcheck.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("South")); }
                    catch { read_error = 1; }
                    try { UTMzonebox.Text = xreader.ReadElementString("UTMzone"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Timeseries"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_ero_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_erosion")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_dep_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_deposition")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_net_ero_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("net_erosion")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_SDR_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("SDR")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_average_alt_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_average_alt")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_rain_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_rain")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_infil_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_infil")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_evap_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_evap")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_total_outflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_outflow")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_number_waterflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("wet_cells")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_number_erosion_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("eroded_cells")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_number_dep_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("deposited_cells")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_cell_altitude_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cell_altitude")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_cell_waterflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cell_waterflow")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_textbox_waterflow_threshold.Text = xreader.ReadElementString("waterflow_threshold"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_textbox_erosion_threshold.Text = xreader.ReadElementString("erosion_threshold"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_textbox_deposition_threshold.Text = xreader.ReadElementString("deposition_threshold"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_textbox_cell_row.Text = xreader.ReadElementString("cell_row"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_textbox_cell_col.Text = xreader.ReadElementString("cell_col"); }
                    catch { read_error = 1; }



                    try { timeseries.total_OM_input_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_OM_input")); }
                    catch { read_error = 1; }
                    try { timeseries.total_average_soilthickness_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_average_soil_thickness")); }
                    catch { read_error = 1; }
                    try { timeseries.total_phys_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_phys_weath")); }
                    catch { read_error = 1; }
                    try { timeseries.total_chem_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_chem_weath")); }
                    catch { read_error = 1; }
                    try { timeseries.total_fine_formed_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_fine_formed")); }
                    catch { read_error = 1; }
                    try { timeseries.total_fine_eluviated_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_fine_eluviated")); }
                    catch { read_error = 1; }
                    try { timeseries.total_mass_bioturbed_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_mass_bioturbed")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_depth_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_soil_depth")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_mass_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_soil_mass")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_coarser_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_coarser")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_number_soil_thicker_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_thicker")); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_cell_col.Text = xreader.ReadElementString("soil_cell"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_cell_row.Text = xreader.ReadElementString("soil_col"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_coarser_fraction_textbox.Text = xreader.ReadElementString("coarser_fraction"); }
                    catch { read_error = 1; }
                    try { timeseries.timeseries_soil_thicker_textbox.Text = xreader.ReadElementString("thicker_threshold"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Profiles"); }
                    catch { read_error = 1; }
                    try { profile.radio_pro1_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile1_row")); }
                    catch { read_error = 1; }
                    try { profile.radio_pro1_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile1_col")); }
                    catch { read_error = 1; }
                    try { profile.radio_pro2_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile2_row")); }
                    catch { read_error = 1; }
                    try { profile.radio_pro2_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile2_col")); }
                    catch { read_error = 1; }
                    try { profile.radio_pro3_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile3_row")); }
                    catch { read_error = 1; }
                    try { profile.radio_pro3_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile3_col")); }
                    catch { read_error = 1; }
                    try { profile.p1_row_col_box.Text = xreader.ReadElementString("p1_number"); }
                    catch { read_error = 1; }
                    try { profile.p2_row_col_box.Text = xreader.ReadElementString("p2_number"); }
                    catch { read_error = 1; }
                    try { profile.p3_row_col_box.Text = xreader.ReadElementString("p3_number"); }
                    catch { read_error = 1; }
                    try { profile.check_waterflow_profile1.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p1_waterflow")); }
                    catch { read_error = 1; }
                    try { profile.check_altitude_profile1.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p1_altitude")); }
                    catch { read_error = 1; }
                    try { profile.check_waterflow_profile2.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p2_waterflow")); }
                    catch { read_error = 1; }
                    try { profile.check_altitude_profile2.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p2_altitude")); }
                    catch { read_error = 1; }
                    try { profile.check_waterflow_profile3.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p3_waterflow")); }
                    catch { read_error = 1; }
                    try { profile.check_altitude_profile3.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p3_altitude")); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }


                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    try { xreader.ReadStartElement("Soilfractions"); }
                    catch { read_error = 1; }
                    try { soildata.coarsebox.Text = xreader.ReadElementString("coarsefrac"); }
                    catch { read_error = 1; }
                    try { soildata.sandbox.Text = xreader.ReadElementString("sandfrac"); }
                    catch { read_error = 1; }
                    try { soildata.siltbox.Text = xreader.ReadElementString("siltfrac"); }
                    catch { read_error = 1; }
                    try { soildata.claybox.Text = xreader.ReadElementString("clayfrac"); }
                    catch { read_error = 1; }
                    try { soildata.fineclaybox.Text = xreader.ReadElementString("fclayfrac"); }
                    catch { read_error = 1; }
                    try { xreader.ReadEndElement(); }
                    catch { read_error = 1; }

                    if (read_error == 1) { MessageBox.Show("warning : not all runfile data could be read.\r\n LORICA can continue"); }
                    if (read_error == 2) { MessageBox.Show("Error in new XML lines"); }


                    xreader.Close();

                    this.Text = basetext + " (" + Path.GetFileName(cfgname) + ")";
                    start_button.Enabled = true;
                    tabControl1.Visible = true;

                }
            }
        }

        private void menuItemConfigFileSave_Click(object sender, System.EventArgs e)
        {
            XmlTextWriter xwriter;

            if ((sender == menuItemConfigFileSaveAs) || (cfgname == null))
            {

                SaveFileDialog saveFileDialog1 = new SaveFileDialog();

                saveFileDialog1.InitialDirectory = workdir;
                saveFileDialog1.Filter = "cfg files (*.xml)|*.xml|All files (*.*)|*.*";
                saveFileDialog1.FilterIndex = 1;
                saveFileDialog1.RestoreDirectory = false;

                if (saveFileDialog1.ShowDialog() == DialogResult.OK)
                {
                    cfgname = saveFileDialog1.FileName;
                }
            }
            if (cfgname != null)
            {

                //Create a new XmlTextWriter.
                xwriter = new XmlTextWriter(cfgname, System.Text.Encoding.UTF8);
                //Write the beginning of the document including the 
                //document declaration. Standalone is true. 
                //Use indentation for readability.
                xwriter.Formatting = Formatting.Indented;
                xwriter.Indentation = 4;

                xwriter.WriteStartDocument(true);

                //Write the beginning of the "data" element. This is 
                //the opening tag to our data 
                xwriter.WriteStartElement("Parms");
                xwriter.WriteStartElement("Processes");
                xwriter.WriteStartElement("Water_erosion");
                xwriter.WriteElementString("water_active", XmlConvert.ToString(Water_ero_checkbox.Checked));
                xwriter.WriteElementString("para_m", parameter_m_textbox.Text);
                xwriter.WriteElementString("para_n", parameter_n_textbox.Text);
                xwriter.WriteElementString("para_p", parameter_conv_textbox.Text);
                xwriter.WriteElementString("para_K", parameter_K_textbox.Text);
                xwriter.WriteElementString("para_ero_threshold", erosion_threshold_textbox.Text);
                xwriter.WriteElementString("para_rock_protection_const", rock_protection_constant_textbox.Text);
                xwriter.WriteElementString("para_bio_protection_const", bio_protection_constant_textbox.Text);
                xwriter.WriteElementString("para_selectivity", selectivity_constant_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Tillage");
                xwriter.WriteElementString("tillage_active", XmlConvert.ToString(Tillage_checkbox.Checked));
                xwriter.WriteElementString("para_plough_depth", parameter_ploughing_depth_textbox.Text);
                xwriter.WriteElementString("para_tillage_constant", parameter_tillage_constant_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Weathering");
                xwriter.WriteElementString("bio_weathering_active", XmlConvert.ToString(Biological_weathering_checkbox.Checked));
                xwriter.WriteElementString("para_P0", parameter_P0_textbox.Text);
                xwriter.WriteElementString("para_k1", parameter_k1_textbox.Text);
                xwriter.WriteElementString("para_k2", parameter_k2_textbox.Text);
                xwriter.WriteElementString("para_Pa", parameter_Pa_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Landsliding");
                xwriter.WriteElementString("landsliding_active", XmlConvert.ToString(Landslide_checkbox.Checked));
                xwriter.WriteElementString("radio_ls_absolute", XmlConvert.ToString(radio_ls_absolute.Checked));
                xwriter.WriteElementString("radio_ls_fraction", XmlConvert.ToString(radio_ls_fraction.Checked));
                xwriter.WriteElementString("para_absolute_rain_intens", text_ls_abs_rain_intens.Text);
                xwriter.WriteElementString("para_relative_rain_intens", text_ls_rel_rain_intens.Text);
                xwriter.WriteElementString("para_cohesion", textBox_ls_coh.Text);
                xwriter.WriteElementString("para_friction", textBox_ls_ifr.Text);
                xwriter.WriteElementString("para_density", textBox_ls_bd.Text);
                xwriter.WriteElementString("para_transmissivity", textBox_ls_trans.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Creep");
                xwriter.WriteElementString("creep_active", XmlConvert.ToString(creep_active_checkbox.Checked));
                xwriter.WriteElementString("para_diffusivity", parameter_diffusivity_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Tree_fall");
                xwriter.WriteElementString("treefall_active", XmlConvert.ToString(treefall_checkbox.Checked));
                xwriter.WriteElementString("tf_width", tf_W.Text);
                xwriter.WriteElementString("tf_depth", tf_D.Text);
                xwriter.WriteElementString("tf_growth", tf_growth.Text);
                xwriter.WriteElementString("tf_age", tf_age.Text);
                xwriter.WriteElementString("tf_freq", tf_freq.Text);
                xwriter.WriteEndElement();
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Soil_forming_processes");
                xwriter.WriteStartElement("Physical_weathering");
                xwriter.WriteElementString("phys_weath_active", XmlConvert.ToString(soil_phys_weath_checkbox.Checked));
                xwriter.WriteElementString("weath_rate_constant", Physical_weath_C1_textbox.Text);
                xwriter.WriteElementString("constant1", physical_weath_constant1.Text);
                xwriter.WriteElementString("constant2", physical_weath_constant2.Text);
                xwriter.WriteElementString("size_coarse", upper_particle_coarse_textbox.Text);
                xwriter.WriteElementString("size_sand", upper_particle_sand_textbox.Text);
                xwriter.WriteElementString("size_silt", upper_particle_silt_textbox.Text);
                xwriter.WriteElementString("size_clay", upper_particle_clay_textbox.Text);
                xwriter.WriteElementString("size_fine", upper_particle_fine_clay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Chemical_weathering");
                xwriter.WriteElementString("chem_weath_active", XmlConvert.ToString(soil_chem_weath_checkbox.Checked));
                xwriter.WriteElementString("weath_rate_constant", chem_weath_rate_constant_textbox.Text);
                xwriter.WriteElementString("constant3", chem_weath_depth_constant_textbox.Text);
                xwriter.WriteElementString("constant4", chem_weath_specific_coefficient_textbox.Text);
                xwriter.WriteElementString("surface_coarse", specific_area_coarse_textbox.Text);
                xwriter.WriteElementString("surface_sand", specific_area_sand_textbox.Text);
                xwriter.WriteElementString("surface_silt", specific_area_silt_textbox.Text);
                xwriter.WriteElementString("surface_clay", specific_area_clay_textbox.Text);
                xwriter.WriteElementString("surface_fine_clay", specific_area_fine_clay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Clay_dynamics");
                xwriter.WriteElementString("clay_dynamics_active", XmlConvert.ToString(soil_clay_transloc_checkbox.Checked));
                xwriter.WriteElementString("neoform_rate_constant", clay_neoform_constant_textbox.Text);
                xwriter.WriteElementString("constant5", clay_neoform_C1_textbox.Text);
                xwriter.WriteElementString("constant6", clay_neoform_C2_textbox.Text);
                xwriter.WriteElementString("max_eluviation", maximum_eluviation_textbox.Text);
                xwriter.WriteElementString("eluviation_coefficient", eluviation_coefficient_textbox.Text);
                xwriter.WriteElementString("ct_Jagercikova_active", XmlConvert.ToString(ct_Jagercikova.Checked));
                xwriter.WriteElementString("ct_v0_Jagercikova", ct_v0_Jagercikova.Text);
                xwriter.WriteElementString("ct_dd_Jagercikova", ct_dd_Jagercikova.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Bioturbation");
                xwriter.WriteElementString("bioturbation_active", XmlConvert.ToString(soil_bioturb_checkbox.Checked));
                xwriter.WriteElementString("potential_bioturb", potential_bioturbation_textbox.Text);
                xwriter.WriteElementString("bioturb_depth_decay", bioturbation_depth_decay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Carboncycle");
                xwriter.WriteElementString("carboncycle_active", XmlConvert.ToString(soil_carbon_cycle_checkbox.Checked));
                xwriter.WriteElementString("carbon_input", carbon_input_textbox.Text);
                xwriter.WriteElementString("carbon_depth_decay", carbon_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_hum_fraction", carbon_humification_fraction_textbox.Text);
                xwriter.WriteElementString("carbon_y_decomp", carbon_y_decomp_rate_textbox.Text);
                xwriter.WriteElementString("carbon_y_depth_decay", carbon_y_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_y_twi_decay", carbon_y_twi_decay_textbox.Text);
                xwriter.WriteElementString("carbon_o_decomp", carbon_o_decomp_rate_textbox.Text);
                xwriter.WriteElementString("carbon_o_depth_decay", carbon_o_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_o_twi_decay", carbon_o_twi_decay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Inputs");
                xwriter.WriteElementString("check_space_DTM", XmlConvert.ToString(check_space_DTM.Checked));
                xwriter.WriteElementString("check_space_soil", XmlConvert.ToString(check_space_soildepth.Checked));
                xwriter.WriteElementString("check_space_landuse", XmlConvert.ToString(check_space_landuse.Checked));
                xwriter.WriteElementString("check_space_tillfields", XmlConvert.ToString(check_space_till_fields.Checked));
                xwriter.WriteElementString("check_space_rain", XmlConvert.ToString(check_space_rain.Checked));
                xwriter.WriteElementString("check_space_infil", XmlConvert.ToString(check_space_infil.Checked));
                xwriter.WriteElementString("check_space_evap", XmlConvert.ToString(check_space_evap.Checked));
                xwriter.WriteElementString("check_time_landuse", XmlConvert.ToString(check_time_landuse.Checked));
                xwriter.WriteElementString("check_time_tillfields", XmlConvert.ToString(check_time_till_fields.Checked));
                xwriter.WriteElementString("check_time_rain", XmlConvert.ToString(check_time_rain.Checked));
                xwriter.WriteElementString("check_time_infil", XmlConvert.ToString(check_time_infil.Checked));
                xwriter.WriteElementString("check_time_evap", XmlConvert.ToString(check_time_evap.Checked));

                xwriter.WriteElementString("dailywater", XmlConvert.ToString(daily_water.Checked));
                xwriter.WriteElementString("dailyP", dailyP.Text);
                xwriter.WriteElementString("dailyET0", dailyET0.Text);
                xwriter.WriteElementString("dailyD", dailyD.Text);
                xwriter.WriteElementString("dailyT_avg", dailyT_avg.Text);
                xwriter.WriteElementString("dailyT_min", dailyT_min.Text);
                xwriter.WriteElementString("dailyT_max", dailyT_max.Text);
                xwriter.WriteElementString("latitude_deg", latitude_deg.Text);
                xwriter.WriteElementString("latitude_min", latitude_min.Text);
                xwriter.WriteElementString("snowmelt_factor", snowmelt_factor_textbox.Text);
                xwriter.WriteElementString("snowmelt_threshold", snow_threshold_textbox.Text);
                xwriter.WriteElementString("daily_n_years", daily_n.Text);
                xwriter.WriteElementString("scaledailyweather", XmlConvert.ToString(check_scaling_daily_weather.Checked));


                xwriter.WriteElementString("dtm_input_filename", dtm_input_filename_textbox.Text);
                xwriter.WriteElementString("soildepth_input_filename", soildepth_input_filename_textbox.Text);
                xwriter.WriteElementString("landuse_input_filename", landuse_input_filename_textbox.Text);
                xwriter.WriteElementString("tillfields_input_filename", tillfields_input_filename_textbox.Text);
                xwriter.WriteElementString("rain_input_filename", rain_input_filename_textbox.Text);
                xwriter.WriteElementString("infil_input_filename", infil_input_filename_textbox.Text);
                xwriter.WriteElementString("evap_input_filename", evap_input_filename_textbox.Text);

                xwriter.WriteElementString("soildepth_constant_value", soildepth_constant_value_box.Text);
                xwriter.WriteElementString("landuse_constant_value", landuse_constant_value_box.Text);
                xwriter.WriteElementString("tillfields_constant_value", tillfields_constant_textbox.Text);
                xwriter.WriteElementString("rain_constant_value", rainfall_constant_value_box.Text);
                xwriter.WriteElementString("infil_constant_value", infil_constant_value_box.Text);
                xwriter.WriteElementString("evap_constant_value", evap_constant_value_box.Text);

                xwriter.WriteElementString("check_fill_sinks_before", XmlConvert.ToString(fill_sinks_before_checkbox.Checked));
                xwriter.WriteElementString("check_fill_sinks_during", XmlConvert.ToString(fill_sinks_during_checkbox.Checked));

                xwriter.WriteEndElement();


                xwriter.WriteStartElement("Run");
                xwriter.WriteElementString("runs_radiobutton", XmlConvert.ToString(runs_checkbox.Checked));
                xwriter.WriteElementString("number_runs", Number_runs_textbox.Text);

                xwriter.WriteStartElement("Specialsettings");
                xwriter.WriteElementString("Spitsbergen", XmlConvert.ToString(Ik_ben_Marijn.Checked));
                xwriter.WriteElementString("Luxembourg", XmlConvert.ToString(version_lux_checkbox.Checked));
                //xwriter.WriteElementString("other", XmlConvert.ToString(runs_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("CalibrationSensitivity");
                xwriter.WriteElementString("calibration_active_button", XmlConvert.ToString(Calibration_button.Checked));
                xwriter.WriteElementString("calibration_ratios_string", calibration_ratios_textbox.Text);
                xwriter.WriteElementString("calibration_levels", calibration_levels_textbox.Text);
                xwriter.WriteElementString("calibration_ratio_reduction_per_level", calibration_ratio_reduction_parameter_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Output");

                xwriter.WriteStartElement("File_Output");

                xwriter.WriteStartElement("Moment_of_Output");
                xwriter.WriteElementString("final_output_checkbox", XmlConvert.ToString(Final_output_checkbox.Checked));
                xwriter.WriteElementString("regular_output_checkbox", XmlConvert.ToString(Regular_output_checkbox.Checked));
                xwriter.WriteElementString("years_between_outputs", Box_years_output.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Type_of_Output");
                xwriter.WriteElementString("cumulative", XmlConvert.ToString(cumulative_output_checkbox.Checked));
                xwriter.WriteElementString("annual", XmlConvert.ToString(annual_output_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Maps_to_Output");
                xwriter.WriteElementString("alti", XmlConvert.ToString(Altitude_output_checkbox.Checked));
                xwriter.WriteElementString("altichange", XmlConvert.ToString(Alt_change_output_checkbox.Checked));
                xwriter.WriteElementString("soildepth", XmlConvert.ToString(Soildepth_output_checkbox.Checked));
                xwriter.WriteElementString("all_processes", XmlConvert.ToString(all_process_output_checkbox.Checked));
                xwriter.WriteElementString("waterflow", XmlConvert.ToString(water_output_checkbox.Checked));
                xwriter.WriteElementString("depressions", XmlConvert.ToString(depressions_output_checkbox.Checked));
                xwriter.WriteElementString("diagnostics", XmlConvert.ToString(diagnostic_output_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Other_outputs");

                xwriter.WriteStartElement("Avi_Animation");
                xwriter.WriteElementString("Save_as_AVI", XmlConvert.ToString(checkBoxGenerateAVIFile.Checked));
                xwriter.WriteElementString("AVIfilename", textBoxAVIFile.Text);
                xwriter.WriteElementString("years_between_AVI_outputs", saveintervalbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Google_Animation");
                xwriter.WriteElementString("Save_as_Google", XmlConvert.ToString(googleAnimationCheckbox.Checked));
                xwriter.WriteElementString("Google_filename", googleAnimationTextBox.Text);
                xwriter.WriteElementString("years_between_Google_outputs", googAnimationSaveInterval.Text);
                xwriter.WriteElementString("begindate", googleBeginDate.Text);
                xwriter.WriteElementString("UTM", XmlConvert.ToString(UTMgridcheckbox.Checked));
                xwriter.WriteElementString("South", XmlConvert.ToString(UTMsouthcheck.Checked));
                xwriter.WriteElementString("UTMzone", UTMzonebox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Timeseries");
                xwriter.WriteElementString("total_erosion", XmlConvert.ToString(timeseries.timeseries_total_ero_check.Checked));
                xwriter.WriteElementString("total_deposition", XmlConvert.ToString(timeseries.timeseries_total_dep_check.Checked));
                xwriter.WriteElementString("net_erosion", XmlConvert.ToString(timeseries.timeseries_net_ero_check.Checked));
                xwriter.WriteElementString("SDR", XmlConvert.ToString(timeseries.timeseries_SDR_check.Checked));
                xwriter.WriteElementString("total_average_alt", XmlConvert.ToString(timeseries.timeseries_total_average_alt_check.Checked));
                xwriter.WriteElementString("total_rain", XmlConvert.ToString(timeseries.timeseries_total_rain_check.Checked));
                xwriter.WriteElementString("total_infil", XmlConvert.ToString(timeseries.timeseries_total_infil_check.Checked));
                xwriter.WriteElementString("total_evap", XmlConvert.ToString(timeseries.timeseries_total_evap_check.Checked));
                xwriter.WriteElementString("total_outflow", XmlConvert.ToString(timeseries.timeseries_total_outflow_check.Checked));
                xwriter.WriteElementString("wet_cells", XmlConvert.ToString(timeseries.timeseries_number_waterflow_check.Checked));
                xwriter.WriteElementString("eroded_cells", XmlConvert.ToString(timeseries.timeseries_number_erosion_check.Checked));
                xwriter.WriteElementString("deposited_cells", XmlConvert.ToString(timeseries.timeseries_number_dep_check.Checked));
                xwriter.WriteElementString("cell_altitude", XmlConvert.ToString(timeseries.timeseries_cell_altitude_check.Checked));
                xwriter.WriteElementString("cell_waterflow", XmlConvert.ToString(timeseries.timeseries_cell_waterflow_check.Checked));
                xwriter.WriteElementString("waterflow_threshold", timeseries.timeseries_textbox_waterflow_threshold.Text);
                xwriter.WriteElementString("erosion_threshold", timeseries.timeseries_textbox_erosion_threshold.Text);
                xwriter.WriteElementString("deposition_threshold", timeseries.timeseries_textbox_deposition_threshold.Text);
                xwriter.WriteElementString("cell_row", timeseries.timeseries_textbox_cell_row.Text);
                xwriter.WriteElementString("cell_col", timeseries.timeseries_textbox_cell_col.Text);
                xwriter.WriteElementString("total_OM_input", XmlConvert.ToString(timeseries.total_OM_input_checkbox.Checked));
                xwriter.WriteElementString("total_average_soil_thickness", XmlConvert.ToString(timeseries.total_average_soilthickness_checkbox.Checked));
                xwriter.WriteElementString("total_phys_weath", XmlConvert.ToString(timeseries.total_phys_weath_checkbox.Checked));
                xwriter.WriteElementString("total_chem_weath", XmlConvert.ToString(timeseries.total_chem_weath_checkbox.Checked));
                xwriter.WriteElementString("total_fine_formed", XmlConvert.ToString(timeseries.total_fine_formed_checkbox.Checked));
                xwriter.WriteElementString("total_fine_eluviated", XmlConvert.ToString(timeseries.total_fine_eluviated_checkbox.Checked));
                xwriter.WriteElementString("total_mass_bioturbed", XmlConvert.ToString(timeseries.total_mass_bioturbed_checkbox.Checked));
                xwriter.WriteElementString("timeseries_soil_depth", XmlConvert.ToString(timeseries.timeseries_soil_depth_checkbox.Checked));
                xwriter.WriteElementString("timeseries_soil_mass", XmlConvert.ToString(timeseries.timeseries_soil_mass_checkbox.Checked));
                xwriter.WriteElementString("timeseries_coarser", XmlConvert.ToString(timeseries.timeseries_coarser_checkbox.Checked));
                xwriter.WriteElementString("timeseries_thicker", XmlConvert.ToString(timeseries.timeseries_number_soil_thicker_checkbox.Checked));
                xwriter.WriteElementString("soil_cell", timeseries.timeseries_soil_cell_col.Text);
                xwriter.WriteElementString("soil_col", timeseries.timeseries_soil_cell_row.Text);
                xwriter.WriteElementString("coarser_fraction", timeseries.timeseries_soil_coarser_fraction_textbox.Text);
                xwriter.WriteElementString("thicker_threshold", timeseries.timeseries_soil_thicker_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Profiles");
                xwriter.WriteElementString("profile1_row", XmlConvert.ToString(profile.radio_pro1_row.Checked));
                xwriter.WriteElementString("profile1_col", XmlConvert.ToString(profile.radio_pro1_col.Checked));
                xwriter.WriteElementString("profile2_row", XmlConvert.ToString(profile.radio_pro2_row.Checked));
                xwriter.WriteElementString("profile2_col", XmlConvert.ToString(profile.radio_pro2_col.Checked));
                xwriter.WriteElementString("profile3_row", XmlConvert.ToString(profile.radio_pro3_row.Checked));
                xwriter.WriteElementString("profile3_col", XmlConvert.ToString(profile.radio_pro3_col.Checked));
                xwriter.WriteElementString("p1_number", profile.p1_row_col_box.Text);
                xwriter.WriteElementString("p2_number", profile.p2_row_col_box.Text);
                xwriter.WriteElementString("p3_number", profile.p3_row_col_box.Text);
                xwriter.WriteElementString("p1_waterflow", XmlConvert.ToString(profile.check_waterflow_profile1.Checked));
                xwriter.WriteElementString("p1_altitude", XmlConvert.ToString(profile.check_altitude_profile1.Checked));
                xwriter.WriteElementString("p2_waterflow", XmlConvert.ToString(profile.check_waterflow_profile2.Checked));
                xwriter.WriteElementString("p2_altitude", XmlConvert.ToString(profile.check_altitude_profile2.Checked));
                xwriter.WriteElementString("p3_waterflow", XmlConvert.ToString(profile.check_waterflow_profile3.Checked));
                xwriter.WriteElementString("p3_altitude", XmlConvert.ToString(profile.check_altitude_profile3.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Soilfractions");
                xwriter.WriteElementString("coarsefrac", soildata.coarsebox.Text);
                xwriter.WriteElementString("sandfrac", soildata.sandbox.Text);
                xwriter.WriteElementString("siltfrac", soildata.siltbox.Text);
                xwriter.WriteElementString("clayfrac", soildata.claybox.Text);
                xwriter.WriteElementString("fclayfrac", soildata.fineclaybox.Text);
                xwriter.WriteEndElement();
                //End the document
                xwriter.WriteEndDocument();

                //Flush the xml document to the underlying stream and
                //close the underlying stream. The data will not be
                //written out to the stream until either the Flush()
                //method is called or the Close() method is called.
                xwriter.Close();

                this.Text = basetext + " (" + Path.GetFileName(cfgname) + ")";
            }
        }

        private void read_soil_elevation_distance_from_output(int time, string dir)
        {
            // read latest output and start calculating from there
            dir = dir + "\\";

            initialise_once();

            filename = dir + "0_" + time + "_out_dtm.asc";
            read_double(filename, dtm);
            Debug.WriteLine("read dtm");

            filename = dir + "0_" + time + "_out_soildepth.asc";
            read_double(filename, soildepth_m);
            Debug.WriteLine("read soildepth");

            filename = dir + "0_" + time + "_out_change.asc";
            read_double(filename, dtmchange);
            Debug.WriteLine("read dtm change");

            filename = dir + "0_" + time + "_out_water_erosion.asc";
            read_double(filename, sum_water_erosion);
            Debug.WriteLine("read water erosion");

            filename = dir + "0_" + time + "_out_tillage.asc";
            read_double(filename, sum_tillage);
            Debug.WriteLine("read sum_tillage");

            filename = dir + "0_" + time + "_out_creep.asc";
            read_double(filename, creep);
            Debug.WriteLine("read creep");

            filename = dir + "0_" + time + "_out_dz_treefall.asc";
            read_double(filename, dz_treefall);
            Debug.WriteLine("read dz_treefall");

            filename = dir + "0_" + time + "_out_tillage.asc";
            read_double(filename, sum_tillage);
            Debug.WriteLine("read sum_tillage");

            filename = dir + "0_" + time + "_out_dz_soil.asc";
            read_double(filename, dz_soil);
            Debug.WriteLine("read sum_dz_soil");
            // SOIL INFORMATION
            // reset old info
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    for (int lay = 0; lay < max_soil_layers; lay++)
                    {
                        texture_kg[row, col, lay, 0] = 0;
                        texture_kg[row, col, lay, 1] = 0;
                        texture_kg[row, col, lay, 2] = 0;
                        texture_kg[row, col, lay, 3] = 0;
                        texture_kg[row, col, lay, 4] = 0;
                        young_SOM_kg[row, col, lay] = 0;
                        old_SOM_kg[row, col, lay] = 0;
                        layerthickness_m[row, col, lay] = 0;
                        bulkdensity[row, col, lay] = 0;
                    }
                }
            }


            using (var reader = new StreamReader(dir + "t" + time + "_out_allsoils.csv"))
            {
                int row, col, lay;
                // discard first line (header)    
                var line = reader.ReadLine();
                var values = line.Split(',');

                while (!reader.EndOfStream)
                {
                    line = reader.ReadLine();
                    values = line.Split(',');

                    row = Convert.ToInt32(values[0]);
                    col = Convert.ToInt32(values[1]);
                    lay = Convert.ToInt32(values[3]);

                    texture_kg[row, col, lay, 0] = Convert.ToDouble(values[8]); //coarse
                    texture_kg[row, col, lay, 1] = Convert.ToDouble(values[9]); // sand
                    texture_kg[row, col, lay, 2] = Convert.ToDouble(values[10]); // silt
                    texture_kg[row, col, lay, 3] = Convert.ToDouble(values[11]); // clay
                    texture_kg[row, col, lay, 4] = Convert.ToDouble(values[12]); // fine clay
                    young_SOM_kg[row, col, lay] = Convert.ToDouble(values[13]); // young SOM
                    old_SOM_kg[row, col, lay] = Convert.ToDouble(values[14]); // old SOM
                    layerthickness_m[row, col, lay] = Convert.ToDouble(values[5]); // thickness
                    bulkdensity[row, col, lay] = Convert.ToDouble(values[23]); // bulk density

                }
            }
        }

        #endregion

        #region depression code

        void findsinks()
        {
            this.InfoStatusPanel.Text = "findtrouble has been entered";
            int number, twoequals = 0, threeequals = 0, moreequals = 0;
            int[] intoutlet = new int[9];
            int x;
            numsinks = 0;
            int row, col;

            for (row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        dh = 0.0; high = 0; low = 0; equal = 0; status_map[row, col] = 0; number = 0;
                        for (x = 0; x < 9; x++) { intoutlet[x] = 99; }
                        for (i = (-1); i <= 1; i++)
                        {       //make a circle around every cell  ...
                            for (j = (-1); j <= 1; j++)
                            {
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)) && dtm[row + i, col + j] != -9999)
                                { //boundaries of grid
                                    number++;
                                    dh = dtm[row, col] - dtm[row + i, col + j];
                                    if (dh < 0) { high++; intoutlet[number - 1] = -1; }     // add one to the higher-nbour-counter and add 'h' to the outlet-string
                                    if (dh > 0) { low++; intoutlet[number - 1] = 1; }       // add one to the lower-nbour-counter and add 'l' to the outlet-string
                                    if (dh == 0) { equal++; intoutlet[number - 1] = 0; }      // add one to the equal-nbour-counter and add 'e' to the outlet-string
                                    //Debug.WriteLine("cell %d %d, alt=%.2f nb %d %d, alt=%.2f dh %.3f low %d, equal %d, high %d\n",row,col,dtm[row,col],row+i,col+j,dtm[row+i,col+j],dh,low,equal,high); 
                                }  //end if within boundaries
                            }  // end for j
                        } // end for i, we have considered the circle around the cell and counted higher, equal and, therefore, lower neighbours

                        if (low == 0 && intoutlet[7] != 99) { status_map[row, col] = 1; numsinks++; }       // if 0 lower cells cells are present and 8 cells in total, we have a sink
                        if (low == 8) { status_map[row, col] = -1; }       // if 8 lower cells are present, we have a top
                        if (equal == 1) { twoequals++; }        // this case is rare in real DEMs
                        if (equal == 2) { threeequals++; }      // this case is very rare in real DEMs
                        if (equal > 2) { moreequals++; }        // this case is extremely rare in real DEMs
                    } //end for nodata
                    else
                    {
                        status_map[row, col] = 3;
                    }
                }   // end for col
            }  // end for row

            /*
            last but not least we give status_map a 3 for all cells on the edge of the DEM, so we can end formation of depressions there
            */

            for (col = 0; col < nc; col++)
            {
                status_map[0, col] = 3; status_map[nr - 1, col] = 3;
            }
            for (row = 0; row < nr; row++)
            {
                status_map[row, 0] = 3; status_map[row, nc - 1] = 3;
            }


            //reports

            //this.InfoStatusPanel.Text = "found " + numsinks + " true sinks in " + nr * nc + "  cells";
            //Debug.WriteLine("\n\n--sinks overview at t = " + t + "--");

            //if (numsinks / (nr * nc) > 0.0075) { Debug.WriteLine("this DEM contains " + numsinks + " true sinks in " + nr * nc + "  cells\n That's a lot!"); }
            //else { Debug.WriteLine("t" + t + " this DEM contains " + numsinks + " true sinks in " + nr * nc + "  cells"); }
            //Debug.WriteLine(" equals: " + twoequals / 2 + " double, " + threeequals / 3 + " triple and about " + moreequals + " larger\n");

            // 
            //.WriteLine(" numberofweirdoutlets: " + numberofweirdoutlets + "\n\n"); 
            // 

        }

        void searchdepressions()
        {
            int z;
            //this.InfoStatusPanel.Text = "searchdepressions has been entered";
            for (row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (col = 0; col < nc; col++)
                {
                    depression[row, col] = 0;     // set depression to zero
                }
            }

            for (z = 0; z < numberofsinks; z++)
            {         // the maximum number of depressions is the number of sinks
                drainingoutlet_row[z, 0] = -1;
                drainingoutlet_col[z, 0] = -1;
                drainingoutlet_row[z, 1] = -1;
                drainingoutlet_col[z, 1] = -1;
                drainingoutlet_row[z, 2] = -1;
                drainingoutlet_col[z, 2] = -1;
                drainingoutlet_row[z, 3] = -1;
                drainingoutlet_col[z, 3] = -1;
                drainingoutlet_row[z, 4] = -1;
                drainingoutlet_col[z, 4] = -1;
                depressionlevel[z] = 0;
                depressionsize[z] = 0;
                depressionvolume_m[z] = 0;
                iloedge[z] = 0;
                jloedge[z] = 0;
                iupedge[z] = 0;
                jupedge[z] = 0;
            }

            totaldepressions = 0; totaldepressionsize = 0; maxsize = 0; totaldepressionvolume = 0; largestdepression = -1;
            depressionnumber = 0;
            for (row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (col = 0; col < nc; col++)
                {
                    if (status_map[row, col] == 1 && depression[row, col] == 0)
                    {   // sink  -NODATA cells are never sinks, no need to exclude them explicitly here
                        numberoflowestneighbours = 0;
                        for (lowestneighbourcounter = 0; lowestneighbourcounter < maxlowestnbs; lowestneighbourcounter++)
                        {
                            rowlowestnb[lowestneighbourcounter] = -1;
                            collowestnb[lowestneighbourcounter] = -1;
                        }
                        depressionnumber++;                 // so depressionnumber 0 is not used, neither is depression[r,c] = 0
                        if (depressionnumber == 1153000) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }
                        //Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " is initially " + depressionvolume[depressionnumber]); 
                        totaldepressions++;
                        depressionlevel[depressionnumber] = dtm[row, col];
                        iloedge[depressionnumber] = row - 1;
                        iupedge[depressionnumber] = row + 1;
                        jloedge[depressionnumber] = col - 1;
                        jupedge[depressionnumber] = col + 1;
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" Sink " + depressionnumber + " located: " + row + "," + col + " alt " + dtm[row, col]);
                            Debug.WriteLine(" edges : " + iloedge[depressionnumber] + ", " + iupedge[depressionnumber] + ", " + jloedge[depressionnumber] + ", " + jupedge[depressionnumber]);
                        }
                        depressionsize[depressionnumber] = 1;
                        depression[row, col] = depressionnumber;
                        if (depression[row, col] < 0)
                        {
                            MessageBox.Show("Depression error at row " + row + " col " + col + " dep " + depression[row, col]);
                        }
                        iupradius = 1; jupradius = 1; iloradius = 1; jloradius = 1;
                        depressionready = 0; depressiondrainsout = 0;
                        while (depressionready != 1)
                        {
                            if (depressionnumber == 1153000) { diagnostic_mode = 1; }
                            minaltidiff = -99999999; int already_lower_than_lakelevel = 0;
                            for (i = (-1 * iloradius); i <= iupradius; i++)
                            {       //make a circle around the current cell that is so large that it covers all neighbours of all cells currently in the depression
                                for (j = (-1 * jloradius); j <= jupradius; j++)
                                {
                                    if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // in this case, we DO want to find cells with NODATA, because these are valid end-points of lakes
                                    {
                                        //if (diagnostic_mode == 1) { Debug.WriteLine("now at " + (row + i) + ", " + (col + j)); }
                                        nbismemberofdepression = 0;
                                        for (alpha = (-1); alpha <= 1; alpha++)
                                        {       // check in circle around the current cell if one of its neighbours is member of the depression
                                            for (beta = (-1); beta <= 1; beta++)
                                            {
                                                if (((row + i + alpha) >= 0) && ((row + i + alpha) < nr) && ((col + j + beta) >= 0) && ((col + j + beta) < nc) && !((alpha == 0) && (beta == 0)))
                                                {
                                                    if (depression[row + i + alpha, col + j + beta] == depressionnumber)
                                                    {   //and only if the cell is an actual neighbour of a cell that is member of the depression
                                                        nbismemberofdepression = 1;
                                                    } // end if nb = member of depression
                                                } // end if boundary
                                            }
                                        } // end for first alpha-beta circle to see if any nb = member of depression. It could have been no neighbour of the current depression but still within ilorarius, iupradius etc.
                                        if (nbismemberofdepression == 1 && depression[row + i, col + j] != depressionnumber)
                                        {   // only in case cell row+i, col+j  has a nb that is already member, we are interested in its altitude diff with depressionlevel
                                            altidiff = depressionlevel[depressionnumber] - dtm[row + i, col + j];
                                            if (diagnostic_mode == 1)
                                            {
                                                Debug.WriteLine((row + i) + ", " + (col + j) + " is neighbour of depression , altidifference " + altidiff);
                                            }
                                            if (altidiff == minaltidiff)
                                            {   //if lowest higher nb = equally high as previous lowest higher nb
                                                lowestneighbourcounter++; numberoflowestneighbours++;
                                                if (numberoflowestneighbours == maxlowestnbs) { Debug.WriteLine(" WARNING: the setting for maximum number of lowest neighbours is " + numberoflowestneighbours + " lowest nbs" + maxlowestnbs); }
                                                rowlowestnb[lowestneighbourcounter] = (row + i);
                                                collowestnb[lowestneighbourcounter] = (col + j);
                                                // in this way, we can add all equally high lowest higher neighbours to the current depression (maximum = maxlowestnbs)
                                            } //end if higher neighbour, equal as before
                                            if (altidiff > minaltidiff || dtm[row + i, col + j] < depressionlevel[depressionnumber])  // this INCLUDES nodata cells bordering the lake!!
                                            {   //het hoogteverschil met deze buur telt alleen als minder hoog dan vorige buren OF lager dan meerniveau 
                                                minaltidiff = altidiff;
                                                if (dtm[row + i, col + j] < depressionlevel[depressionnumber] && already_lower_than_lakelevel == 1)
                                                {  // the new lowest neighbour is lower than lakelevel!! 
                                                    // We want to know all lowest nbs that are lower than lakelevel, so we do not zero the rowlowestnb 
                                                    // and colllowestnb arrays
                                                    lowestneighbourcounter++; numberoflowestneighbours++;
                                                    rowlowestnb[lowestneighbourcounter] = (row + i);
                                                    collowestnb[lowestneighbourcounter] = (col + j);
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" found another neighbour that is lower than lakelevel "); }
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" lower neighbour that is lower than lakelevel: " + rowlowestnb[lowestneighbourcounter] + ", " + collowestnb[lowestneighbourcounter] + " , " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]); }
                                                }
                                                else  // the new lowest neighbour is higher than lakelevel or is the first lowest nb that is lower than lakelevel
                                                {
                                                    if (dtm[row + i, col + j] < depressionlevel[depressionnumber]) { already_lower_than_lakelevel = 1; }
                                                    for (lowestneighbourcounter = 0; lowestneighbourcounter < maxlowestnbs; lowestneighbourcounter++)
                                                    {
                                                        rowlowestnb[lowestneighbourcounter] = -1; collowestnb[lowestneighbourcounter] = -1;
                                                    } //end:  for all lowestneighbours that we had before, the rowlowestnb and collowestnb arrays have been zeroed
                                                    lowestneighbourcounter = 0; numberoflowestneighbours = 1;
                                                    rowlowestnb[0] = (row + i); collowestnb[0] = (col + j);
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" higher neighbour that is lower than previous higher nbs: " + rowlowestnb[0] + ", " + collowestnb[0] + " , " + dtm[rowlowestnb[0], collowestnb[0]]); }
                                                }
                                            } //end if higher neighbour but lower than before
                                        } //end if nbismemberofdepression

                                    } // end if boundary
                                }
                            } // double end for circle with possibly extended radius around the sink, alpha - beta circle . We now know what is/are the lowest higher neighbours


                            if (diagnostic_mode == 1)
                            {
                                for (lowestneighbourcounter = 0; lowestneighbourcounter < numberoflowestneighbours; lowestneighbourcounter++)
                                {
                                    Debug.WriteLine(rowlowestnb[lowestneighbourcounter] + " " + collowestnb[lowestneighbourcounter] + " is one of the " + numberoflowestneighbours + " lowest neighbours of depression " + depressionnumber + ". Its altitude is " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]);
                                }
                            }

                            int outletfound = 0; int numberofoutlets = 0; int outletnumber = 0;

                            for (lowestneighbourcounter = 0; lowestneighbourcounter < numberoflowestneighbours; lowestneighbourcounter++)
                            {
                                if (rowlowestnb[lowestneighbourcounter] >= iupedge[depressionnumber]) { iupedge[depressionnumber] = rowlowestnb[lowestneighbourcounter] + 1; }
                                if (rowlowestnb[lowestneighbourcounter] <= iloedge[depressionnumber]) { iloedge[depressionnumber] = rowlowestnb[lowestneighbourcounter] - 1; }
                                if (collowestnb[lowestneighbourcounter] >= jupedge[depressionnumber]) { jupedge[depressionnumber] = collowestnb[lowestneighbourcounter] + 1; }
                                if (collowestnb[lowestneighbourcounter] <= jloedge[depressionnumber]) { jloedge[depressionnumber] = collowestnb[lowestneighbourcounter] - 1; }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" minaltidiff = " + minaltidiff + "; depression " + depressionnumber + " row " + rowlowestnb[lowestneighbourcounter] + " col " + collowestnb[lowestneighbourcounter] + " alt " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + " is lower than depressionlevel " + depressionlevel[depressionnumber]); }

                                if (minaltidiff <= 0.0)
                                { // if the cell is higher than depressionlevel
                                    // it can either be a cell of another depression

                                    if (diagnostic_mode == 1) { Debug.WriteLine(rowlowestnb[lowestneighbourcounter] + "," + collowestnb[lowestneighbourcounter] + " is member of depression " + depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]); }
                                    if (depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] != 0 && depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] != depressionnumber)
                                    {  // then we have touched upon a depression that was previously analysed
                                        //status_map[rowlowestnb[lowestneighbourcounter],collowestnb[lowestneighbourcounter]] = 0;
                                        otherdepressionsize = 0;
                                        otherdepression = depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        if (t > 1000000) { diagnostic_mode = 1; }
                                        totaldepressions--;
                                        totaldepressionvolume -= depressionvolume_m[otherdepression];
                                        for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                                        {
                                            drainingoutlet_row[otherdepression, outletcounter] = -1;
                                            drainingoutlet_col[otherdepression, outletcounter] = -1;
                                        }
                                        depressionvolume_m[depressionnumber] += depressionvolume_m[otherdepression];
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " was increased to " + depressionvolume[depressionnumber] + " with " + depressionvolume[otherdepression] + " of depression " + otherdepression); }
                                        depressionvolume_m[depressionnumber] += (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]));  //
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" added " + depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]) + " to depressionvolume of depression " + depressionnumber + ". Dtm " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + ", depressionlevel " + depressionlevel[depressionnumber]); }
                                        depressionvolume_m[otherdepression] = 0;
                                        depressionlevel[depressionnumber] = dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" first: ilo = " + iloradius + " , iup = " + iupradius + " , jlo = " + jloradius + " , jup = " + jupradius + "  around sink " + row + " " + col); }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" depression " + otherdepression + " : iloedge " + iloedge[otherdepression] + " , iupedge " + iupedge[otherdepression] + " , jloedge " + jloedge[otherdepression] + " , jupedge " + jupedge[otherdepression]); }
                                        if (jloedge[otherdepression] < (col - jloradius)) { jloradius = Math.Abs(jloedge[otherdepression] - col) + 1; jloedge[depressionnumber] = col - jloradius; }     // we enlarge the area around the sink of the current depression that is to be checked
                                        if (iloedge[otherdepression] < (row - iloradius)) { iloradius = Math.Abs(iloedge[otherdepression] - row) + 1; iloedge[depressionnumber] = row - iloradius; }     // it now includes the complete area of the depression that has been touched upon
                                        if (jupedge[otherdepression] > (col + jupradius)) { jupradius = Math.Abs(jupedge[otherdepression] - col) + 1; jupedge[depressionnumber] = col + jupradius; }
                                        if (iupedge[otherdepression] > (row + iupradius)) { iupradius = Math.Abs(iupedge[otherdepression] - row) + 1; iupedge[depressionnumber] = row + iupradius; }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" now: ilo = " + iloradius + " , iup = " + iupradius + " , jlo = " + jloradius + " , jup = " + jupradius + " around sink " + row + "  " + col); }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" begonnen met gebied om sink om cellen uit ander meer om te nummeren"); }
                                        for (alpha = (-1 * iloradius); alpha <= iupradius; alpha++)
                                        {       // move around in this square and change depressionnumber
                                            for (beta = (-1 * jloradius); beta <= jupradius; beta++)
                                            {
                                                if (((row + alpha) >= 0) && ((row + alpha) < nr) &&   // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                    ((col + beta) >= 0) && ((col + beta) < nc) && !((alpha == 0) && (beta == 0)) && dtm[row + alpha, col + beta] != -9999)
                                                {
                                                    if (depression[row + alpha, col + beta] == otherdepression)
                                                    {
                                                        depression[row + alpha, col + beta] = depressionnumber;
                                                        otherdepressionsize++;
                                                        if (diagnostic_mode == 1) { Debug.WriteLine(" moved cell " + (row + alpha) + " , " + (col + beta) + "(" + dtm[row + alpha, col + beta] + ") from depression " + otherdepression + " to depression " + depressionnumber + " "); }
                                                    } // end if cell belonged to other depression
                                                }
                                            }
                                        } // double end for second alpha-beta square : around the sink to change depressionnumber of previously checked depression
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" All " + otherdepressionsize + "  cells of depression " + otherdepression + "  were added to depression " + depressionnumber + "  (prvsly " + depressionsize[depressionnumber] + " ), level now " + depressionlevel[depressionnumber]); }
                                        depressionsize[depressionnumber] += otherdepressionsize;
                                        depressionsize[otherdepression] = 0;
                                        totaldepressionsize -= otherdepressionsize;
                                        if (diagnostic_mode == 1) { Debug.WriteLine("B totaldepressionsize " + totaldepressionsize + " , otherdepressionnsize " + otherdepression + "  = " + otherdepressionsize + "  depressionnumber " + depressionnumber + " "); }

                                        // it is theoretically possible that the outlet that connects the 'depression' and the 'otherdepression' , drains to a third side. In that case, the new, combined depression
                                        // should be declared ready after added 'otherdepression' to 'depression' ...

                                        for (alpha = (-1); alpha <= 1; alpha++)
                                        {
                                            for (beta = -1; beta <= 1; beta++)
                                            {
                                                if (((rowlowestnb[lowestneighbourcounter] + alpha) >= 0) && ((rowlowestnb[lowestneighbourcounter] + alpha) < nr) &&
                                                    ((collowestnb[lowestneighbourcounter] + beta) >= 0) && ((collowestnb[lowestneighbourcounter] + beta) < nc) &&
                                                    !((alpha == 0) && (beta == 0)) && dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != -9999)
                                                {  // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                    if (depression[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != depressionnumber)
                                                    {
                                                        if (dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] < depressionlevel[depressionnumber])
                                                        {
                                                            depressionready = 1;
                                                            drainingoutlet_row[depressionnumber, 0] = rowlowestnb[lowestneighbourcounter];
                                                            drainingoutlet_col[depressionnumber, 0] = collowestnb[lowestneighbourcounter];
                                                            status_map[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] = 2;
                                                            if (diagnostic_mode == 1)
                                                            {
                                                                Debug.WriteLine(" depression " + depressionnumber + " drains to a third side and is ready ");
                                                                //displayonscreen(rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta);
                                                            }
                                                        } // end if lower than outlet = depressionlevel
                                                    }  // end if depression != depression
                                                } // end if boundaries
                                            } // end for beta
                                        } // end for alpha
                                    }  // end if touched another depression with lowest nb

                                    //or it can be any other non-depression cell

                                    else
                                    {      // so we did not touch another depression with our lowest nb , but it was a higher or equally high nb so the depression is not yet ready
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" this lowest neighbour: second option: no depression "); }
                                        depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] = depressionnumber;
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " is " + depressionvolume_m[depressionnumber]); }
                                        depressionvolume_m[depressionnumber] += (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]));  // add the amount of water added to the surface already part of depression
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" added " + (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber])) + " to depressionvolume of depression " + depressionnumber + ". depressionsize: " + depressionsize[depressionnumber] + ", dtm %6.6f, depressionlevel " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]], depressionlevel[depressionnumber]); }
                                        depressionsize[depressionnumber]++;
                                        depressionlevel[depressionnumber] = dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" added " + rowlowestnb[lowestneighbourcounter] + ", " + collowestnb[lowestneighbourcounter] + "  with level " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + " to depression " + depressionnumber + " , size now " + depressionsize[depressionnumber] + " "); }
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" lowest neighbour of depression " + depressionnumber + "  is " + rowlowestnb[lowestneighbourcounter] + " , " + collowestnb[lowestneighbourcounter] + " ," + depressionlevel[depressionnumber] + "  "); }
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" depressionlevel for this depression is currently: " + depressionlevel[depressionnumber]); }  // laagste buur is nog niet betrokken bij een ander meer

                                        if (status_map[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] == 3)
                                        { // then this depression drains out of the DEM...
                                            depressionready = 1;
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" depression " + depressionnumber + " drains out of the DEM and is ready "); }
                                            depressiondrainsout = 1;
                                            drainingoutlet_row[depressionnumber, 0] = rowlowestnb[lowestneighbourcounter];
                                            drainingoutlet_col[depressionnumber, 0] = collowestnb[lowestneighbourcounter];
                                        }
                                        else
                                        { // depression does not drain out of DEM
                                            if ((rowlowestnb[lowestneighbourcounter] - row) == iupradius) { iupradius++; }     //in that case we will now change searchradius
                                            if ((row - rowlowestnb[lowestneighbourcounter]) == iloradius) { iloradius++; }
                                            if ((collowestnb[lowestneighbourcounter] - col) == jupradius) { jupradius++; }
                                            if ((col - collowestnb[lowestneighbourcounter]) == jloradius) { jloradius++; }
                                        } // end else
                                    } //end else
                                } // end if cell was higher than depressionlevel

                                else
                                {  // apparently it was lower than depressionlevel
                                    //Debug.WriteLine(" found lower neighbour " + rowlowestnb[lowestneighbourcounter] + "  " + collowestnb[lowestneighbourcounter] + "  alt " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + "  for depression " + depressionnumber + "   level " + depressionlevel[depressionnumber] + " "); 
                                    outletfound = 1;
                                    // find for this cell, that should not be part of the depression, the necessarily present depression nb @ depressionlevel and call it a outlet
                                    for (alpha = (-1); alpha <= 1; alpha++)
                                    {
                                        for (beta = -1; beta <= 1; beta++)
                                        {
                                            if (((rowlowestnb[lowestneighbourcounter] + alpha) >= 0) && ((rowlowestnb[lowestneighbourcounter] + alpha) < nr) &&
                                                    ((collowestnb[lowestneighbourcounter] + beta) >= 0) && ((collowestnb[lowestneighbourcounter] + beta) < nc) &&
                                                    !((alpha == 0) && (beta == 0)) && dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != -9999)
                                            {  // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                if (depression[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] == depressionnumber)
                                                {
                                                    if (dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] == depressionlevel[depressionnumber])
                                                    {
                                                        //Debug.WriteLine(" At lower cell  " + rowlowestnb[lowestneighbourcounter] + " " + collowestnb[lowestneighbourcounter] + ", looking back at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta));
                                                        if (drainingoutlet_col[depressionnumber, outletnumber] != -1) //ArT is outletnumber put to zero before here somewhere?
                                                        {
                                                            // Then we found an earlier outlet (somewhere), and we have to define an extra one here, IF that earlier one was not this one.      
                                                            bool this_is_an_earlier_outlet = false;
                                                            for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                                                            {
                                                                if (rowlowestnb[lowestneighbourcounter] + alpha == drainingoutlet_row[depressionnumber, outletcounter] && collowestnb[lowestneighbourcounter] + beta == drainingoutlet_col[depressionnumber, outletcounter])
                                                                {
                                                                    this_is_an_earlier_outlet = true;
                                                                    //Debug.WriteLine(" A prior outlet definition for depression " + depressionnumber + " exists at " + drainingoutlet_row[depressionnumber, outletcounter] + " " + drainingoutlet_col[depressionnumber, outletcounter] + " (" + (lowestneighbourcounter + 1) + "/" + numberoflowestneighbours + ")");
                                                                }
                                                            }
                                                            if (this_is_an_earlier_outlet == false)
                                                            {
                                                                //Debug.WriteLine(" A new outlet was found for depression " + depressionnumber + " at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta) + " (" + (lowestneighbourcounter + 1) + "/" + numberoflowestneighbours + ")");
                                                                outletnumber++;
                                                                numberofoutlets++;
                                                                if (outletnumber > 4)
                                                                {
                                                                    //displayonscreen(drainingoutlet_row[depressionnumber, 1], drainingoutlet_col[depressionnumber, 1]);
                                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" Warning: LORICA seeks to define more than five outlets for depression " + depressionnumber + ". This request is denied"); }
                                                                    outletnumber--; numberofoutlets--;
                                                                }
                                                                else
                                                                {
                                                                    drainingoutlet_row[depressionnumber, outletnumber] = rowlowestnb[lowestneighbourcounter] + alpha;
                                                                    drainingoutlet_col[depressionnumber, outletnumber] = collowestnb[lowestneighbourcounter] + beta;
                                                                    status_map[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] = 2;
                                                                    //Debug.WriteLine(" made " + (rowlowestnb[lowestneighbourcounter] + alpha) + "  " + (collowestnb[lowestneighbourcounter] + beta) + "  the nr " + outletnumber + " outlet for depression " + depressionnumber + " ");
                                                                }
                                                            }

                                                        }
                                                        else  // then this is the first outlet, and we will define it as such
                                                        {
                                                            //Debug.WriteLine(" First definition of outlet for depression " + depressionnumber + " at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta) + " (" + (lowestneighbourcounter+1) + "/" + numberoflowestneighbours + ")");
                                                            if (outletnumber > 4)
                                                            {
                                                                //displayonscreen(drainingoutlet_row[depressionnumber, 1], drainingoutlet_col[depressionnumber, 1]);
                                                                if (diagnostic_mode == 1) { Debug.WriteLine(" Warning: LORICA seeks to define more than five outlets for depression " + depressionnumber + ". This request is denied"); }
                                                                outletnumber--; numberofoutlets--;
                                                            }
                                                            else
                                                            {
                                                                drainingoutlet_row[depressionnumber, outletnumber] = rowlowestnb[lowestneighbourcounter] + alpha;
                                                                drainingoutlet_col[depressionnumber, outletnumber] = collowestnb[lowestneighbourcounter] + beta;
                                                                status_map[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] = 2;
                                                                //Debug.WriteLine(" made " + (rowlowestnb[lowestneighbourcounter] + alpha) + "  " + (collowestnb[lowestneighbourcounter] + beta) + "  the nr " + outletnumber + " outlet for depression " + depressionnumber + " ");
                                                            }
                                                        }

                                                    } // end if dtm = depressionlevel
                                                } // end if depression = depressionnumber
                                            } // end if bnd
                                        } // end for beta
                                    } // end for alpha
                                } // end else
                            } //end for all lowestneighbours
                            // if outlet(s) defined ==> depressionready
                            if (outletfound == 1) { depressionready = 1; }
                        } // end while depressionready != 1

                        //if (depressionnumber == 180) {diagnostic_mode = 1;}
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" depression " + depressionnumber + "  (" + depressionlevel[depressionnumber] + "  m) is ready and contains " + depressionsize[depressionnumber] + "  cells. Volume = " + depressionvolume_m[depressionnumber] + " ");
                            if (depressiondrainsout == 1) { Debug.WriteLine(" depression " + depressionnumber + "  (" + depressionlevel[depressionnumber] + "  m) drains outside the DEM "); }
                            minimaps(row, col);
                        }
                        totaldepressionsize += depressionsize[depressionnumber];
                        totaldepressionvolume += depressionvolume_m[depressionnumber];
                        if (maxsize < depressionsize[depressionnumber]) { maxsize = depressionsize[depressionnumber]; largestdepression = depressionnumber; }
                        if (maxdepressionnumber < depressionnumber) { maxdepressionnumber = depressionnumber; }
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" Defined depression " + depressionnumber + ". Now size " + depressionsize[depressionnumber] + " and volume " + depressionvolume_m[depressionnumber]);
                        }
                    } // end if sink
                    //Debug.WriteLine("now at row " + row + " and col " + col);
                }  // end for  col
            } // end for   row
            /*
            Debug.WriteLine("\n\n--depressions overview--");
            if (totaldepressions != 0)
            {
                Debug.WriteLine("found " + totaldepressions + "  depressions containing " + totaldepressionsize + "  cells, with a volume of " + totaldepressionvolume);
                Debug.WriteLine(" " + totaldepressions + " depressions with a volume of " + totaldepressionvolume);
                //Debug.WriteLine("depression " + largestdepression + "  is largest by area: " + maxsize + " cells " + depressionlevel[largestdepression] + " m " + depressionvolume[largestdepression] + "m3");
                //if (depressionvolume[largestdepression] < 0) { Debug.WriteLine("negative depressionvolume found"); }
            }
            else
            {
                Debug.WriteLine(" no depressions found ");

            } */
            //Debug.WriteLine("\n");
            //Debug.WriteLine(" drains at: " + + " , " + + " , volume: %6.9f " ,drainingoutlet_row[largestdepression],drainingoutlet_col[largestdepression],depressionvolume[largestdepression]); 
            //out_integer("lakes.asc",depression);
            //out_integer("status.asc", status_map);
            // 
            // * */
        }

        void define_fillheight_new()  //calculates where depressions must be filled how high
        {
            // when completely filling a depression, we need to know - for each constituent cell and even for its neighbours - the altitude we
            // can fill it to. Since the depression must still drain towards the outlet, we add a very small value
            // to membercells so they drain towards the outlet.
            // we cannot simply use distance_to_outlet for each member cell, since depressions can round corners....

            //this.InfoStatusPanel.Text = "def fillheight has been entered";
            //Debug.WriteLine("defining fillheight\n");
            int notyetdone, done, depressiontt;

            once_dtm_fill = 0;

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    dtmfill_A[row, col] = -1;
                } //for
            } //for


            depressiontt = 0;
            for (depressiontt = 1; depressiontt <= maxdepressionnumber; depressiontt++)
            {  // for all possible depressions

                if (depressionsize[depressiontt] > 0)
                {      // if they exist, so have not been intermediate depressions
                    dtmfill_A[drainingoutlet_row[depressiontt, 0], drainingoutlet_col[depressiontt, 0]] = depressionlevel[depressiontt];
                    if (drainingoutlet_row[depressiontt, 1] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 1], drainingoutlet_col[depressiontt, 1]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 2] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 2], drainingoutlet_col[depressiontt, 2]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 3] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 3], drainingoutlet_col[depressiontt, 3]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 4] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 4], drainingoutlet_col[depressiontt, 4]] = depressionlevel[depressiontt]; }

                    notyetdone = 1; done = 0;
                    while (notyetdone > 0)
                    {
                        notyetdone = 0;
                        //if (diagnostic_mode == 1) { Debug.WriteLine("depressioncells depression " + depressiontt + " size " + depressionsize[depressiontt] + " " +drainingoutlet_row[depressiontt]+ " " + drainingoutlet_col[depressiontt]); }
                        //diagnostic_mode = 0;
                        for (row = iloedge[depressiontt]; row <= iupedge[depressiontt]; row++)
                        {
                            for (col = jloedge[depressiontt]; col <= jupedge[depressiontt]; col++)
                            {
                                if (((row) >= 0) && ((row) < nr) && ((col) >= 0) && ((col) < nc) && dtm[row, col] != -9999)
                                {  //bnd
                                    if (t > 1000000) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }
                                    if (diagnostic_mode == 1) { Debug.WriteLine("dtmfill_A of " + row + " " + col + " = " + dtmfill_A[row, col] + ", checking on behalf of depression " + depressiontt); }
                                    if (dtmfill_A[row, col] == -1 && depression[row, col] == depressiontt)
                                    {  // if this is a cell of the current depression that has not yet got a dtmfill
                                        // and remember that this is the only place where this cell could have gotten that DTMfill
                                        notyetdone++;       // then we are not yet ready
                                        if (diagnostic_mode == 1) { Debug.WriteLine(row + " " + col + ": notyetdone =  " + notyetdone); }
                                        //if (diagnostic_mode == 1) { displayonscreen(row, col); }
                                        for (i = -1; i <= 1; i++)
                                        {      // go and see if it has a depression-nb that does have a dtmfill and that is lower than the previous possible dep-nb's dtmfill
                                            for (j = -1; j <= 1; j++)
                                            {
                                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)) && dtm[row + i, col + j] != -9999)
                                                {  //bnd
                                                    if (depression[row + i, col + j] == depressiontt && dtmfill_A[row + i, col + j] > 0.0)
                                                    { // if it IS a depression-nb and DOES have a dtmfill
                                                        if ((i == 0 || j == 0) && (dtmfill_A[row, col] == -1 || (dtmfill_A[row, col] > dtmfill_A[row + i, col + j] + epsilon * dx)))
                                                        {
                                                            dtmfill_A[row, col] = (dtmfill_A[row + i, col + j] + epsilon * dx);
                                                        } // end if
                                                        if ((i != 0 && j != 0) && (dtmfill_A[row, col] == -1 || (dtmfill_A[row, col] > dtmfill_A[row + i, col + j] + epsilon * dx * Math.Sqrt(2))))
                                                        {
                                                            dtmfill_A[row, col] = (dtmfill_A[row + i, col + j] + epsilon * dx * Math.Sqrt(2));
                                                        } // end if
                                                    } // end if
                                                }//end if within boundaries
                                            }//end for circle (first part)
                                        }//end for circle (second part)
                                        if (dtmfill_A[row, col] > 0) { notyetdone--; done++; }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" notyetdone =  " + notyetdone + " done = " + done); }
                                    } // end if depression
                                    //if (diagnostic_mode == 1) { Debug.WriteLine("-> " + notyetdone); }
                                } // end if bnd
                            } // end for
                        } // end for
                    } // end while
                } // end if they exist
            } //end for all possible depressions

            //Debug.WriteLine("\n--dtmfill determination finished--");

        }

        void cleardelta(int iloradius, int iupradius, int jloradius, int jupradius, int clear_row, int clear_col)   //clears a delta
        {
            int epsilon, eta;
            if (diagnostic_mode == 1) { Debug.WriteLine(" clearing delta lake " + Math.Abs(depression[clear_row, clear_col]) + " around " + clear_row + " " + clear_col); }
            for (epsilon = -(iloradius + 3); epsilon <= iupradius + 3; epsilon++)
            {
                for (eta = -(jloradius + 3); eta <= jupradius + 3; eta++)
                {
                    if (((clear_row + epsilon) >= 0) && ((clear_row + epsilon) < nr) && ((clear_col + eta) >= 0) && ((clear_col + eta) < nc))
                    { // boundaries
                        if (depression[clear_row + epsilon, clear_col + eta] < 0)
                        {
                            depression[clear_row + epsilon, clear_col + eta] = Math.Abs(depression[clear_row, clear_col]);
                            if (diagnostic_mode == 1)
                            {
                                Debug.WriteLine(" membership of delta has been cancelled for " + (clear_row + epsilon) + " " + (clear_col + eta));
                            }
                        }  // end if depression < 0
                    }   // end if boundary
                }   // end for eta
            } // end for epsilon
            //Debug.WriteLine("cleared delta\n");
            if (diagnostic_mode == 1)
            {
                Debug.WriteLine(" ");
            }
        }

        void update_depression(int number)   //updates depressions when the erosion/deposition process has reached them to include cells that have been eroded to below lakelevel
        {
            /*  a.	First estimate of required sediment is fillheight  dtm for all lake cells. Test whether dz_ero_m and dz_sed_m for these cells are zero (they should be).
                b.	Starting from every lake cell, look for cells around it that are not part of the lake and had dtm above lakelevel.
                    	For such a cell, look around it for all lake-neighbours and determine the one that would yield the lowest fillheight. 
                    	Assign that fillheight to the cell, see  if its current altitude (corrected for already calculated ero and sed) is lower than fillheight.
                    	Add the difference to the sediment needed to fill the (now larger) lake.
                    	Add the cell to the lake and update the size and volume  of the lake
                c.	Continue until no more cells around the lake are lower 
                This would potentially clash with lakes that have more than two outlets. The third and later outlets would be 
                seen as lake cells and their lower neighbours on the non-lake-side would be added to the lake, leading to errors. */
            int urow = 0, ucol = 0, size = 0;
            int depressionnumber = number;
            //if (depressionnumber > 1) diagnostic_mode = 1;
            if (diagnostic_mode == 1) { Debug.WriteLine(" now updating depression " + depressionnumber); }
            depressionsum_water_m = 0;
            depressionsum_sediment_m = 0;
            depressionsum_texture_kg[0] = 0; depressionsum_texture_kg[1] = 0; depressionsum_texture_kg[2] = 0; depressionsum_texture_kg[3] = 0; depressionsum_texture_kg[4] = 0; depressionsum_YOM_kg = 0; depressionsum_OOM_kg = 0;
            needed_to_fill_depression_m = 0;

            for (urow = iloedge[depressionnumber]; urow <= iupedge[depressionnumber]; urow++)
            {
                for (ucol = jloedge[depressionnumber]; ucol <= jupedge[depressionnumber]; ucol++)
                {
                    if (((urow) >= 0) && ((urow) < nr) && ((ucol) >= 0) && ((ucol) < nc) && dtm[urow, ucol] != -9999)
                    {  //bnd
                        if (depression[urow, ucol] == depressionnumber)
                        {
                            if (only_waterflow_checkbox.Checked == false)
                            {
                                if (!(dz_ero_m[urow, ucol] == 0 && dz_sed_m[urow, ucol] == 0))
                                {
                                    Debug.WriteLine(" error in depression " + depressionnumber);
                                    // this should not happen: erosion or sedimentation into lake cells is not allowed - only the provision of those cells with sediment in transport.
                                    minimaps(urow, ucol);
                                }
                            }
                            // if they are member of the lake : add the diff between fillheight and dtm to the volume that must be filled, and add the sedintrans to what is available for filling
                            depressionsum_water_m += waterflow_m3[urow, ucol] / dx / dx;
                            if (only_waterflow_checkbox.Checked == false)
                            {
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    depressionsum_texture_kg[size] += sediment_in_transport_kg[urow, ucol, size];
                                }
                                depressionsum_OOM_kg += old_SOM_in_transport_kg[urow, ucol];
                                depressionsum_YOM_kg += young_SOM_in_transport_kg[urow, ucol];
                            }
                            needed_to_fill_depression_m += dtmfill_A[urow, ucol] - dtm[urow, ucol];
                            //if (diagnostic_mode == 1) { Debug.WriteLine(" dep_cell " + row + " " + col + " fillheight " + dtmfill_A[urow, ucol] + " dtm " + dtm[urow, ucol] + " needed now " + needed_to_fill_depression  ); }
                        }
                    }
                }
            }

            //now that we know how much kgs of every material are available for lake filling, we can calculate how much thickness [m3/m2 = m] that means.
            depressionsum_sediment_m = calc_thickness_from_mass(depressionsum_texture_kg, depressionsum_YOM_kg, depressionsum_OOM_kg);


            int updating_lake = 1;
            while (updating_lake == 1)
            {
                // while there are potential cells to be added to the lake
                updating_lake = 0;
                for (urow = iloedge[depressionnumber] - 1; urow <= iupedge[depressionnumber] + 1; urow++)
                {
                    for (ucol = jloedge[depressionnumber] - 1; ucol <= jupedge[depressionnumber] + 1; ucol++)
                    {
                        if (((urow) >= 0) && ((urow) < nr) && ((ucol) >= 0) && ((ucol) < nc) && dtm[urow, ucol] != -9999)
                        {  //bnd
                            if (depression[urow, ucol] != depressionnumber && dtm[urow, ucol] > depressionlevel[depressionnumber]) // the second part of the condition should ensure that no cells on the downstream side of outlets are added. 
                            {
                                double lowest_dtm_fill = 9999;
                                // we have now found a cell that should potentiall added to the lake - however, it should have a lake-neighbour for that to be really true. We look around to check this.
                                for (alpha = -1; alpha <= 1; alpha++)
                                {
                                    for (beta = -1; beta <= 1; beta++)
                                    {
                                        if ((urow + alpha) >= 0 && (urow + alpha) < nr && (ucol + beta) >= 0 && (ucol + beta) < nc && !((alpha) == 0 && (beta) == 0) && dtm[urow + alpha, ucol + beta] != -9999)
                                        {
                                            if ((urow != urow + alpha) && (ucol != ucol + beta)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            if (only_waterflow_checkbox.Checked == false)
                                            {
                                                if (depression[urow + alpha, ucol + beta] == depressionnumber && (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]) < (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x))
                                                // if this cell has a lake neighbour and has a current altitude lower than the fillheight resulting from that neighbour, we store that fillheight until we find the lowest fillheight resulting from any lake-nbs of this cell
                                                {
                                                    if ((dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x) < lowest_dtm_fill)
                                                    {
                                                        lowest_dtm_fill = (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x);

                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (depression[urow + alpha, ucol + beta] == depressionnumber && (dtm[urow, ucol]) < (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x))
                                                // if this cell has a lake neighbour and has a current altitude lower than the fillheight resulting from that neighbour, we store that fillheight until we find the lowest fillheight resulting from any lake-nbs of this cell
                                                {
                                                    if ((dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x) < lowest_dtm_fill)
                                                    {
                                                        lowest_dtm_fill = (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x);

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                // after checking, if this cell had any lake-nb and was low enough itself, it is added to the lake and the search window is enlarged.
                                if (lowest_dtm_fill < 9999)
                                {
                                    depression[urow, ucol] = depressionnumber;
                                    depressionsize[depressionnumber]++;
                                    dtmfill_A[urow, ucol] = lowest_dtm_fill;
                                    if (only_waterflow_checkbox.Checked == false)
                                    {
                                        needed_to_fill_depression_m += dtmfill_A[urow, ucol] - (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]);
                                        for (size = 0; size < n_texture_classes; size++)
                                        {
                                            sediment_in_transport_kg[urow, ucol, size] = 0;
                                        }
                                    }
                                    else { needed_to_fill_depression_m += dtmfill_A[urow, ucol] - (dtm[urow, ucol]); }
                                    updating_lake = 1;
                                    if (urow == iloedge[depressionnumber] - 1) { iloedge[depressionnumber]--; }
                                    if (urow == iupedge[depressionnumber] + 1) { iupedge[depressionnumber]++; }
                                    if (ucol == jloedge[depressionnumber] - 1) { jloedge[depressionnumber]--; }
                                    if (ucol == jupedge[depressionnumber] + 1) { jupedge[depressionnumber]++; }

                                    // setting sed in trans to 0 is required to avoid double-counting when building delta's later
                                    // no addition to depressionsum_sed or _water is required because flows from this cell have already been considered earlier, and any dz_ero_m or dz_sed_m have been considered, and sed_in_trans has arrived at the lake to be counted
                                    //if (diagnostic_mode == 1) { Debug.WriteLine(" non_dep_cell " + urow + " " + ucol + " fillheight " + dtmfill_A[urow, ucol] + " new dtm " + (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]) + " needed now " + needed_to_fill_depression); }
                                }
                            }
                        }
                    }
                }  // end for

            } // end while
            if (diagnostic_mode == 1) { Debug.WriteLine(" Updated depression " + depressionnumber + ". Now size " + depressionsize[depressionnumber] + ", sum_water " + depressionsum_water_m + " sum_sed " + depressionsum_sediment_m + " Needed: " + needed_to_fill_depression_m); }

        }

        void fill_depression(int number)  // completely fills updated depressions (because enough sediment was available)
        {
            int this_depression = number;
            int fillrow = 0, size, fillcol = 0;
            //Debug.WriteLine(" now filling depression " + this_depression);
            sediment_filled_m += needed_to_fill_depression_m;


            for (fillrow = iloedge[this_depression]; fillrow <= iupedge[this_depression]; fillrow++)
            {
                for (fillcol = jloedge[this_depression]; fillcol <= jupedge[this_depression]; fillcol++)
                {
                    if (((fillrow) >= 0) && ((fillrow) < nr) && ((fillcol) >= 0) && ((fillcol) < nc) && dtm[fillrow, fillcol] != -9999)
                    {  //bnd
                        if (depression[fillrow, fillcol] == this_depression)
                        {
                            //Debug.WriteLine(" adding "  +(dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol])+" sed to " + fillrow + " "+ fillcol ); 
                            lake_sed_m[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            dtm[fillrow, fillcol] = dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol];
                            dtmchange[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            soildepth_m[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            if (dtm[fillrow, fillcol] == -1) { Debug.WriteLine("C cell " + (fillrow) + " " + (fillcol) + " has an altitude of -1 now"); minimaps(fillrow, fillcol); }
                        }
                    }
                }
            }
            int outletcounter = 0;
            while (drainingoutlet_col[this_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (i = 0; i < outletcounter; i++)
            {
                waterflow_m3[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] += dx * dx * (depressionvolume_m[this_depression]) / outletcounter;
                //we need a rule to determine whether any sediment size stays behind preferentially if we fill a depression. For the moment: no preference
                for (size = 0; size < n_texture_classes; size++)
                {
                    //sediment_in_transport_kg[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] += (depressionsum_sediment_m - needed_to_fill_depression_m) / outletcounter * ;
                    //we need to calculate how much of which fraction there is in transport, and then deposit by weight-ratio (or anything else).                
                }
            }
            //Debug.WriteLine(" Filled depression " + this_depression);
        }

        void leave_depression_alone(int number)  // only updates counters and sentinels
        {
            /*int this_depression = number;
            int leaverow = 0, leavecol = 0;
            //Debug.WriteLine(" leaving depression " + this_depression + " alone");

            for (leaverow = iloedge[this_depression];
            leaverow <= iupedge[this_depression]; leaverow++)
            {
                for (leavecol = jloedge[this_depression]; leavecol <= jupedge[this_depression]; leavecol++)
                {
                    if (((leaverow) >= 0) && ((leaverow) < nr) && ((leavecol) >= 0) && ((leavecol) < nc) && dtm[leaverow, leavecol] != -9999)
                    {  //bnd
                        if (depression[leaverow, leavecol] == this_depression)
                        {
                            considered[leaverow, leavecol] = 1;
                        }
                    }
                }
            }
            int outletcounter = 0;
            while (drainingoutlet_col[this_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (i = 0; i < outletcounter; i++)
            {
                considered[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] = 0;
            }
            //Debug.WriteLine(" Left depression " + this_depression + " alone"); */
        }

        void delta_depression(int number)  // builds deltas in an updated depression (because not enough sed)
        {
            /*When there is not enough sediment to fill the lake, fill the lake from each of its initial side-cells that have a non-zero sediment in transport, excluding outlet cells (their sediment in transport gets moved outside  they will never have to be raised higher than lakelevel which they already have  - they will remain having the lakenumber even when the whole lake would have been filled). 

                c. For each of these cells, while there is sediment in transport /dx left:
                    	Find a potentially lower oblique cell (in the lake, but there are  no others)
                    	Find the first higher oblique cell relative to that cell
                    	Raise the oblique deepest cell to that level
                    	Reduce the remaining amount of sediment in transport with the raised amount
                    	Test whether the cell has now been raised above fillheight, in which case: 
                            it must be lowered to its fillheight, 
                            remaining amount of sed in trans must be increased again
                            lakecell must be removed from the lake (potentially fragmenting the original lake) */

            int active_depression = number, size;
            if (diagnostic_mode == 1 && number > 23) { Debug.WriteLine(" building deltas in depression " + number + " sed needed " + needed_to_fill_depression_m + " sed available " + depressionsum_sediment_m); }
            //else { diagnostic_mode = 0; }

            //if (number == 30001 && t == 1) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }

            for (startrow = iloedge[active_depression]; startrow <= iupedge[active_depression]; startrow++)
            {
                for (startcol = jloedge[active_depression]; startcol <= jupedge[active_depression]; startcol++)
                {
                    if (((startrow) >= 0) && ((startrow) < nr) && ((startcol) >= 0) && ((startcol) < nc) && dtm[startrow, startcol] != -9999)
                    {  //bnd
                        int sediment_present = 0;
                        for (size = 0; size < n_texture_classes; size++)
                        {
                            if (sediment_in_transport_kg[startrow, startcol, size] > 0)
                            { sediment_present = 1; }
                        }
                        if (depression[startrow, startcol] == active_depression && sediment_present == 1)
                        // so, for all cells in the depression that have a non-zero sediment in transport (and EXCLUDING the outlets) 
                        {
                            if (!(drainingoutlet_row[active_depression, 0] == startrow && drainingoutlet_col[active_depression, 0] == startcol) &&
                                !(drainingoutlet_row[active_depression, 1] == startrow && drainingoutlet_col[active_depression, 1] == startcol) &&
                                !(drainingoutlet_row[active_depression, 2] == startrow && drainingoutlet_col[active_depression, 2] == startcol) &&
                                !(drainingoutlet_row[active_depression, 3] == startrow && drainingoutlet_col[active_depression, 3] == startcol) &&
                                !(drainingoutlet_row[active_depression, 4] == startrow && drainingoutlet_col[active_depression, 4] == startcol))
                            {
                                deltasize = 0;
                                dhobliquemax1 = 0;
                                iloradius3 = 1; iupradius3 = 1; jloradius3 = 1; jupradius3 = 1;
                                iloradius2 = 1; iupradius2 = 1; jloradius2 = 1; jupradius2 = 1;
                                rowlowestobnb = startrow; collowestobnb = startcol;
                                if (diagnostic_mode == 1) { Debug.WriteLine(" building a delta from " + startrow + " " + startcol + ", dtm " + dtm[startrow, startcol]); minimaps(startrow, startcol); }
                                double[] local_s_i_t_kg = new double[5] { 0, 0, 0, 0, 0 };
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    local_s_i_t_kg[size] = sediment_in_transport_kg[startrow, startcol, size] / dx;
                                    sediment_in_transport_kg[startrow, startcol, size] = 0;
                                }
                                available_for_delta_m += calc_thickness_from_mass(local_s_i_t_kg, 0, 0);
                                sediment_delta_m += available_for_delta_m;
                                // we will completely use all of this sed in trans now, so let's add it to the overall counter of the volume used in delta's

                                while (available_for_delta_m > 0)
                                {

                                    find_lowest_oblique_neighbour(active_depression);  // to start in the right location with building the delta
                                    // this may be lower in the lake than at the side-cell, at location rowlowestobnb,collowestobnb
                                    depression[rowlowestobnb, collowestobnb] = -active_depression;   // we have found the start of this delta
                                    deltasize = 1;    // therefore we give delta a value of 1
                                    dhobliquemax2 = 99999.99;
                                    II = 0; JJ = 0;
                                    iloradius3 = 1; iupradius3 = 1; jloradius3 = 1; jupradius3 = 1;

                                    while (dhobliquemax2 > 0 && available_for_delta_m > 0)
                                    // starting in the lowest cell, we will now find the lowest higher nb
                                    // we will continue looking for lowest higher nbs as long as we find one and have sediment left
                                    // while doing this, we will raise our delta with us
                                    {
                                        find_lowest_higher_oblique_neighbour(active_depression);

                                        if (dhobliquemax2 < 0)
                                        {   // if we have found a lower neighbour
                                            // leave the current delta and bring the remaining sediment to the lower oblique neighbour
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" lowest oblique neighbour is lower - moving sediment down "); }
                                            cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb);
                                            if (iloradius2 < -(rowlowestobnb + II - startrow)) { iloradius2 = -(rowlowestobnb + II - startrow); }
                                            if (iupradius2 < (rowlowestobnb + II - startrow)) { iupradius2 = (rowlowestobnb + II - startrow); }
                                            if (jloradius2 < -(collowestobnb + JJ - startcol)) { jloradius2 = -(collowestobnb + JJ - startcol); }
                                            if (jupradius2 < (collowestobnb + JJ - startcol)) { jupradius2 = (collowestobnb + JJ - startcol); }
                                            dhobliquemax1 = ((dtm[startrow, startcol] + dz_ero_m[startrow, startcol] + +dz_sed_m[startrow, startcol]) - (dtm[rowlowestobnb + II, collowestobnb + JJ] + dz_ero_m[rowlowestobnb + II, collowestobnb + JJ] + dz_sed_m[rowlowestobnb + II, collowestobnb + JJ]) - (Math.Sqrt((startrow - rowlowestobnb - II) * (startrow - rowlowestobnb - II) + (startcol - collowestobnb - JJ) * (startcol - collowestobnb - JJ)) * dx * tangent_of_delta)) - 0.0000001;
                                        }
                                        if (dhobliquemax2 == 0)
                                        {
                                            // this is not supposed to happen because in this case the search in find_lowest_higher_oblique_nb must go on.
                                            if (diagnostic_mode == 1) { Debug.WriteLine("Warning. Found dhobliquemax = 0 outside of find_lowest_higher_ob_nb"); }
                                        }
                                        if (dhobliquemax2 > 0)
                                        {
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" lowest higher oblique neighbour is higher - raising delta"); }
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" available " + available_for_delta_m + "m and space for " + (deltasize * dhobliquemax2) + " m"); }
                                            if (available_for_delta_m >= deltasize * dhobliquemax2)
                                            {
                                                if (diagnostic_mode == 1) { Debug.WriteLine(" raising delta to higher oblique level "); }
                                                raise_delta_completely(active_depression);
                                            }
                                            else
                                            {
                                                if (diagnostic_mode == 1) { Debug.WriteLine(" raising delta as far as possible given sediment "); }
                                                raise_delta_partly(active_depression);
                                                if (diagnostic_mode == 1) { minimaps(row, col); }
                                                if (obnbchanged == 0) { cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb); }
                                                // if the starting cell was raised above lakelevel, it is no longer member of the lake, and we have taken care of that in raise_delta_partly by changing obnb. 
                                                // this must not be removed, so if obnbchanged != 0, we do not clear the delta.
                                            }

                                        } // end if dhoblmax2 > 0
                                    } // end while dhobliquemax2 > 0
                                } // end while sediment_available
                                cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb);
                            } //end if not outlet 
                        } // end if depressio
                    } // end if boundaries
                } // end for col
            } //end for row 

            // we now divide the total amount of extra water (the amount replaced by sediment in the lake) over the (max 5) outlets.
            int outletcounter = 0;
            while (drainingoutlet_col[active_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (i = 0; i < outletcounter; i++)
            {
                waterflow_m3[drainingoutlet_row[active_depression, i], drainingoutlet_col[active_depression, i]] += dx * dx * (depressionsum_sediment_m) / outletcounter;
            }
            //diagnostic_mode = 1;
        }

        void find_lowest_oblique_neighbour(int this_depression) // to determine where to start or continue with current delta 
        {
            if (t > 300000) { diagnostic_mode = 1; }
            if (diagnostic_mode == 1) { Debug.WriteLine(" entered find_lowest_oblique_neighbour"); }
            // finds the lowest oblique neighbour of the current delta
            // affects (changes) global doubles dhobliquemax1 et al
            //int this_depression = Math.Abs(depression[startrow, startcol]);

            int readysearching = 0;
            while (readysearching == 0)
            {
                readysearching = 1;      // we expect to be ready searching, but when not, we will set this to 0
                if (diagnostic_mode == 1) { Debug.WriteLine(" dhobliquemax1 : " + dhobliquemax1); }
                if (diagnostic_mode == 1) { Debug.WriteLine(" ilo " + iloradius2 + ", iup " + iupradius2 + ", jlo " + jloradius2 + ", jup " + jupradius2 + ", row: " + startrow + ", col " + startcol); }
                for (i = -iloradius2; i <= iupradius2; i++)
                {
                    for (j = -jloradius2; j <= jupradius2; j++)
                    {
                        if ((startrow + i >= 0) && (startrow + i < nr) && (startcol + j >= 0) && (startcol + j < nc) && !((i == 0) && (j == 0)) && dtm[startrow + i, startcol + j] != -9999) //&& !((startrow + i == row) && (startcol + j == col))
                        { // boundary check while looking around startrow startcol for the neighbours of the entire current delta
                            if (diagnostic_mode == 1) { Debug.WriteLine(" oblique neighbour now " + (startrow + i) + " " + (startcol + j) + ", depression " + depression[startrow + i, startcol + j] + " dtm " + (dtm[startrow + i, startcol + j] + dz_ero_m[startrow + i, startcol + j] + dz_sed_m[startrow + i, startcol + j])); }
                            if (depression[startrow + i, startcol + j] == this_depression || depression[startrow + i, startcol + j] == -this_depression)
                            {  // if you are a member of this depression
                                dhoblique = (dtm[startrow, startcol] + dz_ero_m[startrow, startcol] + dz_sed_m[startrow, startcol]) - (dtm[startrow + i, startcol + j] + dz_ero_m[startrow + i, startcol + j] + dz_sed_m[startrow + i, startcol + j]) - (Math.Sqrt((i * i) + (j * j)) * dx * tangent_of_delta);
                                if (diagnostic_mode == 1) { Debug.WriteLine(" oblique neighbour now " + (startrow + i) + " " + (startcol + j) + " :" + dhoblique); }
                                //if (diagnostic_mode == 1) { Debug.WriteLine(" dhobliquemax1 : " + dhobliquemax1); }
                                if ((dhoblique > dhobliquemax1))
                                {      // vanwege afkortinsverschillen 0.000000000 etc 1
                                    dhobliquemax1 = dhoblique;
                                    rowlowestobnb = startrow + i;
                                    collowestobnb = startcol + j;
                                    //deltasize = 1;
                                    if (this_depression > 0)
                                    {
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" lowest oblique neighbour now " + rowlowestobnb + " " + collowestobnb + " dhobliquemax1 : " + dhobliquemax1); }
                                    }
                                    lower_nb_exists = 1;
                                    readysearching = 0;
                                    if (i == -1 * iloradius2) { iloradius2++; }
                                    if (i == iupradius2) { iupradius2++; }
                                    if (j == -1 * jloradius2) { jloradius2++; }
                                    if (j == jupradius2) { jupradius2++; }
                                    if (diagnostic_mode == 1) { Debug.WriteLine(" ilo " + iloradius2 + ", iup " + iupradius2 + ", jlo " + jloradius2 + ", ju2 " + jupradius2); }
                                } // end if dhoblique  < dhobliquemax1)
                                if (dhoblique < 0.0000000001 && dhobliquemax1 < 0.0000000001 && dhoblique > -0.0000000001)
                                { 	// in this case, we may have filled the present neighbour
                                    // in an earlier stage, but have had to clear the delta because
                                    // a lower obnb was found. We must look beyond this equally-high
                                    // oblique nb to be able to find this lower obnb.....
                                    if (diagnostic_mode == 1) { Debug.WriteLine("found previous delta"); }
                                    if (i == -1 * iloradius2) { iloradius2++; readysearching = 0; }
                                    if (i == iupradius2) { iupradius2++; readysearching = 0; }
                                    if (j == -1 * jloradius2) { jloradius2++; readysearching = 0; }
                                    if (j == jupradius2) { jupradius2++; readysearching = 0; }
                                } // end if dhoblique and dhobliquemax1 are zero
                            } // end if depression = depression
                        } // end if boundaries
                    } // end for j
                } // end if
            } // end while readysearching = 0
            if (diagnostic_mode == 1) { Debug.WriteLine(" ready searching - dhobliquemax1: " + dhobliquemax1 + ", dx: " + dx + ", row " + rowlowestobnb + ", col " + collowestobnb); }
        }

        void find_lowest_higher_oblique_neighbour(int here_depression) // to determine to which level (and cell) the current delta can be raised 
        {
            if (t > 1000000) { diagnostic_mode = 1; }
            if (diagnostic_mode == 1) { Debug.WriteLine(" entered find_lowest_higher_oblique_neighbour"); }
            if (diagnostic_mode == 1) { Debug.WriteLine(" rowlow = " + rowlowestobnb + " collow = " + collowestobnb + " range " + iloradius3 + iupradius3 + jloradius3 + jupradius3); }
            if (diagnostic_mode == 1 && rowlowestobnb == 224) { minimaps(rowlowestobnb, collowestobnb); }
            readysearching = 0;
            while (readysearching == 0)
            {
                dhobliquemax2 = 99999.99;
                for (i = -1 * iloradius3; i <= iupradius3; i++)
                {
                    for (j = -1 * jloradius3; j <= jupradius3; j++)
                    {
                        if (((rowlowestobnb + i) >= 0) && ((rowlowestobnb + i) < nr) && ((collowestobnb + j) >= 0) && ((collowestobnb + j) < nc) && !((i == 0) && (j == 0)))
                        { // boundaries
                            if (depression[rowlowestobnb + i, collowestobnb + j] == here_depression)
                            {
                                dhoblique = -((dtm[rowlowestobnb, collowestobnb]) + dz_ero_m[rowlowestobnb, collowestobnb] + dz_sed_m[rowlowestobnb, collowestobnb]) + (dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) + (Math.Sqrt(Math.Pow((rowlowestobnb + i - startrow), 2) + Math.Pow((collowestobnb + j - startcol), 2)) - Math.Sqrt(Math.Pow((rowlowestobnb - startrow), 2) + Math.Pow((collowestobnb - startcol), 2))) * dx * tangent_of_delta;
                                if (dhoblique != 0 && dhoblique < dhobliquemax2)
                                {
                                    readysearching = 1;
                                    dhobliquemax2 = dhoblique;
                                    II = i; JJ = j;
                                    if (diagnostic_mode == 1 && dhobliquemax2 < 0) { Debug.WriteLine("cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " is a lower obnb (dhoblmax2 = " + dhobliquemax2 + ") from " + rowlowestobnb + collowestobnb); }
                                    // 
                                } // end if
                                if (dhoblique < 0.0000000001 && dhoblique > -0.0000000001)
                                { 		//this means we have transferred to a 'new delta' after encountering a negative dhobliquemax2 first,
                                    //then filled this new delta to the point that we are as high as the previous one
                                    // we therefore encounter one or more cells with dhoblique = 0
                                    //we must incorporate these cells into the delta and increase the searchradius
                                    depression[rowlowestobnb + i, collowestobnb + j] = -here_depression;
                                    deltasize++;
                                    readysearching = 0;
                                    if (diagnostic_mode == 1) { Debug.WriteLine("added " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (dhoblique 0.0000) to the delta and will increase searchradius for lowest higher nbour"); }
                                } //end if dhoblmax2 == 0
                            } // end if depression == depression
                        } // end if bndries
                    } // end for j
                } // end for i
                if (readysearching == 0)
                {
                    // If no neighbour within the original radius3 from obnb was member of a lake (which can happen if they were raised to dtm_fill earlier), then 
                    // we will increase the searchradius (there can be another lake cell somewhere, because the lake is not being filled completely).
                    iloradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("ilo is higher"); }
                    iupradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("iup is higher"); }
                    jloradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("jlo is higher"); }
                    jupradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("jup is higher"); }
                    //however, no higher ob nb is necessarily present. The current obnb, and possibly its delta, need not have a lake-neighbour with a higher dhoblique
                    //this is for instance the case when we are currently looking at the last cell in the lake.
                    //In that case, we must fill the current delta as much as possible with the existing sediment. A corresponding dhoblique must be sent back to control.
                    if (rowlowestobnb - iloradius3 <= iloedge[here_depression] && rowlowestobnb + iupradius3 >= iupedge[here_depression] &&
                        collowestobnb - jloradius3 <= jloedge[here_depression] && collowestobnb + jupradius3 >= jupedge[here_depression])
                    {
                        readysearching = 1;
                        dhobliquemax2 = (dtmfill_A[rowlowestobnb, collowestobnb] - (dtm[rowlowestobnb, collowestobnb] + dz_ero_m[rowlowestobnb, collowestobnb] + dz_sed_m[rowlowestobnb, collowestobnb]));
                        if (dhobliquemax2 == 0) { dhobliquemax2 = 1; }//ArT If the dhoblique is zero, because the obnb was the outlet with dtmfill== dtm, then we give an emergency value to dhobliquemax2  
                        if (diagnostic_mode == 1) { Debug.WriteLine(" search for lower ob nb finished - not found - sending dhobliquemax as equal to fillspace of " + dhobliquemax2); }
                    }
                }
            } //end while readysearching == 1
        }

        void raise_delta_completely(int this_depression) // raise delta completely (and then go on raising it to higher obl heights)  
        {
            int size;
            // the amount of sed_in_trans left is enough to raise the entire delta with dhobliquemax1
            if (diagnostic_mode == 1) { Debug.WriteLine(" 2: to be added: " + dhobliquemax2 + ", sed_for_delta: " + available_for_delta_m + "m, deltasize: " + deltasize); }
            if (diagnostic_mode == 1) { Debug.WriteLine(" rowlowestobnb " + rowlowestobnb + " collowestobnb " + collowestobnb + " and " + iloradius3 + iupradius3 + jloradius3 + jupradius3); }
            for (i = -1 * iloradius3; i <= iupradius3; i++)
            {
                for (j = -1 * jloradius3; j <= jupradius3; j++)
                {
                    if (((rowlowestobnb + i) >= 0) && ((rowlowestobnb + i) < nr) && ((collowestobnb + j) >= 0) && ((collowestobnb + j) < nc) && !(rowlowestobnb + i == row && collowestobnb + j == col) && dtm[rowlowestobnb + i, collowestobnb + j] != -9999)
                    { // boundaries, note that i==0 && j==0 is allowed  ;we can raise rowlowestobnb,colloewsobnb when it is part of the delta.
                        if (depression[rowlowestobnb + i, collowestobnb + j] == -this_depression) // i.e. if cell is part of present delta
                        {
                            dtm[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            dtmchange[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            lake_sed_m[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            available_for_delta_m -= dhobliquemax2;
                            if (dtm[rowlowestobnb + i, collowestobnb + j] == -1) { Debug.WriteLine("A1 cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                            if (available_for_delta_m < 0) { Debug.WriteLine(" Error: negative sediment for delta " + available_for_delta_m + " m"); minimaps(rowlowestobnb + i, collowestobnb + j); }
                            if (diagnostic_mode == 1) { Debug.WriteLine(" raised " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " with " + dhobliquemax2 + " to " + (dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) + " sed_for_delta now " + available_for_delta_m); }
                            if (diagnostic_mode == 1 && dhobliquemax2 < 0) { Debug.WriteLine(" warning: dhobliquemax2 is less than zero at " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " " + dhobliquemax2); }
                            //if (diagnostic_mode == 1) { MessageBox.Show("warning - extremely high coarse sed_in_trans:" + sediment_in_transport_kg[startrow, startcol,0]); }
                            if ((dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) > dtmfill_A[rowlowestobnb + i, collowestobnb + j])
                            {   // then we have raised this cell too high
                                if (diagnostic_mode == 1) { Debug.WriteLine("1 we change the too-high altitude of " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (depressionlevel " + depressionlevel[this_depression] + ") from " + dtm[rowlowestobnb + i, collowestobnb + j] + " to " + dtmfill_A[rowlowestobnb + i, collowestobnb + j]); }
                                available_for_delta_m += ((dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) - dtmfill_A[rowlowestobnb + i, collowestobnb + j]);
                                double[] local_s_i_t_kg = new double[5] { 0, 0, 0, 0, 0 };
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    //any sediment in transport that was possibly waiting for consideration later than the current startrow, startcol is taken into this startrow startcol to make a bigger delta here
                                    local_s_i_t_kg[size] = sediment_in_transport_kg[rowlowestobnb + i, collowestobnb + j, size];
                                    sediment_in_transport_kg[rowlowestobnb + i, collowestobnb + j, size] = 0;
                                }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" adding " + calc_thickness_from_mass(local_s_i_t_kg, 0, 0) + " to delta-available " + available_for_delta_m); }
                                available_for_delta_m += calc_thickness_from_mass(local_s_i_t_kg, 0, 0);
                                if (available_for_delta_m < 0) { Debug.WriteLine("5 negative sediment for delta " + available_for_delta_m + " m"); }
                                lake_sed_m[rowlowestobnb + i, collowestobnb + j] += ((dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) - dtmfill_A[rowlowestobnb + i, collowestobnb + j]);
                                dtmchange[rowlowestobnb + i, collowestobnb + j] += ((dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) - dtmfill_A[rowlowestobnb + i, collowestobnb + j]);
                                if (lake_sed_m[rowlowestobnb + i, collowestobnb + j] < -0.0000001) { Debug.WriteLine("1 Warning: negative lake deposition in " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " of " + lake_sed_m[rowlowestobnb + i, collowestobnb + j] + " dtm " + dtm[rowlowestobnb + i, collowestobnb + j] + " fill " + dtmfill_A[rowlowestobnb + i, collowestobnb + j]); minimaps(rowlowestobnb + i, collowestobnb + j); }
                                dtm[rowlowestobnb + i, collowestobnb + j] = dtmfill_A[rowlowestobnb + i, collowestobnb + j] - dz_ero_m[rowlowestobnb + i, collowestobnb + j] - dz_sed_m[rowlowestobnb + i, collowestobnb + j];
                                if (dtm[rowlowestobnb + i, collowestobnb + j] == -1) { Debug.WriteLine("A2 cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                                depression[rowlowestobnb + i, collowestobnb + j] = 0;
                                deltasize--;
                                if (diagnostic_mode == 1) { Debug.WriteLine("1: " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (depressionlevel " + depressionlevel[depression[row, col]] + ") now at " + dtm[rowlowestobnb + i, collowestobnb + j] + " = fill_A " + dtmfill_A[rowlowestobnb + i, collowestobnb + j] + " sed for delta " + available_for_delta_m); }
                                if (diagnostic_mode == 1) { Debug.WriteLine("decreased deltasize with 1 to " + deltasize); }
                            } // end if dtm > depressionlevel
                        }   // end if member of delta
                    }  // end if boundaries
                }  // end for j
            }  // end for i
            if (diagnostic_mode == 1)
            {
                Debug.WriteLine(" raised and now move on to enlarge delta with " + (rowlowestobnb + II) + " " + (collowestobnb + JJ) + " available for delta now " + available_for_delta_m + "m");
                Debug.WriteLine(" by changing " + (rowlowestobnb + II) + "," + (collowestobnb + JJ) + " from " + depression[rowlowestobnb + II, collowestobnb + JJ] + " into " + (-this_depression));
            }
            depression[rowlowestobnb + II, collowestobnb + JJ] = -this_depression;
            deltasize++;
            if (diagnostic_mode == 1) { Debug.WriteLine(" raised deltasize with 1 to " + deltasize + ". " + (rowlowestobnb + II) + " " + (collowestobnb + JJ) + " now negative lakevalue"); }
            //dhobliquemax2 = 0;
            if (II == -iloradius3) { iloradius3++; }
            if (II == iupradius3) { iupradius3++; }
            if (JJ == -jloradius3) { jloradius3++; }
            if (JJ == jupradius3) { jupradius3++; }
        }

        void raise_delta_partly(int this_depression) // raise partly (and then go to new cells on border of lake)  
        {

            int size;
            //Debug.WriteLine( "raising delta partly for dep " + this_depression);
            mem_m = available_for_delta_m / deltasize;
            available_for_delta_m = 0;
            if (diagnostic_mode == 1) { Debug.WriteLine(" 1: to be added: " + mem_m + ", deltasize: " + deltasize); }
            tempx = rowlowestobnb; tempy = collowestobnb;
            obnbchanged = 0;
            for (i = -1 * iloradius3; i <= iupradius3; i++)
            {
                for (j = -1 * jloradius3; j <= jupradius3; j++)
                {
                    if (((tempx + i) >= 0) && ((tempx + i) < nr) && ((tempy + j) >= 0) && ((tempy + j) < nc) && !(tempx + i == row && tempy + j == col) && dtm[tempx + i, tempy + j] != -9999)
                    { // boundaries
                        if (depression[tempx + i, tempy + j] == -this_depression)
                        {
                            dtm[tempx + i, tempy + j] += mem_m;
                            dtmchange[tempx + i, tempy + j] += mem_m;
                            lake_sed_m[tempx + i, tempy + j] += mem_m;
                            if (dtm[rowlowestobnb + i, collowestobnb + j] == -1) { Debug.WriteLine("B cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                            if (lake_sed_m[tempx + i, tempy + j] < -0.0000001) { Debug.WriteLine("4 Warning: negative lake deposition in " + (tempx + i) + " " + (tempy + j) + " of " + lake_sed_m[tempx + i, tempy + j]); minimaps(tempx + i, tempy + j); }
                            if (diagnostic_mode == 1) { Debug.WriteLine(" added " + mem_m + " to cell " + (tempx + i) + " " + (tempy + j)); }
                            if ((dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) > dtmfill_A[tempx + i, tempy + j])
                            {
                                if (diagnostic_mode == 1) { Debug.WriteLine(" cell " + (tempx + i) + " " + (tempy + j) + " raised above filllevel " + dtmfill_A[tempx + i, tempy + j] + ", to " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j])); }
                                available_for_delta_m += ((dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) - dtmfill_A[tempx + i, tempy + j]);
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    local_s_i_t_kg[size] = sediment_in_transport_kg[tempx + i, tempy + j, size];
                                    sediment_in_transport_kg[tempx + i, tempy + j, size] = 0;   //ART recently changed, should solve a bug (this line did not exist, violation mass balance
                                }
                                available_for_delta_m += calc_thickness_from_mass(local_s_i_t_kg, 0, 0);
                                if (available_for_delta_m < 0) { Debug.WriteLine("9 negative sediment in transport (m) remaining for delta " + available_for_delta_m + "m"); }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" A we change the altitude of " + (tempx + i) + " " + (tempy + j) + " (depressionlevel " + depressionlevel[this_depression] + ") from " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) + " to " + dtmfill_A[tempx + i, tempy + j]); }
                                if (tempx + i == row && tempy + j == col) { Debug.WriteLine("we are changing outlet " + tempx + " " + tempy + " into 0"); }
                                lake_sed_m[tempx + i, tempy + j] -= ((dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) - dtmfill_A[tempx + i, tempy + j]);
                                dtmchange[tempx + i, tempy + j] -= ((dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) - dtmfill_A[tempx + i, tempy + j]);
                                if (lake_sed_m[tempx + i, tempy + j] < -0.0000001) { Debug.WriteLine("3 Warning: negative lake deposition in " + (tempx + i) + " " + (tempy + j) + " of " + lake_sed_m[tempx + i, tempy + j] + " alt " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) + " fill " + dtmfill_A[tempx + i, tempy + j]); minimaps(tempx + i, tempy + j); }
                                dtm[tempx + i, tempy + j] = (dtmfill_A[tempx + i, tempy + j] - dz_ero_m[tempx + i, tempy + j] - dz_sed_m[tempx + i, tempy + j]); //so that with ero and sed, it equals dtmfill
                                if (dtm[tempx + i, tempy + j] == -1) { Debug.WriteLine("C cell " + (tempx + i) + " " + (tempy + j) + " has an altitude of -1 now"); minimaps(tempx + i, tempy + j); } //
                                if (diagnostic_mode == 1) { Debug.WriteLine(" will change depressionmembership of " + (tempx + i) + " " + (tempy + j) + " from " + depression[tempx + i, tempy + j] + " to 0"); }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" II = " + II + ", JJ = " + JJ); }
                                depression[tempx + i, tempy + j] = 0;
                                if (diagnostic_mode == 1) { Debug.WriteLine(" obnbchanged? - row " + row + " col " + col + " startrow " + startrow + " startcol " + startcol + " rowobnb " + rowlowestobnb + " colobnb " + collowestobnb + " tempx+i " + (tempx + i) + " tempy+j " + (tempy + j)); }
                                obnbchanged = 1;  // if there is at least one cell that has been raised above dtmfill, then that is the lowest oblique neighbour: the cell with rowlowestobnb, collowestobnb. 
                                // In that case, we must move to a new rowlowestobnb collowestobnb to build the remainder of the delta from there. There is a remainder because some of the sediment used to raise the original
                                // lowest oblique neighbour above dtmfill has been added to available_for_delta again.
                                deltasize--;
                                if (diagnostic_mode == 1) { Debug.WriteLine("decreased deltasize with 1 to " + deltasize); }
                                break;
                            } // end if higher than depressionlevel
                        }  //end if member of delta
                    } // end for boundaries
                } //end for j
            }  // end for i
            if (obnbchanged == 1)
            {
                // this code makes sure that the starting situation for the delta to be built with the remainder of the sediment is correct.
                // this desired situation is: 
                // a) correct amount of sediment (already guaranteed)
                // b) correct cells member of delta (already correct if deltasize > 0, but if deltasize == 0 after removal of the too-high cell, then not correct).
                // c) correct starting cell for delta building (rowlowestobnb and collowestobnb). Not correct because it may be that cell which was just removed from lake and delta. 
                // In case deltasize > 0 and rowlobnb,collobnb is no longer part of the delta, we select any delta-neighbour of the old starting cell.
                // In case deltasize = 0, we select the lowest higher oblique nb for this.
                // Nov 2021: If deltasize = 0, rowlobnb, collownb also is possibly no longer part of the lake. Then what? Then any lake-neighbour of the old starting cell, but we'll need to look harder.

                if (deltasize == 0)
                {
                    if (depression[tempx + II, tempy + JJ] == this_depression)
                    {
                        deltasize++;
                        if (diagnostic_mode == 1) { Debug.WriteLine("increased deltasize with 1 to " + deltasize); }
                        if (diagnostic_mode == 1) { Debug.WriteLine("lowest oblique neighbour now " + rowlowestobnb + " " + collowestobnb + ", will be: " + (tempx + II) + " " + (tempy + JJ)); }
                        rowlowestobnb = tempx + II;
                        collowestobnb = tempy + JJ;
                        if (diagnostic_mode == 1) { Debug.WriteLine(" will change depressionmembership of " + rowlowestobnb + " " + collowestobnb + " from " + depression[rowlowestobnb, collowestobnb] + " to " + (-this_depression)); }
                        depression[rowlowestobnb, collowestobnb] = -this_depression;
                    }
                    else
                    {
                        //we have no delta cells left, but we do have sed_in_trans left. We don't know from where to continue delta-building. We do know from where we started delta building, but that cell may no longer be part of the lake.
                        //we also know that there are at least one lake cells left (because we are in fill_delta_partly here), and that all lake cells are within iupradius3,iloradius3, etc from tempx, tempy
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine("row" + row + "col " + col + " depression " + depression[row, col]);
                            Debug.WriteLine("rowlowestobnb" + rowlowestobnb + "collowestobnb " + collowestobnb + " depression " + depression[rowlowestobnb, collowestobnb]);
                            Debug.WriteLine("tempx" + tempx + "tempy " + tempy + " depression " + depression[tempx, tempy]);
                            Debug.WriteLine("tempx + II" + (tempx + II) + "tempy + JJ " + (tempy + JJ) + " depression " + depression[tempx + II, tempy + JJ]);
                            minimaps(row, col);
                        }
                        bool found_a_delta_starter = false;
                        int tprowlowestobnb = -9999;
                        int tpcollowestobnb = -9999;
                        for (i = -1 * iloradius3; i <= iupradius3; i++)
                        {
                            for (j = -1 * jloradius3; j <= jupradius3; j++)
                            {
                                if (((tempx + i) >= 0) && ((tempx + i) < nr) && ((tempy + j) >= 0) && ((tempy + j) < nc) && !(tempx + i == row && tempy + j == col) && dtm[tempx + i, tempy + j] != -9999)
                                { // boundaries
                                    if (depression[tempx + i, tempy + j] == this_depression)
                                    {
                                        Debug.WriteLine(" found a possible delta-starter in cell" + (tempx + i) + " " + (tempy + j) + " depression " + depression[tempx + i, tempy + j] + " for depression " + this_depression);
                                        found_a_delta_starter = true;
                                        tprowlowestobnb = tempx + i;
                                        tpcollowestobnb = tempy + j;

                                    }
                                }
                            }
                        }
                        if (found_a_delta_starter == true)
                        {
                            depression[tprowlowestobnb, tpcollowestobnb] = -this_depression;
                            rowlowestobnb = tprowlowestobnb;
                            collowestobnb = tpcollowestobnb;
                            deltasize++;
                            if (diagnostic_mode == 1) { Debug.WriteLine("increased deltasize with 1 to " + deltasize); }
                        }
                        else
                        {
                            Debug.WriteLine("did not find an alternative start for this delta  " + deltasize);
                        }

                    }
                }
                if (deltasize > 0 && depression[rowlowestobnb, collowestobnb] != -this_depression)
                {
                    if (depression[rowlowestobnb + 1, collowestobnb + 1] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb + 1, collowestobnb] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; }
                    if (depression[rowlowestobnb + 1, collowestobnb - 1] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; collowestobnb = collowestobnb - 1; }
                    if (depression[rowlowestobnb, collowestobnb + 1] == -this_depression) { collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb, collowestobnb - 1] == -this_depression) { collowestobnb = collowestobnb - 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb + 1] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb - 1] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; collowestobnb = collowestobnb - 1; }
                }
                if (deltasize > 0 && depression[rowlowestobnb, collowestobnb] == -this_depression)
                {
                    //no action needed, just reporting
                    if (diagnostic_mode == 1) { Debug.WriteLine(" no action needed, lowestobnb is part of the delta " + rowlowestobnb + " " + collowestobnb + " lake " + depression[rowlowestobnb, collowestobnb]); }
                }
            }
            if (diagnostic_mode == 1) { Debug.WriteLine(" sed_for_delta is now " + available_for_delta_m + " and deltasize = " + deltasize); }
            //diagnostic_mode = 0;
        }

        #endregion

        #region experimental and maintenance code

        void minimaps(int row, int col)
        {
            int lowerrow, upperrow, lowercol, uppercol, disrow, discol;
            lowerrow = row - 4; if (lowerrow < 0) { lowerrow = 0; }
            upperrow = row + 4; if (upperrow > nr - 1) { upperrow = nr - 1; }
            lowercol = col - 4; if (lowercol < 0) { lowercol = 0; }
            uppercol = col + 4; if (uppercol > nc - 1) { uppercol = nc - 1; }
            string mess;

            // dtm
            Debug.Write(" \n"); Debug.Write("      DEM");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                //Qs = {0:F8}", tomsedi * dx * dx
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D8}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F6}", dtm[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D8}", (disrow + 1)); Debug.Write(mess); }
            }
            /*
            //water flow
            Debug.Write(" \n"); Debug.Write("      Q");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                //Qs = {0:F8}", tomsedi * dx * dx
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D8}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F6}", OFy_m[disrow, discol,0]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D8}", (disrow + 1)); Debug.Write(mess); }
            }
            */
            Debug.Write(" \n"); Debug.Write("SedI_TRA_kg");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", sediment_in_transport_kg[disrow, discol, 0]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("fillheightA_m");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", dtmfill_A[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("dz_ero_m    ");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", dz_ero_m[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write(" DEPRESSION");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:D10}", depression[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("    status");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:D10}", status_map[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }



        }

        private void display_thick(int row, int col)
        {

        }

        private void displaysoil(int row, int col)
        {

            int layer; double cumthick = 0; double depth = 0, z_layer = dtm[row, col];
            //  if (t == 0) { Debug.WriteLine("digitally augering and analysing at row " + row + " col " + col); }//header
            Debug.WriteLine("row col t nlayer cumth(m)  thick(m)  depth(m) z(m) coarse(kg) sand(kg)   silt(kg)   clay(kg)   fine(kg)   YOM(kg)    OOM(kg)   YOM/OOM   w%coarse   w%sand   w%silt   w%clay   w%fineclay BD"); //header


            for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
            {
                //if (layerthickness_m[row, col, layer] > 0)
                //{
                cumthick += layerthickness_m[row, col, layer];
                depth -= layerthickness_m[row, col, layer] / 2;
                double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                try { Debug.WriteLine(row + " " + col + " " + t + " " + layer + " " + cumthick + " " + layerthickness_m[row, col, layer] + " " + depth + " " + z_layer + " " + texture_kg[row, col, layer, 0] + " " + texture_kg[row, col, layer, 1] + " " + texture_kg[row, col, layer, 2] + " " + texture_kg[row, col, layer, 3] + " " + texture_kg[row, col, layer, 4] + " " + young_SOM_kg[row, col, layer] + " " + old_SOM_kg[row, col, layer] + " " + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + " " + texture_kg[row, col, layer, 0] / totalweight + " " + texture_kg[row, col, layer, 1] / totalweight + " " + texture_kg[row, col, layer, 2] / totalweight + " " + texture_kg[row, col, layer, 3] / totalweight + " " + texture_kg[row, col, layer, 4] / totalweight + " " + bulkdensity[row, col, layer]); }
                catch { Debug.WriteLine("Cannot write soilprofile"); }
                depth -= layerthickness_m[row, col, layer] / 2;
                z_layer -= layerthickness_m[row, col, layer];
                //}
            }

            /*if (t < end_time )
            {
                
                for (layer = 0; layer < max_soil_layers; layer++) // all layers
                {
                    if (layerthickness_m[row, col, layer] > 0)
                    {

                        cumthick += layerthickness_m[row, col, layer];
                        double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                        try { Debug.WriteLine(t + " " + cumthick + " " + layerthickness_m[row, col, layer] + " " + texture_kg[row, col, layer, 0] + " " + texture_kg[row, col, layer, 1] + " " + texture_kg[row, col, layer, 2] + " " + texture_kg[row, col, layer, 3] + " " + texture_kg[row, col, layer, 4] + " " + young_SOM_kg[row, col, layer] + " " + old_SOM_kg[row, col, layer] + " " + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + " " + (texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight + " " + texture_kg[row, col, layer, 2] / totalweight + " " + texture_kg[row, col, layer, 1] / totalweight); }
                        catch { Debug.WriteLine("Cannot write soilprofile"); }
                    }
                }
            }*/
            //Debug.WriteLine("");
        }

        bool check_negative_weight(int row, int col)
        {
            bool check = false;
            for (int layer1 = 0; layer1 < max_soil_layers; layer1++)
            {
                for (int tex = 0; tex < 5; tex++)
                {
                    if (texture_kg[row, col, layer1, tex] < 0)
                    {
                        check = true;
                    }
                }
            }
            return (check);
        }

        void calculate_terrain_derivatives()
        {
            //takes the DTM and calculates key derivatives and writes these to ASCII files
            try { dtm_file(dtm_input_filename_textbox.Text); }
            catch { Debug.WriteLine("could not read DEM for derivative calculation"); }

            //declare rasters and memory
            double[,] ledges, nedges, hedges, hhcliff, hlcliff, slhcliff, sllcliff, terruggedindex, ledgeheight;
            int[,] ledgenames;
            terruggedindex = new double[nr, nc];
            ledges = new double[nr, nc];
            nedges = new double[nr, nc];
            hedges = new double[nr, nc];
            hhcliff = new double[nr, nc];
            hlcliff = new double[nr, nc];
            slhcliff = new double[nr, nc];
            sllcliff = new double[nr, nc];
            ledgeheight = new double[nr, nc];
            ledgenames = new int[nr, nc];
            int runner = 0;

            //Topographic Ruggedness Index (Riley, S.J., DeGloria, S.D., Elliot, R., 1999. A terrain ruggedness index that quantifies topographic heterogeneity. Intermt. J. Sci. 5, 2327.)
            double sum_squared_difference = 0; int num_nbs = 0;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            sum_squared_difference = 0;
                            num_nbs = 0;
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    if (!(i == 0 && j == 0) && (row + i) >= 0 && (col + j) >= 0 && (row + i) < nr && (col + j) < nc)
                                    {
                                        if (dtm[row + i, col + j] != -9999)
                                        {
                                            sum_squared_difference += Math.Pow((dtm[row, col] - dtm[row + i, col + j]), 2);
                                            num_nbs++;
                                        }
                                    }
                                }
                            }
                            if (num_nbs == 0) { terruggedindex[row, col] = -9999; }
                            else { terruggedindex[row, col] = Math.Sqrt(sum_squared_difference) * (8 / num_nbs); }
                        }
                    }
                }
                out_double("ruggednessindex.asc", terruggedindex);
                Debug.WriteLine("terrain ruggedness index calculation and storage successfull");
            }
            catch { Debug.WriteLine("terrain ruggedness index calculation or storage failed"); }


            // Properties of possible ledges on the hillslope above and below each cell.
            //We need to ingest ledge positions
            try { read_integer("ledgenames.asc", ledgenames); Debug.WriteLine("ledgenames read successfully"); }
            catch { Debug.WriteLine("ledgenames not found"); }

            //then calculate local properties of the landscape around ledges. We expect that ledge positions may be up to 1 cell wrong.
            double maxcliffheight = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    ledges[row, col] = -9999;
                    nedges[row, col] = -9999;
                    hedges[row, col] = -9999;
                    hhcliff[row, col] = -9999;
                    hlcliff[row, col] = -9999;
                    slhcliff[row, col] = -9999;
                    sllcliff[row, col] = -9999;
                    ledgeheight[row, col] = -9999;
                    if (dtm[row, col] != -9999)
                    {
                        ledges[row, col] = 0;
                        nedges[row, col] = 0;
                        hedges[row, col] = 0;
                        hhcliff[row, col] = 0;
                        hlcliff[row, col] = 0;
                        slhcliff[row, col] = 0;
                        sllcliff[row, col] = 0;
                        ledgeheight[row, col] = 0;
                        if (ledgenames[row, col] != -9999)
                        {
                            try
                            {
                                maxcliffheight = 0;
                                for (i = (-1); i <= 1; i++)
                                {
                                    for (j = (-1); j <= 1; j++)
                                    {
                                        if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                        {
                                            if (dtm[row + i, col + j] != -9999)
                                            {
                                                for (ii = (-1); ii <= 1; ii++)
                                                {
                                                    for (jj = (-1); jj <= 1; jj++)
                                                    {
                                                        if (!(i + ii == 0 && j + jj == 0) && row + i + ii >= 0 && col + j + jj >= 0 && row + i + ii < nr && col + j + jj < nc)
                                                        {
                                                            if (dtm[row + i + ii, col + j + jj] != -9999)
                                                            {
                                                                if (Math.Abs(dtm[row + i + ii, col + j + jj] - dtm[row + i, col + j]) > maxcliffheight) { maxcliffheight = Math.Abs(dtm[row + i + ii, col + j + jj] - dtm[row + i, col + j]); }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                ledgeheight[row, col] = maxcliffheight;
                            }
                            catch { }
                        }
                    }
                }
            }
            Debug.WriteLine("ledgeheights determined");

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        if (ledgeheight[row, col] == -9999)
                        {
                            double highestledgeheight = 0;
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                    {
                                        if (ledgeheight[row + i, col + j] > highestledgeheight)
                                        {
                                            highestledgeheight = ledgeheight[row + i, col + j];
                                        }


                                    }
                                }
                            }
                            ledgeheight[row + i, col + j] = highestledgeheight;
                        }
                    }
                }
            }

            //now, we sort the dtm from high to low and walk through it from high to low to assign ledge properties to 
            comb_sort();
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {     // the index is sorted from low to high values, but flow goes from high to low
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];
                    //Debug.WriteLine("now at row " + row + " col " + col + " alt " + dtm[row, col]);
                    if (ledgenames[row, col] != -9999)
                    {
                        //we are on a ledge. Setting and resetting time
                        hhcliff[row, col] = ledgeheight[row, col];
                        slhcliff[row, col] = hhcliff[row, col] / dx;
                        hedges[row, col]++;
                    }
                    else
                    {
                        double tempslhcliff = 0, steepest = 0, steepness, distance, steepdist = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!(i == 0 && j == 0) && (row + i >= 0) && (col + j >= 0) && (row + i < nr) && (col + j < nc))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        if (dtm[row + i, col + j] > dtm[row, col])
                                        {
                                            if (i == 0 || j == 0) { distance = dx; } else { distance = dx * 1.414; }
                                            steepness = (dtm[row + i, col + j] - dtm[row, col]) / distance;
                                            if (steepness > steepest)
                                            {
                                                //we copy the cliffheight from the steepest neighbour cell
                                                steepdist = distance;
                                                steepest = steepness;
                                                hhcliff[row, col] = hhcliff[row + i, col + j]; tempslhcliff = slhcliff[row + i, col + j];
                                                hedges[row, col] = hedges[row + i, col + j];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        //we now have an updated hhcliff, so we can also update slhcliff
                        slhcliff[row, col] = hhcliff[row, col] / (steepdist + hhcliff[row, col] / tempslhcliff);
                    }
                }
            }
            Debug.WriteLine("downslope variables calculated");

            //now, we walk the other way (from low to high in the DTM). 
            for (runner = 0; runner < number_of_data_cells; runner++)
            {
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];
                    if (ledgenames[row, col] != -9999)
                    {
                        //we are on a ledge. Setting and resetting time
                        hlcliff[row, col] = ledgeheight[row, col];
                        sllcliff[row, col] = hlcliff[row, col] / dx;
                        ledges[row, col]++;
                    }
                    else
                    {
                        double tempsllcliff = 0, steepest = 0, steepness = 0, distance = 0, steepdist = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        if (dtm[row + i, col + j] < dtm[row, col])
                                        {
                                            if (i == 0 || j == 0) { distance = dx; } else { distance = dx * 1.414; }
                                            steepness = -(dtm[row + i, col + j] - dtm[row, col]) / distance;
                                            if (steepness > steepest)
                                            {
                                                //we copy the cliffheight from the steepest neighbour cell
                                                steepdist = distance;
                                                steepest = steepness;
                                                hlcliff[row, col] = hlcliff[row + i, col + j]; tempsllcliff = sllcliff[row + i, col + j];
                                                ledges[row, col] = ledges[row + i, col + j];
                                            }
                                        }


                                    }
                                }
                            }
                        }
                        //we now have an updated hhcliff, so we can also update slhcliff
                        sllcliff[row, col] = hlcliff[row, col] / (steepdist + hlcliff[row, col] / tempsllcliff);
                    }
                }
            }
            Debug.WriteLine("upslope variables calculated");

            //finally, add up ledges and hedges to get nedges
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        nedges[row, col] = ledges[row, col] + hedges[row, col];
                    }
                }
            }

            //now write all these rasters to ascii:
            out_double("ledgeheights.asc", ledgeheight);
            out_double("nedges.asc", nedges);
            out_double("hedges.asc", hedges);
            out_double("ledges.asc", ledges);
            out_double("hhcliff.asc", hhcliff);
            out_double("hlcliff.asc", hlcliff);
            out_double("slhcliff.asc", slhcliff);
            out_double("sllcliff.asc", sllcliff);
            Debug.WriteLine("variables exported to ASCII");
        }
        #endregion

        #region initialisation code

        void initialise_once()        //fills the inputgrids with values
        {

            if (daily_water.Checked && input_data_error == false)
            {
                try
                {
                    filename = this.dailyP.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    // Debug.WriteLine("P_all record created successfully");

                    int namelength = filename.Length;
                    string fn = filename.Substring(0, (namelength - 4));
                    filename = fn + "_sc" + P_scen + ".csv";

                    read_record(filename, P_all);
                    // Debug.WriteLine("P_all read successfully");

                    //filename = this.dailyET0.Text;
                    //if (memory_records_d == false) { makedailyrecords(filename); }
                    //read_record(filename, ET0_all);
                    //Debug.WriteLine("ET0_all read successfully");

                    filename = this.dailyD.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, D_all);
                    // Debug.WriteLine("D_all read successfully");

                    filename = this.dailyT_avg.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tavg_all);
                    // Debug.WriteLine("Tavg_all read successfully");

                    filename = this.dailyT_min.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmin_all);
                    // Debug.WriteLine("Tmin_all read successfully");

                    filename = this.dailyT_max.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmax_all);
                    // Debug.WriteLine("Tmax_all read successfully");

                    //// Hargreaves extraterrestrial radiation
                    //// http://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
                    //double dr, delta, ws;
                    //double lat_st = Math.PI/180*(System.Convert.ToDouble(latitude_deg.Text)+ System.Convert.ToDouble(latitude_min.Text) / 60); // latitude in radians

                    //for (double day_ra = 1; day_ra <= 365; day_ra++)
                    //{
                    //    dr = 1 + 0.033 * Math.Cos(2 * Math.PI * (day_ra / 365)); //inverse relative distance Earth-Sun
                    //    delta = 0.409 * Math.Sin(2 * Math.PI * (day_ra / 365) - 1.39); //solar declination [rad].
                    //    ws = Math.Acos(-Math.Tan(lat_st) * Math.Tan(delta)); // sunset hour angle [rad]
                    //    Ra_ann[Convert.ToInt16(day_ra - 1)] = (24 * 60 / Math.PI * 0.082 * dr * (ws * Math.Sin(lat_st) * Math.Sin(delta) + Math.Cos(lat_st) * Math.Cos(delta) * Math.Sin(ws))) * 0.408; // extraterrestrial radiation [mm d-1]
                    //}

                    Ra_rcm = new double[nr, nc, 12];
                    OFy_m = new double[nr, nc, 10]; // 0: outflow, 1:8 flow to neighbours, 9: inflow
                    Iy = new double[nr, nc];
                    waterfactor = new double[nr, nc];
                    pond_y = new double[nr, nc];
                    outflow_y = new double[nr, nc];
                    total_outflow_y = new double[nr, nc];
                    water_balance_m = new double[nr, nc, 5]; // 1: rainfall, 2: actual ET, 3: runon, 4: runoff, 5: I
                    ETay = new double[nr, nc];
                    ET0y = new double[nr, nc];
                    veg_correction_factor = new double[nr, nc];
                    waterflow_m3 = new double[nr, nc];
                    vegetation_type = new int[nr, nc];

                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            veg_correction_factor[row, col] = 1;
                            vegetation_type[row, col] = 0;
                        }
                    }

                    Ks_topsoil_mh = new double[nr, nc];
                    Ks_md = new double[nr, nc, max_soil_layers];
                    stagdepth = new double[nr, nc];
                    snow_m = 0;
                    snow_start_m = 0;
                    snowfall_m = 0;
                    snowmelt_factor_mTd = Convert.ToDouble(snowmelt_factor_textbox.Text);
                    snow_threshold_C = Convert.ToDouble(snow_threshold_textbox.Text);
                    // snowmelt factor now assumed to be 0.004 m per degree per day, as a mean from the following paper: Hock 2003, https://www.sciencedirect.com/science/article/pii/S0022169403002579#BIB50
                    // DEVELOP I didn't take the correct parameter (DDF instead of Fm, see paper). Change to right parameter based on the paper of Gottlieb, 1980. Other developments are varying melt factors, based on month, incoming radiation etc. (See Hock 2003)
                }
                catch { Debug.WriteLine(" problem preparing for hourly water balance "); }
            }

            if (check_space_soildepth.Checked && input_data_error == false)
            {
                filename = this.soildepth_input_filename_textbox.Text;
                read_double(filename, soildepth_m);
                Debug.WriteLine("read soildepth");
            }
            if (check_space_till_fields.Checked && input_data_error == false)
            {
                filename = this.tillfields_input_filename_textbox.Text;
                read_integer(filename, tillfields);
                Debug.WriteLine("read tillfields");
            }
            if (check_space_landuse.Checked && input_data_error == false)
            {
                filename = this.landuse_input_filename_textbox.Text;
                read_integer(filename, landuse);
                Debug.WriteLine("read landuse");
            }
            if (check_space_evap.Checked && input_data_error == false)
            {
                filename = this.evap_input_filename_textbox.Text;
                read_double(filename, evapotranspiration);
            }
            if (check_space_infil.Checked && input_data_error == false)
            {
                filename = this.infil_input_filename_textbox.Text;
                read_double(filename, infil);
            }
            if (check_space_rain.Checked && input_data_error == false)
            {
                filename = this.rain_input_filename_textbox.Text;
                read_double(filename, rain);
            }
            // If required, read timeseries instead.
            if (check_time_landuse.Checked && input_data_error == false)
            {
                filename = this.landuse_input_filename_textbox.Text;
                read_integer(filename, landuse);
            }
            if (check_time_evap.Checked && input_data_error == false)
            {
                filename = this.evap_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, evap_record);
            }
            if (check_time_infil.Checked && input_data_error == false)
            {
                filename = this.infil_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, infil_record);
            }
            if (check_time_rain.Checked && input_data_error == false)
            {
                filename = this.rain_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, rainfall_record);
            }
            if (check_time_T.Checked && input_data_error == false)
            {
                filename = this.temp_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, temp_record);
            }


            if (check_time_till_fields.Checked && input_data_error == false)
            {
                filename = this.tillfields_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, till_record);
                Debug.WriteLine("Tillage time parameters read");
            }

            try
            {
                // Debug.WriteLine(" assigning starting values for geomorph  ");
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        dz_soil[row, col] = 0;
                        if (Creep_Checkbox.Checked) { sum_creep_grid[row, col] = 0; creep[row, col] = 0; }
                        if (Solifluction_checkbox.Checked) { sum_solifluction[row, col] = 0; }
                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false) { sum_water_erosion[row, col] = 0; total_sed_export = 0; }
                        if (treefall_checkbox.Checked) { dz_treefall[row, col] = 0; treefall_count[row, col] = 0; }
                        if (Biological_weathering_checkbox.Checked) { sum_biological_weathering[row, col] = 0; }
                        if (Frost_weathering_checkbox.Checked) { sum_frost_weathering[row, col] = 0; }
                        if (Tillage_checkbox.Checked) { sum_tillage[row, col] = 0; total_sum_tillage = 0; dz_till_bd[row, col] = 0; }
                        if (Landslide_checkbox.Checked) { sum_landsliding[row, col] = 0; total_sum_tillage = 0; }
                        if (soildepth_m[row, col] < 0.0 && soildepth_m[row, col] != -9999) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                        if (uplift_active_checkbox.Checked) { sum_uplift[row, col] = 0; total_sum_uplift = 0; }
                        if (tilting_active_checkbox.Checked) { sum_tilting[row, col] = 0; total_sum_tilting = 0; }
                        if (check_space_soildepth.Checked != true) { soildepth_m[row, col] = soildepth_value; }
                        if (check_space_till_fields.Checked != true && Tillage_checkbox.Checked)
                        {
                            tillfields[row, col] = 1;

                        }



                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false)
                        {
                            K_fac[row, col] = advection_erodibility; P_fac[row, col] = P_act;
                        } //WVG K_fac matrix initialisation is needed when landuse is disabled

                        if (Water_ero_checkbox.Checked && check_space_landuse.Checked == true)
                        {
                            //currently, this will throw an exception if landuse is actually spatial //development required //ArT
                            if (landuse[row, col] == 1)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 2)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 3)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 4)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 5)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 6)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 7)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 8)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 9)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 10)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Dep_textbox.Text);
                            }
                        }
                    } //for
                } //for
                  // Debug.WriteLine(" assigned starting values for geomorph  ");
                  // Debug.WriteLine("before initialise soil {0}", texture_kg[0, 0, 0, 2]);

                initialise_soil();
                //Debug.WriteLine("after initialise soil {0}", texture_kg[0, 0, 0, 2]);
                if (findnegativetexture())
                {
                    Debug.WriteLine("err_ini1");
                    // Debugger.Break(); 
                }

                // displaysoil(0, 0);
                // Debug.WriteLine("Total catchment mass = " + total_catchment_mass());


                //displaysoil(50, 0);
                //writesoil(0, 0);
            } //try
            catch { Debug.WriteLine(" problem assigning starting values to matrices "); }

            if (fill_sinks_before_checkbox.Checked)
            {
                try
                {
                    findsinks();
                    if (numberofsinks > 0)
                    {
                        searchdepressions();
                        //define_fillheight_new();
                        for (row = 0; row < nr; row++)
                        {
                            for (col = 0; col < nc; col++)
                            {
                                if (dtm[row, col] < dtmfill_A[row, col] && dtm[row, col] != -9999) { 
                                    dtm[row, col] = dtmfill_A[row, col]; 
                                }
                            }
                        }
                    }
                }
                catch { Debug.WriteLine(" problem with sink definition "); }
            }

            // Timeseries preparation
            try
            {
                number_of_outputs = 0;
                if (timeseries.timeseries_cell_waterflow_check.Checked) { timeseries_order[1] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_cell_altitude_check.Checked) { timeseries_order[2] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_net_ero_check.Checked) { timeseries_order[3] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_dep_check.Checked) { timeseries_order[4] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_erosion_check.Checked) { timeseries_order[5] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_waterflow_check.Checked) { timeseries_order[6] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_SDR_check.Checked) { timeseries_order[7] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_average_alt_check.Checked) { timeseries_order[8] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_dep_check.Checked) { timeseries_order[9] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_ero_check.Checked) { timeseries_order[10] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_evap_check.Checked) { timeseries_order[11] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_infil_check.Checked) { timeseries_order[12] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_outflow_check.Checked) { timeseries_order[13] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_rain_check.Checked) { timeseries_order[14] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_phys_weath_checkbox.Checked) { timeseries_order[15] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_chem_weath_checkbox.Checked) { timeseries_order[16] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_formed_checkbox.Checked) { timeseries_order[17] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_eluviated_checkbox.Checked) { timeseries_order[18] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_mass_bioturbed_checkbox.Checked) { timeseries_order[19] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_OM_input_checkbox.Checked) { timeseries_order[20] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_average_soilthickness_checkbox.Checked) { timeseries_order[21] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { timeseries_order[22] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_coarser_checkbox.Checked) { timeseries_order[23] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_soil_depth_checkbox.Checked) { timeseries_order[24] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_soil_mass_checkbox.Checked) { timeseries_order[25] = number_of_outputs; number_of_outputs++; }
            }
            catch { Debug.WriteLine("timeseries preparation was unsuccesful"); }

            //if ((Final_output_checkbox.Checked && t == end_time) || (Regular_output_checkbox.Checked && (t % (int.Parse(Box_years_output.Text)) == 0)))
            //Debug.WriteLine(" successfully ended initialisations  ");
        }

        void initialise_soil_standard()
        {
            double depth_m;
            Debug.WriteLine("initialising soil");
            // At this point, we know the input soildepth at every location (may be zero). 
            // We do not yet know how many layers that corresponds to.
            // If soildepth is not zero, we will calculate the number of layers and assign thicknesses and material to them.
            int soil_layer, texture_class;
            upper_particle_size[0] = Convert.ToDouble(upper_particle_coarse_textbox.Text);
            upper_particle_size[1] = Convert.ToDouble(upper_particle_sand_textbox.Text);
            upper_particle_size[2] = Convert.ToDouble(upper_particle_silt_textbox.Text);
            upper_particle_size[3] = Convert.ToDouble(upper_particle_clay_textbox.Text);
            upper_particle_size[4] = Convert.ToDouble(upper_particle_fine_clay_textbox.Text);
            //calculate bulk density so that we know how much kg of material goes into a layer.  //ART this will go wrong when there are different textures in different locations, but is faster up until that time.
            double coarsefrac = Convert.ToDouble(soildata.coarsebox.Text) / 100;
            double sandfrac = Convert.ToDouble(soildata.sandbox.Text) / 100;
            double siltfrac = Convert.ToDouble(soildata.siltbox.Text) / 100;
            double clayfrac = Convert.ToDouble(soildata.claybox.Text) / 100;
            double fclayfrac = Convert.ToDouble(soildata.fineclaybox.Text) / 100;
            double location_bd;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    depth_m = 0;
                    if (creep_testing.Checked)
                    {
                        coarsefrac = 0;
                        sandfrac = 1;
                        siltfrac = 0;
                        clayfrac = 0;
                        fclayfrac = 0;

                    }

                    if (soildepth_m[row, col] == 0)
                    {

                        for (soil_layer = 0; soil_layer < max_soil_layers; soil_layer++)
                        {
                            for (texture_class = 0; texture_class < n_texture_classes; texture_class++)
                            {
                                texture_kg[row, col, soil_layer, texture_class] = 0;
                            }
                            young_SOM_kg[row, col, soil_layer] = 0;
                            old_SOM_kg[row, col, soil_layer] = 0;
                            bulkdensity[row, col, soil_layer] = 0;
                            layerthickness_m[row, col, soil_layer] = -1;
                        }
                    }
                    else
                    {

                        //now assign thicknesses and material to layer.
                        double available_soildepth = soildepth_m[row, col];
                        soil_layer = 0;
                        while (available_soildepth > 0)
                        {
                            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=10
                            // daarna     min 50    insteek 100  geen max            n=5
                            // If max_soil_layers is smaller than the sum of the perfect layers in each of the three ' packages' , then we simply make the lowest layer very thick.
                            //if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                            /*
                            if (soil_layer < 40 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.05)
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.05;
                                    available_soildepth -= 0.05;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            */
                            if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.05) //
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.05; // 
                                    available_soildepth -= 0.05;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            if (soil_layer > 9 && soil_layer < 20 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.15) // was 0.25
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.15; // was 0.15
                                    available_soildepth -= 0.15;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            if (soil_layer > 19 && soil_layer < max_soil_layers && soil_layer < max_soil_layers - 1) // Rest
                            {
                                if (available_soildepth > 0.5) // was 1
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.5; // was 1
                                    available_soildepth -= 0.5; // was 1
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }

                            if (soil_layer == max_soil_layers - 1)
                            {
                                layerthickness_m[row, col, soil_layer] = available_soildepth;
                                available_soildepth = 0;
                            }

                            if (layerthickness_m[row, col, soil_layer] != 0)
                            {
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                location_bd = bulk_density_calc(coarsefrac, sandfrac, siltfrac, clayfrac, fclayfrac, 0, 0, depth_m);
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                texture_kg[row, col, soil_layer, 0] = location_bd * layerthickness_m[row, col, soil_layer] * coarsefrac * dx * dx;   //  kg = kg/m3 * m * kg/kg * m * m
                                texture_kg[row, col, soil_layer, 1] = location_bd * layerthickness_m[row, col, soil_layer] * sandfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 2] = location_bd * layerthickness_m[row, col, soil_layer] * siltfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 3] = location_bd * layerthickness_m[row, col, soil_layer] * clayfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 4] = location_bd * layerthickness_m[row, col, soil_layer] * fclayfrac * dx * dx;
                                bulkdensity[row, col, soil_layer] = location_bd;

                                if (decalcification_checkbox.Checked)
                                {
                                    CO3_kg[row, col, soil_layer] = (location_bd * layerthickness_m[row, col, soil_layer] * dx * dx) * Convert.ToDouble(ini_CaCO3_content.Text) * 40.08 / (40.08 + 60.01); // calculate total CO3: total mass * fraction of soil * fraction of CaCO3 molecule
                                }

                            }
                            if (creep_testing.Checked)
                            {
                                sandfrac -= 0.05;
                                clayfrac += 0.05;

                                sandfrac = Math.Max(sandfrac, 0);
                                clayfrac = Math.Min(clayfrac, 1);
                            }

                            soil_layer++;

                        } // end availabke soil depth > 0
                    } // end else 

                } // end col
            } // end row
              // Debug.WriteLine("initialised soil");

        }  //keep this code even when it's unreferenced

        void initialise_soil()
        {
            double depth_m;
            //Debug.WriteLine("initialising soil");
            // At this point, we know the input soildepth at every location (may be zero). 
            // We do not yet know how many layers that corresponds to.
            // If soildepth is not zero, we will calculate the number of layers and assign thicknesses and material to them.
            int soil_layer, texture_class;
            upper_particle_size[0] = Convert.ToDouble(upper_particle_coarse_textbox.Text);
            upper_particle_size[1] = Convert.ToDouble(upper_particle_sand_textbox.Text);
            upper_particle_size[2] = Convert.ToDouble(upper_particle_silt_textbox.Text);
            upper_particle_size[3] = Convert.ToDouble(upper_particle_clay_textbox.Text);
            upper_particle_size[4] = Convert.ToDouble(upper_particle_fine_clay_textbox.Text);
            //calculate bulk density so that we know how much kg of material goes into a layer.  //ART this will go wrong when there are different textures in different locations, but is faster up until that time.
            double coarsefrac = Convert.ToDouble(soildata.coarsebox.Text) / 100;
            double sandfrac = Convert.ToDouble(soildata.sandbox.Text) / 100;
            double siltfrac = Convert.ToDouble(soildata.siltbox.Text) / 100;
            double clayfrac = Convert.ToDouble(soildata.claybox.Text) / 100;
            double fclayfrac = Convert.ToDouble(soildata.fineclaybox.Text) / 100;
            double location_bd;
            double dz_standard = 0.1;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    depth_m = 0;
                    if (creep_testing.Checked)
                    {
                        coarsefrac = 0;
                        sandfrac = 1;
                        siltfrac = 0;
                        clayfrac = 0;
                        fclayfrac = 0;

                    }

                    if (soildepth_m[row, col] == 0)
                    {

                        for (soil_layer = 0; soil_layer < max_soil_layers; soil_layer++)
                        {
                            for (texture_class = 0; texture_class < n_texture_classes; texture_class++)
                            {
                                texture_kg[row, col, soil_layer, texture_class] = 0;
                            }
                            young_SOM_kg[row, col, soil_layer] = 0;
                            old_SOM_kg[row, col, soil_layer] = 0;
                            bulkdensity[row, col, soil_layer] = 0;
                            layerthickness_m[row, col, soil_layer] = -1;
                        }
                    }
                    else
                    {
                        //now assign thicknesses and material to layer.
                        double available_soildepth = soildepth_m[row, col];
                        soil_layer = 0;
                        while (available_soildepth > 0)
                        {
                            //first time around, depth_m = 0 here, and then gets larger with increasing assigned soildepth.

                            if (available_soildepth > dz_standard)
                            {
                                layerthickness_m[row, col, soil_layer] = dz_standard;
                                available_soildepth -= dz_standard;
                            }
                            else
                            {
                                layerthickness_m[row, col, soil_layer] = available_soildepth;
                                available_soildepth = 0;
                            }

                            if (soil_layer == max_soil_layers - 1)
                            {
                                layerthickness_m[row, col, soil_layer] = available_soildepth;
                                available_soildepth = 0;
                            }

                            //now limit layerthicknes to hardlayer limitations if needed
                            if (blocks_active==1) {
                                if (dtm[row, col] >= hardlayerelevation_m)
                                {
                                    double currentdepth = (dtm[row, col] - depth_m - layerthickness_m[row, col, soil_layer]);
                                    if (currentdepth < hardlayerelevation_m && currentdepth > (hardlayerelevation_m - hardlayerthickness_m))
                                    {
                                        layerthickness_m[row, col, soil_layer] = (dtm[row, col] - depth_m) - hardlayerelevation_m;
                                        //Debug.WriteLine(" limited layerthickness and soildepth to account for proximity of hardlayer  in " + row + " " + col);
                                        //Debug.WriteLine(" hardlayerelevation_m " + hardlayerelevation_m + ", " + ((dtm[row, col] - depth_m) - hardlayerelevation_m) + " under the top of this layer");
                                        //Debug.WriteLine(" dtm " + dtm[row, col] + " currentdepth " + currentdepth + " available_soildepth " + available_soildepth + " depth_m " + depth_m);
                                        //Debug.WriteLine(" adapted layerthickness is " + layerthickness_m[row, col, soil_layer]);
                                        available_soildepth = 0;

                                        //this ensures that soils stay thinner on top of hardlayers, and don't continue under them.
                                    }
                                }
                            }

                            if (layerthickness_m[row, col, soil_layer] != 0)
                            {
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                location_bd = bulk_density_calc(coarsefrac, sandfrac, siltfrac, clayfrac, fclayfrac, 0, 0, depth_m);
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                texture_kg[row, col, soil_layer, 0] = location_bd * layerthickness_m[row, col, soil_layer] * coarsefrac * dx * dx;   //  kg = kg/m3 * m * kg/kg * m * m
                                texture_kg[row, col, soil_layer, 1] = location_bd * layerthickness_m[row, col, soil_layer] * sandfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 2] = location_bd * layerthickness_m[row, col, soil_layer] * siltfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 3] = location_bd * layerthickness_m[row, col, soil_layer] * clayfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 4] = location_bd * layerthickness_m[row, col, soil_layer] * fclayfrac * dx * dx;
                                bulkdensity[row, col, soil_layer] = location_bd;

                                if (decalcification_checkbox.Checked)
                                {
                                    CO3_kg[row, col, soil_layer] = (location_bd * layerthickness_m[row, col, soil_layer] * dx * dx) * Convert.ToDouble(ini_CaCO3_content.Text) * 40.08 / (40.08 + 60.01); // calculate total CO3: total mass * fraction of soil * fraction of CaCO3 molecule
                                }

                            }
                            if (creep_testing.Checked)
                            {
                                sandfrac -= 0.05;
                                clayfrac += 0.05;

                                sandfrac = Math.Max(sandfrac, 0);
                                clayfrac = Math.Min(clayfrac, 1);
                            }

                            soil_layer++;

                        } // end available soil depth > 0
                    } // end else 
                    soildepth_m[row, col] = total_soil_thickness(row, col);

                } // end col
            } // end row
            //Debug.WriteLine("initialised soil");

        } // anngepast voor standaard diktes

        void initialise_every_till()
        {
            if (check_time_till_fields.Checked && check_space_till_fields.Checked == false)
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        tillfields[row, col] = 1 * till_record[t];
                    }
                }

            }
        }

        void initialise_every()                         //fills the inputgrids with values
        {
            int corrected_t;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    // time runs from 1 to end_time - compensate for that when taking values from records
                    // also compensate for records shorter than end_time
                    if (check_time_rain.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > rainfall_record.Length) { corrected_t -= rainfall_record.Length; }

                        rain_value_m = 0.001 * rainfall_record[corrected_t]; //from mm (in record) to m (LORICA)   // mvdm -1 weggehaald van corrected_t, leidde tot OutOfRange errors
                                                                             // changed rain[row, col] to rain_value_m, due to errors, this is not spatial, but temporal variation
                                                                             //this should be improved for when rainfall is not also spatially variable //ArT
                    }
                    if (check_time_infil.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > infil_record.Length) { corrected_t -= infil_record.Length; }
                        infil_value_m = 0.001 * infil_record[corrected_t];
                    }
                    if (check_time_evap.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > evap_record.Length) { corrected_t -= evap_record.Length; }
                        evap_value_m = 0.001 * evap_record[corrected_t];
                    }

                    if (check_time_T.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > temp_record.Length) { corrected_t -= temp_record.Length; }

                        rain_value_m = 0.001 * temp_record[corrected_t]; //from mm (in record) to m (LORICA)   // mvdm -1 weggehaald van corrected_t, leidde tot OutOfRange errors
                        temp_value_C = temp_record[corrected_t];
                        // changed rain[row, col] to rain_value_m, due to errors, this is not spatial, but temporal variation
                        //this should be improved for when rainfall is not also spatially variable //ArT
                    }




                    if (annual_output_checkbox.Checked)
                    {
                        dz_soil[row, col] = 0;
                        if (Creep_Checkbox.Checked) { sum_creep_grid[row, col] = 0; creep[row, col] = 0; }
                        if (treefall_checkbox.Checked) { dz_treefall[row, col] = 0; treefall_count[row, col] = 0; }
                        if (Solifluction_checkbox.Checked) { sum_solifluction[row, col] = 0; }
                        if (Water_ero_checkbox.Checked) { sum_water_erosion[row, col] = 0; }
                        if (Biological_weathering_checkbox.Checked) { sum_biological_weathering[row, col] = 0; }
                        if (Frost_weathering_checkbox.Checked) { sum_frost_weathering[row, col] = 0; }
                        if (Tillage_checkbox.Checked) { sum_tillage[row, col] = 0; total_sum_tillage = 0; }
                        if (soildepth_m[row, col] < 0.0) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                    }
                    if (soildepth_m[row, col] < 0.0) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                    if (Water_ero_checkbox.Checked) { waterflow_m3[row, col] = 0.0; }

                } //for
            } //for

            if (fill_sinks_during_checkbox.Checked)
            {
                findsinks();
                if (numberofsinks > 0)
                {
                    searchdepressions();
                    //define_fillheight_new();
                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            if (dtm[row, col] < dtmfill_A[row, col] && dtm[row, col] != -9999) {
                                dtmchange[row, col] += dtmfill_A[row, col] - dtm[row, col];
                                dtm[row, col] = dtmfill_A[row, col]; 
                            
                            }
                        }
                    }
                }
            }
            //Debug.WriteLine("initialised every");
        }

        #endregion

        #region Hydrology code

        int[] P_all, ET0_all, Tavg_all, Tmin_all, Tmax_all, D_all;
        double[] Py = new double[365], ET0_m = new double[12];
        int[] Tavgy = new int[365], Tminy = new int[365], Tmaxy = new int[365], Dy = new int[365];
        // int[] D_all = new int[123], Dy = new int[365];
        double[,,] OFy_m, Ks_md, water_balance_m, Ra_rcm;
        double[,] Iy, ROy, Ks_topsoil_mh, pond_d, pond_y, outflow_y, stagdepth, waterfactor, total_outflow_y, ETay, ET0y;
        int[] month = new int[12] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
        int[] monthcum = new int[12] { 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
        int[] midmonthdays = new int[] { 16, 46, 75, 106, 136, 167, 197, 228, 259, 289, 320, 350 };
        double Ks_min_mh, Ks_max_mh, snow_m, snow_start_m, snowfall_m, snowmelt_factor_mTd, snow_threshold_C, Pduringsnowmelt; // snow thickness is now constant in space. develop: spatially varying effects of snowfall. snowmelt factor in m T-1 d-1
                                                                                                                               // snowmelt modeling in Hock, 2003, Eq. 2: https://www.sciencedirect.com/science/article/pii/S0022169403002579#BIB50
                                                                                                                               // read data into P_all  etc
        DateTime ponding_start;

        double local_solar_radiation(double slope_rad, double aspect_rad, int month)
        {
            //Debug.WriteLine("lsr1");
            // SOURCE: Swift 1976: Algorithm for solar radiation on mountain slopes
            // https://doi.org/10.1029/WR012i001p00108
            double lat_rad, L1_Ra, L2_Ra, D1_Ra, D_Ra, E_Ra, R0_Ra, R1_Ra, R4_Ra, T_Ra, T7_Ra, T6_Ra, T3_Ra, T2_Ra, T1_Ra, T0_Ra, acos_in;

            R0_Ra = 1.95 * 0.041868; // Convert from cal/cm2/min to MJ/m2/min
            lat_rad = Math.PI / 180 * (System.Convert.ToDouble(latitude_deg.Text) + System.Convert.ToDouble(latitude_min.Text) / 60); // latitude [rad]
            L1_Ra = Math.Asin(Math.Cos(slope_rad) * Math.Sin(lat_rad) + Math.Sin(slope_rad) * Math.Cos(lat_rad) * Math.Cos(aspect_rad)); // equivalent latitude [rad]
            D1_Ra = Math.Cos(slope_rad) * Math.Cos(lat_rad) - Math.Sin(slope_rad) * Math.Sin(lat_rad) * Math.Cos(aspect_rad);
            if (D1_Ra == 0) { D1_Ra = 1E-10; }
            L2_Ra = Math.Atan(Math.Sin(slope_rad) * Math.Sin(aspect_rad) / D1_Ra);
            if (D1_Ra < 0) { L2_Ra += Math.PI; }

            int day_Ra = midmonthdays[month];

            D_Ra = 0.4 * Math.PI / 180 - 23.3 * Math.PI / 180 * Math.Cos((day_Ra + 10) * Math.PI / 180 * 0.986);
            E_Ra = 1 - 0.0167 * Math.Cos((day_Ra - 3) * Math.PI / 180 * 0.986);
            R1_Ra = 60 * R0_Ra / (E_Ra * E_Ra);

            acos_in = -Math.Tan(L1_Ra) * Math.Tan(D_Ra);
            if (acos_in > 1) { acos_in = 1; }
            T_Ra = Math.Acos(acos_in);
            T7_Ra = T_Ra - L2_Ra;
            T6_Ra = -T_Ra - L2_Ra;

            acos_in = -Math.Tan(lat_rad) * Math.Tan(D_Ra);
            if (acos_in > 1) { acos_in = 1; }
            T_Ra = Math.Acos(acos_in);
            T1_Ra = T_Ra;
            T0_Ra = -T_Ra;
            if (T7_Ra < T1_Ra) { T3_Ra = T7_Ra; } else { T3_Ra = T1_Ra; }
            if (T6_Ra > T0_Ra) { T2_Ra = T6_Ra; } else { T2_Ra = T0_Ra; }

            R4_Ra = R1_Ra * (Math.Sin(D_Ra) * Math.Sin(L1_Ra) * (T3_Ra - T2_Ra) * 12 / Math.PI + Math.Cos(D_Ra) * Math.Cos(L1_Ra) * (Math.Sin(T3_Ra + L2_Ra) - Math.Sin(T2_Ra + L2_Ra)) * 12 / Math.PI);
            //Debug.WriteLine("lsr2");
            if (R4_Ra < 0)
            {
                Debug.WriteLine("err_lsr1");
            }
            return (R4_Ra * 0.408 / 1000); // convert to m/d
        }

        void update_solar_radiation()
        {
            if (t % 100 == 0)
            {
                update_slope_and_aspect(); // updates slopemap slopeAnalysis [rad] and aspect [rad]
            }

            for (int hrow = 0; hrow < nr; hrow++)
            {
                for (int hcol = 0; hcol < nc; hcol++)
                {
                    if (dtm[hrow, hcol] != -9999)
                    {
                        for (int mo = 0; mo < 12; mo++)
                        {
                            //Debug.WriteLine("sr1");
                            // Fill 3D matrix with local monthly ET
                            Ra_rcm[hrow, hcol, mo] = local_solar_radiation(slopeAnalysis[hrow, hcol], aspect[hrow, hcol], mo);
                            //Debug.WriteLine("sr2");
                        }

                    }
                }
            }
        }

        double total_snow_melt, total_water_flow;
        void water_balance()
        {
            // Debug.WriteLine("wb1");
            total_water_flow = 0;
            if (t % 100 == 0)
            {
                update_solar_radiation();
            }
            Pduringsnowmelt = 0;

            total_snow_melt = 0;
            snow_start_m = snow_m;
            snowfall_m = 0;
            create_daily_weather(); // Calculate daily weather variables

            // Create yearly matrices for infiltration and overland flow
            // Debug.WriteLine("wb2");
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    pond_y[row, col] = 0;
                    outflow_y[row, col] = 0;
                    waterfactor[row, col] = 1;
                    total_outflow_y[row, col] = 0;
                    ETay[row, col] = 0;
                    ET0y[row, col] = 0;
                    Iy[row, col] = 0;
                    for (int dir = 0; dir < 10; dir++)
                    {
                        OFy_m[row, col, dir] = 0;
                    }
                }
            }
            comb_sort();

            double P_OF, snowmelt_m = 0;
            // Debug.WriteLine("wb3");
            if (t % 10 == 0) { update_Ks(); }

            // Debug.WriteLine("wb4");
            int daycount = 0;
            for (int mo = 0; mo < 12; mo++)
            {
                // create monthly timeseries
                double[] Pm = new double[month[mo]];
                int[] Dm = new int[month[mo]], Tavgm = new int[month[mo]];
                P_OF = 0;
                Array.Copy(Py, daycount, Pm, 0, month[mo]);
                Array.Copy(Dy, daycount, Dm, 0, month[mo]);
                Array.Copy(Tavgy, daycount, Tavgm, 0, month[mo]);
                ;
                // daily overland flow
                snow_threshold_C = 0;
                for (int day = 0; day < month[mo]; day++)
                {
                    if (Tavgm[day] <= snow_threshold_C) // temperature below 0, all rain falls as snow
                    {
                        if (Pm[day] > 0)
                        {
                            // Debug.WriteLine("snowfall");
                            snowfall_m += Pm[day];
                            snow_m += Pm[day];
                            P_OF += Pm[day];
                        }
                    }
                    else // T above 0, snow can melt and is all added to runoff. 
                    {
                        if (snow_m > 0) // Snow present
                        {
                            Pduringsnowmelt += Pm[day];
                            snowmelt_m = snowmelt_factor_mTd * (Tavgm[day] - snow_threshold_C);
                            if (snowmelt_m > snow_m) { snowmelt_m = snow_m; }
                            snow_m -= snowmelt_m;
                            total_snow_melt += snowmelt_m;
                            // Debug.WriteLine("t {0}, m {1} d {2} snowmelt {3} m", t,mo, day,snowmelt_m);
                            dailyflow(Pm[day], Dm[day], day, mo, snowmelt_m); // all snowmelt (+extra rain) becomes overland flow
                            P_OF += Pm[day];

                        }
                        else // no snow cover, rainfall intensity is used as threshold
                        {
                            if (Pm[day] > (Ks_min_mh * Dm[day]) && Dm[day] != 0) // develop. If rainfall is also spatially variable, this has to be adjusted
                            {
                                // Debug.WriteLine("wb4a");
                                //Debug.WriteLine("Overland flow initiated at date {0}/{1}/{2}", day, mo, t);
                                dailyflow(Pm[day], Dm[day], day, mo, 0);
                                P_OF += Pm[day];
                            }
                        }

                        if (snow_m < 0)
                        {
                            Debug.WriteLine("err_sno1");
                        }
                    }
                }

                //if (Pm.Sum() < P_OF) { MessageBox.Show("Pd > P"); }
                // Monthly water balance
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double ET0m_act = ET0_m[mo] * Ra_rcm[row, col, mo] * veg_correction_factor[row, col];
                            // if (row == 0 & col == 0) { Debug.WriteLine(ET0m_act); }
                            ET0y[row, col] += ET0m_act;
                            double ETam = Pm.Sum() / Math.Pow(1 + Math.Pow(Pm.Sum() / (ET0m_act), 1.5), (1 / 1.5));

                            ETay[row, col] += ETam;

                            Iy[row, col] += (Pm.Sum() - P_OF) - ETam; // overland flow has been dealt with earlier (dailyflow), just as ponding
                            if (double.IsNaN(Iy[row, col]))
                            {
                                Debug.WriteLine("err wb1");
                            }
                        }
                    }
                }
                // Debugger.Break();

                daycount += month[mo];
            } // end months

            // yearly update infiltration

            bool Ineg = false;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (Iy[row, col] < 0)
                    {
                        Ineg = true;
                    }
                }
            }
            if (Ineg)
            {
                ;
            }
            //if (t % 10 == 0) { Debugger.Break(); }
            // Debug.WriteLine("wb6");
        }

        void print_water_balance()
        {
            double P_wb = 0, ETa_wb = 0, I_wb = 0, OutF_wb = 0, snow_wb = 0, snow_left = 0, snow_start = 0, OFy_0 = 0, OFy_9 = 0;
            for (int rowb = 0; rowb < nr; rowb++)
            {
                for (int colb = 0; colb < nc; colb++)
                {
                    if (dtm[rowb, colb] != -9999)
                    {
                        P_wb += Py.Sum();
                        ETa_wb += ETay[rowb, colb];
                        I_wb += Iy[rowb, colb];
                        OutF_wb += total_outflow_y[rowb, colb];
                        snow_wb += snowfall_m;
                        snow_start += snow_start_m;
                        snow_left += snow_m;
                        OFy_0 += OFy_m[row, col, 0];
                        OFy_9 += OFy_m[row, col, 9];
                    }

                }
            }
            double balance = P_wb - ETa_wb - I_wb - OutF_wb;
            Debug.WriteLine("Snow start: {0}, snow end: {1}, P during snow: {2}", snow_start, snow_left, Pduringsnowmelt * nr * nc);
            Debug.WriteLine("Annual water balance");
            Debug.WriteLine("P: {0}, of which snowfall: {1}.  ETa: {2}. I: {3}. Outflow: {4}. Balance: {5}. OFy_0: {6}, OFy_9: {7}", P_wb, snow_wb, ETa_wb, I_wb, OutF_wb, balance, OFy_0, OFy_9);
            if (double.IsNaN(I_wb))
            {
                Debug.WriteLine("err_pwb1");
            }
            if (Math.Abs(balance + snow_start - snow_left) > 0.00000001)
            {
                Debug.WriteLine("err_pwb2");
            }
        }

        void print_spatial_water_balance()
        {
            for (int rowb = 0; rowb < nr; rowb++)
            {
                for (int colb = 0; colb < nc; colb++)
                {
                    Debug.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}", rowb, colb, t, Py.Sum(), ETay[rowb, colb], OFy_m[rowb, colb, 0] - OFy_m[rowb, colb, 9], Iy[rowb, colb], (Py.Sum() - ETay[rowb, colb] - Iy[rowb, colb]), snow_m, snow_start_m, snowfall_m, total_outflow_y[rowb, colb], Pduringsnowmelt);
                    // snowfall_m is part of Py.Sum(), therefore, this should not be accounted for in the balance. Important terms are P, ETa, I and outflow. They close the balance. 
                }
            }
        }

        void print_P_ET0()
        {
            double ET_out = 0;
            double count = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    ET_out += ET0y[row, col];
                    count += 1;

                }
            }
            Debug.WriteLine("P {0} ET0 {1}", Py.Sum(), ET_out / count);
        }

        void update_potential_ET()
        {
            for (int hrow = 0; hrow < nr; hrow++)
            {
                for (int hcol = 0; hcol < nc; hcol++)
                {

                }
            }
        }

        void update_Ks() // both Ks matrix as Ks for topsoil
        {
            double[] tex_topsoil;
            double depth, fsilt, fclay, fOM, BD_t, slope_rad;
            int lay;
            Ks_min_mh = 1000; Ks_max_mh = 0;
            List<double> BD_topsoil;


            // Debug.WriteLine("uks1");
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    BD_topsoil = new List<double>();
                    depth = 0;
                    tex_topsoil = new double[7];
                    lay = 0;
                    if (total_soil_mass(row, col) > 0)
                    {
                        while (depth <= 0.5 & lay < max_soil_layers)
                        {
                            // if (lay == max_soil_layers) { Debugger.Break(); }
                            if (total_layer_mass(row, col, lay) > 0)
                            {
                                depth += layerthickness_m[row, col, lay] / 2;

                                for (int text = 0; text < 5; text++)
                                {
                                    tex_topsoil[text] += texture_kg[row, col, lay, text];
                                }
                                tex_topsoil[5] += young_SOM_kg[row, col, lay];
                                tex_topsoil[5] += old_SOM_kg[row, col, lay];

                                BD_topsoil.Add(bulk_density_calc(texture_kg[row, col, lay, 0], texture_kg[row, col, lay, 1], texture_kg[row, col, lay, 2], texture_kg[row, col, lay, 3], texture_kg[row, col, lay, 4], old_SOM_kg[row, col, lay], young_SOM_kg[row, col, lay], depth));
                                depth += layerthickness_m[row, col, lay] / 2;

                            }
                            lay += 1;
                        }

                        fsilt = 100 * tex_topsoil[2] / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4]); // only fine fraction
                        fclay = 100 * (tex_topsoil[3] + tex_topsoil[4]) / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4]); // only fine fraction
                        fOM = 100 * tex_topsoil[5] / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4] + tex_topsoil[5]); // only fine fraction
                        BD_t = BD_topsoil.Average() / 1000;
                        slope_rad = calc_slope_stdesc(row, col);
                        double slope_test = Math.Cos(slope_rad);

                        // Debug.WriteLine("uks3a");
                        Ks_topsoil_mh[row, col] = (Ks_wosten(fsilt, fclay, fOM, BD_t, 1) / 24) * Math.Cos(slope_rad);
                    }
                    else
                    {
                        Ks_topsoil_mh[row, col] = 0;
                        Debug.WriteLine("Empty soil at row {0}, col {1}, t {2}", row, col, t);
                    }

                    if (double.IsNaN(Ks_topsoil_mh[row, col]))
                    {
                        Debug.WriteLine("err_kst1");
                    }
                    // Debug.WriteLine("uks4");


                    //  Ks_topsoil_mh[row, col] *= veg_lag_factor;
                    // Ks_update
                    if (Ks_min_mh > Ks_topsoil_mh[row, col]) { Ks_min_mh = Ks_topsoil_mh[row, col]; }
                    if (Ks_max_mh < Ks_topsoil_mh[row, col]) { Ks_max_mh = Ks_topsoil_mh[row, col]; }
                    // Debug.WriteLine("uks5");
                }
            }
            ;
        }

        void create_daily_weather()
        {
            //Debug.WriteLine("dw.start");
            // 1. Select yearly timeseries and the corrected temperatures

            double P_ann = rain_value_m;
            int T_ann = temp_value_C;

            Random year_w = new Random(t); // t as random seed to get deterministic results
            int n_timeseries = year_w.Next(0, System.Convert.ToInt32(daily_n.Text));
            // n_timeseries = 5;

            //Debug.WriteLine("dw.1c");
            Array.Copy(Tmin_all, 365 * (n_timeseries), Tminy, 0, 365); // read new Tmin timeseries
            Array.Copy(Tmax_all, 365 * (n_timeseries), Tmaxy, 0, 365); // read new Tmin timeseries
            Array.Copy(Tavg_all, 365 * (n_timeseries), Tavgy, 0, 365); // read new Tmin timeseries

            Array.Copy(P_all, 365 * (n_timeseries), Py, 0, 365); // read new P timeseries
            Array.Copy(D_all, 365 * (n_timeseries), Dy, 0, 365); // read new D timeseries
            for (int pi = 0; pi < 365; pi++)
            {
                Py[pi] /= 1000; // convert to meters
                                // if (Py[pi] > 0.036) { Debugger.Break(); }
            }

            // 2. Rescale rainfall and temperature
            //Debug.WriteLine("dw.1a");

            if (check_scaling_daily_weather.Checked) // scaling with yearly values, for global change scenarios
            {
                double Py_sum = Py.Sum();
                for (int pi = 0; pi < Py.Count(); pi++) { Py[pi] = Py[pi] / Py_sum * P_ann; } // Scale with yearly P in meters
                double total_P = Py.Sum();

                int d_T = T_ann - Convert.ToInt32(Tavgy.Average());
                for (int pi = 0; pi < Tavgy.Count(); pi++)
                {
                    Tminy[pi] += d_T;
                    Tmaxy[pi] += d_T;
                    Tavgy[pi] += d_T;
                }
            }


            // 3. Calculate PET according to Hargreaves https://www.repository.utl.pt/bitstream/10400.5/4250/1/REP-J.L.Teixeira-InTech-Hargreaves_and_other_reduced_set_methods_for_calculating_evapotranspiration.pdf
            // Use monthly T values, gives a result very similar to daily values
            // multiplication with extraterrestrial radiation occurs in a later step, when ET0_m is actually necessary (water balance). Here we capture the monthly variation. At the later step, the spatiotemporal differences in solar radiation are captured
            int[] Tminm, Tmaxm, Tavgm;
            int daycount = 0;
            for (int pi = 0; pi < 12; pi++)
            {
                Tminm = new int[month[pi]];
                Tmaxm = new int[month[pi]];
                Tavgm = new int[month[pi]];

                Array.Copy(Tminy, daycount, Tminm, 0, month[pi]);
                Array.Copy(Tmaxy, daycount, Tmaxm, 0, month[pi]);
                Array.Copy(Tavgy, daycount, Tavgm, 0, month[pi]);

                daycount += month[pi];
                //get temperature info
                ET0_m[pi] = 0.0023 * (Tavgm.Average() + 17.78) * Math.Sqrt(Tmaxm.Average() - Tminm.Average()) * month[pi]; // multiply value by number of days in the month, to get the monthly total
                if (ET0_m[pi] < 0) { ET0_m[pi] = 0; }

            }


            //Debug.WriteLine("dw.end"); 
        }

        void dailyflow(double P_total, double D_total, int qday, int qmonth, double snowmelt)
        {
            // Debug.WriteLine("df1");
            /*
            Check:
            -is all water flow reset after first iteration?
            -do dtm and ponding values correspond well?
            -is the water balance closing?
            -do all cells refer to OFd[r,c,0] as flow component? rainfall and overland flow
            -link infiltration to differences in Ks (negative Ks) !!!
             */

            pond_d = new double[nr, nc];
            double[,] currentflow = new double[nr, nc];
            // Debug.WriteLine("df1");
            //every cell, inflow and outflow;
            double powered_slope_sum, OF_tot1 = 0, OF_tot2 = 0, OF_tot3 = 0; ;
            double[,,] OFd = new double[nr, nc, 10];

            //0: total flow
            //1-8: flow to neighbours
            //
            // 1 2 3 
            // 4   5
            // 6 7 8
            //
            //9: temporary flow, for the thresholds


            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    pond_d[row, col] = 0;
                    for (int it = 0; it <= 9; it++)
                    {
                        OFd[row, col, it] = 0;
                    } // reset all values
                }
            }


            int runner = 0;
            // Debug.WriteLine("df2");
            double totalwater = 0, totalwater2 = 0;
            // create overland flow in current flow map. This will be reset after flowing out, to consider a new flux of water after saddle overflow, without counting the first flux twice. 
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    // Add rainfall excess to every cell. If negative, it can absorb incoming water from upstream.Overland flow will only be calculated when outflow is larger than zero. 
                    // Infiltration is dealt with at the end of the day. Water can still flow into the cell from higher up
                    //If there is snowmelt, all water (including rainfall), becomes overland flow
                    if (snowmelt > 0)
                    {
                        currentflow[row, col] = P_total + snowmelt;
                        total_water_flow += P_total + snowmelt;
                    }
                    else
                    {
                        currentflow[row, col] = P_total - Ks_topsoil_mh[row, col] * D_total; // infiltration excess becomes overland flow
                        total_water_flow += P_total - Ks_topsoil_mh[row, col] * D_total;
                    }
                    totalwater += currentflow[row, col];
                }
            }

            List<double> dh_list = new List<double>();
            List<string> dh_list_loc = new List<string>();
            // Debug.WriteLine("df3");
            // Debug.WriteLine("df2");
            // route to neighbours
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {
                //Debug.WriteLine("runner start of run: " + runner);
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];

                    //if (row == 186 & col == 499 & t == 5) { minimaps(186, 499); }


                    powered_slope_sum = 0;

                    // dh_list = new List<double>();

                    if (currentflow[row, col] > 0) // if there is currently water flowing out of the cell
                    {
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {  //if the cell has no NODATA

                                        dh = dtm[row, col] - (dtm[row + i, col + j] + pond_d[row + i, col + j]);
                                        //Debug.WriteLine("dh = {0}", dh);
                                        if (dh > 0)
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length

                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            dh_list.Add(dh);
                                            dh_list_loc.Add(Convert.ToString(col) + "." + Convert.ToString(j));
                                            powered_slope_sum = powered_slope_sum + dh;

                                            // no correction for possible sedimentation, like in normal overland flow
                                        }
                                    }
                                }
                            }
                        }
                        // Debug.WriteLine("df3");
                        if (powered_slope_sum > 0) // not in a depression
                        {
                            try
                            {

                                int direction = 0;
                                for (i = (-1); i <= 1; i++)
                                {
                                    for (j = (-1); j <= 1; j++)
                                    {
                                        if (!((i == 0) && (j == 0))) { direction++; }
                                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                        {
                                            if (dtm[row + i, col + j] != -9999)
                                            {  //if the cell has no NODATA

                                                dh = dtm[row, col] - (dtm[row + i, col + j] + pond_d[row + i, col + j]);
                                                if (dh > 0)
                                                {
                                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length

                                                    dh = dh / d_x;
                                                    dh = Math.Pow(dh, conv_fac);
                                                    int t2 = t;
                                                    // if (col == 12) { Debugger.Break(); }
                                                    // flow to ij = dh / powered_slope_sum
                                                    OFd[row, col, direction] += dh / powered_slope_sum * currentflow[row, col]; // update outflow to each cell
                                                    currentflow[row + i, col + j] += dh / powered_slope_sum * currentflow[row, col];// update inflow of receiving cell. Here, a negative currentflow can become less negative or positive. 
                                                    OFd[row + i, col + j, 9] += dh / powered_slope_sum * currentflow[row, col]; // to track total inflow for the water balance

                                                }
                                            }
                                        }

                                    } // end j
                                } // end i
                                OFd[row, col, 0] += currentflow[row, col]; // total outflow
                                currentflow[row, col] = 0; // reset currentflow for possible later new flux after saddle position overflow
                            }
                            catch
                            {
                                MessageBox.Show("Error in water redistribution");
                            }


                        } // end powered_slope_sum > 0



                        else // no outflow, so at the edge of the catchment, or in a sink or depression
                        {
                            bool nodataneighbour = search_nodataneighbour(row, col);



                            if (nodataneighbour == true) // outflow
                            {
                                OFd[row, col, 0] += currentflow[row, col];
                                total_outflow_y[row, col] += currentflow[row, col];
                                currentflow[row, col] = 0;
                            }
                            else // depression
                            {
                                // Debug.WriteLine("df3a");
                                List<double> saddle_OF = new List<double>();
                                saddle_OF = ponding(row, col, currentflow[row, col], qday, qmonth);
                                OFd[row, col, 0] += currentflow[row, col];
                                currentflow[row, col] = 0;
                                // Debug.WriteLine("df3b");
                                // Debug.WriteLine("col =" + col);
                                if (saddle_OF.Count() > 0) // if there is saddle overflow
                                {
                                    int OF_row = Convert.ToInt32(saddle_OF[1]);
                                    int OF_col = Convert.ToInt32(saddle_OF[2]);
                                    currentflow[OF_row, OF_col] += saddle_OF[0];
                                    // Debug.WriteLine("runner old: " + runner + ", " + saddle_OF[0] + " " + saddle_OF[1] + " " + saddle_OF[2]);
                                    string rowcol = OF_row.ToString() + "." + OF_col.ToString();
                                    runner = Array.IndexOf(rowcol_index, rowcol) + 1; // index of selected row and col + 1, because in the next iteration of the for loop, 1 is subtracted from runner
                                                                                      // Debug.WriteLine("runner new: " + runner);
                                } // end of saddle overflow
                            }
                        }

                        // Debug.WriteLine("df4");
                    } // end inflow > 0
                    else
                    {


                        // two options:
                        // currentflow is still negative, indicating that only infiltration occurs. 
                        // currentflow has been reset earlier, so nothing happens
                        // if (snowmelt > 0) { Debugger.Break(); }
                        OFd[row, col, 0] += currentflow[row, col]; //Creates negative flow, because this is used for calculating infiltration. At that stage, this parameters will be set to zero
                        currentflow[row, col] = 0;
                    }


                } // end runner !=-9999
            } // end runner
              // Debug.WriteLine("df4");

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    Iy[row, col] += pond_d[row, col];
                    if (double.IsNaN(Iy[row, col]))
                    {
                        Debug.WriteLine("err_df1");
                    }

                    // Calculate infiltration from rainfall and incoming flow
                    if (snowmelt == 0) // no snowmelt
                    {
                        if (OFd[row, col, 0] > 0) // if runoff occurred out of this cell, infiltration is maximum possible infiltration
                        {
                            Iy[row, col] += Ks_topsoil_mh[row, col] * D_total;
                            if (double.IsNaN(Iy[row, col]))
                            {
                                Debug.WriteLine("err_df2");
                            }

                        }
                        else
                        { // cell not saturated, infiltration is maximum infiltration minus the deficit at row, col, which is recorded in OFd[,,0]
                            Iy[row, col] += Ks_topsoil_mh[row, col] * D_total + OFd[row, col, 0]; //+, because OFd[row, col is negative
                                                                                                  //if (double.IsNaN(Iy[row, col])) { Debugger.Break(); }

                            OFd[row, col, 0] = 0;
                        }
                    }
                    else
                    {
                        // snow melt, no infiltration, because the soil is frozen. The rest leaves the catchment. this water only infiltrates when ponding. For the rest, it influences erosion
                    }



                    // Write daily flow to yearly flow
                    for (int it = 0; it <= 9; it++)
                    {
                        OFy_m[row, col, it] += OFd[row, col, it];
                    }

                    // check if total ponding equals total overland flow
                    pond_y[row, col] += pond_d[row, col];
                }
            }
            // Debug.WriteLine("df6");
        } // end dailyflow

        double Ks_wosten(double silt, double clay, double OM, double BD, int topsoil)
        {
            // Debug.WriteLine("KsW1");
            if (OM < 0.5) { OM = 0.5; } // half percent of OM for soils where it is absent, otherwise the PTFs will crash
            double KsW = Math.Exp(7.755 + 0.03252 * silt + 0.93 * topsoil - 0.967 * BD * BD - 0.000484 * clay * clay - 0.000322 * silt *
                silt + 0.001 / silt - 0.0748 / OM - 0.643 * Math.Log(silt) - 0.01398 * BD * clay - 0.1673 * BD * OM + 0.02986 * topsoil * clay - 0.03305 * topsoil * silt) / 100;
            // Debug.WriteLine("KsW2");
            if (Double.IsNaN(KsW)) { KsW = 0; }
            // Debug.WriteLine("KsW3");
            return (KsW); // m day-1

        }

        List<double> ponding(int row1, int col1, double inflow_m, int pday, int pmonth)
        {
            ponding_start = DateTime.Now;
            pond_d[row1, col1] += inflow_m;
            bool flatwater = false;
            int rowp, colp, rowp1, colp1, pondedcells, ri_of, ci_of;
            double minponding = inflow_m, dz_water;
            List<double> elev_p = new List<double>();
            List<double> output = new List<double>();
            elev_p.Add(dtm[row1, col1]);

            // 1. initiate list of ponded rows and cols
            List<int> pondingrows = new List<int>();
            List<int> pondingcols = new List<int>();
            pondingrows.Add(row1);
            pondingcols.Add(col1);
            List<double> dh_nb;
            // Debug.WriteLine("po1");

            // 2. loop over neighbours of ponded sink, to look for lowest neighbour to share water with
            // start with lowest neighbour of ponded cells, and work the way up
            while (flatwater == false)
            {
                dh_nb = new List<double>(); // store the dhs in a list, because we don't know how big the pond gets and therefore how many neighbours there are

                for (int pondcell = 0; pondcell < pondingrows.Count(); pondcell++)
                {

                    rowp = pondingrows[pondcell];
                    colp = pondingcols[pondcell];
                    // if (minponding > pond_d[row, colp]) {minponding = pond_d[row, colp]; }
                    for (int i = -1; i <= 1; i++)
                    { // find lowest neighbour of all ponded cells.
                        for (int j = -1; j <= 1; j++)
                        {
                            if (((rowp + i) >= 0) && ((rowp + i) < nr) && ((colp + j) >= 0) && ((colp + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                if (dtm[rowp + i, colp + j] != -9999)
                                {
                                    dh = (dtm[rowp, colp] + pond_d[rowp, colp]) - (dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j]);
                                    dh_nb.Add(dh);
                                } // end dtm != -9999
                            } // end if
                        } // end j
                    }  // end i
                }// end rowp colp

                //  Debug.WriteLine("po2");
                double maxdiff = dh_nb.Max();

                // 3. If there is a lower neighbour, share the water with him. Threshold a bit above 0, to avoid rounding errors
                if (maxdiff > 0.000000000001)
                {
                    // Debug.WriteLine("po3a");
                    for (int pondcell = 0; pondcell < pondingrows.Count(); pondcell++)
                    {
                        rowp = pondingrows[pondcell];
                        colp = pondingcols[pondcell];
                        double h_c = dtm[rowp, colp];
                        for (int i = -1; i <= 1; i++)
                        { // 4. relocate lowest neighbour of all ponded cells.
                            for (int j = -1; j <= 1; j++)
                            {
                                if (((rowp + i) >= 0) && ((rowp + i) < nr) && ((colp + j) >= 0) && ((colp + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[rowp + i, colp + j] != -9999)
                                    {
                                        // Debug.WriteLine("po3b");
                                        dh = (dtm[rowp, colp] + pond_d[rowp, colp]) - (dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j]);
                                        if (dh == dh_nb.Max()) // if the selected neighbour is the lowest neighbour
                                        {

                                            pondedcells = pondingrows.Count();
                                            dz_water = pondedcells * dh / (pondedcells + 1); // amount of water added to the lowest (waterless) neighbour

                                            // if change in ponded cells exceeds available water in shallowest ponding cell (e.g. saddle positions), water drop is limited to this depth, preventing negative ponding
                                            double h_n = dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j];
                                            if (h_n < h_c) // if we cross a saddle position, stop water flow for now

                                            {
                                                double overflow = pond_d[rowp, colp] * pondedcells; // excess water is ponding level at the saddle position, times the amount of ponding cells

                                                for (int i_of = 0; i_of < pondedcells; i_of++)
                                                {
                                                    ri_of = pondingrows[i_of];
                                                    ci_of = pondingcols[i_of];
                                                    pond_d[ri_of, ci_of] -= overflow / pondedcells;
                                                }
                                                output.Add(overflow); // create list for output, consisting of saddle r and c, and amount of overflow
                                                output.Add(rowp);
                                                output.Add(colp);
                                                //OFd[rowp, colp, 0] += overflow; // add overflow to the saddle cell, not the lower neighbour. from the saddle cell it will flow onward
                                                dz_water = 0; flatwater = true;
                                            }

                                            else
                                            {
                                                // Debug.WriteLine("po3c");
                                                for (int pondcell1 = 0; pondcell1 < pondingrows.Count(); pondcell1++)
                                                { // subtract redistributed water from original ponds
                                                    rowp1 = pondingrows[pondcell1];
                                                    colp1 = pondingcols[pondcell1];
                                                    pond_d[rowp1, colp1] -= dz_water / pondedcells;
                                                }
                                                pond_d[rowp + i, colp + j] += dz_water; // add water to the new ponding cell
                                                                                        //  Debug.WriteLine("po3d");
                                                pondingrows.Add(rowp + i);
                                                pondingcols.Add(colp + j);
                                                if (minponding > pond_d[rowp + i, colp + j]) { minponding = pond_d[rowp + i, colp + j]; }
                                                elev_p.Add(dtm[rowp + i, colp + j]);
                                            }


                                            //for(int iii = 0;iii<pondingrows.Count();iii++)
                                            //{
                                            //    Debug.Write(dtm[pondingrows[iii], pondingcols[iii]] + pond_d[pondingrows[iii], pondingcols[iii]]+" ");
                                            //}
                                            //Debug.Write("\n");
                                        }
                                    } // end dtm != -9999
                                } // end if
                            } // end j
                        }  // end i

                    } // end rowp colp
                } // end if dh_nb > 
                else
                { // no lower neighbour, end of ponding
                    flatwater = true;
                }
                // Debug.WriteLine("po3");
            } // end of water redistribution


            bool negativeponding = false;
            for (int r = 0; r < nr; r++)
            {
                for (int c = 0; c < nc; c++)
                {
                    //pond_y[r, c] += pond_d[r, c];
                    if (pond_d[r, c] < -0.00000001) { Debug.WriteLine("negative ponding on row {0} and col {1}. Amount = {2} ", row, col, pond_d[r, c]); }
                }
            }
            // if(negativeponding == true) { out_double(workdir + "\\debug\\" + run_number + "_" + t + "_ "+ pmonth+"_ " + pday + "_out_ponding.asc", pond_d); }
            ponding_t += DateTime.Now - ponding_start;

            return (output);

        }

        bool stagnation(double I_d)
        {
            // DEVELOP MM account for different moisture conditions throughout the year
            bool stag;
            bool stag_total = false;
            int lay;
            double depth;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        stag = false;
                        lay = 0;
                        depth = 0;
                        if (I_d > Ks_md[row, col, lay]) { stag = true; stag_total = true; }
                        while (stag == false)
                        {
                            depth += layerthickness_m[row, col, lay];
                            if (I_d > Ks_md[row, col, lay]) { stag = true; stag_total = true; }
                        }
                        if (stag == true) { stagdepth[row, col] = depth; }
                    }
                }
            }
            return (stag_total);
        }

        void lateral_flow()
        {

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                if (dtm[row + i, col + j] != -9999)
                                {  //if the cell has no NODATA

                                }
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Soil development code

        void update_all_soil_thicknesses(int row_update, int col_update)
        {
            for (int layer_update = 0; layer_update < max_soil_layers; layer_update++)
            {
                layerthickness_m[row_update, col_update, layer_update] = thickness_calc(row_update, col_update, layer_update);
                layerthickness_m[row_update, col_update, layer_update] = thickness_calc(row_update, col_update, layer_update);
            }

        }

        void remove_empty_layers(int row2, int col2)
        {
            // mainly after tree fall, there can be empty soil layers at the surface. This module shifts the layers up.
            // displaysoil(row2, col2);
            // Debug.WriteLine("rel1");
            // DEVELOP after shifting cells up the script runs through the lower empty cells, moving them up also. with some booleans, this should be prevented. there is no error now, only longer simulation time.  
            try
            {
                if (diagnostic_mode == 1) { Debug.WriteLine("entered removing empty layers"); }
                int empty_layers = 0;
                bool shift_layers = false;

                int n_shifts = 0;
                double mass_before = total_soil_mass(row2, col2);
                // Debug.WriteLine("rel2");
                for (int lay2 = 0; lay2 < max_soil_layers; lay2++)
                {
                    bool full_layer_shift = false;
                    if (total_layer_mass(row2, col2, lay2) < 0.000000000001) // empty layer
                                                                             // mind for empty layers at the bottom
                    {
                        shift_layers = true;
                        // if(n_shifts == 0) { displaysoil(row2, col2); }
                        // n_shifts += 1;

                        empty_layers++;
                        for (int layert = lay2; layert < max_soil_layers - 1; layert++) // for all underlying layers, shift one up (since there is space anyway)
                        {

                            if (total_layer_mass(row2, col2, layert + 1) > 0) { full_layer_shift = true; }
                            // Debug.WriteLine(layert);
                            for (i = 0; i < 5; i++)
                            {
                                texture_kg[row2, col2, layert, i] = texture_kg[row2, col2, layert + 1, i];
                            }
                            old_SOM_kg[row2, col2, layert] = old_SOM_kg[row2, col2, layert + 1];
                            young_SOM_kg[row2, col2, layert] = young_SOM_kg[row2, col2, layert + 1];
                        }
                        for (i = 0; i < 5; i++)
                        {
                            texture_kg[row2, col2, max_soil_layers - 1, i] = 0;
                        }
                        old_SOM_kg[row2, col2, max_soil_layers - 1] = 0;
                        young_SOM_kg[row2, col2, max_soil_layers - 1] = 0;
                        layerthickness_m[row2, col2, max_soil_layers - 1] = 0;

                        if (full_layer_shift == true) { lay2--; }
                        //Debug.WriteLine("-");
                        //displaysoil(row2, col2);
                    }
                }
                // Debug.WriteLine("rel3");
                if (shift_layers == true)
                {
                    double mass_after = total_soil_mass(row2, col2);
                    if (Math.Round(mass_before - mass_after) > 0.0000001)
                    {
                        Debug.WriteLine("Loss of soil data during removal of empty layers");
                        displaysoil(row2, col2);
                    }

                }

                if (diagnostic_mode == 1) { if (n_shifts > 0) { displaysoil(row2, col2); Debug.WriteLine("n layers shifted: {0} in row {1}, col {2}", n_shifts, row2, col2); } }
                update_all_soil_thicknesses(row2, col2);
            } // end try

            catch
            {
                Debug.WriteLine("Error in removing empty layers");
                Debug.WriteLine(" at end of remove_empty_layers: "); displaysoil(row2, col2); 
            }
            
        }

        void soil_update_split_and_combine_layers_standard()
        {
            //where at the end of soil development, splitting and combining of soil layers is performed.

            //per layer: if too thin: combine with one of the two neighbours (the closest one in properties). 
            // too thick: split
            // if total too much - combine the most similar two layers although the product conforms to most restrictive rule about thicknesses
            //maat voor verschil is som (absolute differences in de vijf text classes and two organic matter classes)

            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=8
            // daarna     min 40    insteek 50  geen max            n=4

            //for combining : only when matrix size exceeded, then those two layers that are most equal are combined
            //do not combine two layers that together are too thick for their position in the profile. If needed, make lowest layer thicker. Therefore, approach from above

            //MISSING: HOW DO WE GO FROM MAX TO LESS LAYERS? ART
            //  Debug.WriteLine("suscl1 ");

            //displaysoil(0,0);
            double mass_before = total_catchment_mass();
            total_average_soilthickness_m = 0;
            number_soil_thicker_than = 0;
            number_soil_coarser_than = 0;
            local_soil_depth_m = 0;
            local_soil_mass_kg = 0;

            int layer;
            int numberoflayers = 0;
            double depth_m;  // keep better track of this, currently not OK yet
            try
            {
                //Debug.WriteLine("suscl2");
                //displaysoil(0, 0);
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            update_all_soil_thicknesses(row, col);
                            update_all_soil_thicknesses(row, col);

                            depth_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                ////update the layers' thickness now that textures and organic matter amounts have changed (if there is anything in the layer at all).
                                //if (!(texture_kg[row, col, layer, 0] == 0 && texture_kg[row, col, layer, 1] == 0 && texture_kg[row, col, layer, 2] == 0 && texture_kg[row, col, layer, 3] == 0 && texture_kg[row, col, layer, 4] == 0 && young_SOM_kg[row, col, layer] == 0 && old_SOM_kg[row, col, layer] == 0))
                                //{
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //if (layerthickness_m[row,col,layer] < 0) { Debugger.Break(); } //MMS
                                //find_negative_texture_rcl(row, col, layer); //MMS
                                //}
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                                {
                                    local_soil_mass_kg += texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    if (local_soil_mass_kg < 0)
                                    {
                                        Debug.WriteLine("err_uscl1");
                                    } //MMS
                                }
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && layer == 0 && texture_kg[row, col, layer, 0] / (texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) > System.Convert.ToDouble(timeseries.timeseries_soil_coarser_fraction_textbox.Text))
                                {
                                    number_soil_coarser_than++;
                                }
                            }

                        }
                    }
                }


                //displaysoil(0, 0);
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double old_soil_mass = total_soil_mass(row, col), new_soil_mass;
                            // Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            //Debug.WriteLine("soil before splitting");
                            // if (row == 0 & col == 0) { displaysoil(row, col); }
                            depth_m = 0; numberoflayers = 0;
                            bool boolsplit = false;
                            bool boolcombine = false;
                            for (layer = 0; layer < max_soil_layers - 1; layer++)
                            {
                                if (layerthickness_m[row, col, layer] > 0)
                                {

                                    //Debug.WriteLine("depth is now " + depth + " for lyr " +  layer);
                                    numberoflayers++;

                                    // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                    // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                    // daarna     min 50    insteek 100  geen max            n=4

                                    if (depth_m <= 0.5)
                                    {
                                        if (layer == 0 & layerthickness_m[row, col, layer] < 0.001) // smaller than one mm -> merge with layer below
                                        {
                                            combine_layers(row, col, layer, layer + 1);
                                            update_all_soil_thicknesses(row, col);
                                            boolcombine = true;
                                            if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6)) { Debug.WriteLine("err_uscl2"); }
                                        }

                                        if (layerthickness_m[row, col, layer] < 0.025 && layer != 0)
                                        { //combine layers: select the one most like this one
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6))
                                                {
                                                    Debug.WriteLine("err_uscl3");
                                                }

                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6)) { Debugger.Break(); }

                                            }
                                            // we will now check whether layers have become too thick and if needed cut them in half
                                        }

                                        while (layerthickness_m[row, col, layer] > 0.1)
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 1");
                                            split_layer(row, col, layer, depth_m);
                                            update_all_soil_thicknesses(row, col);
                                            boolsplit = true;
                                            // if (Math.Abs(old_soil_mass-total_soil_mass(row, col))>0.00000001) { Debugger.Break(); }

                                        }

                                        // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                        // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                        // daarna     min 50    insteek 100  geen max            n=4

                                    }

                                    depth_m += layerthickness_m[row, col, layer]; // MM moved this down one if-function, to be able to split big clumps of earth by tree fall. If I put it at the end, it will give problems with splitting the one-before-last layer




                                    if (depth_m > 0.5 && depth_m <= 2)
                                    {
                                        if (layerthickness_m[row, col, layer] < 0.1 && layer != 0)
                                        { //combine 
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001)
                                                {
                                                    Debug.WriteLine("err_uscl4");
                                                }
                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001) { Debugger.Break(); }

                                            }
                                        }
                                        while (layerthickness_m[row, col, layer] > 0.5)
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 2. layer = {0}, layerthickness = {1}", layer, layerthickness_m[row, col, layer]);
                                            split_layer(row, col, layer, depth_m);
                                            update_all_soil_thicknesses(row, col);
                                            boolsplit = true;
                                            new_soil_mass = total_soil_mass(row, col);
                                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                                            {
                                                Debug.WriteLine("err_uscl5");
                                            }

                                        }
                                    }


                                    if (depth_m > 2)
                                    {
                                        if (layerthickness_m[row, col, layer] < 0.4 && layer != 0)
                                        { //combine 
                                          //displaysoil(row, col);
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001)
                                                {
                                                    Debug.WriteLine("err_uscl6");
                                                }

                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                numberoflayers--;
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001) { Debugger.Break(); }

                                            }

                                        }
                                        if (layerthickness_m[row, col, layer] > 0.5)
                                        { //split 
                                          // no splitting, no maximum thickness
                                        }
                                    }


                                    //Debug.WriteLine("depth is now " + depth + " and number of layers is  " + numberoflayers);
                                }
                            }
                            //Debug.WriteLine("suscl1" + row + ", " + col + ", " + t);

                            for (int layupdate = 0; layupdate < max_soil_layers; layupdate++)
                            {
                                layerthickness_m[row, col, layupdate] = thickness_calc(row, col, layupdate);
                            }
                            //Debug.WriteLine("Soil after splitting");
                            //if (row == 0 & col == 0) { displaysoil(row, col); }
                            //Debug.WriteLine("suscl4");
                            //displaysoil(0, 0);

                            new_soil_mass = total_soil_mass(row, col);
                            // if (numberoflayers > max_soil_layers)
                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                            {
                                // this should never happen, because the data of the lowest layers have then been lost.
                                Debug.WriteLine(" Warning - loss of soil data ");
                                //displaysoil(row, col);
                            }
                            if (timeseries.timeseries_number_soil_thicker_checkbox.Checked && System.Convert.ToDouble(timeseries.timeseries_soil_thicker_textbox.Text) < depth_m) { number_soil_thicker_than++; }
                            if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m += depth_m; }
                            if (timeseries.timeseries_soil_depth_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                            {
                                local_soil_depth_m = depth_m;
                            }

                            //Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            // update dtm and soil thickness map //MMS
                            double old_thickness = soildepth_m[row, col];
                            double new_thickness = total_soil_thickness(row, col);
                            dtm[row, col] += new_thickness - old_thickness;
                            soildepth_m[row, col] = new_thickness;
                            dtmchange[row, col] += new_thickness - old_thickness;
                            dz_soil[row, col] += new_thickness - old_thickness;
                        }// end dtm!=-9999

                    } // end col
                } // end row

                if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m /= number_of_data_cells; }
            }
            catch { }
            double mass_after = total_catchment_mass();
            //if (Math.Round(mass_before, 3) != Math.Round(mass_after, 3)) { Debugger.Break(); }


        } //always keep this code

        void soil_update_split_and_combine_layers()
        {
            double dz_standard = 0.1;
            double tolerance = 0.55; // fraction of standard thickness
                                     //where at the end of soil development, splitting and combining of soil layers is performed.

            //per layer: if too thin: combine with one of the two neighbours (the closest one in properties). 
            // too thick: split
            // if total too much - combine the most similar two layers although the product conforms to most restrictive rule about thicknesses
            //maat voor verschil is som (absolute differences in de vijf text classes and two organic matter classes)

            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=8
            // daarna     min 40    insteek 50  geen max            n=4

            //for combining : only when matrix size exceeded, then those two layers that are most equal are combined
            //do not combine two layers that together are too thick for their position in the profile. If needed, make lowest layer thicker. Therefore, approach from above

            //MISSING: HOW DO WE GO FROM MAX TO LESS LAYERS? ART
            // Debug.WriteLine("suscl1 ");
            if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
            {
                Debug.WriteLine("err_uscl7");
            }

            //displaysoil(0,0);
            double mass_before = total_catchment_mass();
            total_average_soilthickness_m = 0;
            number_soil_thicker_than = 0;
            number_soil_coarser_than = 0;
            local_soil_depth_m = 0;
            local_soil_mass_kg = 0;

            int layer;
            int numberoflayers = 0;
            double depth_m;  // keep better track of this, currently not OK yet
            try
            {
                /*
                //displaysoil(0, 0);
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            update_all_soil_thicknesses(row, col);
                            update_all_soil_thicknesses(row, col);
                            // Debug.WriteLine("suscl2");
                            if (NA_in_soil(row, col)) { Debugger.Break(); }


                            depth_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                ////update the layers' thickness now that textures and organic matter amounts have changed (if there is anything in the layer at all).
                                //if (!(texture_kg[row, col, layer, 0] == 0 && texture_kg[row, col, layer, 1] == 0 && texture_kg[row, col, layer, 2] == 0 && texture_kg[row, col, layer, 3] == 0 && texture_kg[row, col, layer, 4] == 0 && young_SOM_kg[row, col, layer] == 0 && old_SOM_kg[row, col, layer] == 0))
                                //{
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //if (layerthickness_m[row,col,layer] < 0) { Debugger.Break(); } //MMS
                                //find_negative_texture_rcl(row, col, layer); //MMS
                                //}
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                                {
                                    local_soil_mass_kg += texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    if (local_soil_mass_kg < 0) { Debugger.Break(); } //MMS
                                }
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && layer == 0 && texture_kg[row, col, layer, 0] / (texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) > System.Convert.ToDouble(timeseries.timeseries_soil_coarser_fraction_textbox.Text))
                                {
                                    number_soil_coarser_than++;
                                }
                            }

                        }
                    }
                } */



                //displaysoil(0, 0);
                depth_m = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            remove_empty_layers(row, col);
                            remove_empty_layers(row, col);

                            update_all_soil_thicknesses(row, col);

                            //if (NA_in_soil(row, col))
                            //{
                            //    Debug.WriteLine("err_uscl8");
                            //}


                            double old_soil_mass = total_soil_mass(row, col), new_soil_mass;
                            // Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            //Debug.WriteLine("soil before splitting");
                            // if (row == 0 & col == 0) { displaysoil(row, col); }
                            depth_m = 0; numberoflayers = 0;
                            bool boolsplit = false;
                            bool boolcombine = false;
                            for (layer = 0; layer < (max_soil_layers - 1); layer++)
                            {
                                if (total_layer_mass(row, col, layer) > 0)
                                {

                                    //Debug.WriteLine("depth is now " + depth + " for lyr " +  layer);
                                    numberoflayers++;
                                    if (layer == 0)
                                    {
                                        if (layerthickness_m[row, col, layer] < 0.001 | total_soil_mass(row, col) < 0.001) // smaller than one mm, lighter than 1 gram -> merge with layer below, to avoid numerical problems when always a fraction leaves the profile (e.g. with creep)
                                        {
                                            combine_layers(row, col, layer, layer + 1);
                                            update_all_soil_thicknesses(row, col);
                                            boolcombine = true;
                                            if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6))
                                            {
                                                Debug.WriteLine("err_uscl9");
                                            }
                                        }
                                        while (layerthickness_m[row, col, layer] > dz_standard * (1 + tolerance)) //Higher end, split
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 1");
                                          // Debug.WriteLine("d_layer {0}", layerthickness_m[row, col, layer]);

                                            split_layer(row, col, layer, depth_m);
                                            // Debug.WriteLine("d_layer {0}", layerthickness_m[row, col, layer]);
                                            update_all_soil_thicknesses(row, col);
                                            // Debug.WriteLine("d_layer {0}", layerthickness_m[row, col, layer] );
                                            boolsplit = true;
                                        }
                                    }
                                    if (layer != 0)
                                    {
                                        if (layerthickness_m[row, col, layer] < (dz_standard * (1 - tolerance))) // Lower end, combine
                                        {
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                                {
                                                    Debug.WriteLine("err_uscl10");
                                                }
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6))
                                                {
                                                    Debug.WriteLine("err_uscl11");
                                                }
                                            }
                                            else
                                            {
                                                if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                                {
                                                    Debug.WriteLine("err_uscl12");
                                                }
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                update_all_soil_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6)) { Debugger.Break(); }
                                                if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                                {
                                                    Debug.WriteLine("err_uscl13");
                                                }

                                            }
                                        }
                                        if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                        {
                                            Debug.WriteLine("err_uscl14");
                                        }
                                        if (NA_in_soil(row, col))
                                        {
                                            Debug.WriteLine("err_uscl15");
                                        }

                                        while (layerthickness_m[row, col, layer] > dz_standard * (1 + tolerance)) //Higher end, split
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 1");
                                            split_layer(row, col, layer, depth_m);
                                            update_all_soil_thicknesses(row, col);
                                            boolsplit = true;
                                            // if (Math.Abs(old_soil_mass-total_soil_mass(row, col))>0.00000001) { Debugger.Break(); }
                                        }
                                        if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                        {
                                            Debug.WriteLine("err_uscl16");
                                        }

                                        //Debug.WriteLine("depth is now " + depth + " and number of layers is  " + numberoflayers);
                                    }
                                    if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                                    {
                                        Debug.WriteLine("err_uscl17");
                                    }

                                }
                            } // end layer
                              //Debug.WriteLine("suscl1" + row + ", " + col + ", " + t);
                            if (NA_in_soil(row, col))
                            {
                                Debug.WriteLine("err_uscl18");
                            }

                            for (int layupdate = 0; layupdate < max_soil_layers; layupdate++)
                            {
                                layerthickness_m[row, col, layupdate] = thickness_calc(row, col, layupdate);
                            }
                            //Debug.WriteLine("Soil after splitting");
                            //if (row == 0 & col == 0) { displaysoil(row, col); }

                            // Debug.WriteLine("suscl4");
                            //displaysoil(0, 0);
                            if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00001)
                            {
                                Debug.WriteLine("err_uscl19");
                            }
                            new_soil_mass = total_soil_mass(row, col);
                            // if (numberoflayers > max_soil_layers)
                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                            {
                                // this should never happen, because the data of the lowest layers have then been lost.
                                // Debug.WriteLine("{0}", t);
                                Debug.WriteLine(" Warning - loss of soil data ");
                                //displaysoil(row, col);
                                Debug.WriteLine("err_uscl20");

                            }
                            if (timeseries.timeseries_number_soil_thicker_checkbox.Checked && System.Convert.ToDouble(timeseries.timeseries_soil_thicker_textbox.Text) < depth_m) { number_soil_thicker_than++; }
                            if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m += depth_m; }
                            if (timeseries.timeseries_soil_depth_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                            {
                                local_soil_depth_m = depth_m;
                            }

                            //Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            // update dtm and soil thickness map //MMS
                            update_all_soil_thicknesses(row, col);
                            double old_thickness = soildepth_m[row, col];
                            double new_thickness = total_soil_thickness(row, col);
                            dtm[row, col] += new_thickness - old_thickness;
                            soildepth_m[row, col] = new_thickness;
                            dtmchange[row, col] += new_thickness - old_thickness;
                            dz_soil[row, col] += new_thickness - old_thickness;
                        } // end dtm!=-9999
                    } // end col
                } // end row

                if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m /= number_of_data_cells; }
            }
            catch
            {
                Debug.WriteLine("err_uscl21");
            }
            double mass_after = total_catchment_mass();

        } // aangepast voor constante diktes


        private void find_negative_texture()
        {
            for (int rr = 0; rr < nr; rr++)
            {
                for (int cc = 0; cc < nc; cc++)
                {
                    for (int ll = 0; ll < max_soil_layers; ll++)
                    {
                        for (int tt = 0; tt < 5; tt++)
                        {
                            if (texture_kg[rr, cc, ll, tt] < 0)
                            {
                                Debug.WriteLine("err_nt1");
                            }
                        }
                    }
                }
            }
        }

        double layer_difference(int rowwer, int coller, int lay1, int lay2)   //calculates a simple measure of difference between two soil layers based on the sum of relative differences in a set of properties
        {
            double average_property_value = 0, property_difference = 0, sum_property_difference = 0;

            try
            {
                // double average_property_value = 0, property_difference = 0, sum_property_difference = 0;
                for (i = 0; i < 5; i++)
                {
                    //account for total soil mass
                    average_property_value = (texture_kg[rowwer, coller, lay1, i] + texture_kg[rowwer, coller, lay2, i]) / 2;
                    property_difference = Math.Abs(texture_kg[rowwer, coller, lay1, i] - texture_kg[rowwer, coller, lay2, i]);
                    sum_property_difference += property_difference / average_property_value;
                }
                average_property_value = (old_SOM_kg[rowwer, coller, lay1] + old_SOM_kg[rowwer, coller, lay2]) / 2;
                property_difference = Math.Abs(old_SOM_kg[rowwer, coller, lay1] - old_SOM_kg[rowwer, coller, lay2]);
                sum_property_difference += property_difference / average_property_value;
                average_property_value = (young_SOM_kg[rowwer, coller, lay1] + young_SOM_kg[rowwer, coller, lay2]) / 2;
                property_difference = Math.Abs(young_SOM_kg[rowwer, coller, lay1] - young_SOM_kg[rowwer, coller, lay2]);
                sum_property_difference += property_difference / average_property_value;
                sum_property_difference /= 7;
                return sum_property_difference;
            }
            catch
            {
                MessageBox.Show("error in calculating layer difference");
            }
            return sum_property_difference;
        }

        void combine_layers(int rowwer, int coller, int lay1, int lay2)  // combines two soil layers into the first, recalculates their new thickness and shifts underlying layers up
        {

            double mass_before = total_layer_mass(rowwer, coller, lay1) + total_layer_mass(rowwer, coller, lay2);
            try
            {
                double old_soil_mass1 = total_soil_mass(rowwer, coller);
                // Debug.WriteLine("Total soil mass: {0}", old_soil_mass); displaysoil(rowwer, coller); 
                // Debug.WriteLine("cl0");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                for (i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, lay1, i] += texture_kg[rowwer, coller, lay2, i];
                    texture_kg[rowwer, coller, lay2, i] = 0;// set to zero. otherwise the shifting of the layers doesn't work
                    double new_soil_mass = total_soil_mass(rowwer, coller);

                }

                old_SOM_kg[rowwer, coller, lay1] += old_SOM_kg[rowwer, coller, lay2];
                old_SOM_kg[rowwer, coller, lay2] = 0;

                young_SOM_kg[rowwer, coller, lay1] += young_SOM_kg[rowwer, coller, lay2];
                young_SOM_kg[rowwer, coller, lay2] = 0;

                //Debug.WriteLine("cl1");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                layerthickness_m[row, col, lay1] = thickness_calc(row, col, lay1);    // thickness_calc uses a pdf to calculate bulk density and hence layer thickness

                for (int layert = lay2; layert < max_soil_layers - 1; layert++) // for all underlying layers, shift one up (since there is space anyway)
                {
                    // Debug.WriteLine(layert);
                    for (i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, layert, i] = texture_kg[rowwer, coller, layert + 1, i];
                    }
                    old_SOM_kg[rowwer, coller, layert] = old_SOM_kg[rowwer, coller, layert + 1];
                    young_SOM_kg[rowwer, coller, layert] = young_SOM_kg[rowwer, coller, layert + 1];
                }

                //now set the last layer to sentinel value of -1
                for (i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, max_soil_layers - 1, i] = 0;
                }
                old_SOM_kg[rowwer, coller, max_soil_layers - 1] = 0;
                young_SOM_kg[rowwer, coller, max_soil_layers - 1] = 0;
                layerthickness_m[rowwer, coller, max_soil_layers - 1] = 0;
                bulkdensity[rowwer, coller, max_soil_layers - 1] = 0;

                double new_soil_mass1 = total_soil_mass(rowwer, coller);
                //if (Math.Abs(old_soil_mass1 - new_soil_mass1) > 0.00000001) { displaysoil(rowwer, coller); Debugger.Break(); }
                double mass_after = total_layer_mass(rowwer, coller, lay1);
                if (Math.Abs(mass_before - mass_after) > 0.0001)
                {
                    Debug.WriteLine("err_cl1");
                }

            }
            catch
            {
                Debug.WriteLine("Failed at combining layer at row {0}, col {1} at time {2}", row, col, t);
            }
        }

        double bulk_density_calc(double coarse_mass, double sand_mass, double silt_mass, double clay_mass, double fine_clay_mass, double OMo_mass, double OMy_mass, double depth)
        {
            if (depth == 0) { depth = 0.001; } //MvdM value to prevent no data when calculating BD for layers that were previously empty, or for sediments that are deposited. A value of 1 results in an infinite value
            double bd = 2700, combined_frac, m_finesoil;
            m_finesoil = sand_mass + silt_mass + clay_mass + fine_clay_mass;
            if (m_finesoil > 0)
            {
                combined_frac = sand_mass / m_finesoil + 0.76 * silt_mass / m_finesoil;

                bd = 1000 * (1.35 + 0.00452 * 100 * combined_frac + Math.Pow(100 * combined_frac - 44.65, 2) * -0.0000614 + 0.06 * Math.Log10(depth));  // in kg/m3

                //now coarse fragment and SOM correction
                bd = (coarse_mass + m_finesoil + OMo_mass + OMy_mass) / ((m_finesoil / bd) + (coarse_mass / 2700) + (OMo_mass + OMy_mass) / 224); // ooit through interface    
            }
            else
            {
                bd = 2700;
            }
            if (double.IsNaN(bd) | double.IsInfinity(bd)) { Debugger.Break(); }
            return bd;
            // return 1500;
        }

        double thickness_calc(int rowwer, int coller, int lay1)
        {
            double thickness, soil_mass = 0;

            // calculate current depth of layer, for bulk density calculations, using current thickness. 
            double depth_m = 0;
            for (int lay_temp = 0; lay_temp < lay1; lay_temp++)
            {
                depth_m += layerthickness_m[rowwer, coller, lay_temp];
            }
            depth_m += layerthickness_m[rowwer, coller, lay1] / 2;

            int i;
            //first calculate total soil mass to calculate mass percentages for the size fractions
            for (i = 1; i < 5; i++)
            {
                soil_mass += texture_kg[rowwer, coller, lay1, i];
            }
            soil_mass += old_SOM_kg[rowwer, coller, lay1] + young_SOM_kg[rowwer, coller, lay1];
            //if (t == 6 && row == 193 && col == 58) { Debug.WriteLine("A " + row + " " + col + " soil mass " + soil_mass); displaysoil(row, col); }
            if (soil_mass > 0)
            {
                bulkdensity[rowwer, coller, lay1] = bulk_density_calc(texture_kg[rowwer, coller, lay1, 0], texture_kg[rowwer, coller, lay1, 1], texture_kg[rowwer, coller, lay1, 2], texture_kg[rowwer, coller, lay1, 3], texture_kg[rowwer, coller, lay1, 4], old_SOM_kg[rowwer, coller, lay1], young_SOM_kg[rowwer, coller, lay1], depth_m);
                //sand_fraction = texture_kg[rowwer, coller, lay1, 1] / soil_mass;
                //silt_fraction = texture_kg[rowwer, coller, lay1, 2] / soil_mass;
                //combined_fraction = sand_fraction + 0.76 * silt_fraction;
                //bulkdensity[rowwer, coller, lay1] = 1000 * (1.35 + 0.00452 * 100 * combined_fraction + Math.Pow(100 * combined_fraction - 44.65, 2) * -0.0000614);  // in kg/m3
                ////now coarse fragment correction

                //bulkdensity[rowwer, coller, lay1] = (soil_mass + texture_kg[rowwer, coller, lay1, 0]) / ((soil_mass / bulkdensity[rowwer, coller, lay1]) + (texture_kg[rowwer, coller, lay1, 0] / 2700)); // ooit through interface              
                // if (t == 6 && row == 193 && col == 58) { Debug.WriteLine("B " + row + " " + col + " soil mass " + soil_mass); }
            }
            else
            {
                //either there is no soil at all, or there is only coarse material
                if (texture_kg[rowwer, coller, lay1, 0] > 0)
                {
                    bulkdensity[rowwer, coller, lay1] = 2700;   //kg/m3
                }
            }
            // if (t == 6 && row == 193 && col == 58) { Debug.WriteLine("C " + row + " " + col + " soil mass " + soil_mass); }
            soil_mass += texture_kg[rowwer, coller, lay1, 0];
            if (soil_mass == 0)
            {
                thickness = 0;
            }
            else
            {
                thickness = (soil_mass) / (dx * dx * bulkdensity[rowwer, coller, lay1]);  // thickness in m per unit area
            }
            if (double.IsNaN(thickness)) { thickness = 0.00000000001; }
            return thickness;
        }

        double calc_thickness_from_mass(double[] textures_kg, double yom_kg, double oom_kg)
        {
            //pdf goes here
            double thickness_m = 0, soil_mass_kg = 0;
            double sand_fraction, silt_fraction, bulk_density;
            //first calculate total soil mass to calculate mass percentages for the fine earth fractions (excluding coarse)
            for (int ir = 1; ir < 5; ir++)
            {
                soil_mass_kg += textures_kg[ir];
            }
            soil_mass_kg += oom_kg + yom_kg;
            sand_fraction = textures_kg[1] / soil_mass_kg;
            silt_fraction = textures_kg[2] / soil_mass_kg;

            //calculate bulk density
            bulk_density = bulk_density_calc(textures_kg[0], textures_kg[1], textures_kg[2], textures_kg[3], textures_kg[4], oom_kg, yom_kg, 0.001); // MM depth of 1 micrometer, because a depth of 0 will result in infinite numbers 
            thickness_m = (soil_mass_kg + textures_kg[0]) / (dx * dx * bulk_density);  // thickness in m per unit area

            return thickness_m;
        }

        double total_soil_mass(int rowmass, int colmass)
        {
            double tot_mass = 0;
            for (int lay = 0; lay < max_soil_layers; lay++)
            {
                for (int ii = 0; ii < n_texture_classes; ii++)
                {
                    tot_mass += texture_kg[rowmass, colmass, lay, ii];
                }
                tot_mass += old_SOM_kg[rowmass, colmass, lay];
                tot_mass += young_SOM_kg[rowmass, colmass, lay];
            }
            return (tot_mass);
        }

        double total_layer_mass(int rowmass, int colmass, int laymass)
        {
            double tot_mass = 0;

            for (int ii = 0; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        double total_layer_fine_earth_mass(int rowmass, int colmass, int laymass)
        {
            double tot_mass = 0;

            for (int ii = 1; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        bool findnegativetexture()
        {
            bool neg = false;

            try
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        for (int lay = 0; lay < max_soil_layers; lay++)
                        {
                            for (int tex = 0; tex < n_texture_classes; tex++)
                            {
                                if (texture_kg[row, col, lay, tex] < 0) { neg = true; }
                            }
                        }
                    }
                }
            }
            catch
            {
                Debug.WriteLine("err_nt2");

            }

            return neg;
        }

        double total_mass_in_transport()
        {
            double tot_mass = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    for (ii = 0; ii < 5; ii++)
                    {
                        tot_mass += sediment_in_transport_kg[rowmass, colmass, ii];
                    }

                    tot_mass += old_SOM_in_transport_kg[rowmass, colmass];
                    tot_mass += young_SOM_in_transport_kg[rowmass, colmass];
                }
            }
            return (tot_mass);
        }

        double mass_in_transport_row_col(int row1, int col1)
        {
            double tot_mass = 0;
            for (ii = 0; ii < 5; ii++)
            {
                tot_mass += sediment_in_transport_kg[row1, col1, ii];
            }

            tot_mass += old_SOM_in_transport_kg[row1, col1];
            tot_mass += young_SOM_in_transport_kg[row1, col1];

            return (tot_mass);
        }

        double total_catchment_mass()
        {
            double tot_mass = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    for (int lay = 0; lay < max_soil_layers; lay++)
                    {
                        for (ii = 0; ii < 5; ii++)
                        {
                            tot_mass += texture_kg[rowmass, colmass, lay, ii];
                        }
                        tot_mass += old_SOM_kg[rowmass, colmass, lay];
                        tot_mass += young_SOM_kg[rowmass, colmass, lay];
                    }
                }
            }


            return (tot_mass);
        }

        double total_catchment_elevation()
        {
            double tot_elev = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    if (dtm[rowmass, colmass] != -9999)
                    {
                        tot_elev += dtm[rowmass, colmass];
                    }

                }
            }


            return (tot_elev);
        }

        double total_soil_thickness(int rowthick, int colthick)
        {
            double tot_thick = 0;
            for (int lay = 0; lay < max_soil_layers; lay++)
            {
                tot_thick += layerthickness_m[rowthick, colthick, lay];
            }
            return (tot_thick);
        }

        void split_layer(int rowwer, int coller, int lay1, double currentdepth) // splits layers 
        {
            if (t == 44000 && rowwer == 11 && coller == 17) { diagnostic_mode = 1; }
            try
            {
                double max_layer_difference, current_difference, maximum_allowed_thickness;
                //splitting will increase the number of layers. If this splits beyond the max number of layers, then combine the two most similar ones 
                int laynum, combininglayer = -1;
                // Debug.WriteLine("sl0");
                if (diagnostic_mode == 1) { Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller)); }
                double mass_lowest_layer = total_layer_mass(rowwer, coller, max_soil_layers - 1);
                if (diagnostic_mode == 1){ Debug.WriteLine("total mass last layer = {0}", mass_lowest_layer);}
                if ((total_layer_mass(rowwer, coller, max_soil_layers - 1) > 0))  // so, if we are using the lowest possible layer already (even if it's not this layer):
                {
                    //this breaks now because the lowest layer can be empty due to its encountering a hard layer
                    //if they are already all in use, then the split will create one too many. We start by looking for the two most similar layers that would not create a too-thick product (do we need to do that last part?)
                    max_layer_difference = 100; //100 is a huge difference
                    for (laynum = 0; laynum < max_soil_layers - 1; laynum++)
                    {
                        current_difference = layer_difference(rowwer, coller, laynum, laynum + 1);
                        maximum_allowed_thickness = 9999;   // 9999 is a sentinel value and means infinitely thick 
                        if (currentdepth < 0.5) { maximum_allowed_thickness = 0.1; }
                        else { if (currentdepth < 2.5) { maximum_allowed_thickness = 0.5; } }
                        maximum_allowed_thickness = dz_standard * (1 + tolerance);
                        if (layerthickness_m[rowwer, coller, laynum] + layerthickness_m[rowwer, coller, laynum + 1] < maximum_allowed_thickness)  //if it potentially is possible to combine them 
                        {
                            if (current_difference <= max_layer_difference)   // the equal to condition means that we prefer to combine layers lower in the profile (if equally different from each other)
                            {
                                max_layer_difference = current_difference; 
                                combininglayer = laynum;
                            }
                        }
                    }
                    //Debug.WriteLine("sl1");
                    //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));

                    //combine the two most-similar layers, or the lowest two if nothing else possible
                    if (max_layer_difference == 100) { combininglayer = max_soil_layers - 2; }
                    //Debug.WriteLine("test");
                    if (diagnostic_mode == 1)
                    {
                        Debug.WriteLine(rowwer + "," + coller + "," + combininglayer + "," + (combininglayer + 1) + "," + t);
                    }
                    try { combine_layers(rowwer, coller, combininglayer, combininglayer + 1); }
                    catch { Debug.WriteLine(" failed to combine layers to prepare for splitting "); }
                    //make sure to change lay1 if needed (because something overlying has been combined into 1 for instance).
                    if (combininglayer == lay1 || combininglayer == lay1 - 1)
                    {
                        if (diagnostic_mode == 1) { Debug.WriteLine("the layer that needed to be split has now been combined: layer {0} at t {1}", combininglayer, t); }
                        // displaysoil(rowwer, coller);
                        // Debugger.Break();
                    }
                    if (combininglayer < lay1) { lay1++; } // mvdm changed from++ to --, because if layers above are combined, the target layer has moved up one spot
                }
                //Debug.WriteLine("sl2");
                if (diagnostic_mode == 1)
                { Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller)); }
                
                // now we can move all layers down below the one we want to split
                for (laynum = max_soil_layers - 1; laynum >= lay1 + 2; laynum--)  // we want to clear layer lay1+1 (so we run through move-receiving layers from below up to lay1+2). 
                                                                                  //This means that layer laynum+1, into which we want to split, will be evacuated and will give its values to laynum+2;
                {
                    if (diagnostic_mode == 1)
                    {
                        Debug.WriteLine("sl2a, laynum = " + laynum + ", lay1+2 = " + lay1 + 2 + "tex lay 19 =" + texture_kg[rowwer, coller, 19, 2]);
                    }
                    for (i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, laynum, i] = texture_kg[rowwer, coller, laynum - 1, i];
                    }
                    if (diagnostic_mode == 1)
                    {
                        Debug.WriteLine("sl2b, ");
                    }
                    old_SOM_kg[rowwer, coller, laynum] = old_SOM_kg[rowwer, coller, laynum - 1];
                    young_SOM_kg[rowwer, coller, laynum] = young_SOM_kg[rowwer, coller, laynum - 1];
                    // OSL_age[rowwer, coller, laynum] = OSL_age[rowwer, coller, laynum - 1];
                }
                //Debug.WriteLine("sl3");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));

                if (diagnostic_mode == 1)
                {
                    Debug.WriteLine(" moved layers one down to make space for split layer ");
                }
                if ((lay1 + 1) == (max_soil_layers - 1))
                {
                    double div = 0.1 / (layerthickness_m[row, col, lay1]); // aim to have the split layer at 0.1 m
                    if (div > 1) { div = 1; }
                    for (i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, lay1 + 1, i] += texture_kg[rowwer, coller, lay1, i] * (1 - div); texture_kg[rowwer, coller, lay1, i] *= div;
                        if (double.IsNaN(texture_kg[rowwer, coller, lay1, i]))
                        {
                            Debug.WriteLine("err_spl1");
                        }
                        if (double.IsNaN(texture_kg[rowwer, coller, lay1 + 1, i]))
                        {
                            Debug.WriteLine("err_spl2");
                        }
                    }
                    old_SOM_kg[rowwer, coller, lay1 + 1] += old_SOM_kg[rowwer, coller, lay1] * (1 - div); old_SOM_kg[rowwer, coller, lay1] *= div;
                    young_SOM_kg[rowwer, coller, lay1 + 1] += young_SOM_kg[rowwer, coller, lay1] * (1 - div); young_SOM_kg[rowwer, coller, lay1] *= div;
                    //Debug.WriteLine(" successfully split layer ");
                    //Debug.WriteLine("sl4");
                    //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                }
                else // even splitting
                {
                    for (i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, lay1 + 1, i] = texture_kg[rowwer, coller, lay1, i] / 2; texture_kg[rowwer, coller, lay1, i] /= 2;
                    }
                    old_SOM_kg[rowwer, coller, lay1 + 1] = old_SOM_kg[rowwer, coller, lay1] / 2; old_SOM_kg[rowwer, coller, lay1] /= 2;
                    young_SOM_kg[rowwer, coller, lay1 + 1] = young_SOM_kg[rowwer, coller, lay1] / 2; young_SOM_kg[rowwer, coller, lay1] /= 2;
                    //Debug.WriteLine(" successfully split layer ");
                    //Debug.WriteLine("sl4");
                    //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                }

            }
            catch
            {
                Debug.WriteLine("Failed at splitting layer at row {0}, col {1} at time {2}", row, col, t);
            }
            if (t == 44 && rowwer == 11 && coller == 17) { diagnostic_mode = 0; }
        }

        void split_layer_till(int rowwer, int coller, int lay1, double currentdepth) // splits layers 
        {

            double max_layer_difference, current_difference, maximum_allowed_thickness, frac_ap, frac_soil;
            //splitting will increase the number of layers. If this splits beyond the max number of layers, then combine the two most similar ones 
            int laynum, combininglayer = -1;
            if ((layerthickness_m[rowwer, coller, max_soil_layers - 1] > 0))  // so, if we are using the lowest possible layer already:
            {
                //if they are already all in use, then the split will create one too many. We start by looking for the two most similar layers that would not create a too-thick product (do we need to do that last part?)
                max_layer_difference = 100; //100 is a huge difference
                for (laynum = 0; laynum < max_soil_layers - 1; laynum++)
                {
                    current_difference = layer_difference(rowwer, coller, laynum, laynum + 1);
                    maximum_allowed_thickness = 9999;   // 9999 is a sentinel value and means infinitely thick 
                    if (currentdepth < 0.5) { maximum_allowed_thickness = 0.1; }
                    else { if (currentdepth < 2.5) { maximum_allowed_thickness = 0.5; } }

                    if (layerthickness_m[rowwer, coller, laynum] + layerthickness_m[rowwer, coller, laynum + 1] < maximum_allowed_thickness)  //if it potentially is possible to combine them 
                    {
                        if (current_difference <= max_layer_difference)   // the equal to condition means that we prefer to combine layers lower in the profile (if equally different from each other)
                        {
                            max_layer_difference = current_difference; combininglayer = laynum;
                        }
                    }
                }
                //combine the two most-similar layers, or the lowest two if nothing else possible
                if (max_layer_difference == 100) { combininglayer = max_soil_layers - 2; }
                try { combine_layers(rowwer, coller, combininglayer, combininglayer + 1); }
                catch { Debug.WriteLine(" failed to combine layers to prepare for splitting "); }
                //make sure to change lay1 if needed (because something overlying has been combined into 1 for instance).
                if (combininglayer == lay1 || combininglayer == lay1 - 1) { Debug.WriteLine("the layer that needed to be split has now been combined "); }
                if (combininglayer < lay1) { lay1++; }
            }
            // now we can move all layers down below the one we want to split
            for (laynum = max_soil_layers - 1; laynum <= lay1 + 2; laynum--)  // we want to clear layer lay1+1 (so we run through move-receiving layers from below up to lay1+2). 
                                                                              //This means that layer laynum+1, into which we want to split, will be evacuated and will give its values to laynum+2;
            {
                for (i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, laynum, i] = texture_kg[rowwer, coller, laynum - 1, i];
                }
                old_SOM_kg[rowwer, coller, laynum] = old_SOM_kg[rowwer, coller, laynum - 1];
                young_SOM_kg[rowwer, coller, laynum] = young_SOM_kg[rowwer, coller, laynum - 1];
            }
            //Debug.WriteLine(" moved layers one down to make space for split layer ");
            double inithick = layerthickness_m[rowwer, coller, laynum];
            frac_ap = plough_depth / inithick;
            frac_soil = 1 - frac_ap;
            for (i = 0; i < 5; i++)
            {
                texture_kg[rowwer, coller, lay1 + 1, i] = texture_kg[rowwer, coller, lay1, i] * frac_soil; texture_kg[rowwer, coller, lay1, i] *= frac_ap;
            }
            old_SOM_kg[rowwer, coller, lay1 + 1] = old_SOM_kg[rowwer, coller, lay1] / 2; old_SOM_kg[rowwer, coller, lay1] /= 2;
            young_SOM_kg[rowwer, coller, lay1 + 1] = young_SOM_kg[rowwer, coller, lay1] / 2; young_SOM_kg[rowwer, coller, lay1] /= 2;
            //Debug.WriteLine(" successfully split layer ");
        }

        bool search_nodataneighbour(int row, int col)
        {
            bool ndn = false;
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    if ((((row + i) < 0) | ((row + i) >= nr)) | (((col + j) < 0) | ((col + j) >= nc)))
                    {
                        ndn = true;
                    }
                }
            }
            return (ndn);
        }

        void soil_physical_weathering()  //calculate physical weathering
        {
            double old_mass = total_catchment_mass();
            int cells = nr * nc;
            int layer, tex_class;
            double depth;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        int tempcol = col;
                        depth = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, tempcol, layer] > 0)
                            {
                                int templayer = layer;
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                                for (tex_class = 0; tex_class <= 2; tex_class++)   //we only physically weather the coarse, sand and silt fractions.
                                {
                                    int tempclass = tex_class;
                                    // calculate the mass involved in physical weathering
                                    weathered_mass_kg = texture_kg[row, tempcol, templayer, tempclass] * physical_weathering_constant * Math.Exp(-Cone * depth) * -Ctwo / Math.Log10(upper_particle_size[tempclass]) * dt;
                                    total_phys_weathered_mass_kg += weathered_mass_kg;
                                    //Debug.WriteLine(" weathered mass is " + weathered_mass + " for class " + tempclass );
                                    // calculate the products involved
                                    if (tex_class == 0)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += 0.975 * weathered_mass_kg;
                                        texture_kg[row, tempcol, templayer, tempclass + 2] += 0.025 * weathered_mass_kg;
                                    }
                                    if (tex_class == 1)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += 0.96 * weathered_mass_kg;
                                        texture_kg[row, tempcol, templayer, tempclass + 2] += 0.04 * weathered_mass_kg;
                                    }
                                    if (tex_class == 2)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += weathered_mass_kg;
                                    }
                                    texture_kg[row, tempcol, templayer, tempclass] -= weathered_mass_kg;
                                }
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                            }
                        }
                    }  //);
                } // end for cells
                  //timeseries
                if (timeseries.timeseries_cell_waterflow_check.Checked)
                {
                    timeseries_matrix[t, timeseries_order[15]] = total_phys_weathered_mass_kg;
                }
            }
            catch { Debug.WriteLine(" Soil physical weathering calculation threw an exception"); }

            double new_mass = total_catchment_mass();
            if (Math.Abs(old_mass - new_mass) > 0.000001)
            {
                Debug.WriteLine("err_spw1");
            }
        }

        void SPITS_soil_physical_weathering()  //calculate sedimentary rock (siltstone, limestoneF physical weathering
        {
            // in this variant, coarse material (siltstone, limestone) weathers only into a silt fraction. 
            // Nothing else weathers. 
            // Not all of the coarse material weathers into silt, a certain fraction is lost to dissolution (90%).

            int cells = nr * nc;
            int layer, tex_class;
            double depth;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)

                    //Parallel.For(0, nc-1, col =>                    //we should paralellize over cols. Problem so far seems to be that the nc-1 or layer limit is exceeded
                    {
                        int tempcol = col;
                        //Code here is executed in parallel as much as possible for different soils in different places. 
                        //Main assumption: soils affect each other only through their surface interactions and not e.g. through throughflow
                        depth = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, tempcol, layer] > 0)
                            {
                                int templayer = layer;
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                                tex_class = 0;
                                int tempclass = tex_class;
                                // calculate the mass involved in physical weathering
                                weathered_mass_kg = texture_kg[row, tempcol, templayer, tempclass] * physical_weathering_constant * Math.Exp(-Cone * depth) * -Ctwo / Math.Log10(upper_particle_size[tempclass]) * dt;
                                //Debug.WriteLine(" weathered mass is " + weathered_mass + " for class " + tempclass );
                                // calculate the products involved
                                texture_kg[row, tempcol, templayer, tempclass + 2] += 0.1 * weathered_mass_kg;
                                texture_kg[row, tempcol, templayer, tempclass] -= weathered_mass_kg;
                            }
                        }
                    }  //);
                }
            }
            catch { Debug.WriteLine(" Soil physical weathering calculation threw an exception"); }

        }

        void SPITS_aeolian_deposition()
        {
            //tricks the deposition process by playing with tillage fields. Tillage shoudl be ON - but with zero par values.
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (tillfields[row, col] == 1)
                        {
                            //deposition in kg/m2/y is 0.063 
                            texture_kg[row, col, 0, 1] += 0.063 * dx * dx;
                        }
                    }
                }

            }
            catch { }
        }

        void soil_chemical_weathering()
        {
            int cells = nr * nc;
            int layer, tex_class;
            double depth, weathered_mass_kg, total_weath_mass;
            total_chem_weathered_mass_kg = 0;
            total_fine_neoformed_mass_kg = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    //Main assumption: soils affect each other only through their surface interactions and not e.g. through throughflow
                    depth = 0; total_weath_mass = 0;
                    for (layer = 0; layer < max_soil_layers; layer++)
                    {
                        if (layerthickness_m[row, col, layer] > 0)
                        {
                            depth += layerthickness_m[row, col, layer] / 2;
                            for (tex_class = 1; tex_class <= 4; tex_class++) // only sand, silt, clay and fine clay are chemically weathered
                            {
                                weathered_mass_kg = texture_kg[row, col, layer, tex_class] * chemical_weathering_constant / 10 * Math.Exp(-Cthree * depth) * Cfour * specific_area[tex_class] * dt;

                                if (daily_water.Checked) { weathered_mass_kg *= waterfactor[row, col]; }

                                //Debug.WriteLine(" weath mass for layer " + layer + " class " + tex_class + " is " + weathered_mass_kg + " " + Math.Exp(-Cthree * depth));
                                // note that the chem_weath constant is in kg/m2 mineral surface / y (in contrast to the original value from Salvador Blanes (mol/m2 mineral/s)
                                if (weathered_mass_kg > texture_kg[row, col, layer, tex_class]) { weathered_mass_kg = texture_kg[row, col, layer, tex_class]; }
                                total_chem_weathered_mass_kg += weathered_mass_kg;
                                texture_kg[row, col, layer, tex_class] -= weathered_mass_kg;

                                //the following code accounts for the change in average size of the weathered class, 
                                //and the fact that a fraction of it therefore falls into a finer class as well

                                if (tex_class == 1)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.0000156252 * weathered_mass_kg)
                                    {

                                        texture_kg[row, col, layer, tex_class] -= 0.0000156252 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.0000156252 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                if (tex_class == 2)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.0000640041 * weathered_mass_kg)
                                    {
                                        texture_kg[row, col, layer, tex_class] -= 0.0000640041 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.0000640041 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                if (tex_class == 3)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.000125 * weathered_mass_kg)
                                    {
                                        texture_kg[row, col, layer, tex_class] -= 0.000125 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.000125 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                total_weath_mass += weathered_mass_kg;  //leached amount
                            }

                            //// clay neoformation
                            //fraction_neoform = neoform_constant * (Math.Exp(-Cfive * depth) - Math.Exp(-Csix * depth));
                            //if (fraction_neoform >= 1)
                            //{
                            //    Debug.WriteLine(" Warning: more than 100% of leached mass wants to become fine clay. This may indicate an error. Capping at 100%");
                            //    fraction_neoform = 1;
                            //}
                            //if (daily_water.Checked) { fraction_neoform *= waterfactor[row,col]; }
                            //texture_kg[row, col, layer, 4] += total_weath_mass * fraction_neoform;
                            //total_fine_neoformed_mass_kg += total_weath_mass * fraction_neoform;
                            //total_weath_mass -= total_weath_mass * fraction_neoform;
                            //depth += layerthickness_m[row, col, layer] / 2;
                        }
                    }
                }
            }  //);
               //timeseries
            if (timeseries.total_chem_weath_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[16]] = total_chem_weathered_mass_kg;
            }
            if (timeseries.total_fine_formed_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[17]] = total_fine_neoformed_mass_kg;
            }

        }

        void soil_bioturbation()
        {

            Debug.WriteLine("\n--bioturbation--\n");
            try
            {
                //for bioturbation, we first calculate how much bioturbation (kg) this cell will experience, given its thickness
                //shallower soils do not experience the same amount as deeper soils
                //then we look at individual layers. Thicker layers, and layers closer to the surface, will experience more bioturbation kg
                //then, per layer, we will exchange the required bioturbation kg with the surrounding layers. 
                //Layers that are closer will exchange more than those that are further (regardless of whether they are deeper or closer to the surface)

                //XIA : For the Luxembourg study case, the kind of organic matter will affect the overall amount of bioturbation
                //Namely, 'young' organic matter (edible, from hornbeam) will allow more bioturbation than 'old' organic matter (inedible, from beech)
                //I simply calculate how much of each type the soil has, and then let the ratio between the two co-determine bioturbation.

                double local_bioturbation_kg, layer_bioturbation_kg, interlayer_bioturbation_kg;
                double layer_bio_activity_index, total_bio_activity_index, mass_distance_sum, mass_distance_layer;
                int layer, otherlayer;
                double fine_otherlayer_mass, fine_layer_mass;
                double total_soil_thickness_m;
                double depth, otherdepth, distance, potential_bioturbation_kg_m2_y;
                total_mass_bioturbed_kg = 0;
                double[,] temp_tex_som_kg = new double[max_soil_layers, 7]; // this will hold temporary changed values of texture until all bioturbation is done
                double[] layer_0 = new double[7], layer_0_after = new double[7];
                double mass_soil_before = 0, mass_soil_after = 0, mass_top_before = 0, mass_top_after = 0;
                // if (findnegativetexture()) { Debugger.Break(); }
                double lux_hornbeam_OM_litter_fraction = 0;

                double total_young_som_kg, total_old_som_kg;


                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (t == 7000000 && row == 192 && col == 59) { diagnostic_mode = 1; }
                        else { diagnostic_mode = 0; }
                        if (dtm[row, col] != -9999 & soildepth_m[row, col] > 0)
                        {
                            remove_empty_layers(row, col);
                            update_all_soil_thicknesses(row, col);
                            total_young_som_kg = 0; total_old_som_kg = 0;
                            mass_soil_before = total_soil_mass(row, col);
                            mass_top_before = total_layer_mass(row, col, 0);
                            total_soil_thickness_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                if (layer == 0)
                                {
                                    for (int tex = 0; tex < 5; tex++)
                                    {
                                        layer_0[tex] = texture_kg[row, col, 0, tex];
                                    }
                                    layer_0[5] = young_SOM_kg[row, col, 0];
                                    layer_0[6] = old_SOM_kg[row, col, 0];
                                }

                                //if (layer == 0 & !(layerthickness_m[row, col, layer] > 0)) { Debugger.Break(); }
                                //remove_empty_layers(row, col);
                                //if (layer == 0 & !(layerthickness_m[row, col, layer] > 0)) { Debugger.Break(); }
                                if (total_layer_mass(row, col, layer) > 0)  //this says: if the layer actually exists
                                {
                                    for (int prop = 0; prop < 5; prop++) { temp_tex_som_kg[layer, prop] = texture_kg[row, col, layer, prop]; }
                                    temp_tex_som_kg[layer, 5] = young_SOM_kg[row, col, layer];
                                    temp_tex_som_kg[layer, 6] = old_SOM_kg[row, col, layer];
                                    total_soil_thickness_m += layerthickness_m[row, col, layer];

                                    total_young_som_kg += young_SOM_kg[row, col, layer];
                                    total_old_som_kg += old_SOM_kg[row, col, layer];
                                }
                            }

                            //LUX: in the lux case study, we need to know how much litter is hornbeam, i.e. palatable.
                            if (version_lux_checkbox.Checked)
                            {
                                if (total_young_som_kg + total_old_som_kg > 0)
                                {
                                    lux_hornbeam_OM_litter_fraction = total_young_som_kg / (total_young_som_kg + total_old_som_kg);
                                }
                                else
                                {  // ArT quickfix attempt
                                    lux_hornbeam_OM_litter_fraction = 0.5;
                                }
                            }
                            //select vegetation parameters, same as creep
                            potential_bioturbation_kg_m2_y = 4.5;
                            if (daily_water.Checked)
                            {
                                if (aridity_vegetation[row, col] < 1) { potential_bioturbation_kg_m2_y = 4 + 0.3; } // grassland
                                else { potential_bioturbation_kg_m2_y = 4 + 1.3; } // forest
                                                                                   // standard potential creep of 4 kg. 0.3 or 1.3 is added, based on vegetation type. Rates are derived from Wilkinson 2009: Breaking Ground and Gabet
                            }
                            // if (findnegativetexture()) { Debugger.Break(); }

                            // geen split voor voor depth decay voor verschillende vegetaties. Depth decay van creep aanhouden. 
                            //if(daily_water.Checked)
                            //{
                            //    if (aridity_vegetation[row, col] < 1)
                            //    {
                            //        pot_bt_vegetation_kg = 0.3; // kg / m2/ y, from Gabet
                            //        depth_dec_vegetation = -1 / (0.5 / 2); // m-1, estimated root depth of 0.5 m
                            //    }
                            //    else
                            //    {
                            //        pot_bt_vegetation_kg = 1.3; // kg / m2/ y, from Gabet et al., 2003: https://doi.org/10.1146/annurev.earth.31.100901.141314
                            //        depth_dec_vegetation = -1 / (1.5 / 2); // m-1, estimated root depth of 1.5 m
                            //    }

                            //    pot_bt_animals_kg = 3; //  average animal burrowing rate, 30 ton/ha/yr, from Wilkinson et al., 2009: https://doi.org/10.1016/j.earscirev.2009.09.005 
                            //    depth_dec_animals = -1 / (1.0 / 2); // estimated, no source
                            //}
                            //// divide in animals and vegetation. animals is constant, vegetation differs per sort. Make new function?


                            //here we calculate the first quantity: how much bioturbation kg needs to happen in this location
                            local_bioturbation_kg = potential_bioturbation_kg_m2_y * (1 - Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m)) * dx * dx * dt;
                            if (local_bioturbation_kg < 0) // local_bt == 0 happens when soil is absent
                            {
                                Debug.WriteLine(" error in local_bioturbation calculation : zero mass");
                                Debug.WriteLine(" total soil thickness :" + total_soil_thickness_m + " at rc " + row + " " + col);
                                Debug.WriteLine("err_sbt1");

                            }
                            //LUX: if Luxembourg version: we assume that only hornbeam litter leads to bioturbation. More of it - more bioturbation.
                            if (version_lux_checkbox.Checked) { local_bioturbation_kg *= lux_hornbeam_OM_litter_fraction; }

                            total_mass_bioturbed_kg += local_bioturbation_kg;



                            //now let's calculate layer-to-layer exchange to get to that local total needed.
                            depth = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {

                                if (total_layer_fine_earth_mass(row, col, layer) > 0)  //this says: if there is actually fine earth in the layer. 
                                                                                       // That is necessary because we leave the stone fraction out of bioturbation
                                                                                       // and therefore purely stony layers are not involved in bioturbation
                                {
                                    //integration over the exponential decay function in JGR 2006 for the entire profile, and for the current layer.
                                    //then calculate the fraction of bioturbation that will happen in this layer, and multiply with total bioturbation in this cell
                                    fine_layer_mass = total_layer_fine_earth_mass(row, col, layer);
                                    layer_bio_activity_index = Math.Exp(-bioturbation_depth_decay_constant * depth) - (Math.Exp(-bioturbation_depth_decay_constant * (depth + layerthickness_m[row, col, layer])));
                                    total_bio_activity_index = 1 - (Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m));
                                    layer_bioturbation_kg = (layer_bio_activity_index / total_bio_activity_index) * local_bioturbation_kg;
                                    mass_distance_sum = 0;
                                    depth += layerthickness_m[row, col, layer] / 2;
                                    otherdepth = 0; distance = 0;

                                    if (layerthickness_m[row, col, layer] <= 0) { Debug.WriteLine(" error: layer thickness is 0 at t " + t + " r " + row + " c " + col); }

                                    //now that we know how much bioturbation originates in this layer,
                                    //let's look at other layers and decide which one of them exchanges how much of that good stuff.
                                    for (otherlayer = 0; otherlayer < max_soil_layers; otherlayer++)
                                    {
                                        if (total_layer_fine_earth_mass(row, col, otherlayer) > 0)  //this says: if there is actually fine earth in the layer.
                                                                                                    // That is necessary because we leave the stone fraction out of bioturbation
                                                                                                    // and therefore purely stony layers are not involved in bioturbation
                                        {

                                            otherdepth += layerthickness_m[row, col, otherlayer] / 2;
                                            distance = Math.Abs(otherdepth - depth);

                                            if (distance < 0) { Debug.WriteLine(" distance between layers is 0 m at row " + row + " col " + col + " layerdepth " + depth + " otherlayerdepth " + otherdepth); }

                                            if (double.IsNaN(texture_kg[row, col, otherlayer, 1])) { Debug.WriteLine(" texture 1 NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(texture_kg[row, col, otherlayer, 2])) { Debug.WriteLine(" texture 2 NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(texture_kg[row, col, otherlayer, 3])) { Debug.WriteLine(" texture 3 NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(texture_kg[row, col, otherlayer, 4])) { Debug.WriteLine(" texture 4 NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(young_SOM_kg[row, col, otherlayer])) { Debug.WriteLine(" young som NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(old_SOM_kg[row, col, otherlayer])) { Debug.WriteLine(" old som NaN " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }

                                            if ((texture_kg[row, col, otherlayer, 1] < 0)) { Debug.WriteLine(" texture 1 null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if ((texture_kg[row, col, otherlayer, 2] < 0)) { Debug.WriteLine(" texture 2 null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if ((texture_kg[row, col, otherlayer, 3] < 0)) { Debug.WriteLine(" texture 3 null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if ((texture_kg[row, col, otherlayer, 4] < 0)) { Debug.WriteLine(" texture 4 null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if ((young_SOM_kg[row, col, otherlayer] < 0)) { Debug.WriteLine(" young som null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if ((old_SOM_kg[row, col, otherlayer] < 0)) { Debug.WriteLine(" old som null " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }

                                            if (otherlayer != layer) { mass_distance_sum += (texture_kg[row, col, otherlayer, 1] + texture_kg[row, col, otherlayer, 2] + texture_kg[row, col, otherlayer, 3] + texture_kg[row, col, otherlayer, 4] + young_SOM_kg[row, col, otherlayer] + old_SOM_kg[row, col, otherlayer]) / distance; }

                                            otherdepth += layerthickness_m[row, col, otherlayer] / 2;
                                            if (double.IsNaN(mass_distance_sum)) { Debug.WriteLine(" B NaN mass distance in bioturbation t " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(distance)) { Debug.WriteLine(" NaN  distance in bioturbation t " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                            if (double.IsNaN((layerthickness_m[row, col, otherlayer] / 2))) { Debug.WriteLine(" NaN layerthick in bioturbation t " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); }
                                        }
                                    }
                                    double check_mass_distance = 0;
                                    otherdepth = 0; distance = 0;
                                    double BT_fraction = 0;
                                    for (otherlayer = 0; otherlayer < max_soil_layers; otherlayer++)
                                    {
                                        otherdepth += layerthickness_m[row, col, otherlayer] / 2;
                                        if (total_layer_fine_earth_mass(row, col, otherlayer) > 0 && layer != otherlayer)  //this says: if the other layer actually exists and if it's not the current layer
                                        {

                                            distance = Math.Abs(otherdepth - depth);
                                            if (layer != otherlayer)
                                            {
                                                mass_distance_layer = (texture_kg[row, col, otherlayer, 1] + texture_kg[row, col, otherlayer, 2] + texture_kg[row, col, otherlayer, 3] + texture_kg[row, col, otherlayer, 4] + young_SOM_kg[row, col, otherlayer] + old_SOM_kg[row, col, otherlayer]) / distance;
                                            }
                                            else
                                            {
                                                mass_distance_layer = (texture_kg[row, col, otherlayer, 1] + texture_kg[row, col, otherlayer, 2] + texture_kg[row, col, otherlayer, 3] + texture_kg[row, col, otherlayer, 4] + young_SOM_kg[row, col, otherlayer] + old_SOM_kg[row, col, otherlayer]) / (layerthickness_m[row, col, otherlayer] / 2);
                                            }
                                            if (double.IsNaN(mass_distance_layer))
                                            {
                                                Debug.WriteLine(" NaN mass distance layer in bioturbation t " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer); Debug.WriteLine("err_sbt2");
                                            }
                                            if (mass_distance_sum == 0) { Debug.WriteLine(" zero mass distance sum"); }
                                            //here we calculate the amount of material bioturbated between the current layer and the current otherlayer
                                            interlayer_bioturbation_kg = layer_bioturbation_kg * (mass_distance_layer / mass_distance_sum);
                                            check_mass_distance += mass_distance_layer / mass_distance_sum;
                                            BT_fraction += mass_distance_layer / mass_distance_sum;
                                            if (interlayer_bioturbation_kg < 0)
                                            {
                                                Debug.WriteLine("err_sbt3");
                                            }
                                            if (double.IsNaN(interlayer_bioturbation_kg))
                                            {
                                                Debug.WriteLine(" NaN interlayer bioturbation kg in bioturbation t " + t + " rc " + row + " " + col + " layers " + layer + " " + otherlayer);
                                                Debug.WriteLine(" " + mass_distance_layer + " " + mass_distance_sum + " " + layer_bioturbation_kg);
                                                Debug.WriteLine("err_sbt4");

                                            }
                                            fine_otherlayer_mass = texture_kg[row, col, otherlayer, 1] + texture_kg[row, col, otherlayer, 2] + texture_kg[row, col, otherlayer, 3] + texture_kg[row, col, otherlayer, 4] + young_SOM_kg[row, col, otherlayer] + old_SOM_kg[row, col, otherlayer];
                                            if (double.IsNaN(fine_otherlayer_mass)) { Debug.WriteLine(" NaN fine otherlayer mass in bioturbation "); }
                                            if ((fine_otherlayer_mass <= 0))
                                            {
                                                Debug.WriteLine(" fineotherlayermass " + fine_otherlayer_mass + " t " + t + " rc " + row + "  " + col + " layers " + layer + " " + otherlayer);
                                                Debug.WriteLine("err_sbt5");
                                            }

                                            //weathered_mass_kg may be more than present in the other layer, the current layer, or both - in that case one or both of the layers will become mixtures of the original two layers
                                            double fromlayertomixture_kg = 0, fromotherlayertomixture_kg = 0, totalmixturemass_kg = 0, massfromlayer = 0, massfromotherlayer = 0, dmass_l, dmass_ol;
                                            double[] mixture_kg = new double[7];
                                            fromlayertomixture_kg = Math.Min(fine_layer_mass, (interlayer_bioturbation_kg / 2));
                                            fromotherlayertomixture_kg = Math.Min(fine_otherlayer_mass, (interlayer_bioturbation_kg / 2));
                                            // totalmixturemass_kg = fromlayertomixture_kg + fromotherlayertomixture_kg;

                                            if ((fromlayertomixture_kg + fromotherlayertomixture_kg) > 1E-6)  // if there is actual exchange (which is not the case when all fine material is removed)
                                            {
                                                //now add to mixture, and take from donors
                                                double massin_l = 0, massin_ol = 0;
                                                // texture
                                                for (int prop = 1; prop < 5; prop++)
                                                {
                                                    //checks
                                                    if (temp_tex_som_kg[layer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt6");
                                                    }
                                                    if (temp_tex_som_kg[otherlayer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt7");
                                                    }

                                                    //determine how much mass can be exchanged,. Do not take more than is present in the temporary layer to prevent negative textures in the end
                                                    //Should not happen, mass of top layer should stay constant, but happens anyway
                                                    dmass_l = (fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop];
                                                    dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop];

                                                    if (dmass_l > temp_tex_som_kg[layer, prop]) { dmass_l = temp_tex_som_kg[layer, prop]; }
                                                    if (dmass_ol > temp_tex_som_kg[otherlayer, prop]) { dmass_ol = temp_tex_som_kg[otherlayer, prop]; }

                                                    //take mass from donors to mix
                                                    mixture_kg[prop] += (dmass_l + dmass_ol);
                                                    massfromlayer += dmass_l;
                                                    massfromotherlayer += dmass_ol;

                                                    temp_tex_som_kg[layer, prop] -= dmass_l;
                                                    temp_tex_som_kg[otherlayer, prop] -= dmass_ol;

                                                    //mixture_kg[prop] += (fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop];
                                                    //if ((fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop] < 0) { Debugger.Break(); }
                                                    //massfromlayer += (fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop];
                                                    //mixture_kg[prop] += (fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop];
                                                    //massfromotherlayer += (fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop];
                                                    //if ((fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop] < 0) { Debugger.Break(); }

                                                    //temp_tex_som_kg[otherlayer, prop] -= (fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop];
                                                    //temp_tex_som_kg[layer, prop] -= (fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop];

                                                    if (temp_tex_som_kg[layer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt8");
                                                    }
                                                    if (temp_tex_som_kg[otherlayer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt9");
                                                    }

                                                }
                                                //young OM
                                                dmass_l = (fromlayertomixture_kg / fine_layer_mass) * (young_SOM_kg[row, col, layer]);
                                                dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * (young_SOM_kg[row, col, otherlayer]);

                                                if (dmass_l > temp_tex_som_kg[layer, 5]) { dmass_l = temp_tex_som_kg[layer, 5]; }
                                                if (dmass_ol > temp_tex_som_kg[otherlayer, 5]) { dmass_ol = temp_tex_som_kg[otherlayer, 5]; }

                                                //take mass from donors to mix
                                                mixture_kg[5] += (dmass_l + dmass_ol);
                                                massfromlayer += dmass_l;
                                                massfromotherlayer += dmass_ol;

                                                temp_tex_som_kg[layer, 5] -= dmass_l;
                                                temp_tex_som_kg[otherlayer, 5] -= dmass_ol;

                                                //old OM
                                                // if (layer == 0) { Debugger.Break(); }
                                                dmass_l = (fromlayertomixture_kg / fine_layer_mass) * (old_SOM_kg[row, col, layer]);
                                                dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * (old_SOM_kg[row, col, otherlayer]);

                                                if (dmass_l > temp_tex_som_kg[layer, 6]) { dmass_l = temp_tex_som_kg[layer, 6]; }
                                                if (dmass_ol > temp_tex_som_kg[otherlayer, 6]) { dmass_ol = temp_tex_som_kg[otherlayer, 6]; }

                                                //take mass from donors to mix
                                                mixture_kg[6] += (dmass_l + dmass_ol);
                                                massfromlayer += dmass_l;
                                                massfromotherlayer += dmass_ol;

                                                temp_tex_som_kg[layer, 6] -= dmass_l;
                                                temp_tex_som_kg[otherlayer, 6] -= dmass_ol;

                                                // checks
                                                if (temp_tex_som_kg[layer, 5] < 0)
                                                {
                                                    Debug.WriteLine("err_sbt10");
                                                }
                                                if (temp_tex_som_kg[otherlayer, 5] < 0)
                                                {
                                                    Debug.WriteLine("err_sbt11");
                                                }

                                                //now give from mixture to receivers
                                                totalmixturemass_kg = massfromlayer + massfromotherlayer;
                                                if (totalmixturemass_kg == 0)
                                                {
                                                    Debug.WriteLine("err_sbt11");
                                                }

                                                // if (findnegativetexture()) { Debugger.Break(); }


                                                for (int prop = 1; prop < 7; prop++)
                                                {
                                                    if (temp_tex_som_kg[layer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt12");
                                                    }
                                                    if (temp_tex_som_kg[otherlayer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt13");
                                                    }

                                                    if (mixture_kg[prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt14");
                                                    }
                                                    temp_tex_som_kg[otherlayer, prop] += mixture_kg[prop] * (massfromotherlayer / totalmixturemass_kg);
                                                    massin_ol += mixture_kg[prop] * (massfromotherlayer / totalmixturemass_kg);
                                                    temp_tex_som_kg[layer, prop] += mixture_kg[prop] * (massfromlayer / totalmixturemass_kg);
                                                    massin_l += mixture_kg[prop] * (massfromlayer / totalmixturemass_kg);
                                                    //mixture_kg[prop] = 0;  // that's not perse needed, but feels clean

                                                    if (temp_tex_som_kg[layer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt15");
                                                    }
                                                    if (temp_tex_som_kg[otherlayer, prop] < 0)
                                                    {
                                                        Debug.WriteLine("err_sbt16");
                                                    }
                                                }
                                            }


                                            //all sorts of checks - we should never have values under zero, or NotANumber NaN
                                            if (temp_tex_som_kg[otherlayer, 1] < 0)
                                            {
                                                Debug.WriteLine(" texture 1 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " (" + total_layer_mass(row, col, layer) + "kg) " + otherlayer + " (" + total_layer_mass(row, col, otherlayer) + "kg) ");
                                            }
                                            if (temp_tex_som_kg[otherlayer, 2] < 0) { Debug.WriteLine(" texture 2 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 3] < 0) { Debug.WriteLine(" texture 3 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 4] < 0) { Debug.WriteLine(" texture 4 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 5] < 0) { Debug.WriteLine(" young som null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 6] < 0) { Debug.WriteLine(" old som null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }

                                            if (temp_tex_som_kg[layer, 1] < 0) { Debug.WriteLine(" texture 1 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 2] < 0) { Debug.WriteLine(" texture 2 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 3] < 0) { Debug.WriteLine(" texture 3 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 4] < 0) { Debug.WriteLine(" texture 4 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 5] < 0) { Debug.WriteLine(" young som null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 6] < 0) { Debug.WriteLine(" old som null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }

                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 1]))
                                            {
                                                Debug.WriteLine(" texture 1 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " (" + total_layer_mass(row, col, layer) + "kg) " + otherlayer + " (" + total_layer_mass(row, col, otherlayer) + "kg) ");
                                            }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 2])) { Debug.WriteLine(" texture 2 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 3])) { Debug.WriteLine(" texture 3 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 4])) { Debug.WriteLine(" texture 4 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 5])) { Debug.WriteLine(" young som NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 6])) { Debug.WriteLine(" old som NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }

                                            if (double.IsNaN(temp_tex_som_kg[layer, 1])) { Debug.WriteLine(" texture 1 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 2])) { Debug.WriteLine(" texture 2 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 3])) { Debug.WriteLine(" texture 3 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 4])) { Debug.WriteLine(" texture 4 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 5])) { Debug.WriteLine(" young som NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 6])) { Debug.WriteLine(" old som NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                        }
                                        otherdepth += layerthickness_m[row, col, otherlayer] / 2;
                                    }
                                    //if (Math.Round(check_mass_distance,4) != 1) { Debugger.Break(); }
                                    //if (findnegativetexture()) { Debugger.Break(); }

                                    // if (Math.Round(BT_fraction, 6) != 1) { Debugger.Break(); }
                                    depth += layerthickness_m[row, col, layer] / 2;
                                }
                            } // end for layer
                              // now we know the new, bioturbated amounts in every layer in this row col, let's store them in the main texture_kg variables
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                if (layer == 0 & temp_tex_som_kg[0, 2] == 0)
                                {
                                    //Debug.WriteLine("err_sbt_16a. Possible empty top layer after BT 0: {0}, {1}, {2}, {3}, {4}, {5}, {6}. t {7}, row {8}, col {9}, dlayer {10}", layer_0[0], layer_0[1], layer_0[2], layer_0[3], layer_0[4], layer_0[5], layer_0[6], t, row, col, layerthickness_m[row, col, 0]);
                                    //this does not really test for an empty top layer - just for a silt-less top layer.
                                    if (layer == 0 & total_layer_fine_earth_mass(row, col, 0) == 0)
                                    {
                                        //this does!
                                        //Debug.WriteLine("confirmed!");
                                    }
                                }
                                for (int prop = 1; prop < 5; prop++)
                                {
                                    if (temp_tex_som_kg[layer, prop] < 0)
                                    {
                                        Debug.WriteLine("err_sbt17");
                                    }
                                    texture_kg[row, col, layer, prop] = temp_tex_som_kg[layer, prop];
                                    layer_0_after[prop] = temp_tex_som_kg[layer, prop];
                                    temp_tex_som_kg[layer, prop] = 0;
                                }
                                young_SOM_kg[row, col, layer] = temp_tex_som_kg[layer, 5];
                                old_SOM_kg[row, col, layer] = temp_tex_som_kg[layer, 6];
                                layer_0_after[5] = temp_tex_som_kg[layer, 5];
                                layer_0_after[6] = temp_tex_som_kg[layer, 6];
                                temp_tex_som_kg[layer, 5] = 0;
                                temp_tex_som_kg[layer, 6] = 0;
                            } //end for layer
                              // if (findnegativetexture()) { Debugger.Break(); }

                            mass_soil_after = total_soil_mass(row, col);
                            mass_top_after = total_layer_mass(row, col, 0);

                            if (Math.Abs(mass_soil_before - mass_soil_after) > 1E-8 | Math.Abs(mass_top_before - mass_top_after) > 1E-8)
                            {
                                Debug.WriteLine("Mass loss during bioturbation");
                                // Debugger.Break(); 
                            }

                        } // end dtm!=-9999
                    }// for col
                } // end for row
                  // if (findnegativetexture()) { Debugger.Break(); }


                if (timeseries.total_mass_bioturbed_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[19]] = total_mass_bioturbed_kg;
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_sbt20");
                }

            }
            catch { Debug.WriteLine(" No valid text in textbox bioturbation "); }

        } // nieuwe code van Arnaud

        void soil_litter_cycle()
        {
            // uses parameters from Carbon Cycle for now
            try
            {
                double litter_input_kg;

                //this line keeps young (hornbeam) OM completely gone from the surface every second year (reflecting that,
                //in reality, part of the year is unprotected). MvdM I added the else to rest the decomposition rate
                if (t % 2 == 0) { potential_young_decomp_rate = 1; } else { potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text); }

                calculate_TPI(7);
                double a = -0.33;
                double b = 28.33;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        //calculating hornbeam fraction
                        hornbeam_cover_fraction[row, col] = 1 - Math.Exp(a + b * tpi[row, col]) / (1 + Math.Exp(a + b * tpi[row, col]));


                        litter_input_kg = potential_OM_input; // MvdM no changes in litter input due to soil thickness. 

                        // All litter to litter layer matrix
                        litter_kg[row, col, 0] += .230 * (hornbeam_cover_fraction[row, col]); // Hornbeam
                        litter_kg[row, col, 1] += .403 * (1 - hornbeam_cover_fraction[row, col]); // Beech

                        // Decomposition
                        litter_kg[row, col, 0] *= (1 - .97); // Hornbeam
                        litter_kg[row, col, 1] *= (1 - .45); // Beech
                    }
                }
            }
            catch { Debug.WriteLine(" Crash in litter cycle "); }
        }

        void soil_carbon_cycle()
        {
            try
            {
                double local_OM_input_kg, layer_OM_input_kg;
                double young_decomposition_rate, old_decomposition_rate;
                //Debug.WriteLine("succesfully read parameters for soil carbon");
                double depth;
                double total_soil_thickness;
                double layer_OM_input_index, total_OM_input_index;
                int layer;
                total_OM_input_kg = 0;
                if (version_lux_checkbox.Checked)
                {
                    calculate_TPI(7);
                    double a = -0.33;
                    double b = 28.33;
                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            //calculating hornbeam fraction
                            hornbeam_cover_fraction[row, col] = 1 - Math.Exp(a + b * tpi[row, col]) / (1 + Math.Exp(a + b * tpi[row, col]));
                        }
                    }
                    //this line keeps young (hornbeam) OM completely gone from the surface every second year (reflecting that,
                    //in reality, part of the year is unprotected). MvdM I added the else to rest the decomposition rate
                    if (t % 2 == 0) { potential_young_decomp_rate = 1; } else { potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text); }
                }

                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cc1");
                }
                for (row = 0; row < nr; row++)
                {
                    //Parallel.For(0, nc, i =>                    //we parallelize over cols
                    for (col = 0; col < nc; col++)
                    {
                        if (daily_water.Checked)
                        {
                            if (aridity_vegetation[row, col] < 1) { potential_OM_input = 0.67; } // grassland
                            else { potential_OM_input = 0.62; } // forest
                            if (t > (end_time - 500)) { potential_OM_input = 0.42; } // arable land
                        }
                        total_soil_thickness = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, col, layer] > 0)
                            {
                                total_soil_thickness += layerthickness_m[row, col, layer];
                            }
                        }
                        local_OM_input_kg = potential_OM_input * (1 - Math.Exp(-OM_input_depth_decay_constant * total_soil_thickness)) * dx * dx * dt;
                        total_OM_input_kg += local_OM_input_kg;
                        depth = 0;


                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, col, layer] > 0)
                            {
                                // if (layer == 0) { Debugger.Break(); }
                                layer_OM_input_index = -1 / OM_input_depth_decay_constant * (Math.Exp(-OM_input_depth_decay_constant * (depth + layerthickness_m[row, col, layer])) - Math.Exp(-OM_input_depth_decay_constant * depth));
                                total_OM_input_index = -1 / OM_input_depth_decay_constant * (Math.Exp(-OM_input_depth_decay_constant * (total_soil_thickness)) - 1);
                                layer_OM_input_kg = (layer_OM_input_index / total_OM_input_index) * local_OM_input_kg;

                                if (version_lux_checkbox.Checked)
                                {
                                    young_SOM_kg[row, col, layer] += layer_OM_input_kg * (hornbeam_cover_fraction[row, col]);
                                    old_SOM_kg[row, col, layer] += layer_OM_input_kg * (1 - hornbeam_cover_fraction[row, col]);
                                }
                                else
                                {
                                    young_SOM_kg[row, col, layer] += layer_OM_input_kg * (1 - humification_fraction);
                                    old_SOM_kg[row, col, layer] += layer_OM_input_kg * (humification_fraction);
                                }
                                if (double.IsNaN(young_SOM_kg[row, col, layer]))
                                {
                                    Debug.WriteLine("err_cc2");
                                }
                                //decomposition gets lost as CO2 to the air (and soil water)
                                depth += layerthickness_m[row, col, layer] / 2;
                                //young_decomposition_rate = potential_young_decomp_rate * Math.Exp(-young_CTI_decay_constant * dynamic_TWI) * Math.Exp(-young_depth_decay_constant * depth);
                                //old_decomposition_rate = potential_old_decomp_rate * Math.Exp(-old_CTI_decay_constant * dynamic_TWI) * Math.Exp(-old_depth_decay_constant * depth);
                                young_decomposition_rate = potential_young_decomp_rate * 1 * Math.Exp(-young_depth_decay_constant * depth);
                                old_decomposition_rate = potential_old_decomp_rate * 1 * Math.Exp(-old_depth_decay_constant * depth);
                                young_SOM_kg[row, col, layer] *= (1 - young_decomposition_rate);
                                old_SOM_kg[row, col, layer] *= (1 - old_decomposition_rate);
                                //Debug.WriteLine(" cell  " + row + " " + col + " has layer_OM_input of " + layer_OM_input_kg);
                                depth += layerthickness_m[row, col, layer] / 2;
                                if (young_SOM_kg[row, col, layer] < 0 | old_SOM_kg[row, col, layer] < 0)
                                {
                                    Debug.WriteLine("err_cc3");
                                }
                            }

                        }
                    }

                }
                if (timeseries.total_OM_input_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[20]] = total_OM_input_kg;
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cc4");
                }

            }
            catch { Debug.WriteLine(" Crash in soil carbon cycle "); }

        }

        void soil_clay_translocation()
        {
            //possibly a function of local wetness / infiltration, but for now not/.
            double Iavg = 0, Imin = 10000000, Imax = 0;

            if (daily_water.Checked)
            {
                int Icount = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (Imin > Iy[row, col]) { Imin = Iy[row, col]; }
                            if (Imax < Iy[row, col]) { Imax = Iy[row, col]; }
                            Iavg += Iy[row, col];
                            Icount++;
                        }
                    }
                }
                Iavg /= Icount;
            }

            int layer;
            double eluviated_kg, depth;
            total_fine_eluviated_mass_kg = 0;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {


                        depth = 0;
                        for (layer = 0; layer < max_soil_layers - 1; layer++)   // we loop through all layers except the lower one - clay translocation there has no lower recipient
                        {
                            if (layerthickness_m[row, col, layer] > 0 && layerthickness_m[row, col, layer + 1] > 0)  // both source and sink layers have to exist.
                            {
                                if (texture_kg[row, col, layer, 4] > 0)
                                {
                                    depth += layerthickness_m[row, col, layer] / 2;
                                    double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    //calculate the mass of eluviation
                                    if (CT_depth_decay_checkbox.Checked) { eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 4] / totalweight)) * Math.Exp(-ct_depthdec * depth) * dt * dx * dx; }
                                    else { eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 4] / totalweight)) * dt * dx * dx; }
                                    //
                                    if (daily_water.Checked)
                                    {
                                        eluviated_kg *= waterfactor[row, col];
                                        ;

                                    }

                                    if (eluviated_kg > texture_kg[row, col, layer, 4]) { eluviated_kg = texture_kg[row, col, layer, 4]; }


                                    total_fine_eluviated_mass_kg += eluviated_kg;
                                    texture_kg[row, col, layer, 4] -= eluviated_kg;
                                    texture_kg[row, col, layer + 1, 4] += eluviated_kg;
                                    //improve for lowers - where does the fine clay go?
                                    //count the amount of clay and leached chem exiting catchment
                                    // SOIL possibly improve with coarse clay fraction
                                    depth += layerthickness_m[row, col, layer] / 2;
                                }
                            }
                        }
                    }
                }
                if (timeseries.total_fine_eluviated_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[18]] = total_fine_eluviated_mass_kg;
                }
            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_clay_translocation_Jagercikova()
        {
            double ct_adv0, ct_adv0_all, ct_dd, ct_dd_all;
            ct_adv0_all = Convert.ToDouble(ct_v0_Jagercikova.Text);
            ct_dd_all = Convert.ToDouble(ct_dd_Jagercikova.Text);
            ct_adv0 = ct_adv0_all;
            ct_dd = ct_dd_all;

            try
            {
                // based on the advection-diffusion equation of Jagercikova et al., 2017 https://doi.org/10.1007/s11368-016-1560-9
                // We only added the advection part, because the diffusion represents bioturbation and that is already modeled elsewhere
                double local_I;


                double depth, f_clay, f_oc, d_depth, ct_advi, eluviated_kg, CEC_ct, CCEC_ct, wdclay;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (NA_in_soil(row, col))
                            {
                                Debug.WriteLine("ctj1");
                            }

                            if (daily_water.Checked)
                            {
                                local_I = Math.Max(Iy[row, col], 0);
                                ct_adv0 = ct_adv0_all * (1 - Math.Exp(-local_I / (2.0 * (1.0 / 3)))); // Exponential function to determine v0, based on infiltration. The function approaches a v0 of 1. I of 0.5~v0 of 0.5. the 2 indicates the range of the variogram. 
                                ct_dd = ct_dd_all - (1 - Math.Exp(-local_I / (2.0 * (1.0 / 3)))); // adjust depth decay, by subtracting 
                            }

                            depth = 0;
                            for (int layer = 0; layer < max_soil_layers; layer++) // we loop through all layers. Lowest layer has no recipient, so there we have free drainage of clay
                            {
                                if (layerthickness_m[row, col, layer] > 0)  // source layer has to exist. Adjusted for free drainage, receiving layer doesn't have to be present
                                {

                                    if (texture_kg[row, col, layer, 3] > 0)
                                    {
                                        depth += layerthickness_m[row, col, layer] / 2;



                                        f_clay = texture_kg[row, col, layer, 3] / (texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3]); // fine earth fraction of clay. No fine clay
                                        f_oc = (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) / (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3]); // fine earth fraction of clay. No fine clay
                                        f_oc /= 1.72; // calculate from SOM to SOC: https://www.researchgate.net/post/How_can_I_convert_percent_soil_organic_matter_into_soil_C

                                        if ((layer + 1) < max_soil_layers)
                                        {
                                            d_depth = (layerthickness_m[row, col, layer] + layerthickness_m[row, col, layer + 1]) / 2; // distance from mid-point to mid-point of source and sink cell
                                        }
                                        else // eluviation from lowest layer
                                        {
                                            d_depth = (layerthickness_m[row, col, layer] + layerthickness_m[row, col, layer - 1]) / 2; // use distance to higher cell as reference
                                        }

                                        // Eluviation limited by association with OM and CEC (equations from Model 2 of Brubaker et al, 1992: estimating the water-dispersible clay content of soils)
                                        // CEC estimated with PTF from Foth and Ellis 1996, as used in Finke 2012
                                        CEC_ct = (32 + 3670 * f_oc + 196 * f_clay) / 10; // cmol+/kg
                                        CCEC_ct = CEC_ct - 300 * f_oc; // carbon corrected CEC
                                        if (f_clay == 0) { f_clay = 0.000001; } // prevent dividing by 0. clay percentage of 1% always has absent dispersible clay
                                        wdclay = (0.369 * (f_clay * 100) - 8.96 * (CCEC_ct / (f_clay * 100)) + 4.48) / 100; // fraction of clay that can be dispersed
                                        if (wdclay < 0) { wdclay = 0; } // prevent negative water-dispersible clay


                                        // if (t == 3000) { Debugger.Break(); }
                                        // advection
                                        ct_advi = ct_adv0 * Math.Exp(-ct_dd * depth);
                                        eluviated_kg = ct_advi / 100 * bulkdensity[row, col, layer] * f_clay * dx * dx;
                                        // eluviated_kg = 1 / d_depth * (ct_advi * f_clay) * 1000 / bulkdensity[row, col, layer];

                                        if (eluviated_kg > (texture_kg[row, col, layer, 3] * wdclay))
                                        {
                                            eluviated_kg = texture_kg[row, col, layer, 3] * wdclay;
                                        }


                                        if (eluviated_kg > texture_kg[row, col, layer, 3]) { eluviated_kg = texture_kg[row, col, layer, 3]; } // correct for too muchy clay eluviating, not necessary anymore due to limitation water-dispersible clay




                                        total_fine_eluviated_mass_kg += eluviated_kg;
                                        texture_kg[row, col, layer, 3] -= eluviated_kg;
                                        if ((layer + 1) < max_soil_layers) { texture_kg[row, col, layer + 1, 3] += eluviated_kg; } // in case there is a lower receiving layer


                                        depth += layerthickness_m[row, col, layer] / 2;

                                    }

                                    if (NA_in_soil(row, col))
                                    {
                                        Debug.WriteLine("err_ctj2");
                                    }


                                }
                            }
                        }
                    }
                    if (timeseries.total_fine_eluviated_checkbox.Checked)
                    {
                        timeseries_matrix[t, timeseries_order[18]] = total_fine_eluviated_mass_kg;
                    }
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_ctj3");
                }

            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_silt_translocation()
        {
            //in Spitsbergen, it is mostly silt (with attendant clay) that gets translocated in the profile. Clay is not modelled in itself

            int layer;
            double eluviated_kg;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        for (layer = 0; layer < max_soil_layers - 1; layer++)   // we loop through all layers except the lower one - clay translocation there has no lower recipient
                        {
                            if (layerthickness_m[row, col, layer] > 0 && layerthickness_m[row, col, layer + 1] > 0)  // both source and sink layers have to exist.
                            {
                                if (texture_kg[row, col, layer, 2] > 0)
                                {
                                    //calculate the mass of eluviation
                                    eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 2])) * dt * dx * dx;
                                    texture_kg[row, col, layer, 2] -= eluviated_kg;
                                    if (texture_kg[row, col, layer, 2] < 0) { Debug.WriteLine("error: too much clay eluviation "); }
                                    texture_kg[row, col, layer + 1, 2] += eluviated_kg;
                                    //improve for lowers
                                    //count the amount of clay and leached chem exiting catchment
                                    // SOIL possibly improve with coarse clay fraction
                                }
                            }
                        }
                    }
                }
            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_decalcification()
        {
            // develop: erosion of carbonates, link to clay fraction? Or transport CO3_kg with the rest of the sediments?

            // Decalcification depends on the amount of percolation, according to Egli and Fitze (2001). The function below is a linear regression between the data in their paper. This function should work as a simple test. more complicated functions, with equilibria and secondary carbonates are possible
            try
            {
                double CO3_loss;
                // Carbonate losses [mol m-2 y-1] = 205.58 * percolation [m] - 12.392
                // Infiltration / percolation is modeled in m, so adjustments have to be made for cell size. In every step? 
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            CO3_loss = (205.58 * Iy[row, col] - 12.392) * (dx * dx) * 60.01; // Corrected the equation for cell size (dx*dx) and molar mass (60.01 g mol-1)
                            if (CO3_loss < 0) { CO3_loss = 0; }

                            int layer = 0;
                            while (CO3_loss > 0)
                            {
                                //Debug.WriteLine("dec1");
                                if (CO3_kg[row, col, layer] > 0)
                                {
                                    //Debug.WriteLine("dec1a");
                                    if (CO3_kg[row, col, layer] >= CO3_loss)
                                    {
                                        //Debug.WriteLine("dec2");
                                        CO3_kg[row, col, layer] -= CO3_loss;
                                        CO3_loss = 0;
                                    }
                                    else
                                    {
                                        //Debug.WriteLine("dec3");
                                        CO3_loss -= CO3_kg[row, col, layer];
                                        CO3_kg[row, col, layer] = 0;
                                        if (layer < (max_soil_layers - 1)) { layer++; }
                                        else { CO3_loss = 0; }// all CO3 is removed from the catchment
                                    }
                                    //Debug.WriteLine("dec4");
                                }
                                else
                                {
                                    //Debug.WriteLine("dec5");
                                    if (layer < (max_soil_layers - 1)) { layer++; }
                                    else { CO3_loss = 0; }// all CO3 is removed from the catchment
                                    ;
                                }
                            }
                            //Debug.WriteLine("layer decalc: {0}", layer);
                        }
                    }
                }
            }
            catch
            {
                MessageBox.Show("error in decalcification");
            }
        }

        void lessivage_calibration(int row, int col, int cal)
        {
            //Debug.Write(Cclay + " " + max_eluviation + " " + ct_depthdec + " ");
            //double[] lp4 = new double[,]{0.09, 0.09,0.09, 0.10, 0.16, 0.16, 0.19, 0.19, 0.19, 0.16, 0.16, 0.16, 0.16, 0.13, 0.13, 0.13, 0.13, 0.13, 0.13, 0.13};

            double[,] lp4 = new double[6, 2] { { .31, .09 }, { .45, .10 }, { .62, .16 }, { .90, .19 }, { 1.35, .16 }, { 2.0, .13 } };
            double depth, err, rmse_ct, me_ct, lp4_clay;
            int lp4_row = 0;
            int layercount = 0;
            rmse_ct = 0;
            me_ct = 0;
            depth = 0;
            Debug.WriteLine(rmse_ct + ", " + me_ct);
            for (int layer = 0; layer < max_soil_layers; layer++)
            {
                if (layerthickness_m[row, col, layer] > 0)
                {
                    depth += layerthickness_m[row, col, layer] / 2;
                    if (depth <= lp4[5, 0])
                    {
                        double totalweight = texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]; // calibrate on fine soil fraction only
                        while (depth > lp4[lp4_row, 0])
                        {
                            lp4_row++;
                        }
                        lp4_clay = lp4[lp4_row, 1];

                        err = ((texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight) - lp4_clay;
                        rmse_ct += err * err;
                        me_ct += err;
                        layercount += 1;
                    }

                    depth += layerthickness_m[row, col, layer] / 2;
                }

            }
            Debug.WriteLine(layercount);
            rmse_ct = Math.Pow(rmse_ct / layercount, .5);
            me_ct = me_ct / layercount;
            //Debug.Write(rmse_ct + " " + me_ct);
            //Debug.WriteLine("");//start on new line
            lessivage_errors[cal, 0] = Cclay;
            lessivage_errors[cal, 1] = max_eluviation;
            lessivage_errors[cal, 2] = ct_depthdec;
            lessivage_errors[cal, 3] = rmse_ct;
            lessivage_errors[cal, 4] = me_ct;
        }

        #endregion

        #region Geomorphic processes code

        int NA_in_map(double[,] map)
        {
            int NA_count = 0;

            try
            {
                for (int rowNA = 0; rowNA < nr; rowNA++)
                {
                    for (int colNA = 0; colNA < nc; colNA++)
                    {
                        if (Double.IsNaN(map[rowNA, colNA]) | Double.IsInfinity(map[rowNA, colNA]))
                        {
                            NA_count++;
                            Debug.WriteLine("NA at row {0}, col {1}", rowNA, colNA);
                        }
                    }
                }

            }
            catch
            {
                Debug.WriteLine("err_NAmap1");

            }
            return (NA_count);
        }

        bool NA_in_soil(int rowNA, int colNA)
        {
            bool boolNA = false;
            for (int layNA = 0; layNA < max_soil_layers; layNA++)
            {
                for (int texNA = 0; texNA < 5; texNA++)
                {
                    if (Double.IsNaN(texture_kg[rowNA, colNA, layNA, texNA]) | Double.IsInfinity(texture_kg[rowNA, colNA, layNA, texNA]))
                    {
                        boolNA = true;
                        Debug.WriteLine("NA in row {0}, col {1}, lay {2}, tex {3}", rowNA, colNA, layNA, texNA);
                    }

                }
                if (Double.IsNaN(young_SOM_kg[rowNA, colNA, layNA]) | Double.IsInfinity(young_SOM_kg[rowNA, colNA, layNA]))
                {
                    boolNA = true;
                    Debug.WriteLine("NA in row {0}, col {1}, lay {2}, young OM, val {3}", rowNA, colNA, layNA, young_SOM_kg[rowNA, colNA, layNA]);
                }

                if (Double.IsNaN(old_SOM_kg[rowNA, colNA, layNA]) | Double.IsInfinity(old_SOM_kg[rowNA, colNA, layNA]))
                {
                    boolNA = true;
                    Debug.WriteLine("NA in row {0}, col {1}, lay {2}, old OM, val {3}", rowNA, colNA, layNA, old_SOM_kg[rowNA, colNA, layNA]);
                }
            }

            return (boolNA);
        }

        bool NA_anywhere_in_soil()
        {

            bool boolNA = false;
            try
            {
                for (int rowNA = 0; rowNA < nr; rowNA++)
                {
                    for (int colNA = 0; colNA < nc; colNA++)
                    {
                        if (NA_in_soil(rowNA, colNA) == true) { boolNA = true; }
                    }
                }

            }
            catch
            {
                Debug.WriteLine("err_NAmap1");

            }
            return (boolNA);
        }

        int NA_in_location(double[,] map, int rowNA, int colNA)
        {
            int NA_count = 0;
            try
            {
                if (Double.IsNaN(map[rowNA, colNA]) | Double.IsInfinity(map[rowNA, colNA]))
                {
                    NA_count++;
                    Debug.WriteLine("NA at row {0}, col {1}", rowNA, colNA);
                }
            }
            catch
            {
                Debug.WriteLine("err_nal1");

            }
            return (NA_count);
        }

        void calculate_water_ero_sed_daily()
        {
            if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
            {
                Debug.WriteLine("we1");
            }

            double mass_before = total_catchment_mass(), mass_after, mass_export = 0;
            //Debug.WriteLine("WE1");
            int size, dir;
            double water_out, flow_between_cells_m3_per_m, total_sediment_in_transport_kg, rock_fraction, mass_to_be_eroded, selectivity_fraction, total_ero = 0, total_dep = 0, potential_transported_amount_kg, vegetation_cover_fraction;
            double[] total_mass_eroded = new double[7] { 0, 0, 0, 0, 0, 0, 0 };
            double[] total_mass_deposited = new double[7] { 0, 0, 0, 0, 0, 0, 0 };


            double[,,] local_mass_balance = new double[nr, nc, 5]; // 0: mass in, 1: mass out, 2: mass ero, 3: mass sed, 4: Q_out

            double[,] mass_difference_input_output = new double[nr, nc];

            // 1: set all water and sediment flow to 0
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    {
                        if (only_waterflow_checkbox.Checked == false)
                        {

                            for (size = 0; size < n_texture_classes; size++)
                            {
                                sediment_in_transport_kg[row, col, size] = 0;
                            }
                            old_SOM_in_transport_kg[row, col] = 0;
                            young_SOM_in_transport_kg[row, col] = 0;
                            dz_ero_m[row, col] = 0;
                            dz_sed_m[row, col] = 0;
                            lake_sed_m[row, col] = 0;

                            for (int iter = 0; iter < 5; iter++)
                            {
                                local_mass_balance[row, col, iter] = 0;
                            }
                        }
                    }
                }  // end for col
            }  //end for row
               //Debug.WriteLine("WE2");

            // 2: Iterate through rows and columns
            int runner = 0;
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {

                if (index[runner] != -9999)
                {
                    //if (row == 40 & col == 31) { displaysoil(40, 31); Debugger.Break(); }

                    row = row_index[runner]; col = col_index[runner];

                    // local mass balance
                    local_mass_balance[row, col, 4] = OFy_m[row, col, 0];

                    //Debug.WriteLine("WE3");

                    // 3: Determine fraction of water flowing to lower neighbour
                    water_out = 0;
                    for (int dir2 = 1; dir2 < 9; dir2++)
                    {
                        water_out += OFy_m[row, col, dir2];
                        //if (col == 12 && dir2 == 1) { Debugger.Break(); }
                        // if (t == 1) { Debugger.Break(); }
                    }
                    double fracsum = 0;


                    if (water_out > 0)
                    {
                        // Debug.WriteLine("Overland flow in col {0}", col);
                        dir = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!((i == 0) && (j == 0))) { dir++; }

                                dh = 0; fraction = 0; transport_capacity_kg = 0;


                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        // Debug.WriteLine("row = {0}, col = {1}, dir = {2}, i = {3}, j = {4}",row,col,dir,i,j);
                                        dh = dtm[row, col] - dtm[row + i, col + j];
                                        //Debug.WriteLine("Source: {0}, sink: {1}", dtm[row, col], dtm[row + i, col + j]);
                                        d_x = dx;
                                        //if (col + j == 0) { Debugger.Break(); }

                                        if (dh > 0)
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            dh /= d_x;

                                            fraction = OFy_m[row, col, dir] / water_out;
                                            fracsum += fraction;
                                            flow_between_cells_m3_per_m = OFy_m[row, col, dir] * dx * dx / dx; // 

                                            //Debug.WriteLine("WE4");

                                            // 4: Determine transport capacity
                                            transport_capacity_kg = advection_erodibility * (bulkdensity[row, col, 0] * dx * dx) * (Math.Pow(flow_between_cells_m3_per_m, m) * Math.Pow(dh, n));
                                            if (transport_capacity_kg < 0) { transport_capacity_kg = 0; Debug.WriteLine(" Warning: negative transport capacity at" + row + " " + col); } // warning. This should never happen

                                            total_sediment_in_transport_kg = 0;
                                            for (size = 0; size < n_texture_classes; size++)
                                            {
                                                total_sediment_in_transport_kg += fraction * sediment_in_transport_kg[row, col, size]; //all in kg.
                                            } // organic matter doesn't count for total matter in transport


                                            // 5: Determine transport / erosion / sedimentation

                                            //Debug.WriteLine("WE5a");

                                            // 5a: Transport
                                            if (transport_capacity_kg == total_sediment_in_transport_kg)
                                            {
                                                // everything gets transported
                                                for (size = 0; size < n_texture_classes; size++)
                                                {
                                                    sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];  //all in kg 

                                                    // local mass balance
                                                    local_mass_balance[row + i, col + j, 0] += fraction * sediment_in_transport_kg[row, col, size]; // incoming mass
                                                    local_mass_balance[row, col, 1] += fraction * sediment_in_transport_kg[row, col, size]; // outgoing mass
                                                }
                                                old_SOM_in_transport_kg[row + i, col + j] += fraction * old_SOM_in_transport_kg[row, col];  //all in kg
                                                young_SOM_in_transport_kg[row + i, col + j] += fraction * young_SOM_in_transport_kg[row, col];  //all in kg
                                            }

                                            //Debug.WriteLine("WE5b");

                                            // 5b: Erosion
                                            if (transport_capacity_kg > total_sediment_in_transport_kg)
                                            {
                                                // everything we want to transport gets transported, plus a little bit extra
                                                for (size = 0; size < n_texture_classes; size++)
                                                {
                                                    sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];  //all in kg 

                                                    // local mass balance
                                                    local_mass_balance[row + i, col + j, 0] += fraction * sediment_in_transport_kg[row, col, size]; // incoming mass
                                                    local_mass_balance[row, col, 1] += fraction * sediment_in_transport_kg[row, col, size]; // outgoing mass
                                                }
                                                old_SOM_in_transport_kg[row + i, col + j] += fraction * old_SOM_in_transport_kg[row, col];  //all in kg
                                                young_SOM_in_transport_kg[row + i, col + j] += fraction * young_SOM_in_transport_kg[row, col];  //all in kg

                                                // to calculate the (possibly) extra amount we are going to transport, we first evaluate whether we exceed the erosion threshold   
                                                if ((transport_capacity_kg - total_sediment_in_transport_kg) > erosion_threshold_kg)
                                                {

                                                    //first, calculate how much we are going to erode. Not as much as we want to if the soil is protected by rocks or plants
                                                    rock_fraction = texture_kg[row, col, 0, 0] / (texture_kg[row, col, 0, 0] + texture_kg[row, col, 0, 1] + texture_kg[row, col, 0, 2] + texture_kg[row, col, 0, 3] + texture_kg[row, col, 0, 4]);
                                                    if (aridity_vegetation[row, col] >= 1) { vegetation_cover_fraction = 1; }
                                                    else { vegetation_cover_fraction = aridity_vegetation[row, col]; }// 
                                                    mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg) * Math.Exp(-rock_protection_constant * rock_fraction) * Math.Exp(-bio_protection_constant * vegetation_cover_fraction);
                                                    // DEVELOP MM changing vegetation cover in a year

                                                    // second, calculate how the mass to be eroded is taken from the different size fractions: selectivity

                                                    // if total transport capacity is small, only the finer fractions will be eroded (selectivity with diameter to power 0.5). 
                                                    //For larger transport capacities, selectivity decreases (diameter to power 0 = equal between fractions)

                                                    double constant_b1 = 0.5 * Math.Exp(constant_selective_transcap * transport_capacity_kg);
                                                    double sum_diameter_power = 0;
                                                    for (size = 0; size < 5; size++)
                                                    {
                                                        sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], constant_b1);
                                                    }
                                                    double clayeroded_0_kg = 0, claypresent_0_kg = 0, clayeroded_1_kg = 0, claypresent_1_kg = 0;


                                                    for (size = 0; size < 5; size++)
                                                    {

                                                        selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], constant_b1)) / sum_diameter_power;    // unit [-]
                                                        if (texture_kg[row, col, 0, size] >= selectivity_fraction * mass_to_be_eroded)
                                                        {    // typical situation
                                                            if (size > 2)
                                                            {
                                                                clayeroded_0_kg += selectivity_fraction * mass_to_be_eroded;
                                                                claypresent_0_kg += texture_kg[row, col, 0, size];

                                                            }
                                                            mass_difference_input_output[row, col] += selectivity_fraction * mass_to_be_eroded;
                                                            total_mass_eroded[size] += selectivity_fraction * mass_to_be_eroded;
                                                            texture_kg[row, col, 0, size] -= selectivity_fraction * mass_to_be_eroded;   // unit [kg]
                                                            sediment_in_transport_kg[row + i, col + j, size] += selectivity_fraction * mass_to_be_eroded;  // unit [kg]
                                                            total_ero += selectivity_fraction * mass_to_be_eroded;


                                                            // local mass balance
                                                            local_mass_balance[row + i, col + j, 0] += selectivity_fraction * mass_to_be_eroded; // incoming mass next cell
                                                            local_mass_balance[row, col, 1] += selectivity_fraction * mass_to_be_eroded; // outgoing mass current cell
                                                            local_mass_balance[row, col, 2] += selectivity_fraction * mass_to_be_eroded; // eroded mass current cell


                                                        }
                                                        else
                                                        {
                                                            // exceptional. If we want to erode more than present in the layer, we will take it from one layer down.
                                                            //this is to avoid exceptionally thin rocky layers blocking all erosion
                                                            mass_difference_input_output[row, col] += texture_kg[row, col, 0, size];
                                                            total_mass_eroded[size] += texture_kg[row, col, 0, size];
                                                            double left = (selectivity_fraction * mass_to_be_eroded) - texture_kg[row, col, 0, size]; // unit [kg]

                                                            sediment_in_transport_kg[row + i, col + j, size] += texture_kg[row, col, 0, size];
                                                            total_ero += texture_kg[row, col, 0, size];

                                                            if (size > 2)
                                                            {
                                                                clayeroded_0_kg += texture_kg[row, col, 0, size];
                                                                claypresent_0_kg += 0;
                                                            }

                                                            // local mass balance
                                                            local_mass_balance[row + i, col + j, 0] += texture_kg[row, col, 0, size]; // incoming mass next cell
                                                            local_mass_balance[row, col, 1] += texture_kg[row, col, 0, size]; // outgoing mass current cell
                                                            local_mass_balance[row, col, 2] += texture_kg[row, col, 0, size]; // eroded mass current cell

                                                            texture_kg[row, col, 0, size] = 0;

                                                            if (texture_kg[row, col, 1, size] >= left)
                                                            {   // typical
                                                                mass_difference_input_output[row, col] += left;
                                                                total_mass_eroded[size] += left;
                                                                if (size > 2)
                                                                {
                                                                    clayeroded_1_kg += left;
                                                                    claypresent_1_kg += texture_kg[row, col, 1, size] - left;
                                                                }

                                                                texture_kg[row, col, 1, size] -= left;  // unit [kg]
                                                                sediment_in_transport_kg[row + i, col + j, size] += left;  // unit [kg]
                                                                total_ero += left;


                                                                // local mass balance
                                                                local_mass_balance[row + i, col + j, 0] += left; // incoming mass next cell
                                                                local_mass_balance[row, col, 1] += left; // outgoing mass current cell
                                                                local_mass_balance[row, col, 2] += left; // eroded mass current cell


                                                            }
                                                            else
                                                            {

                                                                total_mass_eroded[size] += texture_kg[row, col, 1, size];
                                                                mass_difference_input_output[row, col] += texture_kg[row, col, 1, size];

                                                                if (size > 2)
                                                                {
                                                                    clayeroded_1_kg += texture_kg[row, col, 1, size];
                                                                    claypresent_1_kg += 0; //MM Leidt dit niet tot delen door nul?
                                                                }

                                                                sediment_in_transport_kg[row + i, col + j, size] += texture_kg[row, col, 1, size];// unit [kg] // MM adjusted in water erosion
                                                                total_ero += texture_kg[row, col, 1, size];

                                                                // local mass balance
                                                                local_mass_balance[row + i, col + j, 0] += texture_kg[row, col, 1, size]; // incoming mass next cell
                                                                local_mass_balance[row, col, 1] += texture_kg[row, col, 1, size]; // outgoing mass current cell
                                                                local_mass_balance[row, col, 2] += texture_kg[row, col, 1, size]; // eroded mass current cell


                                                                texture_kg[row, col, 1, size] = 0;

                                                            } // end else 

                                                        }
                                                    } // end size

                                                    //organic matter. // 3c2. Organic matter maximaal erosie = die fractie van OM in de geerodeerde lagen die overeenkomt met de fractie geerodeerde fine earth in de geerodeerde lagen. is eroded as a fraction of total OM. That fraction equals the fraction of clay eroded from the layer
                                                    // do not forget (after all erosion and depositionthe assumption underlying this is done) to recalculate the thickness of layers and adapt the dtm to that. clay and humus are bound in aggregates
                                                    //this does not cover: LMW SOM, peat or large woody debris
                                                    double clayerodedfraction_0;
                                                    if (clayeroded_0_kg > 0) { clayerodedfraction_0 = clayeroded_0_kg / (clayeroded_0_kg + claypresent_0_kg); }
                                                    else { clayerodedfraction_0 = 0; }


                                                    double clayerodedfraction_1;
                                                    if (clayeroded_1_kg > 0) { clayerodedfraction_1 = clayeroded_1_kg / (clayeroded_1_kg + claypresent_1_kg); }
                                                    else { clayerodedfraction_1 = 0; }
                                                    old_SOM_in_transport_kg[row + i, col + j] += old_SOM_kg[row, col, 0] * clayerodedfraction_0 + old_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                    young_SOM_in_transport_kg[row + i, col + j] += young_SOM_kg[row, col, 0] * clayerodedfraction_0 + young_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                    total_mass_eroded[5] += old_SOM_kg[row, col, 0] * clayerodedfraction_0 + old_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                    total_mass_eroded[6] += young_SOM_kg[row, col, 0] * clayerodedfraction_0 + young_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                    old_SOM_kg[row, col, 0] *= (1 - clayerodedfraction_0);
                                                    young_SOM_kg[row, col, 0] *= (1 - clayerodedfraction_0);
                                                    old_SOM_kg[row, col, 1] *= (1 - clayerodedfraction_1);
                                                    young_SOM_kg[row, col, 1] *= (1 - clayerodedfraction_1);

                                                    if (double.IsNaN(young_SOM_kg[row, col, 0]))
                                                    {
                                                        Debug.WriteLine("err_we2");
                                                    }

                                                    //Local Mass balance klopt niet meer met OM erbij



                                                }
                                                else
                                                {
                                                    //do nothing. We wanted to erode, but not enough so to actually exceed the threshold and actually do that
                                                }
                                            }
                                            //Debug.WriteLine("WE5c");

                                            // 5c: Sedimentation
                                            if (transport_capacity_kg < total_sediment_in_transport_kg)
                                            {

                                                //first, calculate how much we are going to keep in transport. This is the way that selectivity works now. 
                                                double sum_diameter_power = 0, clay_deposited = 0, clay_transported = 0;
                                                for (size = 0; size < 5; size++)
                                                {
                                                    sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], 0.5);
                                                }

                                                for (size = 0; size < 5; size++)
                                                {
                                                    selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], 0.5)) / sum_diameter_power;    // unit [-]
                                                    potential_transported_amount_kg = selectivity_fraction * transport_capacity_kg;                      // unit [kg]

                                                    if (potential_transported_amount_kg < (fraction * sediment_in_transport_kg[row, col, size]))
                                                    {
                                                        total_mass_deposited[size] += fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;
                                                        total_mass_eroded[size] -= fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;
                                                        mass_difference_input_output[row, col] -= fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;

                                                        // local mass balance
                                                        local_mass_balance[row, col, 3] += fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg; // deposition mass current cell
                                                        local_mass_balance[row + i, col + j, 0] += potential_transported_amount_kg; // incoming mass next cell
                                                        local_mass_balance[row, col, 1] += potential_transported_amount_kg; // outgoing mass current cell


                                                        texture_kg[row, col, 0, size] += fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;        // unit [kg]
                                                        total_dep += fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;
                                                        sediment_in_transport_kg[row + i, col + j, size] += potential_transported_amount_kg;                                    // unit [kg]  


                                                        if (size > 2)
                                                        {
                                                            clay_deposited += fraction * sediment_in_transport_kg[row, col, size] - potential_transported_amount_kg;
                                                            clay_transported += potential_transported_amount_kg;
                                                        }

                                                        //if(size==3 || size==4) { organic_selectivity_fraction += selectivity_fraction; }
                                                    }
                                                    else
                                                    {
                                                        //do nothing. We keep the sediment in transport, and do not deposit anything
                                                        sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];


                                                        // local mass balance
                                                        local_mass_balance[row + i, col + j, 0] += fraction * sediment_in_transport_kg[row, col, size]; // incoming mass next cell
                                                        local_mass_balance[row, col, 1] += fraction * sediment_in_transport_kg[row, col, size]; // outgoing mass current cell
                                                    }
                                                }
                                                // now organic matter. 
                                                double claydepfraction = 0;
                                                if (clay_deposited > 0) { claydepfraction = clay_deposited / (clay_deposited + clay_transported); }
                                                total_mass_deposited[5] += fraction * young_SOM_in_transport_kg[row, col] * claydepfraction;
                                                total_mass_deposited[6] += fraction * old_SOM_in_transport_kg[row, col] * claydepfraction;
                                                young_SOM_kg[row, col, 0] += fraction * young_SOM_in_transport_kg[row, col] * claydepfraction;
                                                old_SOM_kg[row, col, 0] += fraction * old_SOM_in_transport_kg[row, col] * claydepfraction;

                                                young_SOM_in_transport_kg[row + i, col + j] += fraction * young_SOM_in_transport_kg[row, col] * (1 - claydepfraction);
                                                old_SOM_in_transport_kg[row + i, col + j] += fraction * old_SOM_in_transport_kg[row, col] * (1 - claydepfraction);
                                                //MM aangepast, om ook OM naar de volgende cel te transporteren 


                                                //organic_selectivity_fraction /= 2;  // unit [-]
                                                // the above procedure may cause instability problems by depositing lots of material
                                            } // end sedimentation
                                        } // end dh > 0
                                    } // end dtm!=-9999
                                }
                            } // end j
                        } // end i
                        if (fracsum < 0.9999 & !search_nodataneighbour(row, col))
                        {
                            Debug.WriteLine("fracsum = " + fracsum);
                            for (int otp = 0; otp < 10; otp++)
                            {
                                Debug.WriteLine("dir {0}, {1}", otp, OFy_m[row, col, otp]);
                            }
                            //minimaps(row, col);
                            Debug.WriteLine("err_we3");

                        }
                        // out_double(workdir + "\\" + run_number + "_" + t + "_out_dtm_test.asc", dtm);

                    } // outflow water
                    else
                    { // no outflow of water. 
                      // -> Cell located in depression. Deposit all sediments
                      // -> Cell at border of landscape, outflow of all sediments
                      // double mass_temp = total_catchment_mass();
                        bool bool_outflow = false;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (i != 0 & j != 0)
                                {
                                    if ((row + i) >= nr | (row + i) <= 0 | (col + j) >= nc | (col + j) <= 0) // Does the cell fall outside of the area?
                                    {
                                        bool_outflow = true;
                                    }
                                    else if (dtm[row + i, col + j] == -9999)
                                    {
                                        bool_outflow = true;
                                    }
                                }
                            }
                        }
                        if (bool_outflow) // if there is outflow, export of sediments. 
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                mass_export += sediment_in_transport_kg[row, col, size];
                            }
                            mass_export += old_SOM_in_transport_kg[row, col];  //all in kg
                            mass_export += young_SOM_in_transport_kg[row, col];  //all in kg
                        }
                        else // if there is no outflow, deposition of sediments in cell. No delta formation (yet) develop
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {

                                total_mass_deposited[size] += sediment_in_transport_kg[row, col, size];
                                total_mass_eroded[size] -= sediment_in_transport_kg[row, col, size];
                                mass_difference_input_output[row, col] -= sediment_in_transport_kg[row, col, size];

                                texture_kg[row, col, 0, size] += sediment_in_transport_kg[row, col, size];  //all in kg 
                                total_dep += sediment_in_transport_kg[row, col, size];

                                // local mass balance
                                local_mass_balance[row, col, 3] += sediment_in_transport_kg[row, col, size];
                            }
                            old_SOM_kg[row, col, 0] += old_SOM_in_transport_kg[row, col];  //all in kg
                            young_SOM_kg[row, col, 0] += young_SOM_in_transport_kg[row, col];  //all in kg
                        }


                        //displaysoil(row, col); Debugger.Break();


                        //if (row == 40 & col == 31) { displaysoil(40, 31); Debugger.Break(); }
                        // double mass_temp_diff = mass_temp - total_catchment_mass();
                    }
                    //Debug.WriteLine("WE6");

                    double mass_bal = (local_mass_balance[row, col, 0] + local_mass_balance[row, col, 2]) - (local_mass_balance[row, col, 1] + local_mass_balance[row, col, 3]); // (transport_in + depo) - (transport_out + ero)
                                                                                                                                                                                 // Debug.WriteLine("t: {0}, row: {1}, col: {2}, mass balance {3}",t, row, col,mass_bal);
                                                                                                                                                                                 // Debug.WriteLine("t: {0}, row: {1}, col: {2}, t_in: {3}, t_out: {4}, ero: {5}, depo: {6}, Q: {7}, pedonmass: {8}", t, row, col, local_mass_balance[row, col, 0], local_mass_balance[row, col, 1], local_mass_balance[row, col, 2], local_mass_balance[row, col, 3], local_mass_balance[row, col, 4],total_soil_mass(row, col));
                }
            }
            mass_after = total_catchment_mass();
            if (mass_before - (mass_after + mass_export) > 0.001)
            {
                Debug.WriteLine("err_we4");
            }
            // if (Math.Round(mass_before,6) != Math.Round(mass_after + mass_export,6)) { Debugger.Break(); }


            // 6: Calculate elevation change
            // all cells have now been considered in order of (original) altitude. We must still recalculate their thicknesses and recalculate altitude. While doing that, we should count how much erosion and deposition there has been. 
            double old_total_elevation = total_catchment_elevation();
            volume_eroded = 0; sediment_exported = 0; volume_deposited = 0;
            total_average_altitude = 0; total_altitude = 0;
            total_rain = 0; total_evap = 0; total_infil = 0; total_outflow = 0;
            wet_cells = 0; eroded_cells = 0; deposited_cells = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        if (only_waterflow_checkbox.Checked == false)
                        {
                            double old_thickness = soildepth_m[row, col];
                            update_all_soil_thicknesses(row, col);
                            double new_thickness = total_soil_thickness(row, col);

                            dtm[row, col] += new_thickness - old_thickness;
                            soildepth_m[row, col] = new_thickness;

                            dtmchange[row, col] += new_thickness - old_thickness;
                            sum_water_erosion[row, col] += new_thickness - old_thickness;

                            if ((new_thickness - old_thickness) < 0)
                            { dz_ero_m[row, col] += new_thickness - old_thickness; }
                            else { dz_sed_m[row, col] += new_thickness - old_thickness; }

                            if (-dz_ero_m[row, col] > timeseries.timeseries_erosion_threshold) { eroded_cells++; }
                            if (dz_sed_m[row, col] + lake_sed_m[row, col] > timeseries.timeseries_deposition_threshold) { deposited_cells++; }
                        }

                        // 7: Update timeseries
                        if (check_space_rain.Checked == true) { total_rain += rain[row, col]; }
                        total_rain += rain_value_m;
                        if (check_space_evap.Checked == true) { total_evap += evapotranspiration[row, col]; }
                        total_evap += evap_value_m;
                        if (check_space_infil.Checked == true) { total_infil += infil[row, col]; }
                        total_infil += infil_value_m;
                        if (waterflow_m3[row, col] * dx * dx > timeseries.timeseries_waterflow_threshold) { wet_cells++; }
                    } // end for nodata
                }   // end for col
            } // end for row

            //double new_total_elevation = total_catchment_elevation();
            //if(Math.Abs(new_total_elevation-old_total_elevation)>0.001)
            //{
            //    int t_err = t;
            //    Debugger.Break();
            //}


            // out_double(workdir + "\\" + run_number + "_" + t + "_mass_difference.asc", mass_difference_input_output);
            total_rain *= dx * dx;   // m3
            total_evap *= dx * dx;   // m3
            total_infil *= dx * dx;  // m3
            total_outflow = total_rain - total_evap - total_infil;
            //Debug.WriteLine("\n--erosion and deposition overview--");
            //Debug.WriteLine("rain " + total_rain + " evap " + total_evap + " total_infil " + total_infil);
            if (only_waterflow_checkbox.Checked == false)
            {
                double total_kg_eroded = 0, total_kg_deposited = 0;
                for (size = 0; size < 7; size++)
                {
                    total_kg_eroded += total_mass_eroded[size];
                    total_kg_deposited += total_mass_deposited[size];
                }
            }
            this.InfoStatusPanel.Text = "calc movement has been finished";
            this.out_sed_statuspanel.Text = string.Format("sed_exp {0:F0} * 1000 m3", total_sed_export * dx * dx / 1000);

            //double mass_after = total_catchment_mass();
            //if(mass_before != mass_after)
            //{
            //    Debug.WriteLine("");
            //    Debug.Write(mass_before - mass_after);
            //    Debug.Write(",");
            //    Debug.Write(total_ero - total_dep);
            //    Debug.Write(",");
            //    Debug.Write(total_ero);
            //    Debug.Write(",");
            //    Debug.Write(total_mass_eroded.Sum());
            //    Debug.Write(",");

            //    // Debug.Write(total_sediment_in_transport_kg());
            //    // Debugger.Break(); 
            //}
            if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
            {
                Debug.WriteLine("err_we5");
            }

        }

        void calculate_water_ero_sed()    //where the water starts flowing, eroding and transporting
        {
            //this.InfoStatusPanel.Text = "water erosion calculation";
            dhmax_errors = 0;
            //set all start q values effective precipitation at time t
            nb_ok = 0;  // nb_ok is 1 als er uberhaupt buren zijn, dus 0 als er alleen maar NODATA is
            nb_check = 0; all_grids = 0;
            dz_bal = 0; sediment_exported = 0; erocnt = 0; sedcnt = 0;
            sedbal = 0; erobal = 0; maximum_allowed_deposition = -9999.0; dh_tol = 0.00025;
            sedbal2 = 0; erobal2 = 0;
            tel1 = 0; tel2 = 0; tel3 = 0; tel4 = 0;
            depressions_filled = 0; depressions_delta = 0; depressions_alone = 0; sediment_delta_m = 0; sediment_filled_m = 0; depressionvolume_filled_m = 0; crashed = false;

            double powered_slope_sum, flow_between_cells_m3_per_m, total_sediment_in_transport_kg, organic_in_transport, mass_to_be_eroded, rock_fraction, selectivity_fraction, potential_transported_amount_kg;
            int size;
            double[] total_mass_eroded, total_mass_deposited_kg;
            total_mass_eroded = new double[7] { 0, 0, 0, 0, 0, 0, 0 };
            total_mass_deposited_kg = new double[7] { 0, 0, 0, 0, 0, 0, 0 };

            for (alpha = 1; alpha <= maxdepressionnumber; alpha++)  // zeroing all waterflow at outlets of depressions
            {
                depressionconsidered[alpha] = 0;
                for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                {
                    if (drainingoutlet_row[alpha, outletcounter] != -1)
                    {
                        waterflow_m3[drainingoutlet_row[alpha, outletcounter], drainingoutlet_col[alpha, outletcounter]] = 0;
                    }
                }
            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before row col loop in water erosed"); }
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {

                    if (dtm[row, col] != -9999)
                    {
                        // First, we apply rainwater to our landscape (in a two step approach - first normal cells and lake outlets)
                        if (depression[row, col] == 0 ||
                            (drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                            (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                            (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                            (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                            (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                        {
                            if (check_space_evap.Checked == true) { evap_value_m = evapotranspiration[row, col]; }
                            if (check_space_rain.Checked == true) { rain_value_m = rain[row, col]; }
                            if (check_space_infil.Checked == true) { infil_value_m = infil[row, col]; }
                            //ArT // development required to account for f(t) situations
                            waterflow_m3[row, col] += (rain_value_m - infil_value_m - evap_value_m) * dx * dx;
                            if (waterflow_m3[row, col] < 0) { waterflow_m3[row, col] = 0; }
                            if (waterflow_m3[row, col] < -0.001) { Debug.WriteLine(" Negative waterflow at " + row + " " + col + ": " + waterflow_m3[row, col] + ". rain " + rain_value_m + " infil " + infil_value_m + " evap " + evap_value_m + " use " + landuse[row, col]); }
                        }
                        else  // and then, second step, for other lake cells
                        { // for other lakecells, we send the rainwater directly (equally distributed) to that lake's outlet(s) (infiltration is not zero in the lake at the moment)
                            //Debug.WriteLine(" B at " + row + " col " + col + " alt " + dtm[row, col] + " dep " + depression[row, col]);
                            int outletcounter = 0; ;
                            while (drainingoutlet_col[depression[row, col], outletcounter] != -1)
                            {
                                outletcounter++;
                                if (outletcounter == 5) { break; }
                            }
                            for (i = 0; i < outletcounter; i++)
                            {

                                if (check_space_evap.Checked == true) { evap_value_m = evapotranspiration[row, col]; }
                                if (check_space_rain.Checked == true) { rain_value_m = rain[row, col]; }
                                if (check_space_infil.Checked == true) { infil_value_m = infil[row, col]; }
                                //ArT // development required to account for f(t) situations
                                //ArT remember to check for negative lake outflow once it happens
                                waterflow_m3[drainingoutlet_row[depression[row, col], i], drainingoutlet_col[depression[row, col], i]] += dx * dx * (rain_value_m - infil_value_m - evap_value_m) / outletcounter;
                            }
                        }
                        if (only_waterflow_checkbox.Checked == false)
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                sediment_in_transport_kg[row, col, size] = 0;
                            }
                            old_SOM_in_transport_kg[row, col] = 0;
                            young_SOM_in_transport_kg[row, col] = 0;
                            dz_ero_m[row, col] = 0;
                            dz_sed_m[row, col] = 0;
                            lake_sed_m[row, col] = 0;

                        }
                    }
                }  // end for col
            }  //end for row
            //Debug.WriteLine(" prepared water. Ready to route for erosion and deposition");
            all_grids = (nr) * (nc);
            memberdepressionnotconsidered = 0;
            int runner = 0;
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before sorted row col loop in water erosed"); }
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {     // the index is sorted from low to high values, but flow goes from high to low
                if (index[runner] != -9999)
                {

                    row = row_index[runner]; col = col_index[runner];
                    if (t == 750000) { Debug.WriteLine(runner + " " + row + "  " + col + " nr " + nr + " nc " + nc + " nr*nc " + nr * nc + " data cells " + number_of_data_cells); }
                    //if (t == 262 && row == 203 && col == 27) { diagnostic_mode = 1; }
                    if (t == 750000) { diagnostic_mode = 1; }
                    else { diagnostic_mode = 0; }

                    powered_slope_sum = 0; max_allowed_erosion = 0; dz_min = -9999.99;
                    direct = 20; dz_max = -10; dhtemp = -99999.99; maximum_allowed_deposition = -9999.99;
                    if (depression[row, col] < 0) { depression[row, col] = 0; }
                    if ((drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                        (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                        (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                        (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                        (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                    {
                        if (depressionconsidered[depression[row, col]] == 0)
                        {
                            //diagnostic_mode = 1;
                            depressionnumber = depression[row, col];
                            depressionconsidered[depressionnumber] = 1;
                            //if (t == 1429 && depressionnumber == 43) { diagnostic_mode = 1; }
                            //else { diagnostic_mode = 0; }
                            if (diagnostic_mode == 1) { Debug.WriteLine(" now considering dep " + depressionnumber + " index " + runner); }
                            update_depression(depressionnumber);
                            if (depressionsum_sediment_m == 0)
                            {
                                leave_depression_alone(depressionnumber); depressions_alone++;
                            }
                            else
                            {
                                if (depressionsum_sediment_m >= needed_to_fill_depression_m) { fill_depression(depressionnumber); depressions_filled++; }
                                else { delta_depression(depressionnumber); depressions_delta++; }
                            }
                        }
                        //all cells of this lake have now been considered, except the outlets
                    }
                    if (depression[row, col] < 0) { Debug.WriteLine(" error: negative depression value " + depression[row, col] + " at " + row + " " + col); minimaps(row, col); }
                    // this check indicates a problem with the resetting of cells involved in a delta
                    if (depression[row, col] == 0 ||
                                                (drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                                                (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                                                (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                                                (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                                                (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                    { //for all cells outside a depression and for outlets, we use the stream power equations based on a multiple flow (D8) template
                        //if (row == 24 && col == 81) { Debug.WriteLine(" looking around cell " + row + " " + col); minimaps(row, col); }
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))  //to stay within the grid and avoid the row col cell itself
                                {
                                    // below, we calculate slope_sum for all cells either not in a depression, or being a outlet
                                    // slope_sum is needed to calculate flow in a multiple flow environment until someone thinks of something better
                                    // if (diagnostic_mode == 1) { Debug.WriteLine("checking " + (row + i) + " " + (col + j) + " from cell " + row + " " + col); }
                                    if (depression[row, col] < 0) { Debug.WriteLine(" lakes error: cell has depression < 1"); } //out_integer("wrong_lakes.asc", depression); 
                                    if (depression[row, col] == 0)
                                    {    // if the cell is not in a depression (it could be in a depression as an outlet)
                                        if (dtm[row + i, col + j] != -9999)
                                        {  //if the cell has no NODATA
                                            if (only_waterflow_checkbox.Checked)
                                            {
                                                dh = dtm[row, col] - dtm[row + i, col + j]; // in the case that we are not interested in erosion and deposition, then there is no ero and sed to query                                            }
                                            }
                                            else
                                            {
                                                dh = (dtm[row, col] + dz_ero_m[row, col] + dz_sed_m[row, col]) - (dtm[row + i, col + j] + dz_ero_m[row + i, col + j] + dz_sed_m[row + i, col + j]);    // diff @ this moment 
                                            }
                                            if (dh < 0)  // we are looking at a higher neighbour
                                            {
                                                if (dh > maximum_allowed_deposition) { maximum_allowed_deposition = dh; }   // we keep track of the minimum difference in altitude between this cell and its lowest higher neighbour - we will not raise it more, even if we would like to when the Courant criterion is violated
                                            } // end if dh
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length
                                            if (dh > 0)
                                            {  // i j is a lower neighbour
                                                if (dh > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh - dh_tol); }  // we keep track of the minimum difference in current altitude between this cell and its highest lower neighbour - we will not erode it more, even if we would like to
                                                                                                                                 //if (diagnostic_mode == 1) { Debug.WriteLine("cell " + row + " " + col + " dtm " + dtm[row, col] + " now " + (dtm[row, col] + dz_sed_m[row, col] + dz_ero_m[row, col]) + " nb " + (row + i) + " " + (col + j) + " dtm " + dtm[row + i, col + j] + " is now " + (dtm[row + i, col + j] + dz_ero_m[row + i, col + j] + dz_sed_m[row + i, col + j])); }    
                                                dh = dh / d_x;
                                                dh = Math.Pow(dh, conv_fac);
                                                powered_slope_sum = powered_slope_sum + dh;
                                            }//end if dh  
                                        }//end if novalues
                                    }  // end if not in depression
                                    if ((drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col)
                                        || (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col)
                                        || (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col)
                                        || (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col)
                                        || (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                                    {    // this cell is one of the draining outlets and is only allowed to drain to cells not in the lake																											
                                         // if the lake has been filled at this time, then all its (by now non-lake) cells have an altitude > outlet, and will not be considered for that reason
                                        if (depression[row + i, col + j] != depression[row, col])
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            dh = dtm[row, col] - dtm[row + i, col + j];
                                            if (dh > 0)
                                            {// i j is a lower neighbour
                                                dh = dh / d_x;                      // dh is now equal to slope
                                                dh = Math.Pow(dh, conv_fac);            // dh is nu de helling tot de macht conv fac
                                                powered_slope_sum = powered_slope_sum + dh;
                                            } // end if lower nb
                                        } //end if nb not within depression
                                    } // end if drainingoutlet
                                }// end if boundaries
                            }//end for j
                        }//end for i, we now know slope sum for this cell. We have included cells that are in a lake in this calculation. //ArT should we replace their altitude with depressionlevel?
                        // (row == 24 && col == 81) { Debug.WriteLine("passed"); }
                        if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = -maximum_allowed_deposition; }
                        if (max_allowed_erosion < 0) { max_allowed_erosion = -dh_tol; } else { max_allowed_erosion = -max_allowed_erosion; }
                        //if (diagnostic_mode == 1) { Debug.WriteLine(" slopesum = " + slope_sum + " maximum deposition " + maximum_allowed_deposition + " maximum erosion " + max_allowed_erosion); }

                        // we are now prepared to actually calculate erosion and deposition: we can calculate how much water and sediment is redistributed using slope_sum
                        if (NA_in_soil(row, col) == true) { Debug.WriteLine("NA found before eroding " + row + " " + col); }
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; fraction = 0; transport_capacity_kg = 0;
                                sediment_transported = 0; detachment_rate = 0;
                                d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {  //boundaries
                                    //if (row == 24 && col == 81) { Debug.WriteLine("entered" + i + j); }
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        if (only_waterflow_checkbox.Checked)
                                        {
                                            dh = dtm[row, col] - dtm[row + i, col + j];
                                        }
                                        else
                                        {
                                            dh = (dtm[row, col] + dz_ero_m[row, col] + dz_sed_m[row, col]) - (dtm[row + i, col + j] + dz_ero_m[row + i, col + j] + dz_sed_m[row + i, col + j]);
                                        }
                                        if (dh > 0)
                                        {  //we have found one of the lower nbs
                                            //if (row == 24 && col == 81) { Debug.WriteLine("this is a lower nb " + i + j + "dh" + dh + " " + waterflow_m3[row, col]); }
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            if ((depression[row, col] != 0 && depression[row + i, col + j] != depression[row, col]) || (depression[row, col] == 0))
                                            {   //if cell == outlet of current lake and nb not member of that lake OR if not a lake member


                                                // Now, we first calculate the fraction of water and sediment that goes from row, col to row+i to col+j , always using current altitudes
                                                // Then, we calculate the actual amounts of water and sediment, and with that, using the stream power equation, the transport capacity
                                                // In future, the Hjlstrom diagram can be used to give texture-dependent erosion thresholds (or selectivity)

                                                dh /= d_x;  //dh is now slope
                                                fraction = Math.Pow(dh, conv_fac) / powered_slope_sum;
                                                if (waterflow_m3[row, col] < 0) { waterflow_m3[row, col] = 0; }    // this can have happened if water enters a drier zone in the landscape
                                                flow_between_cells_m3_per_m = fraction * waterflow_m3[row, col] / dx;
                                                if (depression[row + i, col + j] == 0)
                                                {  // if receiving cell is not in a depression, its waterflow is increased 
                                                    waterflow_m3[row + i, col + j] += flow_between_cells_m3_per_m * dx;
                                                }
                                                if (depression[row + i, col + j] != 0)
                                                {  // if receiving cell is in a depression, its outlets' waterflow is increased 
                                                    currentdepression = Math.Abs(depression[row + i, col + j]); // this Abs stuff should not be necessary and is included for stability!
                                                    int outletcounter = 0;
                                                    while (drainingoutlet_col[currentdepression, outletcounter] != -1)
                                                    {
                                                        outletcounter++;
                                                        if (outletcounter == 5) { break; }
                                                    }
                                                    for (int iter = 0; iter < outletcounter; iter++) // for all outlets of this depression, divide that amount of water over them
                                                    {
                                                        waterflow_m3[drainingoutlet_row[currentdepression, iter], drainingoutlet_col[currentdepression, iter]] += dx * flow_between_cells_m3_per_m / outletcounter;
                                                    }
                                                }

                                                if (only_waterflow_checkbox.Checked == false)
                                                {

                                                    organic_in_transport = fraction * (old_SOM_in_transport_kg[row, col] + young_SOM_in_transport_kg[row, col]);    //all in kg
                                                                                                                                                                    //so far, organic in transport does not count towards the transport capacity. We can have infinite amounts of it in transport

                                                    transport_capacity_kg = advection_erodibility * (bulkdensity[row, col, 0] * dx * dx) * (Math.Pow(flow_between_cells_m3_per_m, m) * Math.Pow(dh, n)); // in a departure from literature, the erosion threshold is only evaluated if erosion actually occurs
                                                    if (transport_capacity_kg < 0)
                                                    {
                                                        transport_capacity_kg = 0;
                                                        Debug.WriteLine(" Warning: negative transport capacity at" + row + " " + col);
                                                    }  // this should never happen
                                                       // We now compare transport_capacity with the total amount of sediment in transport, to determine whether we will have erosion or deposition or nothing
                                                    total_sediment_in_transport_kg = 0;

                                                    for (size = 0; size < n_texture_classes; size++)
                                                    {
                                                        total_sediment_in_transport_kg += fraction * sediment_in_transport_kg[row, col, size];                     //all in kg
                                                    }
                                                    if (transport_capacity_kg == total_sediment_in_transport_kg)
                                                    {
                                                        // neither erosion nor deposition, simply transport
                                                        for (size = 0; size < n_texture_classes; size++)
                                                        {
                                                            sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];  //all in kg 
                                                        }
                                                        old_SOM_in_transport_kg[row + i, col + j] += fraction * old_SOM_in_transport_kg[row, col];  //all in kg
                                                        young_SOM_in_transport_kg[row + i, col + j] += fraction * young_SOM_in_transport_kg[row, col];  //all in kg
                                                    }
                                                    if (transport_capacity_kg > total_sediment_in_transport_kg)
                                                    {

                                                        //erosion
                                                        //in case of desired erosion, we first evaluate whether we exceed the erosion threshold
                                                        if ((transport_capacity_kg - total_sediment_in_transport_kg) > erosion_threshold_kg)
                                                        {

                                                            //first, calculate how much we are going to erode. Not as much as we want to if the soil is protected by rocks or plants
                                                            rock_fraction = texture_kg[row, col, 0, 0] / (texture_kg[row, col, 0, 0] + texture_kg[row, col, 0, 1] + texture_kg[row, col, 0, 2] + texture_kg[row, col, 0, 3] + texture_kg[row, col, 0, 4]);
                                                            //if there are blocks on the surface, we determine how much of the cell surface is covered by them
                                                            
                                                            if (blocks_active==1) {
                                                                double blocks_fraction = 0;
                                                                foreach (var Block in Blocklist) {
                                                                    if (Convert.ToInt32(Math.Floor(Block.Y_row)) == row && Convert.ToInt32(Math.Floor(Block.X_col)) == col) {
                                                                        blocks_fraction += Block.Size_m * Block.Size_m;
                                                                    }
                                                                }
                                                                blocks_fraction /= (dx * dx);
                                                                rock_fraction = Math.Max(rock_fraction,blocks_fraction); }
                                                            if (version_lux_checkbox.Checked == false)
                                                            {
                                                                mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                                                                * Math.Exp(-rock_protection_constant * rock_fraction)
                                                                * Math.Exp(-bio_protection_constant * 0);
                                                            }

                                                            else
                                                            {  //for Luxemburg version, here we additially protect soil from erosion by its cover of 'bad' organic matter as litter (i.e. in top layer)

                                                                // MvdM litter fraction is determined by the total amount of litter as fraction of the mineral soil in the top layer. This might be changed, because mineral content is variable and indepent of litter quantity

                                                                //XIA change this number to 0.25 as well. For creep and no creep
                                                                double litter_characteristic_protection_mass_kg_m2 = 0.01; // based on average litter contents in Luxembourg
                                                                double litter_characteristic_protection_mass_kg = litter_characteristic_protection_mass_kg_m2 * dx * dx;
                                                                double litter_protection_fraction = - (litter_kg[row, col, 0] + litter_kg[row, col, 1])/ litter_characteristic_protection_mass_kg;

                                                                //double litter_fraction = (litter_kg[row, col, 0] + litter_kg[row, col, 1]) / (litter_kg[row, col, 0] + litter_kg[row, col, 1] + total_layer_mass(row, col, 0));

                                                                //double litter_fraction = (old_SOM_kg[row, col, 0] + young_SOM_kg[row, col, 0]) / total_layer_mass(row, col, 0);
                                                                //LUX Xia you have to set this parameter here in the code. Value between 0-1.
                                                                //double litter_protection_constant = 0.5;

                                                                mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                                                                * Math.Exp(-rock_protection_constant * rock_fraction)
                                                                * Math.Exp(-bio_protection_constant * 0)
                                                                * Math.Exp(-litter_protection_fraction);
                                                            }
                                                            //DEV possible: - bio_protection_constant * vegetation_cover_fraction
                                                            //Debug.WriteLine("eroding " + mass_to_be_eroded + " rock exp " + Math.Exp(-rock_protection_constant * rock_fraction) + " bio exp " + Math.Exp(-bio_protection_constant * 1));
                                                            // second, calculate how the mass to be eroded is taken from the different size fractions: selectivity
                                                            // if total transport capacity is small, only the finer fractions will be eroded (selectivity with diameter to power 0.5). For larger transport capacities, selectivity decreases (diameter to power 0 = equal between fractions)
                                                            // more info in excel file in dropbox. 
                                                            double constant_b1 = 0.5 * Math.Exp(constant_selective_transcap * transport_capacity_kg);
                                                            double sum_diameter_power = 0;
                                                            for (size = 0; size < 5; size++)
                                                            {
                                                                sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], constant_b1);
                                                            }
                                                            double clayeroded_0_kg = 0, claypresent_0_kg = 0, clayeroded_1_kg = 0, claypresent_1_kg = 0;
                                                            for (size = 0; size < 5; size++)
                                                            {
                                                                selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], constant_b1)) / sum_diameter_power;    // unit [-]
                                                                if (texture_kg[row, col, 0, size] >= selectivity_fraction * mass_to_be_eroded)
                                                                {    // typical situation
                                                                    if (size > 2)
                                                                    {
                                                                        clayeroded_0_kg += selectivity_fraction * mass_to_be_eroded;
                                                                        claypresent_0_kg += texture_kg[row, col, 0, size];
                                                                    }
                                                                    total_mass_eroded[size] += selectivity_fraction * mass_to_be_eroded;
                                                                    texture_kg[row, col, 0, size] -= selectivity_fraction * mass_to_be_eroded;   // unit [kg]
                                                                    sediment_in_transport_kg[row + i, col + j, size] += selectivity_fraction * mass_to_be_eroded;  // unit [kg]
                                                                }
                                                                else
                                                                {    // exceptional. If we want to erode more than present in the layer, we will take it from one layer down.
                                                                     //this is to avoid exceptionally thin rocky layers blocking all erosion
                                                                     //we will then first erode everything from the top layer (layer "0") and then erode from the second layer  (i.e. layer "1").
                                                                    total_mass_eroded[size] += texture_kg[row, col, 0, size];
                                                                    double left = (selectivity_fraction * mass_to_be_eroded) - texture_kg[row, col, 0, size]; // unit [kg]
                                                                    sediment_in_transport_kg[row + i, col + j, size] += texture_kg[row, col, 0, size];
                                                                    if (size > 2)
                                                                    {
                                                                        clayeroded_0_kg += texture_kg[row, col, 0, size];
                                                                        claypresent_0_kg += 0;
                                                                    }
                                                                    texture_kg[row, col, 0, size] = 0;
                                                                    if (texture_kg[row, col, 1, size] >= left)
                                                                    {   // typical
                                                                        total_mass_eroded[size] += left;
                                                                        if (size > 2)
                                                                        {
                                                                            clayeroded_1_kg += left;
                                                                            claypresent_1_kg += texture_kg[row, col, 1, size] - left;
                                                                        }
                                                                        texture_kg[row, col, 1, size] -= left;  // unit [kg]
                                                                        sediment_in_transport_kg[row + i, col + j, size] += left;  // unit [kg]
                                                                    }
                                                                    else
                                                                    {
                                                                        total_mass_eroded[size] += texture_kg[row, col, 1, size];
                                                                        sediment_in_transport_kg[row + i, col + j, size] += texture_kg[row, col, 1, size];// unit [kg]
                                                                        if (size > 2)
                                                                        {
                                                                            clayeroded_1_kg += texture_kg[row, col, 1, size];
                                                                            claypresent_1_kg += 0;
                                                                        }
                                                                        texture_kg[row, col, 1, size] = 0;
                                                                    }
                                                                }
                                                            }

                                                            //organic matter is eroded as a fraction of total OM. That fraction equals the fraction of clay eroded from the layer
                                                            //the assumption underlying this is that clay and humus are bound in aggregates
                                                            //this does not cover: LMW SOM, peat or large woody debris
                                                            double clayerodedfraction_0 = clayeroded_0_kg / (clayeroded_0_kg + claypresent_0_kg);
                                                            double clayerodedfraction_1 = clayeroded_1_kg / (clayeroded_1_kg + claypresent_1_kg);
                                                            if (Double.IsNaN(clayerodedfraction_0))
                                                            {
                                                                clayerodedfraction_0 = 0;
                                                                //Debug.WriteLine(" this should not have happened - no OM erosion possible"); 
                                                            }
                                                            if (Double.IsNaN(clayerodedfraction_1)) { clayerodedfraction_1 = 0; }
                                                            //if (row == 62 && col == 78) { Debug.WriteLine(clayerodedfraction_0 + "  " + clayerodedfraction_1); displaysoil(row, col); }
                                                            
                                                            old_SOM_in_transport_kg[row, col] += old_SOM_kg[row, col, 0] * clayerodedfraction_0 + old_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                            young_SOM_in_transport_kg[row, col] += young_SOM_kg[row, col, 0] * clayerodedfraction_0 + young_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                            total_mass_eroded[5] += old_SOM_kg[row, col, 0] * clayerodedfraction_0 + old_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                            total_mass_eroded[6] += young_SOM_kg[row, col, 0] * clayerodedfraction_0 + young_SOM_kg[row, col, 1] * clayerodedfraction_1;
                                                            old_SOM_kg[row, col, 0] *= 1 - clayerodedfraction_0;
                                                            young_SOM_kg[row, col, 0] *= 1 - clayerodedfraction_0;
                                                            old_SOM_kg[row, col, 1] *= 1 - clayerodedfraction_1;
                                                            young_SOM_kg[row, col, 1] *= 1 - clayerodedfraction_1;
                                                            //if (row == 62 && col == 78) displaysoil(row,col);
                                                        }
                                                        else
                                                        {
                                                            // neither erosion nor deposition, simply transport
                                                            for (size = 0; size < n_texture_classes; size++)
                                                            {
                                                                sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];  //all in kg 
                                                            }
                                                            old_SOM_in_transport_kg[row + i, col + j] += fraction * old_SOM_in_transport_kg[row, col];  //all in kg
                                                            young_SOM_in_transport_kg[row + i, col + j] += fraction * young_SOM_in_transport_kg[row, col];  //all in kg
                                                        }
                                                    }
                                                    if (transport_capacity_kg < total_sediment_in_transport_kg)
                                                    {
                                                        //deposition
                                                        //Debug.WriteLine("deposition");
                                                        //first, calculate how much we are going to keep in transport. This is the way that selectivity works now. 
                                                        double sum_diameter_power = 0, clay_deposited = 0, clay_transported = 0;
                                                        for (size = 0; size < 5; size++)
                                                        {
                                                            sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], 0.5);
                                                        }
                                                        for (size = 0; size < 5; size++)
                                                        {
                                                            selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], 0.5)) / sum_diameter_power;    // unit [-]
                                                            potential_transported_amount_kg = selectivity_fraction * transport_capacity_kg;                      // unit [kg]
                                                            if (potential_transported_amount_kg < sediment_in_transport_kg[row, col, size] * fraction)
                                                            {
                                                                total_mass_deposited_kg[size] += (sediment_in_transport_kg[row, col, size] * fraction) - potential_transported_amount_kg;
                                                                texture_kg[row, col, 0, size] += (sediment_in_transport_kg[row, col, size] * fraction) - potential_transported_amount_kg;        // unit [kg]
                                                                sediment_in_transport_kg[row + i, col + j, size] = potential_transported_amount_kg;                                    // unit [kg]  

                                                                if (size > 2)
                                                                {
                                                                    clay_deposited += (sediment_in_transport_kg[row, col, size] * fraction) - potential_transported_amount_kg;
                                                                    clay_transported += potential_transported_amount_kg;
                                                                }

                                                            }
                                                            else
                                                            {
                                                                //do nothing. We keep the sediment in transport, and do not deposit anything
                                                                //we do move the transport further down
                                                                sediment_in_transport_kg[row + i, col + j, size] += fraction * sediment_in_transport_kg[row, col, size];
                                                            }

                                                        }
                                                        // now organic matter
                                                        if (!(clay_deposited == 0 && clay_transported == 0))
                                                        {
                                                            double claydepfraction = clay_deposited / (clay_deposited + clay_transported);
                                                            total_mass_deposited_kg[5] += young_SOM_in_transport_kg[row, col] * claydepfraction;
                                                            total_mass_deposited_kg[6] += old_SOM_in_transport_kg[row, col] * claydepfraction;
                                                            young_SOM_kg[row, col, 0] += young_SOM_in_transport_kg[row, col] * claydepfraction;
                                                            old_SOM_kg[row, col, 0] += old_SOM_in_transport_kg[row, col] * claydepfraction;
                                                            young_SOM_in_transport_kg[row, col] *= 1 - claydepfraction;
                                                            old_SOM_in_transport_kg[row, col] *= 1 - claydepfraction;
                                                        }
                                                        else  //so both of the clay numbers are zero. This could be for many reasons: there is no clay to erode - there is absolutely no ero   - among them
                                                        {
                                                            //do nothing
                                                            //may be a problem if the landscape is simply clay-less: in that case, we do want to be able to erode OM.
                                                        }

                                                    }
                                                } // end if else : also erosion and deposition considered

                                            }

                                        } //end`dH > 000
                                    }//end if novalues
                                }//end if boundaries
                            }//end for j
                        }//end for i
                        if (NA_in_soil(row, col) == true) { Debug.WriteLine("NA found after eroding " + row + " " + col); }
                        //if (row == 24 && col == 81) { Debug.WriteLine("passed"); }
                    } // end if not in a lake or a lake outlet (all other lake cells have been considered before
                } //end if nodata
            }//end for index
             // all cells have now been considered in order of (original) altitude. We must still recalculate their thicknesses and recalculate altitude. While doing that, we should count how much erosion and deposition there has been. 
            volume_eroded = 0; sediment_exported = 0; volume_deposited = 0;
            total_average_altitude = 0; total_altitude = 0;
            total_rain = 0; total_evap = 0; total_infil = 0; total_outflow = 0;
            wet_cells = 0; eroded_cells = 0; deposited_cells = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        if (only_waterflow_checkbox.Checked == false)
                        {
                            //erosion and deposition affect only the top two layers of soil. All others: unaffected.
                            //So, we calculate the difference between the original and final thicknesses of these two layers to calculate dz_ero_m and dz_sed_m. 
                            //We already knew how much mass was involved in ero and sed, but we need the volumes to update the dtm.
                            for (i = 0; i < 2; i++)
                            {
                                double pastlayer = layerthickness_m[row, col, i];
                                layerthickness_m[row, col, i] = thickness_calc(row, col, i);
                                if (pastlayer < layerthickness_m[row, col, i])  //if there is deposition in volume terms
                                {
                                    dz_sed_m[row, col] += layerthickness_m[row, col, i] - pastlayer;  // leading to positive values for dz_sed_m, which is what we want
                                }
                                else
                                {
                                    dz_ero_m[row, col] += layerthickness_m[row, col, i] - pastlayer;  //leading to negative values for dz_ero_m, which is what we want
                                }
                            }
                            //now dz_ero_m and dz_sed_m hold the changed altitudes. 

                            volume_eroded += dz_ero_m[row, col];
                            volume_deposited += dz_sed_m[row, col];
                            dtmchange[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col];  //attention: LAKE_sed and dz_sed_m are treated differently. 
                            dtm[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col];                           //No need to add lake_sed to dtm in the next line
                            soildepth_m[row,col] += dz_ero_m[row, col] + dz_sed_m[row, col];
                            sum_water_erosion[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col] + lake_sed_m[row, col];

                            if (-dz_ero_m[row, col] > timeseries.timeseries_erosion_threshold) { eroded_cells++; }
                            if (dz_sed_m[row, col] + lake_sed_m[row, col] > timeseries.timeseries_deposition_threshold) { deposited_cells++; }
                        }
                        if (check_space_rain.Checked == true) { total_rain += rain[row, col]; }
                        total_rain += rain_value_m;
                        if (check_space_evap.Checked == true) { total_evap += evapotranspiration[row, col]; }
                        total_evap += evap_value_m;
                        if (check_space_infil.Checked == true) { total_infil += infil[row, col]; }
                        total_infil += infil_value_m;
                        if (waterflow_m3[row, col] * dx * dx > timeseries.timeseries_waterflow_threshold) { wet_cells++; }
                    } // end for nodata
                }   // end for col
            } // end for row
            total_rain *= dx * dx;   // m3
            total_evap *= dx * dx;   // m3
            total_infil *= dx * dx;  // m3
            total_outflow = total_rain - total_evap - total_infil;
            //Debug.WriteLine("\n--erosion and deposition overview--");
            //Debug.WriteLine("rain " + total_rain + " evap " + total_evap + " total_infil " + total_infil);
            if (only_waterflow_checkbox.Checked == false)
            {
                double total_kg_eroded = 0, total_kg_deposited = 0;
                for (size = 0; size < 5; size++)
                {
                    total_kg_eroded += total_mass_eroded[size];
                    total_kg_deposited += total_mass_deposited_kg[size];
                }

                //Debug.WriteLine(" number of dhmax erosion errors: " + + "\n" ,dhmax_errors); 
                //Debug.WriteLine(" filled " + + " of " + + " depressions, %.3f sediment used for %.3f depressionvolume\n",depressions_filled,totaldepressions,sediment_filled,depressionvolume_filled); 
                //Debug.WriteLine(" sedimented into " + + " of " + + " depressions, %.3f sediment used\n",depressions_delta,totaldepressions,sediment_delta);
                //Debug.WriteLine(" left alone " + + " of " + + " depressions",depressions_alone,totaldepressions); 
                //Debug.WriteLine(" total %6.0f cubic metres of sediment (of max %6.0f) deposited ",(sediment_deposited+sediment_delta+sediment_filled)*dx*dx,(-sediment_produced*dx*dx)); 
                /* Debug.WriteLine(" MASS BASED [kg]:");
                 Debug.WriteLine(" SDR_all " + (total_kg_eroded - total_kg_deposited) / (total_kg_eroded));
                 if (total_mass_eroded[0] != 0) { Debug.WriteLine(" SDR_coarse " + (total_mass_eroded[0] - total_mass_deposited[0]) / (total_mass_eroded[0]) + " ero " + total_mass_eroded[0] + "kg sed " + total_mass_deposited[0] + "kg"); } else { Debug.WriteLine("no coarse transport"); }
                 if (total_mass_eroded[1] != 0) { Debug.WriteLine(" SDR_sand " + (total_mass_eroded[1] - total_mass_deposited[1]) / (total_mass_eroded[1]) + " ero " + total_mass_eroded[1] + "kg sed " + total_mass_deposited[1] + "kg"); } else { Debug.WriteLine("no sand transport"); }
                 if (total_mass_eroded[2] != 0) { Debug.WriteLine(" SDR_silt " + (total_mass_eroded[2] - total_mass_deposited[2]) / (total_mass_eroded[2]) + " ero " + total_mass_eroded[2] + "kg sed " + total_mass_deposited[2] + "kg"); } else { Debug.WriteLine("no silt transport"); }
                 if (total_mass_eroded[3] != 0) { Debug.WriteLine(" SDR_clay " + (total_mass_eroded[3] - total_mass_deposited[3]) / (total_mass_eroded[3]) + " ero " + total_mass_eroded[3] + "kg sed " + total_mass_deposited[3] + "kg"); } else { Debug.WriteLine("no clay transport"); }
                 if (total_mass_eroded[4] != 0) { Debug.WriteLine(" SDR_fine_clay " + (total_mass_eroded[4] - total_mass_deposited[4]) / (total_mass_eroded[4]) + " ero " + total_mass_eroded[4] + "kg sed " + total_mass_deposited[4] + "kg"); } else { Debug.WriteLine("no fine clay transport"); }

                 Debug.WriteLine(" VOLUME BASED [m3]:");
                 Debug.WriteLine(" SDR " + (volume_eroded + volume_deposited + sediment_delta + sediment_filled) / (volume_eroded));
                 //Debug.WriteLine(" as sink : %.3f ",((-sediment_delta-sediment_filled)/sediment_produced)); 
                 //Debug.WriteLine(" as sediment : %.3f ",((-sediment_deposited)/sediment_produced)); 
                 Debug.Write(" ERO " + (volume_eroded * dx * dx) + " \n");
                 Debug.Write(" SED " + (volume_deposited * dx * dx) + " \n");
                 Debug.Write(" DEL " + (sediment_delta * dx * dx) + " \n");
                 Debug.WriteLine(" FIL " + (sediment_filled * dx * dx) + " \n");
                 */
                /*if ((volume_eroded + volume_deposited + sediment_delta + sediment_filled) / volume_eroded != 0)
                {
                    Debug.WriteLine(" ALTITUDE BASED:");
                    Debug.WriteLine(" t = " + t + " number of dhmax erosion errors: " + dhmax_errors);
                    Debug.WriteLine(" on m-basis: filled " + depressions_filled + " of " + totaldepressions + " depressions, " + sediment_filled + " sediment used for " + depressionvolume_filled + " depressionvolume");
                    Debug.WriteLine(" on m-basis: sedimented into " + depressions_delta + " of " + totaldepressions + " depressions, " + sediment_delta + "  sediment used");
                } */
            }
            this.InfoStatusPanel.Text = "calc movement has been finished";
            this.out_sed_statuspanel.Text = string.Format("sed_exp {0:F0} * 1000 m3", total_sed_export * dx * dx / 1000);


            //save timeseries_outputs
            if (timeseries.timeseries_cell_waterflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[1]] = waterflow_m3[System.Convert.ToInt32(timeseries.timeseries_textbox_cell_row.Text), System.Convert.ToInt32(timeseries.timeseries_textbox_cell_col.Text)];
            }
            if (timeseries.timeseries_cell_altitude_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[2]] = dtm[System.Convert.ToInt32(timeseries.timeseries_textbox_cell_row.Text), System.Convert.ToInt32(timeseries.timeseries_textbox_cell_col.Text)];
            }
            if (timeseries.timeseries_net_ero_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[3]] = volume_eroded + volume_deposited + sediment_delta_m + sediment_filled_m;
            }
            if (timeseries.timeseries_number_dep_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[4]] = deposited_cells;
            }
            if (timeseries.timeseries_number_erosion_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[5]] = eroded_cells;
            }
            if (timeseries.timeseries_number_waterflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[6]] = wet_cells;
            }
            if (timeseries.timeseries_SDR_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[7]] = (volume_eroded + volume_deposited + sediment_delta_m + sediment_filled_m) / volume_eroded;
            }
            if (timeseries.timeseries_total_average_alt_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[8]] = total_average_altitude;
            }
            if (timeseries.timeseries_total_dep_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[9]] = volume_deposited + sediment_delta_m + sediment_filled_m;
            }
            if (timeseries.timeseries_total_ero_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[10]] = -volume_eroded;
            }
            if (timeseries.timeseries_total_evap_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[11]] = total_evap;
            }
            if (timeseries.timeseries_total_infil_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[12]] = total_infil;
            }
            if (timeseries.timeseries_total_outflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[13]] = total_outflow;
            }
            if (timeseries.timeseries_total_rain_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[14]] = total_rain;
            }

        }
        /*
        void calculate_sediment_dynamics(int row_sd, int col_sd, int i_sd, int j_sd, double waterflow_m3_per_m, double flowfraction, double sum_of_fractions)
        {
            int size;
            double total_sediment_in_transport_kg, organic_in_transport, mass_to_be_eroded, rock_fraction, bio_fraction, vegetation_cover_fraction, selectivity_fraction, potential_transported_amount_kg, organic_selectivity_fraction, frac_eroded, frac_deposited;
            double[] total_mass_eroded, total_mass_deposited_kg;
            total_mass_eroded = new double[7] { 0, 0, 0, 0, 0, 0, 0 };
            total_mass_deposited_kg = new double[7] { 0, 0, 0, 0, 0, 0, 0 };


            transport_capacity_kg = advection_erodibility * (bulkdensity[row_sd, col_sd, 0] * dx * dx) * (Math.Pow(waterflow_m3_per_m, m) * Math.Pow(dh, n)); // in a departure from literature, the erosion threshold is only evaluated if erosion actually occurs
            if (transport_capacity_kg < 0)
            {
                transport_capacity_kg = 0;
                Debug.WriteLine(" Warning: negative transport capacity at" + row_sd + " " + col_sd);
            }  // this should never happen
               // We now compare transport_capacity with the total amount of sediment in transport, to determine whether we will have erosion or deposition or nothing
            total_sediment_in_transport_kg = 0;

            for (size = 0; size < n_texture_classes; size++)
            {
                total_sediment_in_transport_kg += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];                     //all in kg
            }

            // Transport
            if (transport_capacity_kg == total_sediment_in_transport_kg)
            {
                // neither erosion nor deposition, simply transport
                for (size = 0; size < n_texture_classes; size++)
                {
                    sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];  //all in kg 
                }
                old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd];  //all in kg
                young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd];  //all in kg

                if (CN_checkbox.Checked)
                {
                    // add fraction of all CNs to the receiving cell
                    for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                    {
                        CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += Convert.ToInt32(Math.Round(CN_in_transport[row_sd, col_sd, i_cn] * flowfraction));
                    }
                }
                if (OSL_checkbox.Checked)
                {
                    transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, 0);
                }
            }

            // Erosion
            if (transport_capacity_kg > total_sediment_in_transport_kg)
            {
                //in case of desired erosion, we first evaluate whether we exceed the erosion threshold
                if ((transport_capacity_kg - total_sediment_in_transport_kg) > erosion_threshold_kg)
                {
                    //first, calculate how much we are going to erode. Not as much as we want to if the soil is protected by rocks or plants
                    rock_fraction = texture_kg[row_sd, col_sd, 0, 0] / (texture_kg[row_sd, col_sd, 0, 0] + texture_kg[row_sd, col_sd, 0, 1] + texture_kg[row_sd, col_sd, 0, 2] + texture_kg[row_sd, col_sd, 0, 3] + texture_kg[row_sd, col_sd, 0, 4]);
                    if (version_lux_checkbox.Checked == false)
                    {
                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                        * Math.Exp(-rock_protection_constant * rock_fraction)
                        * Math.Exp(-bio_protection_constant);
                    }
                    else
                    {  //for Luxemburg version, here we additially protect soil from erosion by its cover of 'bad' organic matter as litter (i.e. in top layer)

                        // MvdM litter fraction is determined by the total amount of litter as fraction of the mineral soil in the top layer. This might be changed, because mineral content is variable and indepent of litter quantity
                        //XIA change this number to 0.25 as well. For creep and no creep
                        double litter_characteristic_protection_mass_kg_m2 = 0.01; // based on average litter contents in Luxembourg
                        double litter_characteristic_protection_mass_kg = litter_characteristic_protection_mass_kg_m2 * dx * dx;
                        double litter_protection_fraction = Math.Exp(-litter_characteristic_protection_mass_kg / (litter_kg[row_sd, col_sd, 0] + litter_kg[row_sd, col_sd, 1]));
                        // double litter_fraction = (litter_kg[row, col, 0] + litter_kg[row, col, 0]) / (litter_kg[row, col, 0] + litter_kg[row, col, 0] + total_layer_mass(row, col, 0));

                        //double litter_fraction = (old_SOM_kg[row, col, 0] + young_SOM_kg[row, col, 0]) / total_layer_mass(row, col, 0);
                        //LUX Xia you have to set this parameter here in the code. Value between 0-1.
                        // double litter_protection_constant = 0.5;

                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                        * Math.Exp(-rock_protection_constant * rock_fraction)
                        * Math.Exp(-bio_protection_constant)
                        * Math.Exp(-litter_protection_fraction);
                    }
                    if (daily_water.Checked)
                    {
                        if (aridity_vegetation[row, col] >= 1) { vegetation_cover_fraction = 1; }
                        else { vegetation_cover_fraction = aridity_vegetation[row, col]; }
                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                            * Math.Exp(-rock_protection_constant * rock_fraction)
                            * Math.Exp(-bio_protection_constant
                            * vegetation_cover_fraction);
                    }

                    // second, calculate how the mass to be eroded is taken from the different size fractions: selectivity
                    // if total transport capacity is small, only the finer fractions will be eroded (selectivity with diameter to power 0.5). For larger transport capacities, selectivity decreases (diameter to power 0 = equal between fractions)

                    double constant_b1 = 0.5 * Math.Exp(constant_selective_transcap * transport_capacity_kg);
                    double sum_diameter_power = 0;
                    for (size = 0; size < 5; size++)
                    {
                        sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], constant_b1);
                    }
                    double clayeroded_0_kg = 0, claypresent_0_kg = 0, clayeroded_1_kg = 0, claypresent_1_kg = 0;
                    double sanderoded_0_kg = 0, sandpresent_0_kg = 0, sanderoded_1_kg = 0, sandpresent_1_kg = 0;
                    for (size = 0; size < 5; size++)
                    {
                        selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], constant_b1)) / sum_diameter_power;    // unit [-]
                        if (texture_kg[row_sd, col_sd, 0, size] >= selectivity_fraction * mass_to_be_eroded)
                        {    // typical situation
                            if (size == 1)
                            {
                                sanderoded_0_kg = selectivity_fraction * mass_to_be_eroded;
                                sandpresent_0_kg = texture_kg[row_sd, col_sd, 0, size];
                            }
                            if (size > 2)
                            {
                                clayeroded_0_kg += selectivity_fraction * mass_to_be_eroded;
                                claypresent_0_kg += texture_kg[row_sd, col_sd, 0, size];
                            }
                            total_mass_eroded[size] += selectivity_fraction * mass_to_be_eroded;
                            texture_kg[row_sd, col_sd, 0, size] -= selectivity_fraction * mass_to_be_eroded;   // unit [kg]
                            sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += selectivity_fraction * mass_to_be_eroded;  // unit [kg
                        }
                        else
                        {    // exceptional. If we want to erode more than present in the layer, we will take it from one layer down.
                             //this is to avoid exceptionally thin rocky layers blocking all erosion
                             //we will then first erode everything from the top layer (layer "0") and then erode from the second layer  (i.e. layer "1").

                            // Layer 0
                            if (size == 1)
                            {
                                sanderoded_0_kg = texture_kg[row_sd, col_sd, 0, size];
                                sandpresent_0_kg = texture_kg[row_sd, col_sd, 0, size];
                            }
                            if (size > 2)
                            {
                                clayeroded_0_kg += texture_kg[row_sd, col_sd, 0, size];
                                claypresent_0_kg += texture_kg[row_sd, col_sd, 0, size];
                            }
                            total_mass_eroded[size] += texture_kg[row_sd, col_sd, 0, size];
                            double left = (selectivity_fraction * mass_to_be_eroded) - texture_kg[row_sd, col_sd, 0, size]; // unit [kg]
                            sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += texture_kg[row_sd, col_sd, 0, size];
                            texture_kg[row_sd, col_sd, 0, size] = 0;

                            // Layer 1
                            if (texture_kg[row_sd, col_sd, 1, size] >= left)
                            {   // typical
                                if (size == 1)
                                {
                                    sanderoded_1_kg = left;
                                    sandpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                }
                                if (size > 2)
                                {
                                    clayeroded_1_kg += left;
                                    claypresent_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                }
                                total_mass_eroded[size] += left;
                                sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += left;   // unit [kg]
                                texture_kg[row_sd, col_sd, 1, size] -= left;  // unit [kg]
                            }
                            else
                            {
                                total_mass_eroded[size] += texture_kg[row_sd, col_sd, 1, size];
                                if (size == 1)
                                {
                                    sanderoded_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                    sandpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                }
                                if (size > 2)
                                {
                                    clayeroded_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                    claypresent_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                }
                                sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += texture_kg[row_sd, col_sd, 1, size];// unit [kg]
                                texture_kg[row_sd, col_sd, 1, size] = 0;
                            }
                        }
                    }

                    //organic matter is eroded as a fraction of total OM. That fraction equals the fraction of clay eroded from the layer
                    //the assumption underlying this is that clay and humus are bound in aggregates
                    //this does not cover: LMW SOM, peat or large woody debris
                    double clayerodedfraction_0 = clayeroded_0_kg / claypresent_0_kg;
                    double clayerodedfraction_1 = clayeroded_1_kg / claypresent_1_kg;
                    double sanderodedfraction_0 = sanderoded_0_kg / sandpresent_0_kg;
                    double sanderodedfraction_1 = sanderoded_1_kg / sandpresent_1_kg;
                    if (Double.IsNaN(clayerodedfraction_0))
                    {
                        clayerodedfraction_0 = 0;
                        Debug.WriteLine(" this should not have happened - no OM erosion possible");
                    }
                    if (Double.IsNaN(clayerodedfraction_1)) { clayerodedfraction_1 = 0; }
                    if (Double.IsNaN(sanderodedfraction_0)) { sanderodedfraction_0 = 0; }
                    if (Double.IsNaN(sanderodedfraction_1)) { sanderodedfraction_1 = 0; }
                    //if (row == 62 && col == 78) { Debug.WriteLine(clayerodedfraction_0 + "  " + clayerodedfraction_1); displaysoil(row, col); }
                    old_SOM_in_transport_kg[row_sd, col_sd] += old_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + old_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    young_SOM_in_transport_kg[row_sd, col_sd] += young_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + young_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    total_mass_eroded[5] += old_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + old_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    total_mass_eroded[6] += young_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + young_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    old_SOM_kg[row_sd, col_sd, 0] *= 1 - clayerodedfraction_0;
                    young_SOM_kg[row_sd, col_sd, 0] *= 1 - clayerodedfraction_0;
                    old_SOM_kg[row_sd, col_sd, 1] *= 1 - clayerodedfraction_1;
                    young_SOM_kg[row_sd, col_sd, 1] *= 1 - clayerodedfraction_1;

                    if (OSL_checkbox.Checked)
                    {
                        transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, sanderodedfraction_0, sanderodedfraction_1, 0);
                    }

                    if (CN_checkbox.Checked)
                    {
                        for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                        {
                            // Erosion layer 0
                            if (i_cn == 0 | i_cn == 4) { frac_eroded = clayerodedfraction_0; } else { frac_eroded = sanderodedfraction_0; }
                            int CN_erosion = Convert.ToInt32(Math.Round(CN_atoms_cm2[row_sd, col_sd, 0, i_cn] * frac_eroded));
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_erosion; // add CNs associated with eroded fraction to transport
                            CN_atoms_cm2[row_sd, col_sd, 0, i_cn] -= CN_erosion; // remove from source location

                            // Erosion layer 1
                            if (i_cn == 0 | i_cn == 4) { frac_eroded = clayerodedfraction_1; } else { frac_eroded = sanderodedfraction_1; }
                            CN_erosion = Convert.ToInt32(Math.Round(CN_atoms_cm2[row_sd, col_sd, 1, i_cn] * frac_eroded));
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_erosion; // add CNs associated with eroded fraction
                            CN_atoms_cm2[row_sd, col_sd, 1, i_cn] -= CN_erosion; // remove from source location

                            // CNs already in transport
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += Convert.ToInt32(Math.Round(CN_in_transport[row_sd, col_sd, i_cn] * flowfraction));
                        }
                    }
                }
                else
                {
                    //do nothing. We wanted to erode, but not enough so to actually exceed the threshold and actually do that
                    // But we still need to transport the sediments that were already in transport:
                    for (size = 0; size < n_texture_classes; size++)
                    {
                        sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];  //all in kg 
                    }
                    old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd];  //all in kg
                    young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd];  //all in kg

                    if (OSL_checkbox.Checked)
                    {
                        transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, 0);
                    }

                    if (CN_checkbox.Checked)
                    {
                        for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                        {
                            // CNs already in transport
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += Convert.ToInt32(Math.Round(CN_in_transport[row_sd, col_sd, i_cn] * flowfraction));
                        }
                    }

                }
            }

            // Deposition
            if (transport_capacity_kg < total_sediment_in_transport_kg)
            {
                //first, calculate how much we are going to keep in transport. This is the way that selectivity works now. 
                double sum_diameter_power = 0, clay_deposited = 0, clay_transported = 0, clay_in_transport = 0, sand_deposited = 0, sand_in_transport = 0;
                for (size = 0; size < 5; size++)
                {
                    sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], 0.5);
                }
                for (size = 0; size < 5; size++)
                {
                    selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], 0.5)) / sum_diameter_power;    // unit [-]
                    potential_transported_amount_kg = selectivity_fraction * transport_capacity_kg;                      // unit [kg]
                    if (potential_transported_amount_kg < sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction)
                    {
                        total_mass_deposited_kg[size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                        texture_kg[row_sd, col_sd, 0, size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;        // unit [kg]
                        sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] = potential_transported_amount_kg;                                    // unit [kg]  
                        if (size == 1)
                        {
                            sand_deposited = sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                            sand_in_transport = sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                        }
                        if (size > 2)
                        {
                            clay_deposited += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                            clay_transported += potential_transported_amount_kg;
                            clay_in_transport += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                        }
                    }
                    else
                    {
                        //do nothing. We keep the sediment in transport, and do not deposit anything. Only transport the sediments to the next cell
                        sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                    }
                }
                // now organic matter
                double sand_deposited_fraction = sand_deposited / sand_in_transport; if (Double.IsNaN(sand_deposited_fraction)) { sand_deposited_fraction = 0; }
                double clay_deposited_fraction = clay_deposited / clay_in_transport; ; if (Double.IsNaN(clay_deposited_fraction)) { clay_deposited_fraction = 0; }

                total_mass_deposited_kg[5] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                total_mass_deposited_kg[6] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                young_SOM_kg[row_sd, col_sd, 0] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                old_SOM_kg[row_sd, col_sd, 0] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;

                young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * (1 - clay_deposited_fraction);
                old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * (1 - clay_deposited_fraction);

                // Now geochronology
                if (OSL_checkbox.Checked)
                {
                    transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, sand_deposited_fraction); // layer 0
                }

                if (CN_checkbox.Checked)
                {
                    for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                    {
                        // Deposition layer 0
                        if (i_cn == 0 | i_cn == 4) { frac_deposited = clay_deposited_fraction; } else { frac_deposited = sand_deposited_fraction; }

                        int CN_deposition = Convert.ToInt32(Math.Round(CN_in_transport[row_sd, col_sd, i_cn] * flowfraction * frac_deposited));
                        CN_atoms_cm2[row_sd, col_sd, 0, i_cn] += CN_deposition; // deposit CNs
                        CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += (Convert.ToInt32(Math.Round(CN_in_transport[row_sd, col_sd, i_cn] * flowfraction)) - CN_deposition); // transport the rest
                    }
                }
            } // end deposition
        }
        */

        void ini_slope()   //Initialise LS parameters   
        {
            // the soil physical / hydrological / slope stability parameters:
            //	 Transmissivity, Bulk Density,              
            //   Combined Cohesion and Internal riction.
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    //currently spatially uniform
                    T_fac[row, col] = System.Convert.ToDouble(textBox_ls_trans.Text);
                    C_fac[row, col] = System.Convert.ToDouble(textBox_ls_coh.Text);
                    bulkd[row, col] = System.Convert.ToDouble(textBox_ls_bd.Text);
                    intfr[row, col] = System.Convert.ToDouble(textBox_ls_ifr.Text);

                    // below, the old parameter values for New Zealand (spatially different) are kept
                    /*if (soilmap[row, col] == -9999)
                    { //
                        soilmap[row, col] = 0;
                    }
                    T_fac[row, col] = 15 * T_act; C_fac[row, col] = 0.2 * C_act; Cs_fac[row, col] = 10; // Defaults  15;0.2;10.0;1.8;0.7
                    bulkd[row, col] = 1.8 * bulkd_act; intfr[row, col] = 0.7 * intfr_act;
                    /*if (soilmap[row,col]==1) {  // Lone Kauri 15;0.43;12.223;1.455;0.688
                        T_fac[row,col]=a_T*T_act; C_fac[row,col]=a_coh*C_act;
                        bulkd[row,col]=a_bd*bulkd_act; intfr[row,col]=a_ifr*intfr_act;
                     }
                    if (soilmap[row,col]==2) {  // Piha       18;0.21;5.976;1.447;0.678
                        T_fac[row,col]=b_T*T_act; C_fac[row,col]=b_coh*C_act;
                        bulkd[row,col]=b_bd*bulkd_act; intfr[row,col]=b_ifr*intfr_act;
                     }
                    if (soilmap[row,col]==3) {  // Nihotupu   11;0.25;13.352;1.436;0.548
                        T_fac[row,col]=c_T*T_act; C_fac[row,col]=c_coh*C_act;
                        bulkd[row,col]=c_bd*bulkd_act; intfr[row,col]=c_ifr*intfr_act;
                     }
                     if (soilmap[row,col]==4) {  //
                        T_fac[row,col]=d_T*T_act; C_fac[row,col]=d_coh*C_act;
                        bulkd[row,col]=d_bd*bulkd_act; intfr[row,col]=d_ifr*intfr_act;
                     }
                     if (soilmap[row,col]==5) {  //
                        T_fac[row,col]=e_T*T_act; C_fac[row,col]=e_coh*C_act;
                        bulkd[row,col]=e_bd*bulkd_act; intfr[row,col]=e_ifr*intfr_act;
                     }   */
                } //for
            } //for
        }

        void calculate_critical_rain()    //Calculates Critical Steady State Rainfall for Landsliding    
        {
            // from steepest local slope, contributing area and stability parameters
            // start calculation number of contributing draining cells by multiple flow algorithm
            this.InfoStatusPanel.Text = "critical rainfall calculation";
            double beta;
            //set all start q values effective precipitation at time t
            nb_ok = 0; nb_check = 0; all_grids = 0;
            maximum_allowed_deposition = -9999; dh_tol = 0.00025;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    camf[row, col] = 1;    // contributing area multiple flow matrix = 1
                    stslope[row, col] = 0;
                    crrain[row, col] = 0;
                }
            }

            int runner;
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {           // the index is sorted from low to high values, but flow goes from high to low
                row = row_index[runner]; col = col_index[runner];
                // into loop for surounding grids of certain grid
                // Start first the slope_sum loop for all lower neighbour grids
                powered_slope_sum = 0; max_allowed_erosion = 0; dz_min = -9999.99;
                direct = 20; dz_max = -1; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);

                // Repeat the loop to determine flow if all draining neighbours are known
                // but do this only once
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) &&   // boundaries
                             ((col + j) >= 0) && ((col + j) < nc) &&
                       !((i == 0) && (j == 0)))
                        {
                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                            if (dh < 000000)
                            {// i j is a higher neighbour
                                if (dh > dz_min) { dz_min = dh; }
                                if ((dh < 000000))
                                {// i j is a higher neighbour
                                    if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                                }
                            }
                            if (dh > 000000)
                            {// i j is a lower neighbour
                                if ((dh > 000000))
                                {
                                    if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                                }
                                dh = dh / d_x;
                                if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                dh = Math.Pow(dh, conv_fac);
                                powered_slope_sum = powered_slope_sum + dh;
                            }//end if
                        }//end if
                    }//end for
                }//end for
                if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = -maximum_allowed_deposition; }
                if (max_allowed_erosion == 0.0) { max_allowed_erosion = -dh_tol; } else { max_allowed_erosion = -max_allowed_erosion; }
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 000000; fraction = 0;
                        frac_dis = 0;
                        d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                        {
                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                            // Multiple Flow: If there are lower neighbours start evaluating
                            if (dh > 000000)
                            { // multiple flow
                              // fraction of discharge into a neighbour grid
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                Slope = dh / d_x;
                                dh = dh / d_x;
                                dh = Math.Pow(dh, conv_fac);
                                fraction = (dh / powered_slope_sum); // multiple fow
                                frac_dis = (camf[row, col] * fraction);
                                camf[row + i, col + j] += frac_dis;
                            }//end if
                        }//end if boarders
                    }//end for j
                }//end for i
            }   // end for

            // Calculation of steepest descent local slope, 8 cell window
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    direct = 20; dz_max = -1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 000000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                if (dh > 000000)
                                {// i j is a lower neighbour
                                    dh = dh / d_x;
                                    if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                }//end if
                            }//end if
                        }//end for
                    }//end for
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 000000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                if ((i * 3 + 5 + j) == direct)
                                { // steepest descent
                                    stslope[row, col] = Math.Atan(dh / d_x);
                                    // Calculation of CRITICAL RAINFALL value = relative landslide hazard, along steepest descent local slope
                                    beta = (T_fac[row, col] * (Math.Sin(stslope[row, col])) * (dx / (camf[row, col] * dx * dx)) * bulkd[row, col] * (1 - ((Math.Sin(stslope[row, col]) - C_fac[row, col]) / ((Math.Tan(intfr[row, col]) * Math.Cos(stslope[row, col])))))); // 'valid' critical rainfall value
                                    if (Math.Tan(stslope[row, col]) > (Math.Tan(intfr[row, col]) + (C_fac[row, col] / Math.Cos(stslope[row, col])))) { beta = -99; } //unconditionally unstable
                                    if (((bulkd[row, col] * Math.Sin(stslope[row, col])) + ((1 - bulkd[row, col]) * Math.Cos(stslope[row, col]) * Math.Tan(intfr[row, col]))) <= ((bulkd[row, col]) * (C_fac[row, col]))) { beta = 99; } // unconditionally stable
                                    crrain[row, col] = (beta);
                                    //Debug.WriteLine( "critical rain for " + row + " " + col + " " + crrain[row,col] + " T_fac " + T_fac[row, col] + " stslope_sin " + Math.Sin(stslope[row, col]) + " upstream " + camf[row,col] + "\n bulkd " + bulkd[row, col] + " C_fac " + C_fac[row, col] + " intfr " + Math.Tan(intfr[row, col]) + " stslope_cos " + Math.Cos(stslope[row, col]) );
                                }
                            }//end if
                        }//end for
                    }//end for
                } // end for
            } // end for 
            out_double("critrain.asc", crrain);
        }

        void steepdesc(int rowst, int colst)
        {
            int trow;
            int tcol;
            trow = rowst;
            tcol = colst;
            xrow = 0; xcol = 0;
            powered_slope_sum = 0;
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                    if (((trow + i) >= 0) && ((trow + i) < nr) &&   // boundaries
                        ((tcol + j) >= 0) && ((tcol + j) < nc) &&
                        !((i == 0) && (j == 0)))
                    {
                        dh = (dtm[trow, tcol] - dtm[trow + i, tcol + j]);
                        if ((trow != trow + i) && (tcol != tcol + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                        if (dh < 000000)
                        {// i j is a higher neighbour
                            if (dh > dz_min) { dz_min = dh; }
                            if ((dh < 000000))
                            {// i j is a higher neighbour
                                if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                            }
                        }
                        if (dh > 000000)
                        {// i j is a lower neighbour
                            if ((dh > 000000))
                            {
                                if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                            }
                            dh = dh / d_x;
                            if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                            dh = Math.Pow(dh, conv_fac);
                            powered_slope_sum = powered_slope_sum + dh;
                        }//end if
                    }//end if
                }//end for
            }//end for
            if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = (maximum_allowed_deposition * (-1)); }
            if (max_allowed_erosion == 0) { max_allowed_erosion = dh_tol * -1; } else { max_allowed_erosion = (max_allowed_erosion * (-1)); }
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    dh = 000000; fraction = 0;
                    frac_dis = 0;
                    if (((trow + i) >= 0) && ((trow + i) < nr) &&   // boundaries
                           ((tcol + j) >= 0) && ((tcol + j) < nc) &&
                          !((i == 0) && (j == 0)))
                    {
                        dh = (dtm[trow, tcol] - dtm[trow + i, tcol + j]);
                        // Steepest descent only one neighbour
                        if ((i * 3 + 5 + j) == direct)
                        { //steepest descent
                            xrow = trow + i;
                            xcol = tcol + j;
                        }//end if
                    }//end if borders
                }//end for j
            }//end for i
        }

        void calculate_slide()
        {
            try
            {
                this.InfoStatusPanel.Text = "landslide calculation";
                int tell;
                //set all start q values effective precipitation at time t
                nb_ok = 0; nb_check = 0; all_grids = 0.0;
                maximum_allowed_deposition = -9999.0; dh_tol = 0.00025; erotot = 0.0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        slidemap[row, col] -= 1;  // terug opbouwen van 'landslide potential' bij meerdere tijdstappen
                        if (slidemap[row, col] < 0) { slidemap[row, col] = 0; }
                        ero_slid[row, col] = 0.0;
                        sed_slid[row, col] = 0.0;
                        cel_dist[row, col] = 0.0;
                        dh_slid[row, col] = 0.0;
                        sed_bud[row, col] = 0.0;
                    }
                }

                // into while loop for all grids if not all neighbours are processed
                int runner;
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];

                    // into loop for surrounding grids of certain grid
                    // Start first the slope_sum loop for all lower neighbour grids
                    powered_slope_sum = 0.0; max_allowed_erosion = 0.0; dz_min = -9999.99; d_x = dx;
                    direct = 20; dz_max = -1.0; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);
                    // Repeat the loop to determine if all neigbours are processed
                    nb_ok = 1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 0.000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                            }//end if
                        }//end for
                    }//end for
                     // Repeat the loop to determine flow if all draining neighbours are known
                     // but do this only once
                     // First loop to process slide erosion with a slope limit and steepest descent


                    slide_tot = 0.0;
                    dh_tot = 0.0;
                    steepdesc(row, col);
                    dh = (dtm[row, col] - dtm[xrow, xcol]);
                    if ((row != xrow) && (col != xcol)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                    Slope = dh / d_x;
                    if ((Slope > 0.176327) && (slidemap[row, col] < 1))
                    { // FACTOR 1 and not slided yet
                        if (watsh[row, col] == 1)
                        {
                            if ((crrain[row, col] > 0.0) && (crrain[row, col] < 0.02))
                            { // FACTOR 4 RELATIVE RISK FOR 'GOING' SET AT 0.02 m/d !!! = SCENARIO
                                if (ero_slid[row, col] > -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]))
                                { // FACTOR 1 maximal erosion applied if more than one slide
                                    ero_slid[row, col] = -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                    slide_tot += -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                    dh_tot += dh;
                                    //getch();
                                }
                                while (Slope > 0.176327)
                                {   // FACTOR 1
                                    xxrow = xrow; xxcol = xcol;
                                    steepdesc(xrow, xcol);
                                    dh = (dtm[xxrow, xxcol] - dtm[xrow, xcol]);
                                    if ((xxrow != xrow) && (xxcol != xcol)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    Slope = dh / d_x;
                                    if (Slope > 0.176327)
                                    {// FACTOR 1 slide keeps eroding if > 10 degrees steepest descent is encountered
                                        if ((ero_slid[xxrow, xxcol] == 0.0) && (slidemap[row, col] < 1))
                                        { // has not been processed (eroded) earlier
                                            ero_slid[xxrow, xxcol] = -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); //FACTOR 1
                                            slide_tot += -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                            dh_tot += dh;
                                        }
                                    }
                                    else { Slope = 0.0; sed_bud[xxrow, xxcol] += (slide_tot * -1.0); dh_slid[xxrow, xxcol] += (dh_tot); erotot += slide_tot; }
                                }//end while
                            }//end if
                        }
                    }

                }       // end for all sorted cells
                        //2 Second while loop to process slide deposition with a 'cell distance' and 'double' multiple flow
                nb_ok = 0; nb_check = 0; all_grids = 0.0; tell = 0;
                maximum_allowed_deposition = -9999.0; dh_tol = 0.00025; sedtot = 0.0; strsed = 0.0; startsed = 0.0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        cel_dist[row, col] = ((0.4 * dh_slid[row, col]) / dx); // FACTOR 2 calculate 'celdistance', empirical fraction of runout set at 0.4 (Lit.)
                        startsed += sed_bud[row, col]; // 'startsed'-counter = only to display initial sediment budget in ero-sed balance in model run
                    }
                }
                //2 into while loop for all grids if not all neighbours are processed
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    //2 into loop for surounding grids of certain grid
                    //2 Start first the slope_sum loop for all lower neighbour grids
                    powered_slope_sum = 0.0; max_allowed_erosion = 0.0; dz_min = -9999.99; d_x = dx;
                    direct = 20; dz_max = -1.0; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);
                    nb_ok = 1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 0.000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                            }//end if
                        }//end for
                    }//end for
                     //2 Repeat the loop to determine flow if all draining neighbours are known
                     //2 but do this only once
                    if ((sed_bud[row, col] > 0.0) && (cel_dist[row, col] > 0.0))
                    {
                        if (sed_bud[row, col] < 0.00001) tell++;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0.000000; dh1 = 0.000; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) &&   // boundaries
                                     ((col + j) >= 0) && ((col + j) < nc) &&
                            !((i == 0) && (j == 0)))
                                {
                                    dh = (dtm[row, col] - dtm[row + i, col + j]);
                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    if (dh < 0.000000)
                                    {// i j is a higher neighbour
                                        if (dh > dz_min) { dz_min = dh; }
                                        if ((dh < 0.000000))
                                        {// i j is a higher neighbour
                                            if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                                        }
                                    }
                                    if (dh > 0.000000)
                                    {// i j is a lower neighbour
                                        if ((dh > 0.000000))
                                        {
                                            if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                                        }
                                        dh = dh / d_x;
                                        if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                        dh = Math.Pow(dh, conv_fac);
                                        powered_slope_sum = powered_slope_sum + dh;
                                    }//end if
                                }//end if
                            }//end for
                        }//end for
                        if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0.0; } else { maximum_allowed_deposition = (maximum_allowed_deposition * (-1.0)); }
                        if (max_allowed_erosion == 0.0) { max_allowed_erosion = dh_tol * -1.0; } else { max_allowed_erosion = (max_allowed_erosion * (-1.0)); }
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0.000000; fraction = 0.0;
                                frac_dis = 0.0; frac_bud = 0.0;
                                d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    dh = (dtm[row, col] - dtm[row + i, col + j]);
                                    //Multiple Flow: If there are lower neighbours start evaluating
                                    if (dh > 0.000000)
                                    {// && (cel_dist[row,col]>0.0)) { // multiple flow, 'celdistance'
                                     // fraction of discharge into a neighbour grid
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        Slope = dh / d_x;
                                        dh = dh / d_x;
                                        dh = Math.Pow(dh, conv_fac);
                                        fraction = (dh / powered_slope_sum); // multiple fow

                                        if (cel_dist[row, col] <= 1.0)
                                        {
                                            frac_bud = (sed_bud[row, col] * fraction);
                                        }
                                        else
                                        {
                                            frac_bud = ((sed_bud[row, col] / cel_dist[row, col]) * fraction);
                                        }
                                        sed_bud[row + i, col + j] += ((sed_bud[row, col] * fraction) - frac_bud);
                                        sed_slid[row, col] += frac_bud;
                                        sedtot += frac_bud;
                                        if ((cel_dist[row, col] - 1.0) > 0.0)
                                        {
                                            if ((sed_bud[row + i, col + j] > 0.0) && (cel_dist[row + i, col + j] < (cel_dist[row, col] - 1.0)))
                                            {
                                                cel_dist[row + i, col + j] = (cel_dist[row, col] - 1.0);
                                            }
                                            else { cel_dist[row + i, col + j] += 0.0; }
                                        }
                                        else { cel_dist[row + i, col + j] += 0.0; }
                                        if ((camf[row, col] >= 500.0) && (sed_slid[row, col] > 0.0))
                                        { // FACTOR 3
                                            strsed += sed_slid[row, col];
                                        }
                                    }//end if
                                }//end borders
                            }//end for j
                        }//end for i
                    }//2 end if sed_bud
                } //2 end for all cells 2

                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (ero_slid[row, col] < 0.0)
                        {
                            slidemap[row, col] = 4;//potentieel terug opbouwen in # tijdstappen..., sediment kan eventueel al direct terug 'aan' gezet worden, zie hierboven **
                        }
                    }
                }
                Debug.WriteLine("Balance ero: %8.4f sed: %8.4f start:%8.4f strsed:%8.4f", erotot, sedtot, startsed, strsed);
            }
            catch
            {
                Debug.WriteLine("err_sli1");
            }

        } // end calc_slide()      

        private void calculate_tillage()
        {
            try
            {
                double mass_before = total_catchment_mass();
                this.InfoStatusPanel.Text = "tillage calculation";
                int row, col, i, j;
                double slope_sum, dz_min, d_x, dz_max, dh, fraction, temptill, tempdep, slope;

                nb_ok = 0; nb_check = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        till_result[row, col] = 0;
                        // if (dtm[row, col] < -9900 && dtm[row, col] != -9999) { Debug.WriteLine(" Cell " + row + " " + col + " has altitude " + dtm[row, col] + " till " + till_result[row, col]); }
                    }
                }

                int runner = 0;
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    // Debug.WriteLine("till1");

                    if (tillfields[row, col] == 1)
                    {
                        if (check_negative_weight(row, col) == true) { MessageBox.Show("negative weight in t " + t + ", row " + row + ", col " + col + ", step 1"); }

                        // 1. Mixing of the topsoil. 
                        double mixeddepth = 0, completelayerdepth = 0, newdepth = 0;
                        int completelayers = -1;

                        while (mixeddepth <= plough_depth)
                        {
                            completelayers++;
                            mixeddepth += layerthickness_m[row, col, completelayers];
                            // OSL_age[row, col, completelayers] = 0;


                        }// this will lead to incorporation of the (partial) layer below tillage horizon in completelayers parameter. So the highest number indicates the partial layer 
                         // Debug.WriteLine("till2");
                        double[] tilled_text = new double[5]; // includes soil 
                        double[] tilled_om = new double[2]; // includes OM
                        double[] alldepths = new double[completelayers]; // contains thicknesses of all layers
                        double[] fraction_mixed = new double[completelayers + 1];

                        // add material from complete layers
                        double mass_soil_before = total_soil_mass(row, col);
                        for (int lay = 0; lay < completelayers; lay++) // accounted for partial layer, only select complete layers
                        {
                            completelayerdepth += layerthickness_m[row, col, lay];
                            alldepths[lay] = layerthickness_m[row, col, lay];
                            fraction_mixed[lay] = 1;

                            for (int tex = 0; tex < 5; tex++)
                            {
                                tilled_text[tex] += texture_kg[row, col, lay, tex];
                            }
                            tilled_om[0] += old_SOM_kg[row, col, lay];
                            tilled_om[1] += young_SOM_kg[row, col, lay];

                        }
                        // Debug.WriteLine("till3");
                        // add material from partial layer and appoint mixed material, and give back material at the same time
                        double frac_ap = (plough_depth - completelayerdepth) / layerthickness_m[row, col, completelayers];
                        fraction_mixed[completelayers] = frac_ap;
                        if (frac_ap > 1)
                        {
                            Debug.WriteLine("err_ti1");
                        }
                        for (int tex = 0; tex < 5; tex++) // add partial mass of partial layer
                        {
                            tilled_text[tex] += texture_kg[row, col, completelayers, tex] * frac_ap; // add fraction from partial layer
                            texture_kg[row, col, completelayers, tex] *= (1 - frac_ap); // subtract mixed part
                            texture_kg[row, col, completelayers, tex] += tilled_text[tex] * (layerthickness_m[row, col, completelayers] * frac_ap) / plough_depth; // add part from mixed 
                        }

                        tilled_om[0] += old_SOM_kg[row, col, completelayers] * frac_ap;
                        old_SOM_kg[row, col, completelayers] *= (1 - frac_ap);
                        old_SOM_kg[row, col, completelayers] += tilled_om[0] * (layerthickness_m[row, col, completelayers] * frac_ap) / plough_depth;

                        tilled_om[1] += young_SOM_kg[row, col, completelayers] * frac_ap;
                        young_SOM_kg[row, col, completelayers] *= (1 - frac_ap);
                        young_SOM_kg[row, col, completelayers] += tilled_om[1] * (layerthickness_m[row, col, completelayers] * frac_ap) / plough_depth;

                        // Debug.WriteLine("till4");
                        for (int lay = 0; lay < completelayers; lay++)
                        {
                            for (int tex = 0; tex < 5; tex++)
                            {
                                texture_kg[row, col, lay, tex] = tilled_text[tex] * (alldepths[lay] / plough_depth);

                            }
                            old_SOM_kg[row, col, lay] = tilled_om[0] * (alldepths[lay] / plough_depth);
                            young_SOM_kg[row, col, lay] = tilled_om[1] * (alldepths[lay] / plough_depth);


                            layerthickness_m[row, col, lay] = thickness_calc(row, col, lay);
                            layerthickness_m[row, col, lay] = thickness_calc(row, col, lay);
                            newdepth += layerthickness_m[row, col, lay];
                        }
                        newdepth += layerthickness_m[row, col, completelayers];





                        // Debug.WriteLine("till5");
                        // 2. Calculate redistribution of material
                        // 2.a First calculate slope_sum for multiple flow, and remember how much lower the !currently! lowest lower neighbour is
                        slope_sum = 0; d_x = dx; dhtemp = -99999.99; nb_ok = 1; dz_max = 0; dz_min = -9999;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {    // boundaries
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        dh = (dtm[row, col] + till_result[row, col] - dtm[row + i, col + j] + till_result[row + i, col + j]);
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        if (dh > 0)
                                        {           // i j is a lower neighbour
                                            if (dh > dz_max) { dz_max = dh; }
                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            slope_sum = slope_sum + dh;
                                        }//end if
                                    }//end if novalues
                                }// end if boundaries
                            }//end for
                        }//end for

                        // 2.b knowing slope_sum, we can now calculate which fraction of the tilled amount goes where, and how much that is. 
                        // knowing the lowest lower neighbour of row,col lets us limit the tillage-erosion to avoid row,col becoming lower 
                        // than its lowest lower neighbour (avoiding sinks).
                        // we are also going to limit the tilled amount to avoid row+i, col+j becoming higher than its own lowest higher nb.
                        // that avoids sinks as well.
                        double mass_soil_after = total_soil_mass(row, col);
                        if (Math.Abs(mass_soil_before - mass_soil_after) > 0.0001)
                        {
                            Debug.WriteLine("err_ti2");
                        }
                        // Debug.WriteLine("till6");
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; fraction = 0.0;
                                frac_dis = 0.0;
                                d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                                {
                                    if ((dtm)[row + i, col + j] != (-9999))
                                    {
                                        dh = (dtm[row, col] + till_result[row, col] - dtm[row + i, col + j] + till_result[row + i, col + j]);
                                        if (dh > 0.000000) // i j is a lower neighbour to which we would like to till a certain amount.
                                        {
                                            // Calculate fraction of discharge into this cell
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            slope = dh / d_x;
                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            fraction = (dh / slope_sum);
                                            // Tillage erosion calculation
                                            temptill = fraction * (tilc * slope * plough_depth) * dt;    // temptill is what we would like to till from r,c to r+i,c+j
                                                                                                         // Tillage erosion correction through calculating maximum tillage: tempdep
                                            tempdep = soildepth_m[row, col];
                                            //if there is more soil than the difference between the donor cell and its lowest lower nb, limit tillage to that difference.
                                            if (tempdep > dz_max) { tempdep = dz_max; }
                                            //if there is not enough space in the receiver cell because its currently lowest higher neighbour is not high enough, 
                                            //then limit tillage to that amount. First, calculate the current altitude difference with the lowest higher neighbour of r+i,c+j 
                                            dz_min = 9999;
                                            for (alpha = (-1); alpha <= 1; alpha++)
                                            {
                                                for (beta = (-1); beta <= 1; beta++)
                                                {
                                                    if (((row + i + alpha) >= 0) && ((row + i + alpha) < nr) && ((col + j + beta) >= 0) && ((col + j + beta) < nc) && !((alpha == 0) && (beta == 0))) // boundaries
                                                    {
                                                        if (dtm[row + i + alpha, col + j + beta] != -9999)
                                                        {
                                                            if (dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] > (dtm[row + i, col + j] + till_result[row + i, col + j]))
                                                            { // we are looking at a higher neighbour of the receiver cell
                                                                if (dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] - dtm[row + i, col + j] + till_result[row + i, col + j] < dz_min)
                                                                {
                                                                    dz_min = dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] - dtm[row + i, col + j] + till_result[row + i, col + j];
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // knowing the maximum tillage that the receiver cell can receive without blocking its own higher nbs, we limit the maximum tillage to that amount
                                            if (tempdep > dz_min) { tempdep = dz_min; }
                                            if (dz_min == 9999) { tempdep = 0.0; }     // if the receiver cell does not have higher nbs, we cannot till at all.
                                            if (tempdep < 0.0) tempdep = 0.0;
                                            if (tempdep > epsilon) { tempdep -= epsilon; }  // finally, always till just a bit less than the max allowed to prevent flat areas
                                            if (temptill > tempdep) { temptill = tempdep; } // if we want to till more than the maximum possible, we only till the maximum possible.
                                                                                            // update the corresponding grids 

                                            till_result[row, col] -= temptill;
                                            till_result[row + i, col + j] += temptill;
                                            //soildepth_m[row, col] -= temptill;
                                            //soildepth_m[row + i, col + j] += temptill;
                                            //if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                            //if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }

                                            if (check_negative_weight(row, col) == true) { MessageBox.Show("negative weight in t " + t + ", row " + row + ", col " + col + ", step 2"); }


                                            //double dz_till_m = temptill;
                                            // Debug.WriteLine("till7");
                                            // 2.c update soil properties which are tilled
                                            // top layers are mixed, so it doesn't matter where eroded material comes from.
                                            // problems can arise when eroded depth is larger than plough depth. 
                                            // development needed for layers with varying bulk density, in the case this occurs in an Ap horizon
                                            double frac_eroded;

                                            //total_mass_start = total_soil_mass(row, col);
                                            int layero = 0;
                                            double temptill0 = temptill;
                                            while (temptill >= layerthickness_m[row, col, layero] | layero >= max_soil_layers) // hele laag wordt verwijderd, al het materiaal naar de volgende cel
                                            {
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    texture_kg[row + i, col + j, 0, tex] += texture_kg[row, col, layero, tex];
                                                    texture_kg[row, col, layero, tex] = 0;
                                                }
                                                young_SOM_kg[row + i, col + j, 0] += young_SOM_kg[row, col, layero];
                                                young_SOM_kg[row, col, layero] = 0;
                                                old_SOM_kg[row + i, col + j, 0] += old_SOM_kg[row, col, layero];
                                                old_SOM_kg[row, col, layero] = 0;

                                                temptill -= layerthickness_m[row, col, layero];
                                                // layerthickness_m[row, col, layero] = 0;
                                                layero++;
                                            }
                                            // Debug.WriteLine("till8");
                                            // transport eroded fraction
                                            frac_eroded = temptill / layerthickness_m[row, col, layero];
                                            // mass fraction eroded
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                texture_kg[row + i, col + j, 0, tex] += texture_kg[row, col, layero, tex] * frac_eroded;
                                                texture_kg[row, col, layero, tex] -= texture_kg[row, col, layero, tex] * frac_eroded;
                                            }
                                            young_SOM_kg[row + i, col + j, 0] += young_SOM_kg[row, col, layero] * frac_eroded;
                                            young_SOM_kg[row, col, layero] -= young_SOM_kg[row, col, layero] * frac_eroded;
                                            old_SOM_kg[row + i, col + j, 0] += old_SOM_kg[row, col, layero] * frac_eroded;
                                            old_SOM_kg[row, col, layero] -= old_SOM_kg[row, col, layero] * frac_eroded;


                                            layerthickness_m[row, col, layero] = thickness_calc(row, col, layero);
                                            layerthickness_m[row + i, col + j, 0] = thickness_calc(row, col, layero);

                                            //if necessary, i.e. an entire layer removed, shift cells up
                                            if (layero > 0)
                                            {
                                                try { remove_empty_layers(row, col); update_all_soil_thicknesses(row, col); }
                                                catch { Debug.WriteLine("Error in removing empty layers after tillage"); }
                                            }
                                        }//end if
                                    }//end if novalues
                                }//end if borders
                            }//end for j
                        }//end for i
                    } //end if tillfields
                }   // end  for 
                    // Debug.WriteLine("till9");
                    // 3. Update elevation changes
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double old_soil_thickness = soildepth_m[row, col];
                            update_all_soil_thicknesses(row, col);
                            double new_soil_thickness = total_soil_thickness(row, col);

                            dtm[row, col] += new_soil_thickness - old_soil_thickness;
                            dtmchange[row, col] += new_soil_thickness - old_soil_thickness;
                            sum_tillage[row, col] += new_soil_thickness - old_soil_thickness;
                            soildepth_m[row, col] = new_soil_thickness;
                            if (till_result[row, col] > 0) { total_sum_tillage += new_soil_thickness - old_soil_thickness; }
                        }
                    }
                }

                total_tillage_statuspanel.Text = string.Format("till {0:F0} * 1000 m3", total_sum_tillage * dx * dx / 1000);
                // Debug.WriteLine("\n--tillage overview--");
                // Debug.WriteLine(" tilled a total of " + total_sum_tillage * dx * dx / 1000 + " * 1000 m3");
                double mass_after = total_catchment_mass();
                if (Math.Abs(mass_before - mass_after) > 0.0001)
                {
                    Debug.WriteLine("err_ti3");
                }
            }
            catch
            {
                Debug.WriteLine("err_ti4");

            }
        }

        /*
        private void calculate_creep()
        {
            this.InfoStatusPanel.Text = "creep calculation";
            int row, col,
                        i, j,
                        nb_ok;
            double
                        dhmin, dhe_tol, dhs_tol,
                        slope_sum, dhmax, dz_min, d_x, dz_max, dh1, dh,
                        fraction,
                        temp, tempcreep, tempdep,
                        slope;


            nb_ok = 0; nb_check = 0; all_grids = 0;
            dhmin = -9999; dhe_tol = 0.000001; dhs_tol = 0.000001;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    creep[row, col] = 0;	// neighbour check is 0 is false
                }
            }

            int runner = 0;
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {           // the index is sorted from low to high values, but flow goes from high to low
                row = row_index[runner]; col = col_index[runner];
                // into loop for surrounding grids of certain grid
                // Start first the slope_sum loop for all lower neighbour grids
                slope_sum = 0; dhmax = 0; dz_min = -9999.99; d_x = dx;
                dz_max = -1; dhtemp = -99999.99; dhmin = (-9999.99);

                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                        {    // boundaries
                            if ((dtm)[row + i, col + j] != (-9999))
                            {
                                dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                if (dh < 000000)
                                {           // i j is a higher neighbour
                                    if (dh > dz_min) { dz_min = dh; }
                                    if (dh1 > dhmin + dhs_tol) { dhmin = (dh1 + dhs_tol); }
                                }
                                if (dh > 000000)
                                {           // i j is a lower neighbour
                                    if (dh1 > dhmax - dhe_tol) { dhmax = (dh1 - dhe_tol); }
                                    dh = dh / d_x;
                                    if (dh > dz_max) { dz_max = dh; }
                                    dh = Math.Pow(dh, conv_fac);
                                    slope_sum = slope_sum + dh;
                                }//end if
                            }//end if novalues
                        }// end if boundaries
                    }//end for
                }//end for
                if (dhmin == -9999.99) { dhmin = 0; } else { dhmin = -dhmin; }
                if (dhmax <= 0.0) { dhmax = 0.0; } else { dhmax = -dhmax; }
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 0.000000; fraction = 0.0;
                        frac_dis = 0.0;
                        d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                        {
                            if ((dtm)[row + i, col + j] != (-9999.0))
                            {
                                dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                temp = (dtm)[row + i, col + j];
                                // Multiple Flow: If there are lower neighbours start evaluating
                                if (dh > 0.000000)
                                {
                                    // fraction of discharge into a neighbour grid
                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    slope = dh / d_x;
                                    dh = dh / d_x;
                                    dh = Math.Pow(dh, conv_fac);
                                    fraction = (dh / slope_sum);
                                    // Tillage erosion calculation
                                    tempcreep = fraction * slope * diffusivity_creep / dx;
                                    tempdep = soildepth_m[row, col] * -1.0;
                                    if (tempdep > dhmax) tempdep = dhmax;
                                    if (tempcreep < (tempdep)) tempcreep = tempdep;
                                    creep[row, col] -= tempcreep;
                                    creep[row + i, col + j] += tempcreep;
                                    soildepth_m[row, col] -= tempcreep;
                                    soildepth_m[row + i, col + j] += tempcreep;
                                    if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                    if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }
                                    dtm[row, col] -= tempcreep;
                                    dtm[row + i, col + j] += tempcreep;
                                }//end if
                            }//end if novalues
                        }//end if borders
                    }//end for j
                }//end for i
            }		// end for sorted 
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    dtmchange[row, col] += (creep[row, col]);
                    sum_creep_grid[row, col] += (creep[row, col]);
                    if (creep[row, col] > 0) sum_creep += (creep[row, col]);
                }
            }
        }
        */ // oude creep berekeningen


        /*private void calculate_creep()
        {
            try
            {
                this.InfoStatusPanel.Text = "creep calculation";
                int row, col,
                            i, j,
                            nb_ok,
                            NA_dem;
                double
                            dhmin, dhe_tol, dhs_tol,
                            slope_sum, dhmax, dz_min, d_x, dz_max, dh1, dh,
                            fraction,
                            temp, tempcreep, tempdep,
                            slope;

                nb_ok = 0; nb_check = 0; all_grids = 0;
                dhmin = -9999; dhe_tol = 0.000001; dhs_tol = 0.000001;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        creep[row, col] = 0;    // neighbour check is 0 is false
                    }
                }
                NA_dem = NA_in_DEM();
                if (NA_dem != NA_in_DEM()) { Debugger.Break(); }

                int runner = 0;
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    // into loop for surrounding grids of certain grid
                    // Start first the slope_sum loop for all lower neighbour grids
                    slope_sum = 0; dhmax = 0; dz_min = -9999.99; d_x = dx;
                    dz_max = -1; dhtemp = -99999.99; dhmin = (-9999.99);
                    // if(row == 31 && col == 12) { Debug.WriteLine("creep1"); displaysoil(row, col); }
                    if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {    // boundaries
                                if ((dtm)[row + i, col + j] != (-9999))
                                {
                                    dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    if (dh < 000000)
                                    {           // i j is a higher neighbour
                                        if (dh > dz_min) { dz_min = dh; }
                                        if (dh1 > dhmin + dhs_tol) { dhmin = (dh1 + dhs_tol); }
                                    }
                                    if (dh > 000000)
                                    {           // i j is a lower neighbour
                                        if (dh1 > dhmax - dhe_tol) { dhmax = (dh1 - dhe_tol); }
                                        dh = dh / d_x;
                                        if (dh > dz_max) { dz_max = dh; }
                                        dh = Math.Pow(dh, conv_fac);
                                        slope_sum = slope_sum + dh;
                                    }//end if
                                }//end if novalues
                            }// end if boundaries
                        }//end for j
                    }//end for i
                    if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                    if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                    // if (row == 31 && col == 12) { Debug.WriteLine("creep2"); displaysoil(row, col); }

                    if (dhmin == -9999.99) { dhmin = 0; } else { dhmin = -dhmin; }
                    if (dhmax <= 0.0) { dhmax = 0.0; } else { dhmax = -dhmax; }
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 0.000000; fraction = 0.0;
                            frac_dis = 0.0;
                            d_x = dx;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                            {
                                if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                                if ((dtm)[row + i, col + j] != (-9999.0))
                                {
                                    dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                    temp = (dtm)[row + i, col + j];
                                    // Multiple Flow: If there are lower neighbours start evaluating
                                    if (dh > 0.000000)
                                    {
                                        // if (row == 31 && col == 12) { Debug.WriteLine("creep3"); displaysoil(row, col); }

                                        // fraction of discharge into a neighbour grid
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        slope = dh / d_x;
                                        dh = dh / d_x;
                                        dh = Math.Pow(dh, conv_fac);
                                        fraction = (dh / slope_sum);
                                        tempcreep = fraction * slope * diffusivity_creep / dx;
                                        tempdep = soildepth_m[row, col] * -1.0;
                                        // if (tempcreep > 1) { Debugger.Break(); }
                                        if (tempdep > dhmax) tempdep = dhmax;
                                        if (tempcreep < (tempdep)) tempcreep = tempdep;
                                        if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }


                                        //instead, we now call a separate function that calculates for every cell-cell combo the layer-mass of creep, stores effects in a big matrix, and then evaluate results of that matrix after the timestep.

                                        //if (row == 31 && col == 12)
                                        //{
                                        //    Debug.WriteLine("creep4"); displaysoil(row, col);
                                        //    Debug.WriteLine("tempcreep = {0}", tempcreep);

                                        //}
                                        if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        // if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                                        // oldsoildepths
                                        double dsoil_source = total_soil_thickness(row, col);
                                        double dsoil_sink = total_soil_thickness(row + i, col + j);
                                        calc_creep_layers(row, col, i, j, tempcreep);

                                        // if (row == 31 && col == 12) { Debug.WriteLine("creep5"); displaysoil(row, col); }

                                        if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        // if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                                        // update soil depths
                                        update_all_soil_thicknesses(row, col);
                                        update_all_soil_thicknesses(row + i, col + j);
                                        // map updates

                                        // if (row == 31 && col == 12) { Debug.WriteLine("creep6"); displaysoil(row, col); }

                                        if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                                        double dz_source = total_soil_thickness(row, col) - dsoil_source; // change in soil depth
                                        double dz_sink = total_soil_thickness(row + i, col + j) - dsoil_sink; // change in soil depth
                                        creep[row, col] += dz_source;
                                        creep[row + i, col + j] += dz_sink;
                                        soildepth_m[row, col] += dz_source;
                                        soildepth_m[row + i, col + j] += dz_sink;
                                        if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                        if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }
                                        dtm[row, col] += dz_source;
                                        dtm[row + i, col + j] += dz_sink;
                                        dtmchange[row, col] += dz_source; //MMS
                                        dtmchange[row + i, col + j] += dz_sink; //MMS

                                        if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        if (thickness_calc(row, col, 0) < 0) { displaysoil(row, col); Debugger.Break(); }

                                        // if (row == 31 && col == 12) { Debug.WriteLine("creep7"); displaysoil(row, col); }


                                    }//end if
                                }//end if novalues
                            }//end if borders
                        }//end for j
                    }//end for i
                }		// end for sorted 
            }
            catch
            {
                Debugger.Break();
            }

        }
        */ // creep compatible with multiple soil layers, but with diffusivity in meters. The new function below calculated movement in kg/m2/y MM

        private void calculate_creep()
        {
            Debug.WriteLine("start of creep");
            try
            {
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cr1");
                    Debugger.Break();
                }

                this.InfoStatusPanel.Text = "creep calculation";
                int row, col,
                            i, j,
                            nb_ok;
                double
                            dhmin, dhe_tol, dhs_tol,
                            slope_sum, dhmax, dz_min, d_x, dz_max, dh1, dh,
                            fraction,
                            temp, tempcreep_kg,
                            slope,
                            potential_creep_kg = 0, local_creep_kg = 0;

                nb_ok = 0; nb_check = 0; all_grids = 0;
                dhmin = -9999; dhe_tol = 0.00000; dhs_tol = 0.00000;

                //NA_dem = NA_in_DEM();
                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }

                int runner = 0;

                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    if (dtm[row, col] != -9999)
                    {
                        //Debug.WriteLine("cr1");
                        // into loop for surrounding grids of certain grid
                        // Start first the slope_sum loop for all lower neighbour grids
                        slope_sum = 0; dhmax = 0; dz_min = -9999.99; d_x = dx;
                        dz_max = -1; dhtemp = -99999.99; dhmin = (-9999.99);
                        // if(row == 31 && col == 12) { Debug.WriteLine("creep1"); displaysoil(row, col); }
                        if (thickness_calc(row, col, 0) < 0)
                        {
                            displaysoil(row, col); Debug.WriteLine("err_cr2");
                        }

                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {    // boundaries
                                    if ((dtm)[row + i, col + j] != (-9999))
                                    {
                                        dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        if (dh < 000000)
                                        {           // i j is a higher neighbour
                                            if (dh > dz_min) { dz_min = dh; }
                                            if (dh1 > dhmin + dhs_tol) { dhmin = (dh1 + dhs_tol); }
                                        }
                                        if (dh > 000000)
                                        {           // i j is a lower neighbour
                                            if (dh > dhmax - dhe_tol) { dhmax = (dh - dhe_tol); }
                                            dh = dh / d_x;
                                            if (dh > dz_max) { dz_max = dh; }
                                            dh = Math.Pow(dh, conv_fac);
                                            slope_sum = slope_sum + dh;
                                        }//end if
                                    }//end if novalues
                                }// end if boundaries
                            }//end for j
                        }//end for i
                         //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                        if (thickness_calc(row, col, 0) < 0)
                        {
                            displaysoil(row, col); Debug.WriteLine("err_cr3");
                        }
                        if (dhmax < 0)
                        {
                            Debug.WriteLine("err_cr4");
                        }
                        //Debug.WriteLine("cr2");

                        // calculate potential creep in kg
                        double maxslope = Math.Atan(dz_max); // max slope in radians
                        // potential_creep_kg = 4.5;
                        potential_creep_kg = Convert.ToDouble(potential_bioturbation_textbox.Text);
                        if (daily_water.Checked)
                        {
                            if (aridity_vegetation[row, col] < 1) { potential_creep_kg = 4 + 0.3; } // grassland
                            else { potential_creep_kg = 4 + 1.3; } // forest
                                                                   // standard potential creep of 4 kg. 0.3 or 1.3 is added, based on vegetation type. Rates are derived from Wilkinson 2009: breaking ground and Gabet
                        }
                        local_creep_kg = potential_creep_kg * Math.Sin(maxslope) * Math.Cos(maxslope) * dx * dx * dt; //Equation from gabet et al., 2003 https://doi.org/10.1146/annurev.earth.31.100901.141314 
                                                                                                                      //Debug.WriteLine("cr3");
                        if (local_creep_kg > 0)
                        {

                            if (dhmin == -9999.99) { dhmin = 0; } else { dhmin = -dhmin; }
                            if (dhmax <= 0.0) { dhmax = 0.0; } else { dhmax = -dhmax; }
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    dh = 0.000000; fraction = 0.0;
                                    frac_dis = 0.0;
                                    d_x = dx;
                                    //if (col == 1 | col == (nc - 1))
                                    //{ Debugger.Break(); }
                                    if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                                    {
                                        //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        if (thickness_calc(row, col, 0) < 0)
                                        {
                                            displaysoil(row, col); Debug.WriteLine("err_cr5");
                                        }

                                        if ((dtm)[row + i, col + j] != (-9999.0))
                                        {
                                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                                            temp = dtm[row + i, col + j];
                                            // if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                            // Multiple Flow: If there are lower neighbours start evaluating
                                            if (dh > 0.000000)
                                            {
                                                // if (row == 31 && col == 12) { Debug.WriteLine("creep3"); displaysoil(row, col); }
                                                //Debug.WriteLine("Cr1, dtm = {0}", dtm[row, col]);
                                                // fraction of discharge into a neighbour grid
                                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                                slope = dh / d_x;
                                                dh = dh / d_x;
                                                dh = Math.Pow(dh, conv_fac);
                                                fraction = (dh / slope_sum);
                                                tempcreep_kg = fraction * local_creep_kg; //MM develop. Original function was fraction*slope*diffusivity. Do I need to add slope in calculations?
                                                //ArT:No, I don't think so. Just a fraction that you correctly calculated using slope (i.e. dh power conv fac).

                                                //// oldsoildepths
                                                double dsoil_source = total_soil_thickness(row, col);
                                                double dsoil_sink = total_soil_thickness(row + i, col + j);
                                                //displaysoil(row + i, col + j);
                                                double oldmass = total_soil_mass(row, col) + total_soil_mass(row + i, col + j);

                                                double oldmass_source = total_soil_mass(row, col);
                                                double oldmass_sink = total_soil_mass(row + i, col + j);

                                                calc_creep_layers(row, col, i, j, tempcreep_kg);


                                                // update soil depths                                               
                                                update_all_soil_thicknesses(row, col);
                                                update_all_soil_thicknesses(row + i, col + j);

                                                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                                if (thickness_calc(row, col, 0) < 0)
                                                {
                                                    displaysoil(row, col);
                                                    Debug.WriteLine("err_cr6");

                                                    Debug.WriteLine(thickness_calc(row, col, 0));
                                                    ;
                                                }

                                                double dsoil_source_new = total_soil_thickness(row, col);
                                                double dsoil_sink_new = total_soil_thickness(row + i, col + j);

                                                //displaysoil(row + i, col + j);

                                                double dz_source = dsoil_source_new - dsoil_source; // change in soil depth
                                                double dz_sink = dsoil_sink_new - dsoil_sink; // change in soil depth
                                                //at this stage, we should connect to any blocks that are in the source and sink cells,
                                                //and add dz_source and sink to their accum creep counters
                                                //first, see if there are any blocks in here
                                                if (blocks_active == 1)
                                                {
                                                    // need to precalculate total block surface area per cell in a function (not from here) 
                                                    // to allow correction for more blocks having more stopping power and higher buildup behind them
                                                    foreach (var Block in Blocklist)
                                                    {
                                                        int blrow = Convert.ToInt32(Math.Floor(Block.Y_row));
                                                        int blcol = Convert.ToInt32(Math.Floor(Block.X_col));
                                                        if (row == blrow && col == blcol)
                                                        {
                                                            //then we have blocks that are giving in this direction, so should subtract from accum_creep
                                                            //i, j will tell us where this creep went to, so which of our 8 values we shoudl subrtact from
                                                            switch (10 * j + i)
                                                            {
                                                                case -1:  //To N
                                                                    Block.Accumulated_creep_m_0 += Convert.ToSingle(dz_source); break;
                                                                case 9: // To NE
                                                                    Block.Accumulated_creep_m_1 += Convert.ToSingle(dz_source); break;
                                                                case 10: //To E
                                                                    Block.Accumulated_creep_m_2 += Convert.ToSingle(dz_source); break;
                                                                case 11: //To SE
                                                                    Block.Accumulated_creep_m_3 += Convert.ToSingle(dz_source); break;
                                                                case 1: //To S
                                                                    Block.Accumulated_creep_m_4 += Convert.ToSingle(dz_source); break;
                                                                case -9: //To SW
                                                                    Block.Accumulated_creep_m_5 += Convert.ToSingle(dz_source); break;
                                                                case -10: //To W
                                                                    Block.Accumulated_creep_m_6 += Convert.ToSingle(dz_source); break;
                                                                case -11: //To NW
                                                                    Block.Accumulated_creep_m_7 += Convert.ToSingle(dz_source); break;
                                                                default:
                                                                    break;
                                                            }
                                                        }
                                                        if ((row + i) == blrow && (col + j) == blcol)
                                                        {
                                                            //then we have blocks that are receiving FROM this direction, so should add to accum_creep
                                                            //note the changed SWITCH VALUES
                                                            switch (10 * j + i)
                                                            {
                                                                case -1:  //From N, To S, etc
                                                                    Block.Accumulated_creep_m_4 += Convert.ToSingle(dz_sink); break;
                                                                case 9: // From NE
                                                                    Block.Accumulated_creep_m_5 += Convert.ToSingle(dz_sink); break;
                                                                case 10: //From E
                                                                    Block.Accumulated_creep_m_6 += Convert.ToSingle(dz_sink); break;
                                                                case 11: //From SE
                                                                    Block.Accumulated_creep_m_7 += Convert.ToSingle(dz_sink); break;
                                                                case 1: //From S
                                                                    Block.Accumulated_creep_m_0 += Convert.ToSingle(dz_sink); break;
                                                                case -9: //From SW
                                                                    Block.Accumulated_creep_m_1 += Convert.ToSingle(dz_sink); break;
                                                                case -10: //From W
                                                                    Block.Accumulated_creep_m_2 += Convert.ToSingle(dz_sink); break;
                                                                case -11: //From NW
                                                                    Block.Accumulated_creep_m_3 += Convert.ToSingle(dz_sink); break;
                                                                default:
                                                                    break;
                                                            }
                                                        }
                                                    }
                                                }

                                                double newmass = total_soil_mass(row, col) + total_soil_mass(row + i, col + j);
                                                creep[row, col] += dz_source;
                                                creep[row + i, col + j] += dz_sink;

                                                soildepth_m[row, col] += dz_source;
                                                soildepth_m[row + i, col + j] += dz_sink;
                                                // if (soildepth_m[row, col] > 5) { Debugger.Break(); }
                                                if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                                if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }

                                                dtm[row, col] += dz_source;
                                                dtm[row + i, col + j] += dz_sink;

                                                dtmchange[row, col] += dz_source; //MMS
                                                dtmchange[row + i, col + j] += dz_sink; //MMS

                                                //Debug.WriteLine("Cr5, dtm = {0}", dtm[row, col]);
                                                //displaysoil(row, col);

                                                if (Math.Abs(oldmass - newmass) > 0.00001)
                                                {
                                                    Debug.WriteLine("err_cr7");

                                                } //MM Qua hoogte lijkt het hieronder nog mis te gaan. De gewichtscheck hierboven gaat wel goed. 
                                                  // Op DTM zijn de verschillen niet te zien, op creep[,] wel
                                                if (Math.Abs(dz_source + dz_sink) > 0.01 & t > 1)
                                                {
                                                    // Can occur with a thick lower soil layer, due to small changes in depth->bulk density->thickness. Can be 4 cm for a total soil thickness of 100  m.
                                                    Debug.WriteLine("Creep: Thickness erosion and deposition are not approximately equal");
                                                    //displaysoil(row, col); 
                                                    //displaysoil(row + i, col + j); 
                                                    // Debugger.Break();
                                                }
                                                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                                if (thickness_calc(row, col, 0) < 0)
                                                {
                                                    displaysoil(row, col); Debug.WriteLine("err_cr8");
                                                }

                                                // if (row == 31 && col == 12) { Debug.WriteLine("creep7"); displaysoil(row, col); }


                                            }//end if
                                        }//end if novalues
                                    }//end if borders
                                }//end for j
                            }//end for i
                        } // end potential_creep_kg>0
                    }       // end for sorted 
                } // end runner
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cr9");
                }

            }
            catch
            {
                Debug.WriteLine("err_cr10");

            }
            // Debug.WriteLine("end of creep");
        }

        private void calc_creep_layers(int row1, int col1, int iiii, int jjjj, double mass_export_soil_kg)
        {
            // tempcreep in kg
            try
            {
                //Debug.WriteLine("Cr3.1, dtm = {0}", dtm[row1, col1]);
                //displaysoil(row1, col1);
                int layerreceiver = 0;
                double creep_depth_decay_constant = Convert.ToDouble(bioturbation_depth_decay_textbox.Text);

                double frac_overlap_lay, upperdepthdonor = 0, lowerdepthdonor = 0, upperdepthreceiver = 0, lowerdepthreceiver = 0, dsoil = 0, upp_z_lay = 0, int_curve_total, int_curve_lay, mass_export_lay_kg;
                bool C_done = false, lastlayer = false;

                dsoil = total_soil_thickness(row1, col1);
                
                //expanding soil thickness to if blocks are active to account of openness of (possibly) underlying hardlayer:
                if (blocks_active == 1) {
                    //this condition may be too strict or too lax 
                    if ((dtm[row1, col1] - dsoil) <= (hardlayerelevation_m + 0.001) && (dtm[row1, col1] - dsoil) > hardlayerelevation_m - 0.001) {
                        //Debug.WriteLine(" r " + row1 + " c " + col1 + "  increasing total creeping soildepth from " + dsoil + " to " + (dtm[row1, col1] - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1]))));
                        dsoil = Math.Max(dsoil, (dtm[row1, col1] - (hardlayerelevation_m - (hardlayerthickness_m*hardlayeropenness_fraction[row1,col1]))));
                        //Debug.WriteLine(" soildepth now " + dsoil );
                    } 
                }

                int_curve_total = 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * 0) - 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * dsoil); // integral over depth decay function, from depth 0 to total soil depth
                upperdepthdonor = 0; //  dtm[row1, col1]; using 0 leads to a continuous landscapes, instead of a step-wise pattern
                upperdepthreceiver = 0; // dtm[row1 + iiii, col1 + jjjj];
                lowerdepthreceiver = upperdepthreceiver - layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];

                //if (row == 31 && col == 12) { Debug.WriteLine("creep4a. tempcreep = {0}",tempcreep); displaysoil(row, col); }

                for (int lay = 0; lay < max_soil_layers; lay++) // test per layer where material moves to
                {

                    double laythick_m = layerthickness_m[row1, col1, lay];
                    if (laythick_m > 0)
                    {
                        if (blocks_active == 1)
                        {
                            if ((dtm[row1, col1] - (upp_z_lay+ laythick_m)) <= (hardlayerelevation_m + 0.001) && (dtm[row1, col1] - (upp_z_lay+ laythick_m)) > hardlayerelevation_m - 0.001)
                            {
                                //even though we change layer thickness here, we are not adapting how much mass is in it. 
                                //also for layers that currently end slightly IN hardlayer (for reasons unknown), and openness really small, we may actually end up reducing their thickness
                                //and if those layers are already very thin, we may end up with negative layerthicknes..
                                if (((dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1])) - laythick_m) < -0.001)
                                {
                                    Debug.WriteLine(" last layer thick_m " + laythick_m + " will be adding " + ((dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1])) - laythick_m));
                                }
                                laythick_m = (dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1]));
                                //Debug.WriteLine("adapted thickness of last layer to " + laythick_m );
                                if(laythick_m < 0) { 
                                    Debug.WriteLine(" yikes " + laythick_m + " laythick - less than zero ");
                                    Debug.WriteLine("adapted thickness of last layer to " + laythick_m );
                                    laythick_m = 0;
                                }
                            }
                        }
                        int_curve_lay = 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * upp_z_lay) - 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * (upp_z_lay + laythick_m));//integral over depth decay function, from top of layer to bottom of layer
                        upp_z_lay += laythick_m;
                        lowerdepthdonor = upperdepthdonor - laythick_m; // elevation range donor layer  
                        mass_export_lay_kg = mass_export_soil_kg * (int_curve_lay / int_curve_total); // mass to be removed from layer in kg 
                        if(mass_export_lay_kg < 0){
                            Debug.Write(" YIKES" + mass_export_lay_kg + " will be exported ");
                            mass_export_lay_kg = 0;
                        }
                        //frac_dz_lay = (tempcreep * int_curve_lay / int_curve_total) / layerthickness_m[row1, col1, lay]; // fraction that has to be removed
                        frac_overlap_lay = 0; // this fraction will be used to correct for partally overlapping layers 

                        //five options: 
                        //              A donor layer is located completely above receiving layer, exchange with air above receiving layer 0,
                        //              B donor layer partially sticks above upper receiving layer, exchange with air above receiving layer 0,
                        // option A and B will not be used, as we consider the transitio between cells as a continuous curve, i.e. not step-wise pattern
                        // -----------------------------------------------------------
                        //              C (partial) overlap with receiving layer higher than donor layer, 
                        //              D receiving layer fully overlapped by (thicker) donor layer,
                        //              E (partial) overlap with receiving layer lower than donor layer,
                        //              F donor layer fully overlapped by (thicker) receiving layer,
                        //              (G exact overlap (which is like B or E, therefore not explicitly modeled)

                        // Options A and B are about donor layers above the surface of the receiving cell.
                        // Options C-F are about subsurface overlaps of layers, working from higher to lower receiving layers.
                        // This enables update of the receiving layer, when the overlap no longer exists
                        // Exchange of mass is done immediately. After this loop layer thicknesses and DTM are updated for the next calculation

                        // OPTION A: donor layer lies completely above receiving layer
                        // Not possible with the curret setup, where upper depth of donor and receiver both are zero, as is the case in continuous landscapes
                        if (lowerdepthdonor >= upperdepthreceiver && layerreceiver == 0)
                        {
                            frac_overlap_lay = 1;
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);
                            // if(row1==0&&col1==0){ Debug.WriteLine("A, layer " +lay+": " + frac_dz_lay * frac_overlap_lay); }
                            // no need to update rieceiving layer number
                        }

                        // OPTION B. donor layer partly rises above surface source layer. exchange with air above receiving layer 0
                        // Not possible with the curret setup, where upper depth of donor and receiver both are zero, as is the case in continuous landscapes

                        if (upperdepthdonor > upperdepthreceiver && lowerdepthdonor < upperdepthreceiver && layerreceiver == 0)
                        {
                            frac_overlap_lay = (upperdepthdonor - upperdepthreceiver) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);
                            // no need to update receiving layer number, because we only look at air exchange. subsurface exchange will be treated later
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("B, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }

                        // OPTION C: (partial) overlap with receiving layer located higher than donor layer
                        if (upperdepthdonor <= upperdepthreceiver && lowerdepthdonor <= lowerdepthreceiver && upperdepthdonor > lowerdepthreceiver)
                        {
                            frac_overlap_lay = (upperdepthdonor - lowerdepthreceiver) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);

                            C_done = true;

                            if (lowerdepthdonor <= lowerdepthreceiver && layerreceiver < (max_soil_layers - 1)) // update receiving layer to a lower one. only occurs when lowerdepthdonor == lowerdepthreceiver
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("C, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }

                        // OPTION D: receiving layer completely overlapped by (thicker) donor layer
                        while (upperdepthdonor > upperdepthreceiver && lowerdepthdonor < lowerdepthreceiver && lastlayer == false) // while loop, this can occur several times, when the donor layer completely overlaps receiving layers
                        {
                            frac_overlap_lay = (upperdepthreceiver - lowerdepthreceiver) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);
                            // update receiving layer. the next layer can also be overlapped completely by donor layer
                            if (layerreceiver < (max_soil_layers - 1))
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            else
                            {
                                lastlayer = true;
                            }
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("D, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }
                        //OPTION E: overlap with receiving layer lower than donor layer  (take care that this does not evaluate to TRUE when C is also TRUE)
                        if (upperdepthdonor >= upperdepthreceiver && lowerdepthdonor >= lowerdepthreceiver && lowerdepthdonor < upperdepthreceiver && C_done == false)
                        {
                            frac_overlap_lay = (upperdepthreceiver - lowerdepthdonor) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);

                            if (lowerdepthdonor <= lowerdepthreceiver && layerreceiver < (max_soil_layers - 1)) // update receiving layer to a lower one
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            //if (row1 == 0 && col1 == 0)
                            //{
                            //    Debug.WriteLine("E, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay);
                            //    Debug.WriteLine("Dupper = {0}, Dlower = {1}, Rupper = {2}, Rlower = {3}", upperdepthdonor, lowerdepthdonor, upperdepthreceiver, lowerdepthreceiver);
                            //}
                        }

                        //OPTION F, donor layer completely overlapped by (thicker) receiver layer
                        if (upperdepthdonor < upperdepthreceiver && lowerdepthdonor > lowerdepthreceiver)
                        {
                            frac_overlap_lay = 1;
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay);
                            // no update of receiving layer required
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("F, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }
                        }

                        //OPTION H, donor soil might be absent. Material moves to upper layer of receiving layer, if elevation allows
                        if (total_soil_thickness(row1 + iiii, col1 + jjjj) == 0) // if receiving cell is bare rock 
                        {
                            bool partial_overlap = true;
                            if ((dtm[row1, col1] + upperdepthdonor) < dtm[row1 + iiii, col1 + jjjj]) { frac_overlap_lay = 0; partial_overlap = false; } // donor layer lies completely below surface of receiving cell
                            if ((dtm[row1, col1] + lowerdepthdonor) > dtm[row1 + iiii, col1 + jjjj]) { frac_overlap_lay = 1; partial_overlap = false; } // donor layer lies completely above surface of receiving cell

                            if (partial_overlap == true)
                            {
                                frac_overlap_lay = ((dtm[row1, col1] + upperdepthdonor) - dtm[row1 + iiii, col1 + jjjj]) / (upperdepthdonor - lowerdepthdonor);
                            } // donor layer lies partially above surface of receiving cell
                            if (frac_overlap_lay > 1) { frac_overlap_lay = 1; } // fraction can be a bit higher due to rounding errors

                            if (Double.IsInfinity(frac_overlap_lay) | Double.IsNaN(frac_overlap_lay) | frac_overlap_lay > 1)
                            {
                                Debug.WriteLine("err_cr11");
                            } // something went wrong in calculating overlapping fraction. Either divided by zero, a non-real answer or a fraction larger than 1


                            if (frac_overlap_lay > 0) // If the donor layer is (partially) above the bare bedrock of the receiving cell, everything can move to next cell:
                            {
                                frac_overlap_lay = 1;
                                creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, 0, mass_export_lay_kg, frac_overlap_lay);
                            }
                        }

                        upperdepthdonor = lowerdepthdonor;
                        C_done = false;
                    } // end layerthickness > 0
                } // end layers
                  // if (row == 31 && col == 12) { Debug.WriteLine("creep4b"); displaysoil(row, col); }

            } // end of try
            catch
            {
                Debug.WriteLine("Error in time {0}, row {1}, col{2}, receiving row {4}, col {5}", t, row1, col1, row1 + iiii, col1 + jjjj);
                Debug.WriteLine("err_cr12");

            }
        } // end calc_creep_layers

        private void creep_transport(int fromrow, int fromcol, int fromlay, int torow, int tocol, int tolay, double mass_export, double fraction_overlap)
        {
            try
            {
                //Debug.WriteLine("Cr3.1.1, dtm = {0}", dtm[fromrow, fromcol]);
                //displaysoil(fromrow, fromcol);

                // double fraction_transport = fraction_dz * fraction_overlap;
                double fraction_transport = mass_export / total_layer_mass(fromrow, fromcol, fromlay); // fraction of mass to be exported
                if (fraction_transport > 1) { fraction_transport = 1; }
                if (fraction_transport < 0)
                {
                    fraction_transport = 0; Debug.WriteLine("err_cr13");

                }
                if (fraction_overlap > 1) { fraction_overlap = 1; }
                for (int tex = 0; tex < 5; tex++)
                {
                    texture_kg[torow, tocol, tolay, tex] += texture_kg[fromrow, fromcol, fromlay, tex] * fraction_transport;
                    texture_kg[fromrow, fromcol, fromlay, tex] -= texture_kg[fromrow, fromcol, fromlay, tex] * fraction_transport;
                }
                young_SOM_kg[torow, tocol, tolay] += young_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                young_SOM_kg[fromrow, fromcol, fromlay] -= young_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                old_SOM_kg[torow, tocol, tolay] += old_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                old_SOM_kg[fromrow, fromcol, fromlay] -= old_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;

                //Debug.WriteLine("Cr3.1.2, dtm = {0}", dtm[fromrow, fromcol]);
                //displaysoil(fromrow, fromcol);

            }
            catch
            {
                Debug.WriteLine("crashed during creep transport calculations");
                Debug.WriteLine("err_cr14");

            }


        }

        private void calculate_tree_fall()
        {
            double tf_mass_before = total_catchment_mass();

            try
            {
                this.InfoStatusPanel.Text = "tree fall calculation";

                bool fallen = false;
                int i_tf = 0, j_tf = 0;
                // double mass_before_tf = total_catchment_mass();
                double exported_mass_tf = 0, old_soil_depth_m = 0, tree_fall_frac_sum, tf_frac_dx;

                double[] tree_fall_mass, tree_fall_om;
                double[,] tree_fall_frac;
                Random rand = new Random(t); // t as a random seed
                Random falldirection = new Random(t);
                Random age_of_trees = new Random(t);
                int P_fall = Convert.ToInt32(Math.Round((1 / tf_frequency) / (dx * dx)));
                // int P_fall = Convert.ToInt32(Math.Round(1730 / dx / dx)); // 1/P_fall is the chance of tree fall, per m2, that's why we correct for cell size 
                // Debug.WriteLine("elevation of row 57 and col 40 at t {0} is {1}", t, dtm[57, 40]);
                int rowsource = 0, colsource = 0, rowsink = 0, colsink = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999 & aridity_vegetation[row, col] > 1) // if cell exists, and if there is no grass growing
                        {
                            int chance = rand.Next(0, P_fall);
                            // Debug.WriteLine("tf2");
                            //if (row == 31 & col == 31 & t == 226) { displaysoil(31, 31); Debugger.Break(); }
                            if (chance == 1) // if a tree falls
                            {
                                rowsource = row;
                                colsource = col;
                                fallen = true;
                                treefall_count[row, col] += 1;
                                // if (row == 0 & col == 5) { Debug.WriteLine("tf on t {0}", t); }
                                int falldir = falldirection.Next(1, 9); // for now a random fall direction. This can be changed as a function of e.g. slope, aspect and dominant wind direction
                                                                        // It appears that these factors don't have a dominant effect:https://doi.org/10.3159/10-RA-011.1 
                                                                        // trees can now fall in 8 directions, to all neighbouring cells. Depending on the distance to these cells, sediments will be redistributed.
                                                                        // neighbours:
                                                                        // 1  2  3
                                                                        // 4  X  5
                                                                        // 6  7  8
                                                                        // DEVELOP change surface roughness as function of tree fall, to promote more infiltration?
                                                                        //determine row direction i_tf
                                if (falldir < 4) { i_tf = -1; }
                                else if (falldir < 6) { i_tf = 0; }
                                else if (falldir < 9) { i_tf = 1; }
                                else { MessageBox.Show("error in tree fall. Fall direction Y not known"); }
                                // Debug.WriteLine("tf3");

                                // determine col direction j_tf
                                if (falldir == 1 | falldir == 4 | falldir == 6) { j_tf = -1; }
                                else if (falldir == 2 | falldir == 7) { j_tf = 0; }
                                else if (falldir == 3 | falldir == 5 | falldir == 8) { j_tf = 1; }
                                else { MessageBox.Show("error in tree fall. Fall direction X not known"); }

                                d_x = dx; if (falldir == 1 | falldir == 3 | falldir == 6 | falldir == 8) { d_x = dx * Math.Sqrt(2); } // determine lateral fall distance

                                if ((row + i_tf) >= 0 & (row + i_tf) < nr & (col + j_tf) >= 0 & (col + j_tf) < nc)
                                {
                                    if (dtm[row + i_tf, col + j_tf] != -9999)
                                    {
                                        dh = (dtm[row, col] - dtm[row + i_tf, col + j_tf]) / d_x; // if receiving cell is in catchment, calculate slope
                                    }
                                    else
                                    {
                                        dh = 0;
                                    }
                                }
                                else
                                {
                                    dh = 0; // receiving cell outside catchment, so we assume a slope of 0 percent in order to do the calculations below
                                }

                                double dh_deg = Math.Atan(dh);

                                // growth of tree root system. A spherical growth model is assumed. 
                                // Maximum root system width W_m = 4 m in a circle. This will later be converted to a square surface with the same area
                                // Maximum root system depth D_m = 0.7 m. // From paper Finke on tree fall
                                // These depths are reached after 150 years (typical life span)
                                if (thickness_calc(row, col, 0) < 0)
                                {
                                    Debug.WriteLine("err_tf1");
                                }
                                double W_m, D_m;
                                int tree_age = age_of_trees.Next(0, age_a_max); // selects age between 0 and maximum age of tree, for growth model
                                if (tree_age <= growth_a_max)
                                {
                                    W_m = W_m_max * (3 / 2 * tree_age / growth_a_max - 0.5 * Math.Pow((tree_age / growth_a_max), 3));
                                    D_m = D_m_max * (3 / 2 * tree_age / growth_a_max - 0.5 * Math.Pow((tree_age / growth_a_max), 3));
                                }
                                else
                                {
                                    W_m = W_m_max;
                                    D_m = D_m_max;
                                } // growth formula of trees, giving variable root sizes

                                // Convert spherical surface area to square surface area, to facilitate calculations
                                W_m = Math.Sqrt(Math.PI * Math.Pow(W_m / 2, 2));
                                // Debug.WriteLine("tf4");

                                // Calculation of transported mass over distance
                                int n_affected_cells = 1; // number of affected cells (in a square, so n_cells * n_cells
                                while (W_m > n_affected_cells * dx)
                                {
                                    n_affected_cells += 2;
                                }
                                tree_fall_mass = new double[5];
                                tree_fall_om = new double[2];

                                tree_fall_frac = new double[n_affected_cells, n_affected_cells]; // keep track of fractions that are removed from all cells, so that those fractions can be redistributed in teh same pattern one or a few cells outward. 
                                tree_fall_frac_sum = 0;

                                // Debug.WriteLine("N affected cells = {0}", n_affected_cells);

                                // minimaps(row, col); // Base situation

                                for (int ii = (n_affected_cells - 1) / -2; ii <= (n_affected_cells - 1) / 2; ii++)
                                {
                                    for (int jj = (n_affected_cells - 1) / -2; jj <= (n_affected_cells - 1) / 2; jj++)
                                    {
                                        // Debug.WriteLine("tf10");

                                        if (Math.Abs(ii) == (n_affected_cells - 1) / 2 | Math.Abs(jj) == (n_affected_cells - 1) / 2) // cell on the side
                                        {
                                            if (Math.Abs(ii) == (n_affected_cells - 1) / 2 & Math.Abs(jj) == (n_affected_cells - 1) / 2) // all corner cells. Fraction eroded = overlap^2 / dx^2
                                            {
                                                tf_frac_dx = Math.Pow(dx - ((n_affected_cells * dx - W_m) / 2), 2) / Math.Pow(dx, 2);
                                            }
                                            else // all other border cells: fraction = overlap * dx / dx^2
                                            {
                                                tf_frac_dx = ((dx - ((n_affected_cells * dx - W_m) / 2)) * dx) / Math.Pow(dx, 2);
                                            }
                                        }
                                        else
                                        {
                                            tf_frac_dx = 1;
                                        }
                                        if (tf_frac_dx > 1) { MessageBox.Show("df_frac_dx > 1"); }
                                        tree_fall_frac[(n_affected_cells - 1) / 2 + ii, (n_affected_cells - 1) / 2 + jj] = tf_frac_dx;
                                        tree_fall_frac_sum += tf_frac_dx;



                                        if (((row + ii) >= 0) && ((row + ii) < nr) && ((col + jj) >= 0) && ((col + jj) < nc) && dtm[row + ii, col + jj] != -9999)
                                        {
                                            // Debug.WriteLine("tf10b");

                                            old_soil_depth_m = soildepth_m[row + ii, col + jj];
                                            // if (soildepth_m[row + ii, col + jj] < 50) { Debug.WriteLine("tf1 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[row + ii, col + jj], t, row + ii, col + jj); Debugger.Break(); }

                                            // Debug.WriteLine("tf5");

                                            double depth = 0, tf_frac_dz;
                                            int lay = 0;
                                            while (depth < D_m & lay < max_soil_layers)
                                            {
                                                // fraction of lowest layer which is incorporated
                                                if (depth + layerthickness_m[row + ii, col + jj, lay] <= D_m) { tf_frac_dz = 1; } // fraction of layer taken up by roots, in z direction
                                                else { tf_frac_dz = (D_m - depth) / layerthickness_m[row + ii, col + jj, lay]; }

                                                if (tf_frac_dz > 1) { MessageBox.Show("df_frac_dz > 1"); }

                                                // uptake of sediments
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    tree_fall_mass[tex] += texture_kg[row + ii, col + jj, lay, tex] * tf_frac_dz * tf_frac_dx;
                                                    texture_kg[row + ii, col + jj, lay, tex] -= texture_kg[row + ii, col + jj, lay, tex] * tf_frac_dz * tf_frac_dx;
                                                }
                                                tree_fall_om[0] += old_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                old_SOM_kg[row + ii, col + jj, lay] -= old_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                tree_fall_om[1] += young_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                young_SOM_kg[row + ii, col + jj, lay] -= young_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                // Debug.WriteLine("tf10c");

                                                // if (thickness_calc(row, col, 0) < 0) { Debugger.Break(); }

                                                // verder
                                                // check if all fractions are calculated correctly
                                                // what if W_m == dx, than the fraction is 0; correct by doing 1-fraction? is the eroded fraction still calculate correctly?
                                                // calculations of fraction have to be corrected
                                                // redistribution to a next cell, with the right distance etc 
                                                // solve mass loss tree fall
                                                // dtm output has a lot of -9999 instead of no data, check that in R

                                                // update depth and reference layer
                                                depth += layerthickness_m[row + ii, col + jj, lay];
                                                lay += 1;
                                            } // end while depth  < Dm
                                              //Debug.WriteLine("Total soil mass: {0}", total_soil_mass(row + ii, col + jj));
                                              //displaysoil(row + ii, col + jj);
                                            remove_empty_layers(row + ii, col + jj);
                                            //Debug.WriteLine("Total soil mass: {0}", total_soil_mass(row + ii, col + jj));
                                            //displaysoil(row + ii, col + jj);

                                            // Debug.WriteLine("tf11");
                                            update_all_soil_thicknesses(row + ii, col + jj);
                                            update_all_soil_thicknesses(row + ii, col + jj); // meij twice, because bulk density depends on depth. This way, the thickness of the empty layers is set to 0 in the first calculation, and used for bulk density in the second calculation

                                            // Elevation change by erosion (removal of material). 
                                            soildepth_m[row + ii, col + jj] = total_soil_thickness(row + ii, col + jj);
                                            //if (soildepth_m[row + ii, col + jj] < 50) { Debug.WriteLine("tf2 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[row + ii, col + jj], t, row + ii, col + jj); Debugger.Break(); }
                                            if (thickness_calc(row, col, 0) < 0)
                                            {
                                                Debug.WriteLine("err_tf2");
                                            }
                                            // Debug.WriteLine("tf12");

                                            if (old_soil_depth_m - soildepth_m[row + ii, col + jj] > 1)
                                            {
                                                Debug.WriteLine("err_tf3");
                                            }

                                            dtm[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            dz_treefall[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            dtmchange[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            // Debug.WriteLine("erosion by tree fall = {0}", soildepth_m[row + ii, col + jj] - old_soil_depth_m);
                                            // Debug.WriteLine("tf13");



                                        } // end ii or jj in the area
                                    } // end jj
                                } // end ii
                                  //if (n_affected_cells > 1) { Debugger.Break(); }
                                  // minimaps(row, col); // After erosion


                                // Redistribution of material, deposition
                                // Debug.WriteLine("tf14");
                                double falldist;
                                double dh_rad = dh_deg * (Math.PI / 180);
                                if (dh < 0) // negative slope, tree falls upslope
                                {
                                    falldist = W_m / 2 * (Math.Cos(dh_rad) - Math.Sin(dh_rad)) - D_m / 2 * (Math.Cos(dh_rad) + Math.Sin(dh_rad));
                                }
                                else // positive or zero slope, tree falls downslope
                                {
                                    falldist = W_m / 2 * (Math.Cos(dh_rad) + Math.Sin(dh_rad)) + D_m / 2 * (Math.Sin(dh_rad) - Math.Cos(dh_rad));
                                }

                                // falldist is the distance where the centerpoint of the soil-root mass ends up. The distribution of the material follows the same pattern as the uptake, only shifted a few cells. 
                                // DEVELOP distribute material over different cell, based on dimensions of the soil-root mass
                                // Debug.WriteLine("tf15");
                                int ndist_cells = 0;
                                while (falldist > (ndist_cells + 0.5) * dx)
                                {
                                    ndist_cells += 1;
                                }
                                rowsink = row + ndist_cells * i_tf;
                                colsink = col + ndist_cells * j_tf;
                                for (int ii = (n_affected_cells - 1) / -2; ii <= (n_affected_cells - 1) / 2; ii++)
                                {
                                    for (int jj = (n_affected_cells - 1) / -2; jj <= (n_affected_cells - 1) / 2; jj++)
                                    {
                                        // Debug.WriteLine("tf16");

                                        tf_frac_dx = tree_fall_frac[(n_affected_cells - 1) / 2 + ii, (n_affected_cells - 1) / 2 + jj] / tree_fall_frac_sum;
                                        if (((rowsink + ii) >= 0) && ((rowsink + ii) < nr) && ((colsink + jj) >= 0) && ((colsink + jj) < nc) && dtm[rowsink + ii, colsink + jj] != -9999)
                                        {
                                            // Debug.WriteLine("tf17");

                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                texture_kg[rowsink + ii, colsink + jj, 0, tex] += tree_fall_mass[tex] * tf_frac_dx;
                                            }
                                            old_SOM_kg[rowsink + ii, colsink + jj, 0] += tree_fall_om[0] * tf_frac_dx;
                                            old_SOM_kg[rowsink + ii, colsink + jj, 0] += tree_fall_om[1] * tf_frac_dx;


                                            // elevation change by deposition
                                            old_soil_depth_m = soildepth_m[rowsink + ii, colsink + jj];
                                            double ds_1 = soildepth_m[rowsink + ii, colsink + jj];
                                            update_all_soil_thicknesses(rowsink + ii, colsink + jj);
                                            double ds_2 = soildepth_m[rowsink + ii, colsink + jj];
                                            update_all_soil_thicknesses(rowsink + ii, colsink + jj); // update twice, to approach real BD value, which is depth dependent
                                            double ds_3 = soildepth_m[rowsink + ii, colsink + jj];
                                            //if (soildepth_m[rowsink + ii, colsink + jj] < 50)
                                            //{
                                            //    Debug.WriteLine("tf3 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[rowsink + ii, colsink + jj], t, rowsink + ii, colsink + jj);
                                            //    Debugger.Break();
                                            //}

                                            soildepth_m[rowsink + ii, colsink + jj] = total_soil_thickness(rowsink + ii, colsink + jj);
                                            dtm[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            dz_treefall[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            dtmchange[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            //Debug.WriteLine("deposition by tree fall = {0}", soildepth_m[row + ndist_cells * i, col + ndist_cells * j] - old_soil_depth_m);

                                        } // end_time if dtm[,] = -9999
                                        else
                                        {
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                exported_mass_tf += tree_fall_mass[tex] * tf_frac_dx;
                                            }
                                            exported_mass_tf += tree_fall_om[0] * tf_frac_dx;
                                            exported_mass_tf += tree_fall_om[1] * tf_frac_dx;
                                        }
                                    } // end jj
                                } // end ii
                                  // minimaps(row, col); // After deposition


                            } // end chance ==1 (tree is falling)
                        } // end dtm != -9999
                    } // end col
                } // end row
                  // double mass_after_tf = total_catchment_mass() + exported_mass_tf;
                  //if (mass_before_tf != mass_after_tf) { MessageBox.Show("Tree fall mass not equal. difference = "+ (mass_before_tf - mass_after_tf)); }
                if (fallen == true)
                {
                    // Debug.WriteLine("sink cell 1");
                    //displaysoil(rowsink, colsink);

                    //if (t == 4)
                    //{
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsource,colsource));
                    //    displaysoil(rowsource, colsource);
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsink,colsink));
                    //    displaysoil(rowsink,colsink);
                    //}
                    // Debug.WriteLine("tf1a");
                    for (int r_tf = 0; r_tf < nr; r_tf++)
                    {
                        for (int c_tf = 0; c_tf < nc; c_tf++)
                        {
                            remove_empty_layers(r_tf, c_tf);
                            remove_empty_layers(r_tf, c_tf);
                            if (total_soil_mass(r_tf, c_tf) <= 0) { Debugger.Break(); }
                            update_all_soil_thicknesses(r_tf, c_tf);
                        }
                    }
                    soil_update_split_and_combine_layers();
                    // Debug.WriteLine("tf1b");

                    //if (t == 4)
                    //{
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsource, colsource));
                    //    displaysoil(rowsource, colsource);
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsink, colsink));
                    //    displaysoil(rowsink, colsink);
                    //    Debugger.Break();
                    //}
                    if (NA_in_map(dtm) > 0)
                    {
                        Debug.WriteLine("err_tf5");
                    }
                    if (NA_in_map(soildepth_m) > 0)
                    {
                        Debug.WriteLine("err_tf6");
                    }

                }
                double tf_mass_after = total_catchment_mass() + exported_mass_tf;
                //if (Math.Abs(tf_mass_before - tf_mass_after)>0.001) { Debugger.Break(); }
            }
            catch
            {
                Debug.WriteLine("err_tf7");

            }

        }

        private void calculate_bedrock_weathering()
        {
            // as function of infiltration?
            //Debug.WriteLine("Entered bedrock weathering");
            double Iavg = 0, Imin = 10000000, Imax = 0;
            if (daily_water.Checked)
            {
                int Icount = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (Imin > Iy[row, col]) { Imin = Iy[row, col]; }
                            if (Imax < Iy[row, col]) { Imax = Iy[row, col]; }
                            Iavg += Iy[row, col];
                            Icount++;
                        }
                    }
                }
                Iavg /= Icount;
            }
            int soil_layer, lowest_soil_layer;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        double weatheringdepth = 0;
                        //Debug.WriteLine(" bedrock weathering at r " + row + " c " + col);
                        //if the first occurrence of bedrock is the hardlayer, then no weathering should occur.
                        //if more weathering is calculated than needed to get to the hardlayer, then it should be thus limited. 

                        weatheringdepth = soildepth_m[row, col];

                        // humped
                        if (rockweath_method.SelectedIndex == 0)
                        {
                            bedrock_weathering_m[row, col] = P0 * (Math.Exp(-k1 * weatheringdepth) - Math.Exp(-k2 * weatheringdepth)) + Pa;

                        }
                        if (rockweath_method.SelectedIndex == 1)
                        {
                            // exponential (Heimsath, Chappell et al., 2000)
                            bedrock_weathering_m[row, col] = P0 * Math.Exp(-k1 * weatheringdepth);
                        }

                        if (rockweath_method.SelectedIndex == 2)
                        {
                            if (daily_water.Checked)
                            {
                                bedrock_weathering_m[row, col] = P0 * -k1 * (Iy[row, col] - Imin) / (Imax - Imin);
                            }
                        }
                        //we now know how deep we would weather into normal bedrock
                        if (blocks_active == 1)
                        {
                            double newlowestelevsoil = dtm[row, col] - soildepth_m[row, col] - bedrock_weathering_m[row, col];
                            double oldlowestelevsoil = dtm[row, col] - soildepth_m[row, col];
                            if (newlowestelevsoil < hardlayerelevation_m && oldlowestelevsoil >= hardlayerelevation_m)
                            {
                                //we limit bedrock weathering to the part of the bedrock above hardlayer:
                                bedrock_weathering_m[row, col] = (dtm[row, col] - soildepth_m[row, col]) - hardlayerelevation_m;
                                Debug.WriteLine(" limited bedrock weathering to stop at hardlayer r " + row + " c " + col + " dtm "+ dtm[row,col]);
                                //and apply the rest of the weathering to increasing openness of the hardlayer:
                                hardlayeropenness_fraction[row, col] += Convert.ToSingle((hardlayerelevation_m - newlowestelevsoil) * hardlayer_weath_contrast);
                                Debug.WriteLine(" increased openness of hardlayer to " + hardlayeropenness_fraction[row, col]);
                                if (hardlayeropenness_fraction[row, col] > 0.5) { hardlayeropenness_fraction[row, col] = 0.5f; }
                            }
                        }

                        soildepth_m[row, col] += bedrock_weathering_m[row, col]; // this will really be updated at the end of this timestep, but this is a good approximation for the moment

                        //we also add this amount of coarse material to the lowest layer of our soil
                        soil_layer = 0; lowest_soil_layer = 0;
                        while (layerthickness_m[row, col, soil_layer] > 0 )
                        {
                            lowest_soil_layer = soil_layer;
                            soil_layer++;
                            //Debug.WriteLine(" lowest soil layer now " + soil_layer);
                            if (lowest_soil_layer == max_soil_layers - 1) { break; }
                        }
                        texture_kg[row, col, lowest_soil_layer, 0] += bedrock_weathering_m[row, col] * 2700 * dx * dx;   // to go from m (=m3/m2) to kg, we multiply by m2 and by kg/m3
                    }

                }
            }
            //Debug.WriteLine("finished weathering bedrock ");
        }

        private void calculate_tilting()
        {
            this.InfoStatusPanel.Text = "tilting calculation";
            int row, col;

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (tilt_location == 0) { dtm[row, col] += tilt_intensity * (col / nc); }
                    if (tilt_location == 1) { dtm[row, col] += tilt_intensity * (row / nr); }
                    if (tilt_location == 2) { dtm[row, col] += tilt_intensity * ((nc - col) / nc); }
                    if (tilt_location == 3) { dtm[row, col] += tilt_intensity * ((nr - row) / nr); }
                }
            }
        } 

        private void calculate_uplift()
        {
            this.InfoStatusPanel.Text = "uplift calculation";
            int row, col;

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (lift_location == 0 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 1 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 2 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 3 && row > lift_location) { dtm[row, col] += lift_intensity; }
                }
            }
        } 

        //void update_OSL_age()
        //{
        //    for(row = 0;row<nr;row++)
        //    {
        //        for(col = 0;col<nc;col++)
        //        {
        //            if(dtm[row, col]!=-9999)
        //            {
        //                OSL_age[row,col,0] = 0; // reset surface layer
        //                for(int lay = 1; lay<max_soil_layers;lay++)
        //                {
        //                    if(total_layer_mass(row,col,lay)>0)
        //                    {
        //                        OSL_age[row, col, lay] += 1;
        //                    }

        //                }
        //            }
        //        }
        //    }
        //}

        #endregion

        # region Hardlayer and block code

        void hardlayer_breaking()
        {
            //layers break off blocks when dz across the layer is larger than layer thickness
            //by a certain margin > 1 (I imagine)
            //Debug.WriteLine(" started breaking hard layer");
            //Debug.WriteLine(" Current number of blocks is " + Blocklist.Count);
            Random location_gen = new Random(t); // t as random seed to get deterministic results
            for (int hrd_lyr = 0; hrd_lyr < nhardlayers; hrd_lyr++)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (hardlayer_near_surface(row, col) == true)
                            {
                                //Debug.WriteLine(" hard layer is near surface for " + row + " " + col + " dtm " + dtm[row,col] + " layer " + hardlayerelevation_m);
                                int n_to_s = 5;  //impossible values
                                int e_to_w = 5;
                                //Debug.WriteLine("hardlayerthick " + hardlayerthickness_m + "max_dz_across_layer" + max_dz_across_hardlayer_m(row, col, out n_to_s, out e_to_w));
                                if (max_dz_across_hardlayer_m(row, col, out n_to_s, out e_to_w) > hardlayerthickness_m * 1.25)
                                {
                                    //Debug.WriteLine(" hardlayer breaking at row " + row + " " + col );
                                    dtm[row, col] -= hardlayerthickness_m;
                                    if(n_to_s == 5 | e_to_w == 5) { Debug.WriteLine("invalid direction returned from max_dz_across layer at r" + row + " c " + col); }
                                    //break off blocks and drop  them in direction of max_dz
                                    //floor ensures that blocks are not filling that cell up entirely  
                                    int ndropblocks = Convert.ToInt32(Math.Floor((dx * dx) * (1 - hardlayeropenness_fraction[row, col]) / hardlayerthickness_m));
                                    //Debug.WriteLine(" adding " + ndropblocks + " with size " + hardlayerthickness_m);
                                    for (int blck = 0; blck < ndropblocks; blck++)
                                    {
                                        //Debug.Write(" adding block ");
                                        Blocklist.Add(new Block(Convert.ToSingle(row - n_to_s + location_gen.NextDouble()), Convert.ToSingle(col + e_to_w + location_gen.NextDouble()), hardlayerthickness_m, 0, 0, 0, 0, 0, 0, 0, 0));
                                        
                                    }
                                    blocksproduced += ndropblocks;
                                }
                            }
                        }
                    }
                }
            }
            //Debug.WriteLine(" New number of blocks is " + Blocklist.Count);
        }

        bool hardlayer_near_surface(int rowt, int colt)
        {
            if (dtm[rowt, colt] <= (hardlayerelevation_m +0.1) && dtm[rowt, colt] > (hardlayerelevation_m - 0.001))
            { return true; }
            else { return false; }
        }

        float max_dz_across_hardlayer_m(int nowrow, int nowcol, out int n_to_s, out int e_to_w)
        {
            //Debug.WriteLine(" calculating max dz across hardlayer for " + nowrow + " " + nowcol);
            float max_dz_m = 0;
            n_to_s = 5;
            e_to_w = 5;
            //development possible to account for presence of blocks in downslope cells
            //Debug.WriteLineIf(nowrow == 0 && nowcol == 88,"x");
            //Debug.WriteLineIf(nowrow == 0 && nowcol == 88,  "dtm" + dtm[nowrow, nowcol]);
            if (nowrow > 0 && nowcol > 0) { if (dtm[nowrow - 1, nowcol - 1] != -9999) {         if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol - 1]) > max_dz_m) {       max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol - 1]); n_to_s = 1; e_to_w = -1; } } }
            if (nowrow > 0) {               if (dtm[nowrow - 1, nowcol] != -9999) {             if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol]) > max_dz_m) {           max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol]); n_to_s = 1; e_to_w = 0; } } }
            if (nowrow > 0 && (nowcol + 1) < nc){ if( dtm[nowrow - 1, nowcol + 1] != -9999) {     if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol + 1]) > max_dz_m) {       max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol + 1]); n_to_s = 1; e_to_w = 1; } } }
            if (nowcol > 0) {               if(dtm[nowrow , nowcol - 1] != -9999  ) {           if ((dtm[nowrow, nowcol] - dtm[nowrow, nowcol - 1]) > max_dz_m) {           max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow, nowcol - 1]); n_to_s = 0; e_to_w = -1; } } }
            if ((nowcol + 1) < nc){           if (dtm[nowrow , nowcol + 1] != -9999 ) {           if ((dtm[nowrow, nowcol] - dtm[nowrow, nowcol + 1]) > max_dz_m) {           max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow, nowcol + 1]);     n_to_s = 0; e_to_w = 1; } } }
            if ((nowrow + 1) < nr && nowcol > 0){ if(dtm[nowrow + 1, nowcol - 1] != -9999 ) {     if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol - 1]) > max_dz_m) {       max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol - 1]); n_to_s = -1; e_to_w = -1; } } }
            if ((nowrow + 1) < nr ){          if(dtm[nowrow + 1, nowcol ] != -9999 ) {            if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol]) > max_dz_m) {           max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol]);     n_to_s = -1; e_to_w = 0; } } }
            if ((nowrow + 1) < nr && (nowcol + 1) < nc){ if(dtm[nowrow + 1, nowcol + 1] != -9999 ) {if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol + 1]) > max_dz_m) {       max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol + 1]); n_to_s = -1; e_to_w = 1; } } }
            return max_dz_m;
        }

        void block_weathering()
        {
            //blocks are cubic and weather smaller as a function of surface area (size squared)
            if (diagnostic_mode == 1) { Debug.WriteLine(" starting block weathering"); }
            Random location_gen = new Random(t); // t as random seed to get deterministic results
            if (Blocklist.Count > 0)
            {
                int index = 0;
                while (index < Blocklist.Count)
                {
                    //Debug.WriteLine(Blocklist[0].Size_m);
                    //Debug.WriteLine(" Block " + index + " will be weathered. Now size is " + Blocklist[index].Size_m + " total blocks " + Blocklist.Count);
                    //Blocklist[index].Size_m *= blockweatheringratio * Convert.ToSingle(location_gen.NextDouble()+0.5);
                    Blocklist[index].Size_m *= blockweatheringratio ;
                    //Debug.WriteLine(" Block " + index + " was weathered. Now size is " + Blocklist[index].Size_m + " total blocks " + Blocklist.Count);
                    if (Blocklist[index].Size_m < blocksizethreshold_m)
                    {
                        texture_kg[Convert.ToInt32(Math.Floor(Blocklist[index].Y_row)), Convert.ToInt32(Math.Floor(Blocklist[index].X_col)), 0, 0] += Math.Pow(Blocklist[index].Size_m, 3) * hardlayerdensity_kg_m3;
                        Blocklist.RemoveAt(index);
                        //this will also update Blocklist.Count, so we don't count too far. 
                        
                    }
                    index++;
                }
            }
            else
            {
                Debug.WriteLine(" currently no blocks to weather ");
            }

        }

        void block_movement()
        {
            //blocks either roll or creep along
            // function of size, but not shape for now
            //accum_creep_alt (8 directions) += creep_alt_timestep
            //creep_alt_timestep (8 directions) = creep volume / (cell surface area - cell block area)
            //two options      :
            //EITHER
            //block rolls if slope in cell + (net_accum_creep_alt in any direction/size block) > 1 (45 degrees)
            //if block rolls, it rolls in first direction where the condition is met
            //by exactly one block size
            //accum creep alt in that direction is reset, others are kept

            //OR
            //block moves with creeping soil (which should always be less ?))
            //distance in any direction is volume of creep from that direction/cell size/soildepth in cell
            //average all distances and average their direction
            //pythagoras
            //does not reset accum_creep_alt

            // this way of thinking means that all blocks will roll, some more than others. Not nice
            // Also, many blocks in a cell or few blocks in a cell makes no difference.
            // In reality, it probably should because more blocks, less space, more bunching up of regolith, more roll
            // That can later be solved by taking dz_source or dz_sink DIV (1-blockcover) in creep calculations.
            if (diagnostic_mode == 1) { Debug.WriteLine(" starting block movement"); }
            Random location_gen = new Random(t);
            //Debug.WriteLine(" starting block movement");
            List<Block> removelist = new List<Block>();
            if (Blocklist.Count > 0)
            {
                //Debug.WriteLine(" blockcount now " + Blocklist.Count);
                foreach (var Block in Blocklist)
                {
                    int row = Convert.ToInt32(Math.Floor(Block.Y_row));
                    int col = Convert.ToInt32(Math.Floor(Block.X_col));
                    //Debug.WriteLine(" block in cell " + row + " " + col);
                    if (row==0 || row==(nr-1) || col == 0 || col == (nc - 1)) { 
                        removelist.Add(Block);
                        //Debug.WriteLine(" added to remove list ");
                    }
                    else if (dtm[row, col] != -9999)
                    {
                        // we calculate for four possible directions whether the block should roll:
                        bool block_has_rolled = false;
                        //from north to south
                        double averageslope = (dtm[row - 1, col] - dtm[row + 1, col]) / (2 * dx); // averaged over two cells
                        double additionalslope = (Block.Accumulated_creep_m_0 - Block.Accumulated_creep_m_4) / Block.Size_m;
                        double totalslope = averageslope + additionalslope;                      
                        if (totalslope > 1)
                        {
                            //Debug.WriteLine(" block rolling. dtm1 " + dtm[row - 1, col] + " dtm2 " + dtm[row + 1, col] + " avslope " + averageslope + " addslope " + additionalslope + " totslope " + totalslope + "rownow " + Block.Y_row + " sizenow " + Block.Size_m);
                            Block.Y_row -= Block.Size_m;
                            block_has_rolled = true;
                            Block.Accumulated_creep_m_0 = 0;
                            Block.Accumulated_creep_m_4 = 0;
                            topoconttoroll += Math.Abs(averageslope);
                            creepconttoroll += Math.Abs(additionalslope);
                            //Debug.WriteLine(" block rolled n to s");
                            if (Math.Floor(Block.Y_row) == nr) { Blocklist.Remove(Block); }
                        } // rolls to south
                        if (totalslope < -1)
                        {
                            //Debug.WriteLine(" block rolling. dtm1 " + dtm[row - 1, col] + " dtm2 " + dtm[row + 1, col] + " avslope " + averageslope + " addslope " + additionalslope + " totslope " + totalslope + "rownow " + Block.Y_row + " sizenow " + Block.Size_m);
                            Block.Y_row += Block.Size_m;
                            block_has_rolled = true;
                            Block.Accumulated_creep_m_0 = 0;
                            Block.Accumulated_creep_m_4 = 0;
                            topoconttoroll += Math.Abs(averageslope);
                            creepconttoroll += Math.Abs(additionalslope);
                            //Debug.WriteLine(" block rolled s to n, lowered row");
                            if (Math.Floor(Block.Y_row) == -1) { Blocklist.Remove(Block); }
                        } // rolls to north

                        if (block_has_rolled == false)
                        {
                            //from NE to SW (note different slope calculation)
                            averageslope = (dtm[row - 1, col + 1] - dtm[row + 1, col - 1]) / (2 * dx * Math.Sqrt(2)); // averaged over two cells, diagonally
                            additionalslope = (Block.Accumulated_creep_m_1 - Block.Accumulated_creep_m_5) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {   //higher on the NE, rolls to the SW
                                block_has_rolled = true;
                                Block.Y_row -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_1 = 0;
                                Block.Accumulated_creep_m_5 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == nr | Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                block_has_rolled = true;
                                Block.Y_row += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_1 = 0;
                                Block.Accumulated_creep_m_5 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == -1 | Math.Floor(Block.X_col) == nc) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //from E to W
                            averageslope = (dtm[row, col + 1] - dtm[row, col - 1]) / (2 * dx); // averaged over two cells 
                            additionalslope = (Block.Accumulated_creep_m_2 - Block.Accumulated_creep_m_6) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {
                                Block.X_col += Block.Size_m;
                                block_has_rolled = true;
                                Block.Accumulated_creep_m_2 = 0;
                                Block.Accumulated_creep_m_6 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                Block.X_col -= Block.Size_m;
                                block_has_rolled = true;
                                Block.Accumulated_creep_m_2 = 0;
                                Block.Accumulated_creep_m_6 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.X_col) == nr) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //from SE to NW (note different slope calculation)
                            averageslope = (dtm[row + 1, col + 1] - dtm[row - 1, col - 1]) / (2 * dx * Math.Sqrt(2)); // averaged over two cells, diagonally
                            additionalslope = (Block.Accumulated_creep_m_3 - Block.Accumulated_creep_m_7) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {
                                block_has_rolled = true;
                                Block.Y_row += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_3 = 0;
                                Block.Accumulated_creep_m_7 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == -1 | Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                block_has_rolled = true;
                                Block.Y_row -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_3 = 0;
                                Block.Accumulated_creep_m_7 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == nr | Math.Floor(Block.X_col) == nr) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //find steepest lower nb, calculate creep to it, calculate distance from kg -> m3 -> 
                            
                        }
                        if (block_has_rolled==true) { blocksrolled++;  }
                    }
                }
            } else
            {
                //Debug.WriteLine(" currently no blocks to move ");
            }
            Blocklist.RemoveAll(x => removelist.Contains(x));
            //Debug.WriteLine(" removed " + removelist.Count + " blocks from list, leaving blockcount now " + Blocklist.Count);
        }

        #endregion

        #region Vegetation code

        double[,] aridity_vegetation;

        void determine_vegetation_type()
        {
            aridity_vegetation = new double[nr, nc];
            double outflow = 0, aridity, outflowcells = 0;

            for (int vrow = 0; vrow < nr; vrow++)
            {
                for (int vcol = 0; vcol < nc; vcol++)
                {

                    if (dtm[vrow, vcol] != -9999)
                    {
                        // adjusted Budyko
                        // aridity (water stress) = P/PET. If PET>P, water stress, aridity < 1.
                        // P is replaced by (I+ETa), Incoming water that infiltrates in the cell is captured in I

                        outflow = OFy_m[vrow, vcol, 0] - OFy_m[vrow, vcol, 9];
                        // aridity = (Iy[vrow, vcol] + ETay[vrow, vcol] - outflow) / ET0y[vrow, vcol];
                        aridity = (Iy[vrow, vcol] + ETay[vrow, vcol]) / ET0y[vrow, vcol];

                        // First, we had (I+ET)*(P/(P+O) / PET. But I think the scaling is not necessary. 
                        if (aridity < 0)
                        {
                            Debug.WriteLine("err_vg1");
                        }
                        aridity_vegetation[vrow, vcol] = aridity;


                        if (aridity < 1)
                        {
                            vegetation_type[vrow, vcol] += 1; // arid / grass
                        }
                        else
                        {
                            vegetation_type[vrow, vcol] += 1000; // humid / forest
                        }
                    }
                }
            }
        }

        double[,] veg_correction_factor;
        void change_vegetation_parameters()
        {
            // vegetation coefficients for ET
            for (int vrow = 0; vrow < nr; vrow++)
            {
                for (int vcol = 0; vcol < nc; vcol++)
                {
                    if (dtm[vrow, vcol] != -9999)
                    {
                        if (aridity_vegetation[vrow, vcol] < 1) { veg_correction_factor[vrow, vcol] = .75; } // all year long, according to FAO report 56
                        else { veg_correction_factor[vrow, vcol] = .85; } // I took the mid-season coefficient (95) of most deciduous crops and decreased it to 85 to account for less vegetation in other times of the year
                        if (t >= (end_time - 500)) { veg_correction_factor[vrow, vcol] = .45; }  // if there is agriculture

                    }
                }
            }

            //// bioturbation andd creep depth, same parameter
            //if (vegetation_type[vrow, vcol] == 1) { bioturbation_depth_decay_constant = .75; } //
            //if (vegetation_type[vrow, vcol] == 2) { bioturbation_depth_decay_constant = .85; } // I 




        }

        void calculate_TPI(int windowsize)
        {
            try
            {
                //Debug.WriteLine("Started calculating TPI");
                // check if window size is an uneven number, so the window has a center cell
                if (windowsize % 2 == 0) { MessageBox.Show("window size for TPI calculations should be an uneven number"); }

                int windowrange = (windowsize - 1) / 2;
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double tpisum = 0;
                            double tpicount = 0;

                            // calculate moving window average
                            for (int rr = windowrange * -1; rr <= windowrange; rr++)
                            {
                                for (int cc = windowrange * -1; cc <= windowrange; cc++)
                                {
                                    if (row + rr >= 0 & row + rr < nr & col + cc >= 0 & col + cc < nc) // if cell exists in the DEM, 
                                    {
                                        if (dtm[row + rr, col + cc] != -9999 & rr != 0 & cc != 0) // if cell contains a value and cell isn't the target cell, it's considered in the TPI
                                        {
                                            tpisum += dtm[row + rr, col + cc];
                                            tpicount += 1;
                                        }
                                    }
                                }
                            }
                            tpi[row, col] = dtm[row, col] - (tpisum / tpicount);
                        }

                    }
                }
                //Debug.WriteLine("Finished calculating TPI");
            }
            catch
            {
                Debug.WriteLine("Error in calculating TPI");
            }
        }

        #endregion

        #region mapping and drawing code

        double calc_slope_stdesc(int row_s, int col_s)
        {
            double slope_desc = 0, slope_temp = 0;
            if (dtm[row_s, col_s] != -9999)
            {
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        if (((row_s + i) >= 0) && ((row_s + i) < nr) && ((col_s + j) >= 0) && ((col_s + j) < nc) && !((i == 0) && (j == 0)))  //to stay within the grid and avoid the row col cell itself
                        {
                            if (dtm[row_s + i, col_s + j] != -9999) // if neighbour exists
                            {
                                if ((row_s != row_s + i) && (col_s != col_s + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                slope_temp = (dtm[row_s, col_s] - dtm[row_s + i, col_s + j]) / d_x;
                                if (slope_desc < slope_temp) { slope_desc = slope_temp; }
                            }
                        }
                    }
                }
            }

            slope_desc = Math.Atan(slope_desc); // slope in radians
            return (slope_desc);
        }

        void update_slope_and_aspect()
        {
            double slopemax, slope, slopetot;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        slopemax = 0;
                        slope = 0;
                        slopetot = 0;

                        // Do slope analysis and Aspect Calculation first
                        if ((row - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row - 1, col] && dtm[row - 1, col] != -9999) // North 0
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 0 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((row - 1) >= 0 & (col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row - 1, col + 1] && dtm[row - 1, col + 1] != -9999) // Northeast 45
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col + 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 45 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row, col + 1] && dtm[row, col + 1] != -9999) // East 90
                            {
                                slope = (dtm[row, col] - dtm[row, col + 1]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 90 * (3.141592654 / 180);
                                }
                            }
                        }
                        if ((row + 1) < nr & (col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row + 1, col + 1] && dtm[row + 1, col + 1] != -9999) // SouthEast 135
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col + 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 135 * (3.141592654 / 180);
                                }

                            }
                        }

                        if ((row + 1) < nr)
                        {
                            if (dtm[row, col] > dtm[row + 1, col] && dtm[row + 1, col] != -9999) // South 180
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 180 * (3.141592654 / 180);
                                }
                            }
                        }
                        if ((row + 1) < nr & (col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row + 1, col - 1] && dtm[row + 1, col - 1] != -9999) // SouthWest 225
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col - 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 225 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row, col - 1] && dtm[row, col - 1] != -9999) // West 270
                            {
                                slope = (dtm[row, col] - dtm[row, col - 1]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 270;
                                }
                            }
                        }

                        if ((row - 1) >= 0 & (col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row - 1, col - 1] && dtm[row - 1, col - 1] != -9999) // Northwest 315
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col - 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 315 * (3.141592654 / 180);
                                }
                            }
                        }


                        if (slope > 0) slopeAnalysis[row, col] = slopemax;// Tom's: (slope/slopetot); ?
                        else { slopeAnalysis[row, col] = 0; }

                        // Convert slope to radians
                        slopeAnalysis[row, col] = System.Math.Atan(slopeAnalysis[row, col]);

                        //// test
                        //slopeAnalysis[row, col] = 0 * Math.PI / 180;
                        //aspect[row, col] = 0 * Math.PI / 180;

                    }
                }
            }
        }

        #endregion

        #region interface behaviour code

        private void End_button_Click(object sender, EventArgs e)
        {

            this.Close();
        }

        private void UTMgridcheckbox_CheckedChanged(object sender, EventArgs e)
        {
            if (UTMgridcheckbox.Checked) { UTMgroupBox.Visible = true; }
            else { UTMgroupBox.Visible = false; }
        }

        private void Menu_aboutbox_Click(object sender, EventArgs e)
        {
            aboutbox.Visible = true;
        }

        private void timeseries_button_Click(object sender, EventArgs e)
        {
            timeseries.Visible = true;
        }

        private void profiles_button_Click(object sender, EventArgs e)
        {
            profile.Visible = true;
        }

        private void landuse_determinator_button_Click(object sender, EventArgs e)
        {
            landuse_determinator.Visible = true;
        }

        private void Water_ero_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            if (Water_ero_checkbox.Checked == false)
            {
                only_waterflow_checkbox.Enabled = false;
                only_waterflow_checkbox.Checked = false;
            }
            if (Water_ero_checkbox.Checked == true) { only_waterflow_checkbox.Enabled = true; }
        }

        private void Form1_Load(object sender, System.EventArgs e)
        {
            //Mapwindow.Height = this.Height - 180;
            //Mapwindow.Width = this.Width - 200;

            HttpWebRequest req;
            HttpWebResponse res;
            try
            {
                req = (HttpWebRequest)WebRequest.Create("http://www.LORICAmodel.nl/");
                res = (HttpWebResponse)req.GetResponse();
            }
            catch (Exception ex)
            {
                /// do nothing.
            }

            //JMW <20040929 -start>
            this.Text = basetext;
            //DoingGraphics = false;
            //JMW <20040929 - end>

        }

        private void check_cnst_soildepth_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_soildepth.Checked == true) // time can never be true,  because the model calculates soildepth
            {
                soildepth_constant_value_box.Enabled = false;
                soildepth_input_filename_textbox.Enabled = true;
            }
            else
            {
                soildepth_constant_value_box.Enabled = true;
                soildepth_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_landuse_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_landuse.Checked == true)
            {
                landuse_constant_value_box.Enabled = false;
                landuse_input_filename_textbox.Enabled = true;
                check_time_landuse.Checked = false;
            }
            if (check_space_landuse.Checked == false && check_time_landuse.Checked == false)
            {
                landuse_constant_value_box.Enabled = true;
                landuse_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_till_fields_CheckedChanged(object sender, EventArgs e)
        {

            if (check_space_till_fields.Checked == true)
            {
                tillfields_constant_textbox.Enabled = false;
                tillfields_input_filename_textbox.Enabled = true;
                check_time_till_fields.Checked = false;
            }
            if (check_space_till_fields.Checked == false && check_time_till_fields.Checked == false)
            {
                tillfields_constant_textbox.Enabled = true;
                tillfields_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_rain_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_rain.Checked == true)
            {
                rainfall_constant_value_box.Enabled = false;
                rain_input_filename_textbox.Enabled = true;
                check_time_rain.Checked = false;
            }
            if (check_space_rain.Checked == false && check_time_rain.Checked == false)
            {
                rainfall_constant_value_box.Enabled = true;
                rain_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_infil_CheckedChanged(object sender, EventArgs e)
        {
            if (check_space_infil.Checked == true)
            {
                infil_constant_value_box.Enabled = false;
                infil_input_filename_textbox.Enabled = true;
                check_time_infil.Checked = false;
            }
            if (check_space_infil.Checked == false && check_time_infil.Checked == false)
            {
                infil_constant_value_box.Enabled = true;
                infil_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_evap_CheckedChanged(object sender, EventArgs e)
        {
            if (check_space_evap.Checked == true)
            {
                evap_constant_value_box.Enabled = false;
                evap_input_filename_textbox.Enabled = true;
                check_time_evap.Checked = false;
            }
            if (check_space_evap.Checked == false && check_time_evap.Checked == false)
            {
                evap_constant_value_box.Enabled = true;
                evap_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_landuse_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_landuse.Checked == true)
            {
                landuse_constant_value_box.Enabled = false;
                landuse_input_filename_textbox.Enabled = true;
                check_space_landuse.Checked = false;
            }
            if (check_space_landuse.Checked == false && check_time_landuse.Checked == false)
            {
                landuse_constant_value_box.Enabled = true;
                landuse_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_tillage_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_till_fields.Checked == true) // time can only be true when space is also true
            {

                tillfields_constant_textbox.Enabled = false;
                tillfields_input_filename_textbox.Enabled = true;
                check_space_till_fields.Checked = false;
            }
            if (check_space_till_fields.Checked == false && check_time_till_fields.Checked == false)
            {
                tillfields_constant_textbox.Enabled = true;
                tillfields_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_rain_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_rain.Checked == true)
            {
                rainfall_constant_value_box.Enabled = false;
                rain_input_filename_textbox.Enabled = true;
                check_space_rain.Checked = false;
            }
            if (check_space_rain.Checked == false && check_time_rain.Checked == false)
            {
                rainfall_constant_value_box.Enabled = true;
                rain_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_infil_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_infil.Checked == true)
            {
                infil_constant_value_box.Enabled = false;
                infil_input_filename_textbox.Enabled = true;
                check_space_infil.Checked = false;
            }
            if (check_space_infil.Checked == false && check_time_infil.Checked == false)
            {
                infil_constant_value_box.Enabled = true;
                infil_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_evap_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_evap.Checked == true)
            {
                evap_constant_value_box.Enabled = false;
                evap_input_filename_textbox.Enabled = true;
                check_space_evap.Checked = false;
            }
            if (check_space_evap.Checked == false && check_time_evap.Checked == false)
            {
                evap_constant_value_box.Enabled = true;
                evap_input_filename_textbox.Enabled = false;
            }
        }

        private void button8_Click(object sender, EventArgs e)
        {

            //MessageBox.Show()

            /*"Input filenames are not available when both f(row,col) and f(t) are unchecked. In that case, only single values are input
LORICA will use filename in the following way:

1. When f(row,col) is checked but f(t) is not checked, filename is the ascii grid that will be read.
Example: filename = use.asc ; LORICA will read use.asc

2. When f(row,col) and f(t) are checked, filename is the prefix for 
a series of ascii grid files with the timestep following the prefix. 
Example: filename = use.asc ; LORICA will read use1.asc, use2.asc, use3.asc etc

3. When f(row,col) is not checked, but f(t) is checked, filename is the text file containing 
(spatially uniform) timeseries. The number of values in this file should at least equal 
the number of timesteps in the run. LORICA will start using the first value.
Example: rainfall.asc can look like:
0.67
0.54
0.87
0.70
" */
        }

        private void dtm_input_filename_textbox_Click(object sender, EventArgs e)
        {
            /*FolderBrowserDialog arnaudsdialog = new FolderBrowserDialog();
            if (arnaudsdialog.ShowDialog() == DialogResult.OK)
            {
                dtm_input_filename_textbox.Text = arnaudsdialog.SelectedPath;
                workdir = arnaudsdialog.SelectedPath;
            } */

            OpenFileDialog openFileDialog1 = new OpenFileDialog();
            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dtm_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void soildepth_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                soildepth_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void landuse_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                landuse_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void tillfields_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                tillfields_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void rain_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                rain_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void infil_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                infil_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void evap_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                evap_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void dailyP_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyP.Text = openFileDialog1.FileName;
            }
        }

        private void dailyET0_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyET0.Text = openFileDialog1.FileName;
            }
        }

        private void dailyD_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyD.Text = openFileDialog1.FileName;
            }
        }

         private void soil_specify_button_Click(object sender, EventArgs e)
        {
            soildata.Visible = true;
        }

        #endregion

        #region calibration code

        private void calib_calculate_maxruns(int calibparacount)
        {
            //this code calculates the total number of runs needed when calibrating
            string calibration_ratio_string = calibration_ratios_textbox.Text;
            string[] ratiowords = calibration_ratio_string.Split(';');
            int ratio;
            for (ratio = 0; ratio < ratiowords.Length; ratio++)
                for (int par = 0; par < calibparacount; par++)
                {
                    try
                    {
                        calib_ratios[par, ratio] = Convert.ToDouble(ratiowords[ratio]);
                    }
                    catch { input_data_error = true; MessageBox.Show("Calibration ratio input error"); }
                }
            try { calib_levels = Convert.ToInt32(calibration_levels_textbox.Text); }
            catch { input_data_error = true; MessageBox.Show("Calibration iterations must be an integer"); }
            maxruns = calib_levels * Convert.ToInt32(Math.Pow(ratiowords.Length, calibparacount));
            Debug.WriteLine(" the number of runs for calibration will be " + maxruns);
        }

        private void calib_shift_and_zoom(int para_number, double zoom_factor, double orig_par_value)
        {
            //this code iinds out whether the best parameter value was on the edge or inside the range explored. Then shifts and zooms out or in , depending
            try
            {
                Debug.WriteLine(" para number " + para_number);
                Debug.WriteLine(" best_parameter value " + best_parameters[para_number]);
                double mid_ratio = 0;
                if (calib_ratios.GetLength(1) % 2 == 0) { mid_ratio = (calib_ratios[para_number, Convert.ToInt32(calib_ratios.GetLength(1) / 2) - 1] + calib_ratios[para_number, Convert.ToInt32((calib_ratios.GetLength(1) / 2))]) / 2; }
                else { mid_ratio = calib_ratios[para_number, Convert.ToInt32(calib_ratios.GetLength(1) / 2 - 0.5)]; }
                Debug.WriteLine("mid ratio is " + mid_ratio);
                Double best_ratio = best_parameters[para_number] / orig_par_value;
                Debug.WriteLine("best ratio is " + best_ratio);
                if (best_parameters[para_number] == calib_ratios[para_number, 0] * orig_par_value | best_parameters[para_number] == calib_ratios[para_number, calib_ratios.GetLength(1) - 1] * orig_par_value)
                {
                    //the best parameter ratio (and thus value) was on the edge of the range. We must shift our range sideways (we keep the same ratio between upper and lower ratio - are you still with me?)
                    Debug.WriteLine(" currentpara value was on edge of range");

                    for (int ratio = 0; ratio < calib_ratios.GetLength(1); ratio++)
                    {
                        Debug.WriteLine(" setting ratio " + calib_ratios[para_number, ratio] + " to " + calib_ratios[para_number, ratio] * (best_ratio / mid_ratio));
                        calib_ratios[para_number, ratio] = calib_ratios[para_number, ratio] * (best_ratio / mid_ratio);
                    }
                }
                else
                {
                    //the best parameter ratio (and thus value) NOT on the edge of the range. We must shift to the best observed value and then zoom IN
                    Debug.WriteLine(" currentpara value was NOT on edge of range");
                    for (int ratio = 0; ratio < calib_ratios.GetLength(1); ratio++)
                    {
                        Debug.WriteLine(" setting ratio " + calib_ratios[para_number, ratio] + " to " + ((best_ratio - calib_ratios[para_number, ratio]) / zoom_factor));
                        calib_ratios[para_number, ratio] += (best_ratio - calib_ratios[para_number, ratio]) / zoom_factor;
                    }
                }
            }
            catch { Debug.WriteLine(" problem adapting parameters and ratios "); }
        }

        private void calib_prepare_report()
        {
            //this code prepares a calibration report
            //it opens and writes headers for a text file on disk
            string FILENAME = workdir + "\\calibration.log";
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                try
                {
                    sw.Write("run objective_function_value ");
                    //USER INPUT NEEDED IN FOLLOWING LINE: ENTER THE CALIBRATION PARAMETER NAMES 
                    //THEY WILL BE HEADERS IN THE CALIBRATION REPORT
                    sw.WriteLine(" erodibility_K conv_fac");
                }
                catch { Debug.WriteLine(" issue with writing the header of the calibration log file"); }
            }
            Debug.WriteLine(" calib tst - calib_prepare_rep - added first line to file");
        }

        private void calib_update_report(double objective_fnct_result)
        {
            //this code updates a calibration report
            //it writes parameters and objective function outcomes to disk
            string FILENAME = workdir + "\\calibration.log";
            using (StreamWriter sw = File.AppendText(FILENAME))
            {
                try
                {
                    //USER INPUT NEEDED IN FOLLOWING LINE: ENTER THE CALIBRATION PARAMETERS 
                    sw.WriteLine(run_number + " " + objective_fnct_result + " " + advection_erodibility + " " + conv_fac);
                }
                catch { Debug.WriteLine(" issue with writing a line in the calibration log file"); }
            }
            Debug.WriteLine(" calib tst - calib_update_rep - added line to file");
        }

        private void calib_finish_report()
        {
            //this code closes a calibration report
            //it writes the parameters for the best run to disk
            //CALIB_USER : Change the number of parameters referenced (now two)
            try
            {
                string FILENAME = workdir + "\\calibration.log";
                using (StreamWriter sw = File.AppendText(FILENAME))
                {
                    sw.WriteLine(best_run + " " + best_error + " " + best_parameters[0] + " " + best_parameters[1]);
                    Debug.WriteLine(" best run was " + best_run + " with error " + best_error + "m3");
                }
                Debug.WriteLine(" calib tst - calib_finish_rep - wrote final line and closed file");
            }
            catch
            {
                Debug.WriteLine(" calib tst - calib_finish_rep - FAILED to write file");
            }
        }

        private double calib_objective_function()
        {
            //this code calculates the value of the objective function during calibration and is user-specified. 
            //calibration looks to minimize the value of the objective function by varying parameter values
            //CALIB_USER
            //example for Luxembourg: we want to simulate the correct amount of erosion, over the entire slope
            //Xia, number needs to be adapted
            double simulated_ero_m3 = 0;
            double simulated_ero_kg_m2_y = 0;
            double known_ero_kg_m2_y = 0.0313;
            double total_bulk_density = 0;
            double average_bulk_density = 0;
            int objective_function_cells = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        simulated_ero_m3 -= sum_water_erosion[row, col] * dx * dx;
                        total_bulk_density += bulkdensity[row, col, 0];
                        objective_function_cells++;
                    }
                }
            }
            average_bulk_density = total_bulk_density / objective_function_cells;
            simulated_ero_kg_m2_y = average_bulk_density * simulated_ero_m3 / end_time / (objective_function_cells * dx * dx);
            ;
            Debug.WriteLine(" calib tst - calib_objective_function - error is " + Math.Abs(known_ero_kg_m2_y - simulated_ero_kg_m2_y) + "kg per m2 per year");
            return Math.Abs(known_ero_kg_m2_y - simulated_ero_kg_m2_y);
        }

        private void calib_update_best_paras()
        {
            //this code updates the recorded set of parameter values that gives the best score for the objective function
            //USERS have to update code here to reflect the parameters they actually vary
            Debug.WriteLine(" updating parameter set for best scored run");
            // add/change lines below
            best_parameters[0] = advection_erodibility;
            //best_parameters[1] = conv_fac;
            Debug.WriteLine(" best erodib " + best_parameters[0]);
            //Debug.WriteLine(" best conv_fac " + best_parameters[1]);
        }

        #endregion

        #region top level code

        private void main_loop(object sender, System.EventArgs e)
        {
            this.InfoStatusPanel.Text = "Entered main program";
            stopwatch = Stopwatch.StartNew();
            try
            {
                //foreach (string dtmfilename in Directory.EnumerateFiles(this.dtm_input_filename_textbox.Text, "*.txt", SearchOption.TopDirectoryOnly)) //"*.asc"
                //{
                string dtmfilename = dtm_input_filename_textbox.Text;
                Debug.WriteLine("Entered LORICA main code with " + dtmfilename);
                string[] separate = dtmfilename.Split('.');
                workdir = separate[0];
                Debug.WriteLine("storing results in " + workdir);
                System.IO.Directory.CreateDirectory(workdir);
                input_data_error = false;

                try { end_time = int.Parse(Number_runs_textbox.Text); }
                catch { input_data_error = true; MessageBox.Show("Invalid number of years"); }
                try { ntr = System.Convert.ToInt32(end_time); }     // WVG initialise ntr: number of rows in timeseries matrix   
                catch (OverflowException)
                {
                    MessageBox.Show("number of timesteps is outside the range of the Int32 type.");
                }
                //WVG initialise ntr, nr of timesteps, can be changed to nr of output timesteps
                numfile = 1;
                this.ProcessStatusPanel.Text = "";
                if (Water_ero_checkbox.Checked)
                {
                    water_ero_active = true;
                    this.ProcessStatusPanel.Text += "WE ";
                }
                if (Tillage_checkbox.Checked)
                {
                    tillage_active = true;
                    this.ProcessStatusPanel.Text += "TI ";
                }
                if (blocks_active_checkbox.Checked)
                {
                    blocks_active = 1;
                    this.ProcessStatusPanel.Text += "BL ";
                }
                if (Landslide_checkbox.Checked)
                {
                    landslide_active = true;
                    this.ProcessStatusPanel.Text += "LS ";
                }
                if (creep_active_checkbox.Checked)
                {
                    creep_active = true;
                    this.ProcessStatusPanel.Text += "CR ";
                }
                if (Biological_weathering_checkbox.Checked)
                {
                    bedrock_weathering_active = true;
                    this.ProcessStatusPanel.Text += "BW ";
                }
                if (Frost_weathering_checkbox.Checked)
                {
                    frost_weathering_active = true;
                    this.ProcessStatusPanel.Text += "FW ";
                }
                if (tilting_active_checkbox.Checked)
                {
                    tilting_active = true;
                    this.ProcessStatusPanel.Text += "TL ";
                }
                if (uplift_active_checkbox.Checked)
                {
                    uplift_active = true;
                    this.ProcessStatusPanel.Text += "UP ";
                }
                if (soil_phys_weath_checkbox.Checked)
                {
                    soil_phys_weath_active = true;
                    this.ProcessStatusPanel.Text += "PW ";
                }
                if (soil_chem_weath_checkbox.Checked)
                {
                    soil_chem_weath_active = true;
                    this.ProcessStatusPanel.Text += "CW ";
                }
                if (soil_bioturb_checkbox.Checked)
                {
                    soil_bioturb_active = true;
                    this.ProcessStatusPanel.Text += "BT ";
                }
                if (soil_clay_transloc_checkbox.Checked)
                {
                    soil_clay_transloc_active = true;
                    this.ProcessStatusPanel.Text += "CT ";
                }
                if (soil_carbon_cycle_checkbox.Checked) //:)
                {
                    soil_carbon_active = true;
                    this.ProcessStatusPanel.Text += "CC ";
                }

                //INPUTS
                //GENERAL INPUTS
                //Entry point for consecutive runs for sensitivity analyses or calibration 
                maxruns = 1;
                int currentlevel = 0;

                if (Calibration_button.Checked == true)
                {
                    int runs_per_level = 0;
                    //CALIB_USER INPUT NEEDED NEXT LINE IN THE CODE :
                    user_specified_number_of_calibration_parameters = 1;
                    best_error = 99999999999; //or any other absurdly high number
                    best_parameters = new double[user_specified_number_of_calibration_parameters];
                    user_specified_number_of_ratios = calibration_ratios_textbox.Text.Split(';').Length;
                    runs_per_level = Convert.ToInt32(Math.Pow(user_specified_number_of_ratios, user_specified_number_of_calibration_parameters));
                    calib_ratios = new double[user_specified_number_of_calibration_parameters, user_specified_number_of_ratios];
                    original_ratios = new double[user_specified_number_of_ratios];
                    for (int rat = 0; rat < user_specified_number_of_ratios; rat++)
                    {
                        try
                        {
                            original_ratios[rat] = Convert.ToDouble(calibration_ratios_textbox.Text.Split(';')[rat]);
                            for (int par = 0; par < user_specified_number_of_calibration_parameters; par++)
                            {
                                calib_ratios[par, rat] = Convert.ToDouble(calibration_ratios_textbox.Text.Split(';')[rat]);
                            }
                        }
                        catch { Debug.WriteLine(" problem setting original parameter ratios for calibration "); }
                    }
                    calib_calculate_maxruns(user_specified_number_of_calibration_parameters);
                    Debug.WriteLine(maxruns);
                    calib_prepare_report();
                    //CALIB_USER: set the number of parameters and their initial value

                }
                if (Sensitivity_button.Checked == true)
                { //dev needed
                }
                for (run_number = 0; run_number < maxruns; run_number++)
                {
                    Debug.WriteLine(" maxruns is " + maxruns);

                    try { save_interval2 = System.Convert.ToInt32(googAnimationSaveInterval.Text); }
                    catch { input_data_error = true; MessageBox.Show("value for google save interval is not valid"); }

                    if (UTMgridcheckbox.Checked)
                    {
                        try { test = System.Convert.ToInt32(UTMzonebox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for UTM zone is not valid"); }
                    }

                    if (end_time < save_interval2 && googleAnimationCheckbox.Checked == true) { input_data_error = true; MessageBox.Show("value for google save interval cannot be larger than number of runs "); }
                    if (end_time < int.Parse(saveintervalbox.Text) && checkBoxGenerateAVIFile.Checked == true) { input_data_error = true; MessageBox.Show("value for video interval cannot be larger than number of runs "); }


                    //WATER EROSION AND DEPOSITION PARAMETERS
                    if (water_ero_active)
                    {
                        try { m = double.Parse(parameter_m_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter m is not valid"); }                      // Kirkby's m and n factors for increasing
                        try { n = double.Parse(parameter_n_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter n is not valid"); }                   // sheet, wash, overland, gully to river flow
                        try { conv_fac = double.Parse(parameter_conv_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter p is not valid"); }
                        try { advection_erodibility = double.Parse(parameter_K_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter K is not valid"); }
                        try { bio_protection_constant = double.Parse(bio_protection_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { rock_protection_constant = double.Parse(rock_protection_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { constant_selective_transcap = double.Parse(selectivity_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { erosion_threshold_kg = double.Parse(erosion_threshold_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                    }

                    //TILLAGE PARAMETERS
                    if (tillage_active)
                    {
                        try { plough_depth = double.Parse(parameter_ploughing_depth_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter plough depth is not valid"); }
                        try { tilc = double.Parse(parameter_tillage_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tillage constant is not valid"); }
                    }

                    //BLOCK PARAMETERS
                    if (blocks_active == 1) 
                    {
                        try { hardlayerelevation_m = Int32.Parse(hardlayerelevation_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { hardlayerthickness_m = Int32.Parse(hardlayerthickness_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }
                        try { hardlayer_weath_contrast = Double.Parse(hardlayerweath_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { hardlayerdensity_kg_m3 = Int32.Parse(hardlayerdensity_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }

                        try { blocksizethreshold_m = Single.Parse(blocksize_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { blockweatheringratio = Single.Parse(blockweath_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }
                    }

                    //CREEP PARAMETER
                    if (creep_active)
                    {
                        try { conv_fac = double.Parse(parameter_conv_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter p is not valid"); }
                        try { diffusivity_creep = double.Parse(parameter_diffusivity_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter diffusivity is not valid"); }
                    }

                    //LANDSLIDE PARAMETERS
                    if (landslide_active)
                    {
                        conv_fac = 4;        // multiple flow conversion factor
                    }

                    //Bio Weathering PARAMETERS
                    if (bedrock_weathering_active)
                    {
                        try { P0 = double.Parse(parameter_P0_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P0 is not valid"); }
                        try { k1 = double.Parse(parameter_k1_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter k1 is not valid"); }
                        try { k2 = double.Parse(parameter_k2_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter k2 is not valid"); }
                        try { Pa = double.Parse(parameter_Pa_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter Pa is not valid"); }
                    }

                    //Tilting parameters
                    if (tilting_active)
                    {
                        if (radio_tilt_col_zero.Checked) { tilt_location = 0; }
                        if (radio_tilt_row_zero.Checked) { tilt_location = 1; }
                        if (radio_tilt_col_max.Checked) { tilt_location = 2; }
                        if (radio_tilt_row_max.Checked) { tilt_location = 3; }
                        try { tilt_intensity = double.Parse(Tilting_rate_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                    }

                    //Uplift parameters
                    if (uplift_active)
                    {
                        if (radio_lift_row_less_than.Checked) { lift_type = 0; }
                        if (radio_lift_row_more_than.Checked) { lift_type = 1; }
                        if (radio_lift_col_less_than.Checked) { lift_type = 2; }
                        if (radio_lift_row_more_than.Checked) { lift_type = 3; }
                        if (lift_type == 0)
                        {
                            try { lift_location = int.Parse(text_lift_row_less.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 1)
                        {
                            try { lift_location = int.Parse(text_lift_row_more.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 2)
                        {
                            try { lift_location = int.Parse(text_lift_col_less.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 3)
                        {
                            try { lift_location = int.Parse(text_lift_col_more.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        try { lift_intensity = double.Parse(Uplift_rate_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                    }

                    // TREE FALL PARAMETERS
                    if (treefall_checkbox.Checked)
                    {
                        W_m_max = System.Convert.ToDouble(tf_W.Text);
                        D_m_max = System.Convert.ToDouble(tf_D.Text);
                        growth_a_max = System.Convert.ToInt32(tf_growth.Text);
                        age_a_max = System.Convert.ToInt32(tf_age.Text);
                        tf_frequency = System.Convert.ToDouble(tf_freq.Text);
                    }

                    //SOIL PHYSICAL WEATHERING PARAMETERS
                    if (soil_phys_weath_active)
                    {
                        try
                        {
                            physical_weathering_constant = Convert.ToDouble(Physical_weath_C1_textbox.Text);
                            Cone = Convert.ToDouble(physical_weath_constant1.Text);
                            Ctwo = Convert.ToDouble(physical_weath_constant2.Text);
                            //the upper sizes of particle for the different fractions are declared in initialise_soil because they are always needed
                            Debug.WriteLine("succesfully read parameters for pysical weathering");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for pysical weathering");
                        }
                    }


                    //SOIL CHEMICAL WEATHERING PARAMETERS
                    if (soil_chem_weath_active)
                    {
                        try
                        {
                            chemical_weathering_constant = Convert.ToDouble(chem_weath_rate_constant_textbox.Text);
                            Cthree = Convert.ToDouble(chem_weath_depth_constant_textbox.Text);
                            Cfour = Convert.ToDouble(chem_weath_specific_coefficient_textbox.Text);
                            specific_area[0] = Convert.ToDouble(specific_area_coarse_textbox.Text);
                            specific_area[1] = Convert.ToDouble(specific_area_sand_textbox.Text);
                            specific_area[2] = Convert.ToDouble(specific_area_silt_textbox.Text);
                            specific_area[3] = Convert.ToDouble(specific_area_clay_textbox.Text);
                            specific_area[4] = Convert.ToDouble(specific_area_fine_clay_textbox.Text);
                            neoform_constant = Convert.ToDouble(clay_neoform_constant_textbox.Text);
                            Cfive = Convert.ToDouble(clay_neoform_C1_textbox.Text);
                            Csix = Convert.ToDouble(clay_neoform_C2_textbox.Text);
                            Debug.WriteLine("succesfully read parameters for chemical weathering");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for chemical weathering");
                        }
                    }

                    //SOIL CLAY DYNAMICS PARAMETERS
                    if (soil_clay_transloc_active)
                    {
                        try
                        {
                            max_eluviation = Convert.ToDouble(maximum_eluviation_textbox.Text);
                            Cclay = Convert.ToDouble(eluviation_coefficient_textbox.Text);
                            Debug.WriteLine("succesfully read parameters for  clay dynamics");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for clay dynamics");
                        }
                        if (CT_depth_decay_checkbox.Checked)
                        {
                            try
                            {
                                ct_depthdec = Convert.ToDouble(ct_depth_decay.Text);
                            }
                            catch
                            {
                                input_data_error = true; Debug.WriteLine("problem reading depth decay parameter for clay dynamics");
                            }
                        }
                    }

                    //BIOTURBATION PARAMETERS
                    if (soil_bioturb_active)
                    {
                        try
                        {
                            potential_bioturbation_kg = Convert.ToDouble(potential_bioturbation_textbox.Text);
                            bioturbation_depth_decay_constant = Convert.ToDouble(bioturbation_depth_decay_textbox.Text);
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for bioturbation");
                        }
                    }

                    //CARBON CYCLE PARAMETERS
                    if (soil_carbon_active)
                    {
                        try
                        {
                            potential_OM_input = Convert.ToDouble(carbon_input_textbox.Text);
                            OM_input_depth_decay_constant = Convert.ToDouble(carbon_depth_decay_textbox.Text);
                            humification_fraction = Convert.ToDouble(carbon_humification_fraction_textbox.Text);
                            potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text);
                            potential_old_decomp_rate = Convert.ToDouble(carbon_o_decomp_rate_textbox.Text);
                            young_depth_decay_constant = Convert.ToDouble(carbon_y_depth_decay_textbox.Text);
                            old_CTI_decay_constant = Convert.ToDouble(carbon_o_twi_decay_textbox.Text);
                            old_depth_decay_constant = Convert.ToDouble(carbon_o_depth_decay_textbox.Text);
                            young_CTI_decay_constant = Convert.ToDouble(carbon_y_twi_decay_textbox.Text);
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for carbon cycle");
                        }
                    }

                    try
                    {
                        filename = dtmfilename;             //for directory input
                        dtm_file(filename);                 // from dtm_file(), almost all memory for the model is claimed
                    }
                    catch { Debug.WriteLine(" failed to initialise dtm "); }

                    if (input_data_error == false)
                    {
                        try
                        {

                            //Debug.WriteLine("reading general values");
                            if (check_space_soildepth.Checked != true)
                            {
                                try { soildepth_value = double.Parse(soildepth_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter soildepth is not valid"); }
                            }
                            if (check_space_landuse.Checked != true && check_time_landuse.Checked != true)
                            {
                                try { landuse_value = int.Parse(landuse_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter landuse is not valid"); }
                            }
                            if (check_space_evap.Checked != true && check_time_evap.Checked != true)
                            {
                                try { evap_value_m = double.Parse(evap_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter evapotranspiration is not valid"); }
                            }
                            if (check_space_infil.Checked != true && check_time_infil.Checked != true)
                            {
                                try { infil_value_m = double.Parse(infil_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter infiltration is not valid"); }
                            }

                            if (check_space_rain.Checked != true && check_time_rain.Checked != true)
                            {
                                try { rain_value_m = double.Parse(rainfall_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter rainfall is not valid"); }
                            }

                            if (check_time_T.Checked != true)
                            {
                                try { temp_value_C = int.Parse(temp_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter temperature is not valid"); }
                            }

                        }
                        catch { MessageBox.Show("there was a problem reading input values"); input_data_error = true; }
                        // Debug.WriteLine("initialising non-general inputs");
                        try { initialise_once(); } // reading input files
                        catch { MessageBox.Show("there was a problem reading input files "); input_data_error = true; }


                        //CALIB_USER: multiply parameter values with current ratio
                        //Note the correspondence between the formulas. Change only 1 value for additional parameters!
                        if (Calibration_button.Checked == true)
                        {
                            //Debug.WriteLine("erodib " + advection_erodibility + " conv fac " + conv_fac);
                            int rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 0)) % user_specified_number_of_ratios);
                            advection_erodibility *= calib_ratios[0, rat_number];
                            Debug.WriteLine("First ratio number: " + rat_number);
                            //rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 1)) % user_specified_number_of_ratios);
                            //conv_fac *= calib_ratios[1, rat_number];
                            //Debug.WriteLine("Second ratio number: " + rat_number);
                            // Debug.WriteLine("erodib " + advection_erodibility + " conv fac " + conv_fac);
                        }

                        timeseries_matrix = new double[System.Convert.ToInt32(end_time), number_of_outputs];
                        if (input_data_error == false)
                        {
                            if (input_data_error == false)
                            {
                                int count_intervene = 0;
                                t_intervene = 0;
                                if (t_intervene > 0) { read_soil_elevation_distance_from_output(t_intervene, workdir); }

                                for (t = t_intervene; t < end_time; t++)
                                {

                                    try
                                    {
                                        every_timestep();
                                    }
                                    catch
                                    {
                                        Debug.WriteLine("failed to run in timestep " + t);
                                        // Catch for when the model crashes due to unknown reasons. The model will read the latest output and start calculating again from there which I named an intervention). When the crash occurs five times, the model breaks MM
                                        if (count_intervene < 5)
                                        {
                                            count_intervene += 1;
                                            t_intervene = t - (t % (int.Parse(Box_years_output.Text)));
                                            Debug.WriteLine("intervening at t" + t_intervene);
                                            read_soil_elevation_distance_from_output(t_intervene, workdir);
                                        }
                                        else
                                        {
                                            break;
                                        }
                                    }
                                }

                            }
                        }
                    }
                    if (input_data_error == true)
                    {
                        MessageBox.Show("input data error - program can not yet run");
                        tabControl1.Visible = true;
                    }

                    if (Calibration_button.Checked == true)
                    {
                        //calculate how good this run was:
                        double current_error = calib_objective_function();
                        //store that information along with the parameter values used to achieve it:
                        calib_update_report(current_error);
                        if (current_error < best_error) { best_error = current_error; calib_update_best_paras(); best_run = run_number; }
                        //and check whether one 'level' of calibration has finished. If so, we have to change parameter values
                        Debug.WriteLine("run " + run_number + " number paras " + user_specified_number_of_calibration_parameters + " number ratios " + calibration_ratios_textbox.Text.Split(';').Length);
                        if ((run_number + 1) % Convert.ToInt32(Math.Pow(calibration_ratios_textbox.Text.Split(';').Length, user_specified_number_of_calibration_parameters)) == 0)
                        {

                            //a level of calibration has finished

                            //If it was the last level, we are now done
                            currentlevel++;
                            Debug.WriteLine(" successfully finished a level of calibration runs");
                            if (run_number == maxruns - 1)
                            {
                                Debug.WriteLine(" successfully finished last level of calibration runs");
                                calib_finish_report();
                            }
                            else
                            {
                                Debug.WriteLine(" setting new ratios ");
                                //CALIB_USER INPUT NEEDED HERE IN CODE
                                //check whether the best run was on the edge of parameter space or inside, shift to that place and zoom out or in
                                calib_shift_and_zoom(0, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_K_textbox.Text));
                                //calib_shift_and_zoom(1, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_conv_textbox.Text));
                            }
                        }
                        else
                        {
                            //nothing. Parameter values are adapted with the corresponding ratios to continue calibration above.
                        }
                    }

                } // exit point for consecutive runs


            } // end try
            catch
            {
                Debug.WriteLine("Error in accessing file " + this.dtm_input_filename_textbox.Text);
            }

        }  //end main

        private void calculate_overwater_landscape_Spitsbergen()
        {
            //to account for a landscape that is isostaically rebounding from below sealevel to above sealevel. 
            //height above sealevel itself is not important, just that the landscape grows over time
            //therefore, Marijn's solution: if (elevation < threshold(t)) , then elevation = nodata
            double minimum_overwater_elevation = (10263 - t) / 218;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {

                    if (original_dtm[row, col] != -9999)
                    {

                        if (original_dtm[row, col] > minimum_overwater_elevation && dtm[row, col] == -9999)
                        {
                            // these cases were not over water, but now will be.
                            dtm[row, col] = original_dtm[row, col];
                            // all cases that were already overwater, will stay overwater - no changes there.
                        }
                    }
                    else
                    {
                        // nothing happens because these cells are simply not part of the study area
                    }
                }
            }
        }

        private void every_timestep()    //performs actions in every timestep
        {
            // If a cell should remain at the same fixed elevation (e.g. fixed elevation boundary condition), here the cell can be selected
            //if(nr>50&nc>100)
            //{ 
            //    if (t == t_intervene) { dtm00 = dtm[50, 100]; }

            //    // force no-change boundary op de outlet CLORPT
            //    dtm[50, 100] = dtm00;

            //}

            DateTime geo_start, pedo_start, hydro_start;


            //if (t == 0 | t == 1) { displaysoil(50, 0); }
            int i = 0;
            this.TimeStatusPanel.Text = "timestep " + (t + 1) + "/" + +end_time;
            // Debug.WriteLine("starting calculations - TIME " + t);

            if (Ik_ben_Marijn.Checked)
            { calculate_overwater_landscape_Spitsbergen(); }

            #region hydrological processes
            hydro_start = DateTime.Now;
            if (daily_water.Checked)
            {
                water_balance();
            }
            //print_spatial_water_balance();
            // print_P_ET0();
            hydro_t += DateTime.Now - hydro_start;
            #endregion

            #region Vegetation
            // Debug.WriteLine("before vegetation");
            if (daily_water.Checked)
            {
                determine_vegetation_type();
                change_vegetation_parameters();
            }

            #endregion

            #region Geomorphic processes
            geo_start = DateTime.Now;

            //Debug.WriteLine("before WE");
            //displaysoil(0, 0);
            if (water_ero_active)
            {
                //Debug.WriteLine("before WE1");

                initialise_every();
                comb_sort();

                if (daily_water.Checked)
                {
                    //Debug.WriteLine("before WE2");
                    calculate_water_ero_sed_daily();
                    //Debug.WriteLine("before WE3");
                    soil_update_split_and_combine_layers();
                    //Debug.WriteLine("before WE4");

                }
                else
                {
                    findsinks();
                    searchdepressions();
                    define_fillheight_new();
                    if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before erosed"); }
                    calculate_water_ero_sed();
                    soil_update_split_and_combine_layers();
                    if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after erosed"); }
                    if (crashed) { Debug.WriteLine("crashed while calculating water erosion"); }
                }
            }

            // Debug.WriteLine("before TF");
            if (treefall_checkbox.Checked)
            {
                if (t <= (end_time - 500)) // if there is no tillage
                {
                    calculate_tree_fall();
                }
            }

            if (bedrock_weathering_active)
            {
                calculate_bedrock_weathering();
                soil_update_split_and_combine_layers();
            }

            if (creep_active)
            {
                try
                {// Debug.WriteLine("calculating creep");
                    comb_sort();

                    calculate_creep();

                    soil_update_split_and_combine_layers();
                }
                catch { Debug.WriteLine(" failed during creep calculations"); }
            }

            if (blocks_active==1)
            {
                try
                {
                    hardlayer_breaking();
                    //Debug.WriteLine(" broke hard layer");
                    block_weathering();
                    //Debug.WriteLine(" weathered blocks");
                    block_movement();
                    //Debug.WriteLine(" moved blocks");
                    if (t % 1 == 0 | t > 3995)
                    {
                        string outblocks = (workdir + "\\" + "outblocks" + t + ".txt");
                        out_blocks(outblocks);
                        string outopenness = (workdir + "\\" + "openness" + t + ".asc");
                        out_float(outopenness, hardlayeropenness_fraction);
                        if (blocks_active == 1)
                        {
                            Debug.WriteLine("topo control on rolling: " + topoconttoroll + " creep control " + creepconttoroll + " creep control ratio: " + (creepconttoroll / (creepconttoroll + topoconttoroll)));
                            Debug.WriteLine("blocks produced: " + blocksproduced + " rolls: " + blocksrolled + " rolls per block: " + (blocksrolled / blocksproduced));
                        }
                    }
                }
                catch { Debug.WriteLine(" failed during block calculations"); }
            }

            if (tillage_active)
            {
                comb_sort();
                int tilltime = 0;
                //if (check_time_till_fields.Checked) { tilltime = till_record[t]; }
                //else { tilltime = 1; }

                if (t > (end_time - 500)) { tilltime = 1; }
                if (tilltime == 1)
                {


                    initialise_every_till();
                    calculate_tillage();
                    soil_update_split_and_combine_layers();
                }

            }
            //Debug.WriteLine("after TI");
            //displaysoil(0, 0);
            if (landslide_active)
            {
                Debug.WriteLine("calculating landsliding");
                comb_sort();
                ini_slope();
                calculate_critical_rain();
                calculate_slide();
            }

            geo_t += DateTime.Now - geo_start;

            #endregion

            #region pedogenic processes


            pedo_start = DateTime.Now;

            // Debug.WriteLine("before PW");
            //displaysoil(0, 0);
            if (soil_phys_weath_active)
            {
                // Debug.WriteLine("calculating soil physical weathering");
                if (Ik_ben_Marijn.Checked == false) { soil_physical_weathering(); }
                else
                {
                    SPITS_soil_physical_weathering();
                    SPITS_aeolian_deposition();
                }
                soil_update_split_and_combine_layers();


            }
            // Debug.WriteLine("before CW");
            //displaysoil(0, 0);
            if (soil_chem_weath_active)
            {
                //Debug.WriteLine("calculating soil chemical weathering");
                soil_chemical_weathering();
                soil_update_split_and_combine_layers();
                if (timeseries.total_average_soilthickness_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[21]] = total_average_soilthickness_m;
                }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[22]] = number_soil_thicker_than;
                }
                if (timeseries.timeseries_coarser_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[23]] = number_soil_coarser_than;
                }
                if (timeseries.timeseries_soil_depth_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[24]] = local_soil_depth_m;
                }
                if (timeseries.timeseries_soil_mass_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[25]] = local_soil_mass_kg;
                }
            }

            // Debug.WriteLine("before CT");
            //displaysoil(0, 0);
            if (soil_clay_transloc_active)
            {
                // Debug.WriteLine("calculating soil clay dynamics ");

                if (Ik_ben_Marijn.Checked == true)
                {
                    soil_silt_translocation(); // Spitsbergen case study
                }
                else
                {
                    if (ct_Jagercikova.Checked == true)
                    {
                        soil_clay_translocation_Jagercikova();
                    }
                    else
                    {
                        soil_clay_translocation();
                    }
                }
                soil_update_split_and_combine_layers();
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_ets1");
                }

            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before soil carbon"); }
            //displaysoil(0, 0);
            if (soil_carbon_active)
            {
                // Debug.WriteLine("calculating carbon dynamics ");
                if (version_lux_checkbox.Checked)
                {
                    soil_litter_cycle();
                }
                else
                {
                    soil_carbon_cycle();
                }

            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after soil carbon"); }
            if (decalcification_checkbox.Checked)
            {
                //Debug.WriteLine("calculating decalcification");
                soil_decalcification();
            }

            if (soil_bioturb_active)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        update_all_soil_thicknesses(row, col);
                    }
                }
                // Debug.WriteLine("calculating bioturbation");
                soil_bioturbation();
                // if (findnegativetexture()) { Debugger.Break(); }

                soil_update_split_and_combine_layers();
                // if (findnegativetexture()) { Debugger.Break(); }

            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after soil bioturb"); }


            pedo_t += DateTime.Now - pedo_start;

            #endregion

            #region write output

            // Debug.WriteLine("before output");
            numfile++;

            int t_out = t + 1;
            if ((Final_output_checkbox.Checked && t_out == end_time) || (Regular_output_checkbox.Checked && ((t_out) % (int.Parse(Box_years_output.Text)) == 0)))
            {
                if (t == end_time - 1)
                {

                    //Debug.WriteLine("Time balance. Geomorphic processes: {0} min, pedogenic processes: {1} min, hydrologic processes: {2} min, ponding {3} min", geo_t, pedo_t, hydro_t, ponding_t);
                }
                //Debug.WriteLine("Attempting to write outputs");

                // displaysoil(31, 12);
                // Debug.WriteLine("Total catchment mass = " + total_catchment_mass());

                if (daily_water.Checked)
                {
                    Debug.WriteLine("writing daily water");

                    //try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_aridity.asc", aridity_vegetation); }
                    //catch { MessageBox.Show("vegetation has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_infiltration_m.asc", Iy); }
                    catch { MessageBox.Show("infiltration has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_actual_evapotranspiration_m.asc", ETay); }
                    catch { MessageBox.Show("ETa has not been written"); }

                    try
                    {
                        out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_vegetationtype.asc", vegetation_type);
                        for (row = 0; row < nr; row++)
                        {
                            for (col = 0; col < nc; col++)
                            {
                                vegetation_type[row, col] = 0; // reset vegetation_type, to give the output per output period
                            }
                        }
                    }
                    catch { MessageBox.Show("vegetation type has not been written"); }



                }

                if (version_lux_checkbox.Checked == true)
                {
                    try
                    {
                        // outputs for case study Luxembourg. Focus on different litter types
                        // young labile OM is hornbeam, old stable OM is beech
                        // Outputs:
                        // SOM stocks entire profile: total, young, old (kg/m2)
                        // top layer: total, old, young (-) 

                        string[] litter_types = { "hornbeam", "beech", "total" };
                        string[] litter_outputs = { "stocks_kgm2", "toplayer_frac" };

                        foreach (string type in litter_types) // loop over different SOM types
                        {
                            // determine which SOM fraction should be considered
                            bool h_bool = false; bool b_bool = false;
                            if (type == "hornbeam") { h_bool = true; }
                            if (type == "beech") { b_bool = true; }
                            if (type == "total") { h_bool = true; b_bool = true; }

                            foreach (string output in litter_outputs)
                            {
                                // determine which layers to consider and what to calculate
                                int numberoflayers = 0;
                                if (output == "stocks_kgm2") { numberoflayers = max_soil_layers; }
                                if (output == "toplayer_frac") { numberoflayers = 1; }

                                double[,] output_litter_map = new double[nr, nc];
                                for (int row = 0; row < nr; row++)
                                {
                                    for (int col = 0; col < nc; col++)
                                    {
                                        double litterstock_kg = 0;
                                        double mineralsoil_toplayer_kg = 0;
                                        if (h_bool) { litterstock_kg += litter_kg[row, col, 0]; }
                                        if (b_bool) { litterstock_kg += litter_kg[row, col, 1]; }

                                        if (output == "toplayer_frac")
                                        {
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                mineralsoil_toplayer_kg += texture_kg[row, col, 0, tex];
                                            }
                                        }


                                        if (output == "toplayer_frac") { litterstock_kg /= (mineralsoil_toplayer_kg + litterstock_kg); } // calculate to fraction
                                        if (output == "stocks_kgm2") { litterstock_kg /= (dx * dx); } // calculate to kg/m2
                                        output_litter_map[row, col] = litterstock_kg;
                                    }
                                }
                                try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_litter_" + type + "_" + output + ".asc", output_litter_map); }
                                catch { MessageBox.Show("litter output has not been written"); }
                            }
                        }
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_TPI.asc", tpi); }
                        catch { MessageBox.Show("TPI output has not been written"); }

                        /* CODE BLOCK BELOW WRITES OUT DIFFERENT ORGANIC MATTER MAPS. THIS IS NOT NECESSARY ANYMORE NOW LITTER IS STORED IN ITS OWN MATRIX
                            * 
                        // outputs for case study Luxembourg. Focus on different organic matter types
                        // young labile OM is hornbeam, old stable OM is beech
                        // Outputs:
                        // SOM stocks entire profile: total, young, old (kg/m2)
                        // top layer: total, old, young (-) 

                        string[] SOM_types = { "young", "old", "total" };
                        string[] SOM_outputs = { "stocks_kgm2", "toplayer_frac" };

                        foreach (string type in SOM_types) // loop over different SOM types
                        {
                            // determine which SOM fraction should be considered
                            bool y_bool = false; bool o_bool = false;
                            if (type == "young") { y_bool = true; }
                            if (type == "old") { o_bool = true; }
                            if (type == "total") { y_bool = true; o_bool = true; }

                            foreach (string output in SOM_outputs)
                            {
                                // determine which layers to consider and what to calculate
                                int numberoflayers = 0;
                                if (output == "stocks_kgm2") { numberoflayers = max_soil_layers; }
                                if (output == "toplayer_frac") { numberoflayers = 1; }

                                double[,] output_SOM_map = new double[nr, nc] ;
                                for (int row = 0; row < nr; row++)
                                {
                                    for (int col = 0; col < nc; col++)
                                    {
                                        double SOMstock_kg = 0;
                                        double mineralsoil_kg = 0;
                                        for (int lay = 0; lay < numberoflayers; lay++)
                                        {
                                            if (y_bool) { SOMstock_kg += young_SOM_kg[row, col, lay]; }
                                            if (o_bool) { SOMstock_kg += old_SOM_kg[row, col, lay]; }

                                            if (output == "toplayer_frac")
                                            {
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    mineralsoil_kg += texture_kg[row, col, lay, tex];
                                                }
                                            }
                                        }
                                        if (output == "toplayer_frac") { SOMstock_kg /= (mineralsoil_kg + SOMstock_kg); } // calculate to fraction
                                        if (output == "stocks_kgm2") { SOMstock_kg /= (dx * dx); } // calculate to kg/m2
                                        output_SOM_map[row, col] = SOMstock_kg;
                                    }
                                }
                                try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_SOM_" + type + "_" + output + ".asc", output_SOM_map); }
                                catch { MessageBox.Show("SOM output has not been written"); }
                            }
                        }
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_TPI.asc", tpi); }
                        catch { MessageBox.Show("TPI output has not been written"); }

                        */
                    }
                    catch
                    {
                        Debug.WriteLine("Error in writing litterwater_ outputs for Luxembourg case study");
                    }
                }



                try
                {
                    //Debug.WriteLine("writing all soils");
                    writeallsoils();
                }
                catch
                {
                    Debug.WriteLine("Failed during writing of soils");
                }


                if (Altitude_output_checkbox.Checked)
                {

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dtm.asc", dtm); }
                    catch { MessageBox.Show("dtm has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dz_soil.asc", dz_soil); }
                    catch { MessageBox.Show("dz_soil has not been written"); }


                    //try { out_double(workdir + "\\" + run_number + "_" + t + "_out_dzero.asc", dz_ero_m); }
                    //catch { MessageBox.Show("dzero has not been written"); }
                    //try { out_double(workdir + "\\" + run_number + "_" + t + "_out_dzsed.asc", dz_sed_m); }
                    //catch { MessageBox.Show("dzsed has not been written"); }
                }
                if (treefall_checkbox.Checked)
                {
                    try
                    {
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dz_treefall.asc", dz_treefall);
                        out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_treefallcount.asc", treefall_count);

                    }
                    catch { MessageBox.Show("treefall has not been written"); }
                }
                if (Soildepth_output_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_soildepth.asc", soildepth_m); }
                    catch { MessageBox.Show("soildepth has not been written"); }
                }
                if (Alt_change_output_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_change.asc", dtmchange); }
                    catch { MessageBox.Show("change has not been written"); }
                }

                if (water_output_checkbox.Checked & Water_ero_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing water flow");


                    try
                    {
                        if (daily_water.Checked)
                        {
                            for (int roww = 0; roww < nr; roww++)
                            {
                                for (int colw = 0; colw < nc; colw++)
                                {
                                    waterflow_m3[roww, colw] = OFy_m[roww, colw, 0];
                                }
                            }
                        }
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_out_water.asc", waterflow_m3);
                    }
                    catch { MessageBox.Show("water has not been written"); }
                }
                if (depressions_output_checkbox.Checked)
                {
                    try { out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_depress.asc", depression); }
                    catch { MessageBox.Show("depressions have not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dtmfillA.asc", dtmfill_A); }
                    catch { MessageBox.Show("dfmfill has not been written"); }
                }
                if (diagnostic_output_checkbox.Checked)
                {
                    //try { out_double(workdir + "\\" + t + "_out_sedintrans.asc", sediment_in_transport); }
                    //catch {  MessageBox.Show("sed in trans has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dzero.asc", dz_ero_m); }
                    catch { MessageBox.Show("dzero has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dzsed.asc", dz_sed_m); }
                    catch { MessageBox.Show("dzsed has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_lakesed.asc", lake_sed_m); }
                    catch { MessageBox.Show("lakesed has not been written"); }
                }

                if (Water_ero_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing water erosion");

                    if (all_process_output_checkbox.Checked)
                    {
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_water_erosion.asc", sum_water_erosion); }
                        catch { MessageBox.Show("water erosion has not been written"); }
                    }
                }
                if (creep_active_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing creep");

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_creep.asc", creep); }
                    catch { MessageBox.Show("creep has not been written"); }

                }

                if (Tillage_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing tillage erosion");

                    if (all_process_output_checkbox.Checked)
                    {
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_tillage.asc", sum_tillage); }
                        catch { MessageBox.Show("tillage has not been written"); }
                    }
                }
                if (Landslide_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_crrain.asc", crrain); }
                    catch { MessageBox.Show("crrain has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_ca.asc", camf); }
                    catch { MessageBox.Show("ca has not been written"); }
                }

                if (decalcification_checkbox.Checked)
                {
                    try
                    {
                        double[,] decalcification_depth = new double[nr, nc];
                        for (int rowdec = 0; rowdec < nr; rowdec++)
                        {
                            for (int coldec = 0; coldec < nc; coldec++)
                            {
                                bool decal_written = false;
                                if (dtm[rowdec, coldec] != -9999)
                                {
                                    double depthdec = 0;
                                    int laydec = 0;
                                    while (decal_written == false)
                                    {
                                        if (CO3_kg[rowdec, coldec, laydec] == 0 && (laydec != (max_soil_layers - 1)))
                                        {
                                            if (laydec < (max_soil_layers - 1))
                                            {
                                                laydec++;
                                                depthdec += layerthickness_m[rowdec, coldec, laydec];
                                            }

                                        }
                                        else
                                        {
                                            decalcification_depth[rowdec, coldec] = depthdec;
                                            decal_written = true;
                                        }
                                    }
                                }
                            }
                        }
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_decaldepth.asc", decalcification_depth);
                    }
                    catch
                    {
                        MessageBox.Show("decalcification has not been written");
                    }
                }

                if (profile.radio_pro1_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro1_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro2_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro2_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro3_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro3_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                //Debug.WriteLine("after outputs");

            }

            if (t == end_time - 1)
            {

                this.InfoStatusPanel.Text = " --finished--";
                stopwatch.Stop();
                Debug.WriteLine("Elapsed time: " + stopwatch.Elapsed);
                //Timeseries output
                if (number_of_outputs > 0) { timeseries_output(); }
            }
            #endregion

        }

        private void comb_sort()      //sorts the data cells in a dtm in order of increasing altitude
        {
            // comb sorting by Wlodek Dobosiewicz in 1980
            // http://en.wikipedia.org/wiki/Comb_sort
            // LORICA adaptation by Arnaud Temme june 2009
            //Debug.WriteLine("sorting. nr " + nr + " nc " + nc + " t " + t);
            this.InfoStatusPanel.Text = "sorting";
            int i = 0;
            double dtm_temp = 0;
            int row_temp = 0, col_temp = 0;
            string rowcol_temp;
            //Debug.WriteLine("sorting. nr " + nr + " nc " + nc + " t " + t);
            if (t == t_intervene)  // only in the first timestep;
            {
                //Debug.WriteLine("normal sorting. nr " + nr + " nc " + nc + " t " + t);
                number_of_data_cells = 0;
                for (row = 0; row < nr; row++)  // why not do this only in the first timestep? And use the existing one as input in subsequent timesteps?
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            index[i] = dtm[row, col]; row_index[i] = row; col_index[i] = col; rowcol_index[i] = row.ToString() + "." + col.ToString();
                            i++;
                        }
                    }
                }
                number_of_data_cells = i;
            }
            else
            {
                //Debug.WriteLine("alternative sorting. nr " + nr + " nc " + nc + " t " + t);
                for (i = 0; i < number_of_data_cells; i++)
                {
                    index[i] = dtm[row_index[i], col_index[i]];     //merely update the existing index with the adapted altitudes and then sort     
                }
            }
            //displayonscreen(0, 0);
            this.InfoStatusPanel.Text = "data cells: " + number_of_data_cells;
            //Debug.WriteLine("\n--sorting overview--");
            //Debug.WriteLine("Sorting " + number_of_data_cells + " cells");
            long gap = number_of_data_cells;
            bool swaps;
            long total_swaps = 0;
            //while (gap > 1 && swaps == true)  // in freak? situations, swaps may be false for gap = x, but true for subsequent values of gap
            while (gap > 1)
            {
                if (gap > 1)
                {
                    if (gap == 2) { gap = 1; }
                    gap = Convert.ToInt64(gap / 1.2);
                }
                i = 0;
                swaps = false;
                //this.InfoStatusPanel.Text = "i " + i + " gap " + gap + " tot swaps " + total_swaps;
                //Debug.WriteLine("i " + i + " gap " + gap + " tot swaps " + total_swaps);
                while (i + gap < number_of_data_cells)
                {
                    //if (gap == Convert.ToInt64(number_of_data_cells / 1.2) && i < 10) {Debug.WriteLine("    i " + i + " gap " + gap + " tot swaps " + total_swaps + " alt1 " + index[i] + " (" + row_index[i] + "," + col_index[i] + ") alt2 " + index[i+gap] + " (" + row_index[i+gap] + "," + col_index[i+gap] + ")"); }
                    if (index[i] > index[i + gap])
                    {
                        dtm_temp = index[i]; index[i] = index[i + gap]; index[i + gap] = dtm_temp;
                        row_temp = row_index[i]; row_index[i] = row_index[i + gap]; row_index[i + gap] = row_temp;
                        col_temp = col_index[i]; col_index[i] = col_index[i + gap]; col_index[i + gap] = col_temp;
                        rowcol_temp = rowcol_index[i]; rowcol_index[i] = rowcol_index[i + gap]; rowcol_index[i + gap] = rowcol_temp;
                        swaps = true;
                        total_swaps++;
                    } // end if
                    i++;
                }  // end while
                    //if (gap < 4) { Debug.WriteLine("i " + i + " gap " + gap + " tot swaps " + total_swaps); }
            } //end while
            int sorting_error = 0;
            for (i = 0; i < number_of_data_cells - 1; i++)
            {
                if (index[i] > index[i + 1]) { sorting_error = 1; }
            }
            if (sorting_error == 1)
            {
                Debug.WriteLine(" Sorting error in comb_sort ");
            }
            else
            {
                //Debug.WriteLine(" Sorting test successful ");
            }
        }

        private void statusBar1_PanelClick(object sender, StatusBarPanelClickEventArgs e)
        {

        }

        private void checkBox1_CheckedChanged_1(object sender, EventArgs e)
        {

        }

        private void parameter_conv_textbox_TextChanged(object sender, EventArgs e)
        {

        }

        private void textBox3_TextChanged_4(object sender, EventArgs e)
        {

        }

        #endregion

        }
    }


