

// HydroLorica v1.0 by W.M. van der Meij and A.J.A.M. Temme, 2020
// Based on Lorica by Vanwalleghem and Temme 2016
// Based on MILESD 2011 by Vanwalleghem et al and on LAPSUS by Temme, Schoorl and colleagues (2006-2011)
// 
// Credits to T.J. Coulthard for interface coding template (the CAESAR model, www.coulthard.org.uk)

//This program is free software; you can redistribute it and/or modify it under the terms of the 
//GNU General Public License as published by the Free Software Foundation;  
//This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
//without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
//See the GNU General Public License (http://www.gnu.org/copyleft/gpl.html) for more details. 
//You should have received a copy of the GNU General Public License along with this program; 
//if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, 
//MA 02110-1301, USA.

// June 2020

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Concurrent;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.IO;
using System.Net;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Numerics;
using MathNet.Numerics;
using MathNet.Numerics.IntegralTransforms;
using System.Management; //used to find Logical Processor and Core count

namespace LORICA4
{
    /// <summary>
    /// Main LORICA interface
    /// </summary>
    public class Mother_form : System.Windows.Forms.Form
    {
        [DllImport("msvcrt")]
        static extern int _getch();

        #region global interface parameters
        private TabControl Process_tabs;
        private TabPage Water;
        private TextBox parameter_n_textbox;
        private TextBox parameter_conv_textbox;
        private TextBox parameter_K_textbox;
        private TextBox parameter_m_textbox;
        private CheckBox only_waterflow_checkbox;
        private PictureBox pictureBox1;
        private Label label12;
        private Label label11;
        private Label label10;
        private Label label9;
        private CheckBox Water_ero_checkbox;
        private TabPage Tillage;
        private PictureBox pictureBox2;
        private Label label20;
        private Label trte;
        private TextBox parameter_tillage_constant_textbox;
        private TextBox parameter_ploughing_depth_textbox;
        private CheckBox Tillage_checkbox;
        private TabPage Creeper;
        private PictureBox pictureBox3;
        private Label label19;
        private TextBox parameter_diffusivity_textbox;
        private CheckBox creep_active_checkbox;
        private Label label36;
        private RadioButton radio_ls_fraction;
        private RadioButton radio_ls_absolute;
        private Label label35;
        private Label label34;
        private TextBox text_ls_rel_rain_intens;
        private TextBox textBox_ls_trans;
        private TextBox textBox_ls_bd;
        private TextBox textBox_ls_ifr;
        private TextBox textBox_ls_coh;
        private TextBox text_ls_abs_rain_intens;
        private Label label32;
        private Label label31;
        private Label label30;
        private Label label22;
        private Label label18;
        private PictureBox pictureBox4;
        private CheckBox Landslide_checkbox;
        private TabPage Solifluction;
        private PictureBox pictureBox5;
        private CheckBox Solifluction_checkbox;
        private TabPage Rock_weathering;
        private PictureBox pictureBox6;
        private GroupBox groupBox10;
        private CheckBox Frost_weathering_checkbox;
        private GroupBox groupBox9;
        private TextBox parameter_k1_textbox;
        private Label label24;
        private Label label26;
        private Label label27;
        private Label label28;
        private TextBox parameter_k2_textbox;
        private TextBox parameter_Pa_textbox;
        private TextBox parameter_P0_textbox;
        private Label label21;
        private CheckBox Biological_weathering_checkbox;
        private TabPage Tectonics;
        private GroupBox groupBox14;
        private GroupBox groupBox16;
        private TextBox text_lift_col_less;
        private TextBox text_lift_col_more;
        private TextBox text_lift_row_less;
        private TextBox text_lift_row_more;
        private RadioButton radio_lift_col_less_than;
        private RadioButton radio_lift_row_more_than;
        private RadioButton radio_lift_col_more_than;
        private RadioButton radio_lift_row_less_than;
        private TextBox Uplift_rate_textbox;
        private CheckBox uplift_active_checkbox;
        private Label label39;
        private GroupBox groupBox4;
        private Label label38;
        private TextBox Tilting_rate_textbox;
        private GroupBox groupBox15;
        private RadioButton radio_tilt_col_max;
        private RadioButton radio_tilt_row_zero;
        private RadioButton radio_tilt_col_zero;
        private RadioButton radio_tilt_row_max;
        private CheckBox tilting_active_checkbox;
        private TabPage tabPage1;
        private TabControl tabControl2;
        private TabPage physical;
        private TabPage chemical;
        private TabPage clay;
        private TabPage bioturbation;
        private CheckBox soil_phys_weath_checkbox;
        private CheckBox soil_chem_weath_checkbox;
        private CheckBox soil_clay_transloc_checkbox;
        private CheckBox soil_bioturb_checkbox;
        private TextBox upper_particle_fine_clay_textbox;
        private TextBox upper_particle_clay_textbox;
        private TextBox upper_particle_silt_textbox;
        private TextBox upper_particle_sand_textbox;
        private TextBox upper_particle_coarse_textbox;
        private TextBox physical_weath_constant2;
        private TextBox physical_weath_constant1;
        private TextBox Physical_weath_C1_textbox;
        private TextBox chem_weath_specific_coefficient_textbox;
        private TextBox chem_weath_depth_constant_textbox;
        private TextBox chem_weath_rate_constant_textbox;
        private TextBox specific_area_fine_clay_textbox;
        private TextBox specific_area_clay_textbox;
        private TextBox specific_area_silt_textbox;
        private TextBox specific_area_sand_textbox;
        private TextBox specific_area_coarse_textbox;
        private TextBox clay_neoform_C2_textbox;
        private TextBox clay_neoform_C1_textbox;
        private TextBox clay_neoform_constant_textbox;
        private TextBox eluviation_coefficient_textbox;
        private TextBox maximum_eluviation_textbox;
        private TextBox bioturbation_depth_decay_textbox;
        private TextBox potential_bioturbation_textbox;
        private TabPage carbon;
        private TextBox carbon_y_depth_decay_textbox;
        private TextBox carbon_humification_fraction_textbox;
        private TextBox carbon_depth_decay_textbox;
        private TextBox carbon_input_textbox;
        private CheckBox soil_carbon_cycle_checkbox;
        private TextBox carbon_o_twi_decay_textbox;
        private TextBox carbon_y_twi_decay_textbox;
        private TextBox carbon_o_depth_decay_textbox;
        private TextBox carbon_o_decomp_rate_textbox;
        private TextBox carbon_y_decomp_rate_textbox;

        private System.Windows.Forms.MainMenu mainMenu1;
        private System.Windows.Forms.MenuItem menuItemConfigFile;
        private System.Windows.Forms.MenuItem menuItemConfigFileOpen;
        private System.Windows.Forms.MenuItem menuItemConfigFileSave;
        private System.Windows.Forms.MenuItem menuItemConfigFileSaveAs;
        private System.Windows.Forms.StatusBar statusBar1;
        private System.Windows.Forms.StatusBarPanel TimeStatusPanel;
        private System.Windows.Forms.StatusBarPanel ScenarioStatusPanel;
        private System.Windows.Forms.StatusBarPanel InfoStatusPanel;
        private System.Windows.Forms.Button start_button;
        private System.Windows.Forms.Button End_button;
        private System.Windows.Forms.ToolTip toolTip1;
        private OpenFileDialog openFileDialog1;
        private Label label1;
        private Button button6;
        private TextBox textBox1;
        private TextBox textBox2;
        private Label label2;
        private TabPage Output;
        private GroupBox groupBox6;
        private GroupBox groupBox1;
        private CheckBox water_output_checkbox;
        private CheckBox depressions_output_checkbox;
        private CheckBox all_process_output_checkbox;
        private CheckBox Soildepth_output_checkbox;
        private CheckBox Alt_change_output_checkbox;
        private CheckBox Altitude_output_checkbox;
        private CheckedListBox checkedListBox1;
        private CheckBox Regular_output_checkbox;
        private CheckBox Final_output_checkbox;
        private TextBox Box_years_output;
        private TextBox textBox6;
        private CheckBox UTMsouthcheck;
        private TextBox UTMzonebox;
        private TabPage Run;
        private GroupBox groupBox7;
        private RadioButton runs_checkbox;
        private Label label16;
        private TextBox Number_runs_textbox;
        private TabPage Input;
        private TextBox tillfields_constant_textbox;
        private TextBox tillfields_input_filename_textbox;
        private TextBox evap_constant_value_box;
        private TextBox evap_input_filename_textbox;
        private TextBox infil_constant_value_box;
        private TextBox infil_input_filename_textbox;
        private TextBox rainfall_constant_value_box;
        private TextBox landuse_constant_value_box;
        private TextBox soildepth_constant_value_box;
        private TextBox landuse_input_filename_textbox;
        private TextBox soildepth_input_filename_textbox;
        private TextBox rain_input_filename_textbox;
        private TextBox dtm_input_filename_textbox;
        private GroupBox groupBox8;
        private CheckBox fill_sinks_before_checkbox;
        private CheckBox check_space_evap;
        private CheckBox check_space_infil;
        private CheckBox check_space_rain;
        private CheckBox check_space_till_fields;
        private CheckBox check_space_landuse;
        private CheckBox check_space_soildepth;
        private Label label17;
        private Label label15;
        private Label label14;
        private Label label7;
        private Label label5;
        private Label label4;
        private Label label3;
        private Label label25;
        private Label label23;
        private TabPage Processes;
        private CheckBox Creep_Checkbox;
        private TabControl tabControl1;
        private GroupBox groupBox12;
        private GroupBox groupBox11;
        private Label label8;
        private RadioButton annual_output_checkbox;
        private RadioButton cumulative_output_checkbox;
        private GroupBox groupBox13;
        private CheckBox fill_sinks_during_checkbox;
        private CheckBox check_space_DTM;
        private CheckBox check_time_evap;
        private CheckBox check_time_infil;
        private CheckBox check_time_rain;
        private CheckBox check_time_till_fields;
        private CheckBox check_time_landuse;
        private Label label29;
        private Button explain_input_button;
        private MenuItem Menu_About_box;
        private Label label37;
        private TextBox outputcode_textbox;
        private CheckBox diagnostic_output_checkbox;
        private GroupBox groupBox3;
        private Button landuse_determinator_button;
        #endregion

        #region global model parameters
        private Label label87;
        private TextBox selectivity_constant_textbox;
        private TextBox bio_protection_constant_textbox;
        private TextBox erosion_threshold_textbox;
        private TextBox rock_protection_constant_textbox;
        private Label label90;
        private Label label91;
        private Label label92;
        private Label label88;
        private Button soil_specify_button;
        private CheckBox Spitsbergen_case_study;
        private CheckBox CT_depth_decay_checkbox;
        private TextBox ct_depth_decay;
        private CheckBox calibration;
        private CheckBox creep_testing;
        private ComboBox rockweath_method;
        private CheckBox daily_water;
        private TabPage decalcification;
        private CheckBox decalcification_checkbox;
        private Label label94;
        private TextBox ini_CaCO3_content;
        private TabPage treefall;
        private CheckBox treefall_checkbox;
        private bool merely_calculating_derivatives;
        private Label label98;
        private TextBox temp_input_filename_textbox;
        private TextBox temp_constant_value_box;
        private Label label99;
        private CheckBox check_time_T;
        private TabPage tabPage2;
        private Label label105;
        private TextBox snowmelt_factor_textbox;
        private Label label104;
        private TextBox latitude_min;
        private Label label103;
        private TextBox latitude_deg;
        private Label label100;
        private Label label101;
        private Label label102;
        private TextBox dailyT_min;
        private TextBox dailyT_max;
        private TextBox dailyT_avg;
        private Label label97;
        private TextBox daily_n;
        private Label label96;
        private Label label93;
        private Label label89;
        private Label label40;
        private TextBox dailyET0;
        private TextBox dailyD;
        private TextBox dailyP;
        private Label label106;
        private TextBox snow_threshold_textbox;
        private TextBox ct_v0_Jagercikova;
        private TextBox ct_dd_Jagercikova;
        private System.Windows.Forms.Timer timer1;
        private Label label109;
        private Label label108;
        private CheckBox ct_Jagercikova;
        private CheckBox check_scaling_daily_weather;
        private TextBox tf_D;
        private Label label95;
        private Label label107;
        private TextBox tf_W;
        private TextBox tf_growth;
        private Label label110;
        private TextBox tf_age;
        private Label label111;
        private TextBox tf_freq;
        private Label label112;
        private GroupBox groupBox2;
        private Label label118;
        private Label label117;
        private Label label115;
        private Label label114;
        private RadioButton Sensitivity_button;
        private RadioButton Calibration_button;
        private Label label113;
        private TextBox calibration_ratios_textbox;
        private TextBox calibration_levels_textbox;
        private Label label116;
        private TextBox calibration_ratio_reduction_parameter_textbox;
        private Label label119;
        private Label label120;
        private CheckBox version_lux_checkbox;
        private Button button4;
        private TextBox textbox_t_intervene;
        private CheckBox checkbox_t_intervene;
        private Label label_max_soil_layers;
        private TextBox textbox_max_soil_layers;
        private CheckBox checkbox_layer_thickness;
        private TextBox textbox_layer_thickness;
        private TabControl tabControl3;
        private TabPage tabPage3;
        private TabPage tabPage4;
        private TextBox ngrains_textbox;
        private CheckBox OSL_checkbox;
        private TabPage tabPage5;
        private CheckBox CN_checkbox;
        private Label label121;
        private Label label122;
        private TextBox bleachingdepth_textbox;
        private Label label123;
        private TextBox isBe10_sp_input_textbox;
        private TextBox Be10_decay_textbox;
        private TextBox metBe10_input_textbox;
        private Label label124;
        private Label label126;
        private Label label125;
        int save_interval2 = 0;

        private System.ComponentModel.IContainer components;
        Stopwatch stopwatch;
        TimeSpan geo_t, pedo_t, hydro_t, ponding_t, OSL_matrix_t, OSL_JA_t;
        DateTime OSL_matrix_start, OSL_JA_start;
        double[,,,]    //4D matrix for soil texture masses in different x,y and z for t texture classes (x,y,z,t)
                    texture_kg;                 //mass in kg (per voxel = layer * thickness)

        double[,,,] CN_atoms_cm2;        // Keeps track of cosmogenic nuclide stocks. For now 0: meteoric Be, 1: in situ Be, ...
        int n_cosmo = 5;
        double met_10Be_input, met10Be_inherited, met_10Be_clayfraction, is10Be_inherited, isC14_inherited, decay_Be10, P0_10Be_is_sp, P0_10Be_is_mu, decay_C14, P0_14C_is_sp, P0_14C_is_mu, attenuation_length_sp, attenuation_length_mu, met_10Be_adsorptioncoefficient;

        double[,,]     //3D matrices for properties of soil layers in different x y (x,y,z)
                    layerthickness_m,         // : thickness in m 
                    young_SOM_kg,         // : OM mass in kgrams (per voxel = layer * thickness)
                    old_SOM_kg,         // : OM mass in kgrams (per voxel = layer * thickness) 
                    bulkdensity;            // : bulkdensity in kg/m3 (over the voxel = layer * thickness)

        double[,,] sediment_in_transport_kg,         // sediment mass in kg in transport per texture class
                    litter_kg;                     // Litter contents (Luxembourg case study)
        double[,,] CN_in_transport;                // Tracking cosmogenic nuclides

        double[,]   // double matrices - these are huge memory-eaters and should be minimized 
                    // they only get that memory later, and only when needed
                    original_dtm,       //where sealevel interactions are used
                    dtm,                //altitude matrix
                    dtmchange_m,  	    //change in altitude matrix
                    dtmfill_A,
                    dz_soil,
                    waterflow_m3,        //discharge matrix
                    K_fac,
                    P_fac,
                    infil,              //infiltration matrix
                    dz_ero_m,             //altitude change due to erosion  (negative values)
                    dz_sed_m,             //altitude change due to sedimentation   (positive values)
                    soildepth_m,
                    young_SOM_in_transport_kg,
                    old_SOM_in_transport_kg,
                    creep,
                    bedrock_weathering_m,
                    frost_weathering,
                    solif,
                    till_result,
                    dz_till_bd,
                    dz_treefall,        // elevation change by tree fall
                    aspect,             //aspect for calculation of hillshade
                    slopeAnalysis,      //for calculation of hillshade
                    Tau,                //for graphics
                    hillshade,          //for graphics
                    sum_water_erosion,
                    sum_biological_weathering,
                    sum_frost_weathering,
                    sum_creep_grid,
                    sum_solifluction,
                    sum_tillage,
                    sum_landsliding,
                    sum_uplift,
                    sum_tilting,
                    veg,
                    veg_correction_factor,
                    evapotranspiration,
                    stslope,		    // matrix with steepest descent local slope [rad]
                    crrain,             // matrix with critical steady state rainfall for landsliding [m/d]
                    camf,               // matrix with number of contributing draining cells, multiple flow [-]
                    T_fac,              // matrix with transmissivity [m/d] values
                    C_fac,              // matrix with combined cohesion [-] values
                    Cs_fac,             // matrix with soil cohesion [kPa] values
                    bulkd,              // matrix with bulk density values [g/cm3]
                    intfr,              // matrix with angle of internal friction values [rad]
                    reserv,
                    ero_slid,
                    cel_dist,
                    sed_slid,
                    sed_bud,
                    dh_slid,
                    lake_sed_m,         //the thickness of lake sediment
                    rain,
                    timeseries_matrix,
                    lessivage_errors, // for calibration of lessivage
                    tpi,            //topographic position index
                    hornbeam_cover_fraction, //hornbeam fraction Lux
                    observations;

        int[,]  // integer matrices
                    status_map,         //geeft aan of een cel een sink, een zadel, een flat of een top is
                    depression,         //geeft aan of een cel bij een meer hoort, en welk meer
                    slidemap,
                    soilmap,            // integer numbers for soil map
                    watsh,              // watershed;
                    landuse,            //landuse in classes
                    tillfields,         //fields for tillage 
                    treefall_count,     // count number of tree falls
                    vegetation_type;

        int[,,][] OSL_grainages, OSL_depositionages, OSL_surfacedcount;
        int[,][] OSL_grainages_in_transport, OSL_depositionages_in_transport, OSL_surfacedcount_in_transport;
        int ngrains_kgsand_m2, start_age;
        double bleaching_depth_m;

        int[,]
        drainingoutlet_row = new int[numberofsinks, 5],
        drainingoutlet_col = new int[numberofsinks, 5];

        int[] row_index, col_index;  // for sorting the DEM from high to low
        string[] rowcol_index;
        double[] index;

        //sinks and depression parameters:
        //the constant values below may have to be increased for large or strange landscapes and studies
        const int numberofsinks = 10000;           // run the program once to find out the number of sinks. The exact number and any higher number will do....
        const double tangent_of_delta = 0.005;
        const int maxlowestnbs = 100000;
        const double epsilon = 0.000001;
        const double root = 7.07;
        int max_soil_layers;

        double[] local_s_i_t_kg = new double[] { 0, 0, 0, 0, 0 };

        // for constant layer thicknesses
        double dz_standard; // Read from interface
        double tolerance = 0.55; // Standard value

        int n_texture_classes = 5;

        double soildepth_error;

        int[] rainfall_record, evap_record, infil_record, till_record, temp_record;
        int[] rainfall_record_d, evap_record_d, duration_record_d;
        int[] zonesize = new int[22], zoneprogress = new int[22];
        int[]
        iloedge = new int[numberofsinks],
        jloedge = new int[numberofsinks],
        iupedge = new int[numberofsinks],
        jupedge = new int[numberofsinks],
        depressionsize = new int[numberofsinks],
        depressionconsidered = new int[numberofsinks],
        rowlowestnb = new int[maxlowestnbs],
        collowestnb = new int[maxlowestnbs];
        double available_for_delta_kg = 0;
        double available_for_delta_m = 0;

        int t, t_intervene, scenario, number_of_data_cells, run_number;
        bool crashed,
            creep_active,
            water_ero_active,
            tillage_active,
            landslide_active,
            bedrock_weathering_active,
            frost_weathering_active,
            tilting_active,
            uplift_active,
            soil_phys_weath_active,
            soil_chem_weath_active,
            soil_bioturb_active,
            soil_clay_transloc_active,
            soil_carbon_active,
            input_data_error,
            memory_records,
            memory_records_d;

        int num_out,
                ntr,				//WVG 22-10-2010 number of rows (timesteps) in profile timeseries matrices			
                cross1, 			//WVG 22-10-2010 rows (or in the future columns) of which profiles are wanted
                cross2,
                cross3,
                test,
                numfile,
                nr,
                nc,
                row,
                col,
                i,
                j,
                matrixresult,
                er_ifile,
                flat,
                low,
                high,
                equal,
                alpha,
                beta,
                temp,
                num_str,
                numsinks,
                nb_ok,
                direct,
                round,
                s_ch,
                numtel,
                S1_error,
                S2_error,
                cell_lock,
                tel1,
                tel2,
                tel3,
                tel4,
                depressions_delta,
                depressions_alone,
                depressions_filled,  //counters for logging and reporting # of depressions filled/sedimented into/left alone
                rr,
                rrr,
                cc,
                ccc,
                ii,
                jj,
                twoequals,      // the -equals are counters for different types of sinks
                threeequals,
                moreequals,
                nb_check,
                depressionnumber = 0,
                maxdepressionnumber,
                depressionready,
                iloradius, iupradius,
                jloradius, jupradius,
                nbismemberofdepression,
                z,
                otherdepression,
                otherdepressionsize,
                totaldepressions,
                totaldepressionsize,
                maxsize,
                lowestneighbourcounter,
                numberoflowestneighbours,
                depressionreallyready,
                depressiondrainsout,
                largestdepression,
                rememberrow,
                remembercol,
                search,
                twice_dtm_fill,
                once_dtm_fill,
                three_dtm_fill,
                xrow, xcol, xxrow, xxcol,
                landuse_value,
                graphics_scale = 2,
                number_of_outputs = 0,
                wet_cells, eroded_cells, deposited_cells,
                P_scen,
                NumParallelThreads;

        //calibration globals
        int maxruns, best_run, calib_levels, user_specified_number_of_calibration_parameters, user_specified_number_of_ratios;
        double reduction_factor, best_error;
        //USER INPUT NEEDED: establish best versions of parameters varied in calibration:
        double[] best_parameters;
        double[,] calib_ratios;
        private TabPage tabPage6;
        private Label label129;
        private Label label128;
        private Label label127;
        private TextBox blockweath_textbox;
        private TextBox blocksize_textbox;
        private TextBox hardlayerweath_textbox;
        private Label label63;
        private Label label62;
        private TextBox hardlayerdensity_textbox;
        private TextBox hardlayerelevation_textbox;
        private TextBox hardlayerthickness_textbox;
        private Label label61;
        private CheckBox blocks_active_checkbox;
        private NumericUpDown uxNumberThreadsUpdown;
        private Label uxNumberCoresLabel;
        private Label uxNumberLogicalProcessorsLabel;
        private Label uxThreadLabel;
        private Button profiles_button;
        private Button timeseries_button;
        private CheckBox version_Konza_checkbox;
        private CheckBox version_CarboZALF_checkbox;
        private Label ux_number_Processors_label;
        private Label label33;
        private TextBox obsfile_textbox;
        private TextBox num_cal_paras_textbox;
        private Label label79_cn;
        private Label label78_cn;
        private TextBox C14_decay_textbox;
        private TextBox isC14_sp_input_textbox;
        private Label label33_cn;
        private Label label130;
        private Label label133_cn;
        private TextBox attenuationlength_sp_textbox;
        private Label label136_cn;
        private TextBox isC14_inherited_textbox;
        private TextBox isBe10_inherited_textbox;
        private Label label134;
        private TextBox metBe10_inherited_textbox;
        private Label label137;
        private TextBox OSL_inherited_textbox;
        private Label label_met10Be_dd;
        private TextBox met10Be_dd;
        private Label label138_CN;
        private TextBox met_10Be_clayfrac;
        private Label label131_cn;
        private TextBox attenuationlength_mu_textbox;
        private Label label1310_cn;
        private Label label132_cn;
        private TextBox isC14_mu_input_textbox;
        private TextBox isBe10_mu_input_textbox;
        private Label label780_cn;
        double[] original_ratios;

        // tectonics
        int lift_type, lift_location, tilt_location;
        int[] timeseries_order = new int[34];
        //long scan_lon, scan_cnt, NRO, NCO;


        double
                potential_creep_kg_m2_y,
                plough_depth,
                annual_weathering,
                dh, diff, dh1, dh_maxi,
                scan_do, dcount, powered_slope_sum,
                dmax, dmin,
                max_allowed_erosion,			// maximum erosion down to neighbour
                maximum_allowed_deposition, dhtemp,
                CSIZE,
                transport_capacity_kg,			// Capacity 
                detachment_rate,
                settlement_rate,
                frac_sed,   // fraction of landslide deposition into lower grids
                frac_bud,
                startsed,
                strsed,     // sediment delivered to streams
                T_act,         // Transmissivity
                bulkd_act,     // Bulk Density
                intfr_act,     // Internal Friction
                C_act,         // Combined Cohesion
                erotot,      // total landslide erosion
                sedtot,     // total landslide deposition;
                a_ifr, a_coh, a_bd, a_T,  // parameters parent material 1
                b_coh, b_ifr, b_bd, b_T,  // parameters parent material 2
                c_coh, c_ifr, c_bd, c_T,  // parameters parent material 3
                d_coh, d_ifr, d_bd, d_T,  // parameters parent material 4
                e_coh, e_ifr, e_bd, e_T,  // parameters parent material 5
                slopelim,       // slope limit for landslide erosion                          FACTOR 1
                celfrac,        // fraction used in calculation of celdistance (0.4 default)  FACTOR 2
                streamca,       // contributing area, number of cells, for stream development FACTOR 3
                rainfall_intensity,      // threshold critical rainfall value for landslide scenario   FACTOR 4
                slide_tot,
                dh_tot,
                tra_di,
                set_di,
                dx, dy,	  		// grid size in both row and col
                xcoord, ycoord,
                d_x, dh_tol,
                dt = 1,				// time step
                actual_t,      // Time counter for loop
                end_time,      // Total end time of loop
                out_t,
                total_altitude_m,
                total_average_altitude_m,
                total_rain_m, total_evap_m, total_infil_m, 
                total_rain_m3, total_evap_m3, total_infil_m3, total_outflow_m3;
        private CheckBox CarboZALF_calib_stabilizationages_checkbox;
        int output_time;

        private void obsfile_textbox_Click(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();
            openFileDialog1.InitialDirectory = workdir;
            //openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                obsfile_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void timeseries_button_Click_1(object sender, EventArgs e)
        {
            timeseries.Visible = true;
        }

        private void profiles_button_Click_1(object sender, EventArgs e)
        {
            profile.Visible = true;
        }

        private void checkBox1_CheckedChanged_3(object sender, EventArgs e)
        {
            textbox_layer_thickness.Enabled = (checkbox_layer_thickness.CheckState == CheckState.Checked);

        }

        private void button4_Click(object sender, EventArgs e)
        {
            Debug.Write(" merely_calculating_derivatives");
            merely_calculating_derivatives = true;
            try { calculate_terrain_derivatives(); MessageBox.Show("terrain derivatives calculation succeeded"); }
            catch { MessageBox.Show("terrain derivatives calculation failed"); }
        }

        private void radioButton1_CheckedChanged(object sender, EventArgs e)
        {
            if (Calibration_button.Checked == true) { Sensitivity_button.Checked = false; }
        }

        private void radioButton2_CheckedChanged(object sender, EventArgs e)
        {
            if (Sensitivity_button.Checked == true) { Calibration_button.Checked = false; }
        }

        private void dailyT_max_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_max.Text = openFileDialog1.FileName;
            }

        }

        private void dailyT_min_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_min.Text = openFileDialog1.FileName;
            }

        }

        private void dailyT_avg_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyT_avg.Text = openFileDialog1.FileName;
            }

        }

        private void daily_water_CheckedChanged(object sender, EventArgs e)
        {
            dailyP.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyET0.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyD.Enabled = (daily_water.CheckState == CheckState.Checked);
            daily_n.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_avg.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_min.Enabled = (daily_water.CheckState == CheckState.Checked);
            dailyT_max.Enabled = (daily_water.CheckState == CheckState.Checked);
            temp_constant_value_box.Enabled = (daily_water.CheckState == CheckState.Checked);
            temp_input_filename_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);
            check_time_T.Enabled = (daily_water.CheckState == CheckState.Checked);
            latitude_deg.Enabled = (daily_water.CheckState == CheckState.Checked);
            latitude_min.Enabled = (daily_water.CheckState == CheckState.Checked);
            snowmelt_factor_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);
            snow_threshold_textbox.Enabled = (daily_water.CheckState == CheckState.Checked);

        }

        //soil timeseries_variables
        double total_average_soilthickness_m,
            total_phys_weathered_mass_kg,
            total_chem_weathered_mass_kg,
            total_fine_neoformed_mass_kg,
            total_fine_eluviated_mass_kg,
            total_mass_bioturbed_kg,
            total_OM_input_kg,
        local_soil_depth_m,
        local_soil_mass_kg;
        int number_soil_thicker_than,
        number_soil_coarser_than;

        // Water erosion and deposition parameters
        double
        advection_erodibility,
        P_act,
        m, n,				        // capacity slope and discharge exponents
        erosion_threshold_kg,
        rock_protection_constant,
        bio_protection_constant,
        constant_selective_transcap,
        Slope,			            // Gradient
        conv_fac,		            // convergence/divergence factor
        dS, desired_change, dztot,	// Difference in sediment/deposition/erosion
        sedtr_loc,                  // Local sediment transport rate
        all_grids,
        fraction,	                // fraction slope by slopesum
        frac_dis,	                // fraction of discharge into lower grid
        sediment_transported,		// fraction of transport rate
        water_out,
        unfulfilled_change, dz_left1, actual_change, 	// unfulfilled sedimentation
        dz_min, mmin,
        dz_max, maxx,		        // maximum lowest neighbour, steepest descent
        dz_bal, dz_bal2,		    // dz balans counter
        sedbal, sedbal2,
        erobal, erobal2,
        erobalto, sedbalto,
        erocnt,
        sedcnt,
        sediment_exported_m,		        // sediment out of our system
        total_Bolsena_sed_influx,

        // Biological weathering parameters  see Minasny and McBratney 2006 Geoderma 133
        P0,                         // m t-1  // weathering rate constant
        k1,                         // t-1
        k2,                         // t-1
        Pa,                         // m t-1  // weathering rate when soildepth = 0

        // Tilting and Uplift parameters
        tilt_intensity, lift_intensity,

        // Tillage parameter
        tilc;

        // Tree fall parameters
        double W_m_max, D_m_max, W_m, D_m, tf_frequency;
        int growth_a_max, age_a_max;

        //Soil physical weathering parameters
        double physical_weathering_constant, weathered_mass_kg, Cone, Ctwo;
        double[] upper_particle_size = new double[5];

        //Soil chemical weathering parameters
        double chemical_weathering_constant, Cthree, Cfour, Cfive, Csix, neoform_constant;
        double[] specific_area = new double[5];

        //Clay translocation parameters
        double max_eluviation, Cclay, ct_depthdec;

        //Bioturbation parameters
        double potential_bioturbation_kg_m2_y;
        double bioturbation_depth_decay_constant;

        //Carbon cycle parameters
        double potential_OM_input,
               OM_input_depth_decay_constant,
               humification_fraction,
               potential_young_decomp_rate,
               potential_old_decomp_rate,
               young_depth_decay_constant,
               old_CTI_decay_constant,
               old_depth_decay_constant,
               young_CTI_decay_constant;

        // Decalcification parameters
        double[,,] CO3_kg;   // CaCO3, to track decalcification speed. Does not contribute to texture or soil mass (yet) MM
        double ini_CO3_content_frac;

        double noval,
        sediment_filled_m, depressionvolume_filled_m, sediment_delta_m,   // counters for logging and reporting the filling of depressions
        altidiff, minaltidiff,
        totaldepressionvolume,
        infil_value_m, evap_value_m, rain_value_m, soildepth_value,
        volume_eroded_m, volume_deposited_m,
        sum_normalweathered, sum_frostweathered, sum_soildepth, sum_creep, sum_solif, avg_solif, avg_creep, avg_soildepth,
        sum_ls, total_sum_tillage, total_sum_uplift, total_sum_tilting, total_sed_export;  // counters for logging and reporting through time

        int temp_value_C;

        double depressionsum_sediment_m, depressionsum_water_m, depressionsum_YOM_kg, depressionsum_OOM_kg;
        double[] depressionsum_texture_kg;
        double needed_to_fill_depression_m, dhoblique, dhobliquemax1, dhobliquemax2, firstalt, secondalt, dtmlowestnb;
        int dhmax_errors, readynum = 0, memberdepressionnotconsidered, depressionnum = 0, currentdepression;
        int lower_nb_exists, breaker = 0, rowlowestobnb, collowestobnb, II = 0, JJ = 0;
        int startrow, startcol, iloradius2, iupradius2, jupradius2, jloradius2, deltasize;
        int readysearching, iloradius3, iupradius3, jupradius3, jloradius3, couldbesink, omikron, omega;
        int tempx, tempy, obnbchanged;
        double sed_delta_size1 = 0, sed_delta_size2 = 0, sed_delta_size3 = 0;

        //  variables for displaying purposes // straight from Tom Coulthard
        double hue = 360.0;		// Ranges between 0 and 360 degrees
        double sat = 0.90;		// Ranges between 0 and 1.0 (where 1 is 100%)
        double val = 1.0;		// Ranges between 0 and 1.0 (where 1 is 100%)
        double red = 0.0;
        double green = 0.0;
        double blue = 0.0;

        string basetext = "LORICA Landscape Evolution Model";
        string cfgname = null;  //Config file name
        string workdir;
        string timeseries_string = null;

        double[] depressionlevel = new double[numberofsinks],
                    depressionvolume_m = new double[numberofsinks];
        //double SuperMEF = 0, SuperMEF2 = 0;
        double s_tempfactor, s_D, V_factor;
        double c_D;
        double w_P0, w_k1, w_k2, w_Pa;
        double f_soilrate, f_Tmax, f_Tmin, f_max;

        double mem_m;  //the height by which all cells of a current delta need to be raised in order to get rid of the remaining amount of sediment for that delta

        string str, filename, logname, recordname, outfile, f_name, ch, chs;

        string[] inputheader = new string[6];
        double[,] climate_data;

        int diagnostic_mode = 0;
        int number_of_outflow_cells;
        double[] domain_sed_export_kg = new double[5];
        double domain_OOM_export_kg;
        double domain_YOM_export_kg;

        //HARDLAYER AND BLOCK GLOBALS
        int blocks_active = 0;
        int nhardlayers = 1;
        int hardlayerthickness_m = 1;
        int hardlayerelevation_m = 151;
        int hardlayerdensity_kg_m3 = 2500;
        double hardlayer_weath_contrast = 0.2;
        float blockweatheringratio = 0.999f;
        float blocksizethreshold_m = 0.1f;

        //tracking parameters
        double topoconttoroll = 0, creepconttoroll = 0;
        double blocksrolled = 0, blocksproduced = 0;

        //needs to be initialized:
        float[,] hardlayeropenness_fraction;

        public class Block
        {
            public float Y_row { get; set; }
            public float X_col { get; set; }
            public float Size_m { get; set; }
            public double Accumulated_creep_m_0 { get; set; }
            public double Accumulated_creep_m_1 { get; set; }
            public double Accumulated_creep_m_2 { get; set; }
            public double Accumulated_creep_m_3 { get; set; }
            public double Accumulated_creep_m_4 { get; set; }
            public double Accumulated_creep_m_5 { get; set; }
            public double Accumulated_creep_m_6 { get; set; }
            public double Accumulated_creep_m_7 { get; set; }
            //defined with 0 = north, 1 = northeast etc

            public Block(float y_row, float x_col, float size_m,
                double accumulated_creep_m_0,
                double accumulated_creep_m_1,
                double accumulated_creep_m_2,
                double accumulated_creep_m_3,
                double accumulated_creep_m_4,
                double accumulated_creep_m_5,
                double accumulated_creep_m_6,
                double accumulated_creep_m_7)
            {
                Y_row = y_row; X_col = x_col; Size_m = size_m;
                Accumulated_creep_m_0 = accumulated_creep_m_0;
                Accumulated_creep_m_1 = accumulated_creep_m_1;
                Accumulated_creep_m_2 = accumulated_creep_m_2;
                Accumulated_creep_m_3 = accumulated_creep_m_3;
                Accumulated_creep_m_4 = accumulated_creep_m_4;
                Accumulated_creep_m_5 = accumulated_creep_m_5;
                Accumulated_creep_m_6 = accumulated_creep_m_6;
                Accumulated_creep_m_7 = accumulated_creep_m_7;
            }
        }

        List<Block> Blocklist = new List<Block>();

        public class Lakecell
        {
            public Int32 trow { get; set; }
            public Int32 tcol { get; set; }
            public double t_sed_needed_m { get; set; }
            public double t_new_elev_m { get; set; }
            public Lakecell(Int32 row, Int32 col, double sed_needed, double new_elev)
            {
                trow = row; tcol = col; t_sed_needed_m = sed_needed; t_new_elev_m = new_elev;
            }

        }
        List<Lakecell> L_lakecells = new List<Lakecell>();

        #endregion

        public Mother_form()
        {
            //
            // Required for Windows Form Designer support
            //
            InitializeComponent();

            //
            // TODO: Add any constructor code after InitializeComponent call
            //
            getProcessorCoreCount();
        }
        private void getProcessorCoreCount()
        {
            int coreCount = 0;
            foreach (var item in new System.Management.ManagementObjectSearcher("Select * from Win32_Processor").Get())
            {
                coreCount += int.Parse(item["NumberOfCores"].ToString());
            }
            Debug.WriteLine("Number Of Cores: {0}", coreCount);
            Debug.WriteLine("The number of processors on this computer is {0}.", Environment.ProcessorCount);
            this.uxNumberCoresLabel.Text += coreCount.ToString();
            this.ux_number_Processors_label.Text += Environment.ProcessorCount;
            this.uxNumberThreadsUpdown.Value = coreCount;
        }
        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                if (components != null)
                {
                    components.Dispose();
                }
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code
        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.Windows.Forms.Label label6;
            System.Windows.Forms.TabPage Landsliding;
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(Mother_form));
            System.Windows.Forms.Label label41;
            System.Windows.Forms.Label label42;
            System.Windows.Forms.Label label43;
            System.Windows.Forms.Label label44;
            System.Windows.Forms.Label label45;
            System.Windows.Forms.Label label46;
            System.Windows.Forms.Label label47;
            System.Windows.Forms.Label label48;
            System.Windows.Forms.Label label49;
            System.Windows.Forms.Label label50;
            System.Windows.Forms.Label label51;
            System.Windows.Forms.Label label52;
            System.Windows.Forms.Label label53;
            System.Windows.Forms.Label label54;
            System.Windows.Forms.Label label55;
            System.Windows.Forms.Label label56;
            System.Windows.Forms.Label label57;
            System.Windows.Forms.Label label58;
            System.Windows.Forms.Label label59;
            System.Windows.Forms.Label label64;
            System.Windows.Forms.Label label65;
            System.Windows.Forms.Label label66;
            System.Windows.Forms.Label label67;
            System.Windows.Forms.Label label60;
            System.Windows.Forms.Label label69;
            System.Windows.Forms.Label label70;
            System.Windows.Forms.Label eluviation_rate_constant;
            System.Windows.Forms.Label label72;
            System.Windows.Forms.Label label68;
            System.Windows.Forms.Label label71;
            System.Windows.Forms.Label label73;
            System.Windows.Forms.Label label74;
            System.Windows.Forms.Label label75;
            System.Windows.Forms.Label label76;
            System.Windows.Forms.Label label77;
            System.Windows.Forms.Label label81;
            System.Windows.Forms.Label label80;
            System.Windows.Forms.Label label82;
            System.Windows.Forms.Label label83;
            System.Windows.Forms.Label label84;
            System.Windows.Forms.Label label85;
            System.Windows.Forms.Label label86;
            System.Windows.Forms.Label label13;
            this.label36 = new System.Windows.Forms.Label();
            this.radio_ls_fraction = new System.Windows.Forms.RadioButton();
            this.radio_ls_absolute = new System.Windows.Forms.RadioButton();
            this.label35 = new System.Windows.Forms.Label();
            this.label34 = new System.Windows.Forms.Label();
            this.text_ls_rel_rain_intens = new System.Windows.Forms.TextBox();
            this.textBox_ls_trans = new System.Windows.Forms.TextBox();
            this.textBox_ls_bd = new System.Windows.Forms.TextBox();
            this.textBox_ls_ifr = new System.Windows.Forms.TextBox();
            this.textBox_ls_coh = new System.Windows.Forms.TextBox();
            this.text_ls_abs_rain_intens = new System.Windows.Forms.TextBox();
            this.label32 = new System.Windows.Forms.Label();
            this.label31 = new System.Windows.Forms.Label();
            this.label30 = new System.Windows.Forms.Label();
            this.label22 = new System.Windows.Forms.Label();
            this.label18 = new System.Windows.Forms.Label();
            this.pictureBox4 = new System.Windows.Forms.PictureBox();
            this.Landslide_checkbox = new System.Windows.Forms.CheckBox();
            this.mainMenu1 = new System.Windows.Forms.MainMenu(this.components);
            this.menuItemConfigFile = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileOpen = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileSaveAs = new System.Windows.Forms.MenuItem();
            this.menuItemConfigFileSave = new System.Windows.Forms.MenuItem();
            this.Menu_About_box = new System.Windows.Forms.MenuItem();
            this.statusBar1 = new System.Windows.Forms.StatusBar();
            this.InfoStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.TimeStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.ScenarioStatusPanel = new System.Windows.Forms.StatusBarPanel();
            this.start_button = new System.Windows.Forms.Button();
            this.End_button = new System.Windows.Forms.Button();
            this.toolTip1 = new System.Windows.Forms.ToolTip(this.components);
            this.label2 = new System.Windows.Forms.Label();
            this.label25 = new System.Windows.Forms.Label();
            this.label14 = new System.Windows.Forms.Label();
            this.label15 = new System.Windows.Forms.Label();
            this.label17 = new System.Windows.Forms.Label();
            this.fill_sinks_before_checkbox = new System.Windows.Forms.CheckBox();
            this.label8 = new System.Windows.Forms.Label();
            this.fill_sinks_during_checkbox = new System.Windows.Forms.CheckBox();
            this.groupBox13 = new System.Windows.Forms.GroupBox();
            this.label7 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label29 = new System.Windows.Forms.Label();
            this.groupBox3 = new System.Windows.Forms.GroupBox();
            this.landuse_determinator_button = new System.Windows.Forms.Button();
            this.groupBox9 = new System.Windows.Forms.GroupBox();
            this.parameter_k1_textbox = new System.Windows.Forms.TextBox();
            this.label24 = new System.Windows.Forms.Label();
            this.label26 = new System.Windows.Forms.Label();
            this.label27 = new System.Windows.Forms.Label();
            this.label28 = new System.Windows.Forms.Label();
            this.parameter_k2_textbox = new System.Windows.Forms.TextBox();
            this.parameter_Pa_textbox = new System.Windows.Forms.TextBox();
            this.parameter_P0_textbox = new System.Windows.Forms.TextBox();
            this.label21 = new System.Windows.Forms.Label();
            this.Biological_weathering_checkbox = new System.Windows.Forms.CheckBox();
            this.label98 = new System.Windows.Forms.Label();
            this.label99 = new System.Windows.Forms.Label();
            this.checkbox_t_intervene = new System.Windows.Forms.CheckBox();
            this.UTMzonebox = new System.Windows.Forms.TextBox();
            this.openFileDialog1 = new System.Windows.Forms.OpenFileDialog();
            this.label1 = new System.Windows.Forms.Label();
            this.button6 = new System.Windows.Forms.Button();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.textBox2 = new System.Windows.Forms.TextBox();
            this.Output = new System.Windows.Forms.TabPage();
            this.profiles_button = new System.Windows.Forms.Button();
            this.timeseries_button = new System.Windows.Forms.Button();
            this.groupBox6 = new System.Windows.Forms.GroupBox();
            this.groupBox12 = new System.Windows.Forms.GroupBox();
            this.annual_output_checkbox = new System.Windows.Forms.RadioButton();
            this.cumulative_output_checkbox = new System.Windows.Forms.RadioButton();
            this.groupBox11 = new System.Windows.Forms.GroupBox();
            this.Regular_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Final_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Box_years_output = new System.Windows.Forms.TextBox();
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.diagnostic_output_checkbox = new System.Windows.Forms.CheckBox();
            this.label37 = new System.Windows.Forms.Label();
            this.outputcode_textbox = new System.Windows.Forms.TextBox();
            this.water_output_checkbox = new System.Windows.Forms.CheckBox();
            this.depressions_output_checkbox = new System.Windows.Forms.CheckBox();
            this.all_process_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Soildepth_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Alt_change_output_checkbox = new System.Windows.Forms.CheckBox();
            this.Altitude_output_checkbox = new System.Windows.Forms.CheckBox();
            this.checkedListBox1 = new System.Windows.Forms.CheckedListBox();
            this.textBox6 = new System.Windows.Forms.TextBox();
            this.UTMsouthcheck = new System.Windows.Forms.CheckBox();
            this.Run = new System.Windows.Forms.TabPage();
            this.CarboZALF_calib_stabilizationages_checkbox = new System.Windows.Forms.CheckBox();
            this.version_CarboZALF_checkbox = new System.Windows.Forms.CheckBox();
            this.ux_number_Processors_label = new System.Windows.Forms.Label();
            this.version_Konza_checkbox = new System.Windows.Forms.CheckBox();
            this.uxThreadLabel = new System.Windows.Forms.Label();
            this.uxNumberCoresLabel = new System.Windows.Forms.Label();
            this.uxNumberLogicalProcessorsLabel = new System.Windows.Forms.Label();
            this.uxNumberThreadsUpdown = new System.Windows.Forms.NumericUpDown();
            this.button4 = new System.Windows.Forms.Button();
            this.version_lux_checkbox = new System.Windows.Forms.CheckBox();
            this.groupBox2 = new System.Windows.Forms.GroupBox();
            this.num_cal_paras_textbox = new System.Windows.Forms.TextBox();
            this.label33 = new System.Windows.Forms.Label();
            this.obsfile_textbox = new System.Windows.Forms.TextBox();
            this.label120 = new System.Windows.Forms.Label();
            this.calibration_ratio_reduction_parameter_textbox = new System.Windows.Forms.TextBox();
            this.label119 = new System.Windows.Forms.Label();
            this.calibration_levels_textbox = new System.Windows.Forms.TextBox();
            this.label116 = new System.Windows.Forms.Label();
            this.label118 = new System.Windows.Forms.Label();
            this.label117 = new System.Windows.Forms.Label();
            this.label115 = new System.Windows.Forms.Label();
            this.label114 = new System.Windows.Forms.Label();
            this.Sensitivity_button = new System.Windows.Forms.RadioButton();
            this.Calibration_button = new System.Windows.Forms.RadioButton();
            this.label113 = new System.Windows.Forms.Label();
            this.calibration_ratios_textbox = new System.Windows.Forms.TextBox();
            this.calibration = new System.Windows.Forms.CheckBox();
            this.Spitsbergen_case_study = new System.Windows.Forms.CheckBox();
            this.groupBox7 = new System.Windows.Forms.GroupBox();
            this.textbox_t_intervene = new System.Windows.Forms.TextBox();
            this.runs_checkbox = new System.Windows.Forms.RadioButton();
            this.label16 = new System.Windows.Forms.Label();
            this.Number_runs_textbox = new System.Windows.Forms.TextBox();
            this.Input = new System.Windows.Forms.TabPage();
            this.textbox_layer_thickness = new System.Windows.Forms.TextBox();
            this.checkbox_layer_thickness = new System.Windows.Forms.CheckBox();
            this.label_max_soil_layers = new System.Windows.Forms.Label();
            this.textbox_max_soil_layers = new System.Windows.Forms.TextBox();
            this.check_time_T = new System.Windows.Forms.CheckBox();
            this.temp_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.temp_constant_value_box = new System.Windows.Forms.TextBox();
            this.soil_specify_button = new System.Windows.Forms.Button();
            this.label88 = new System.Windows.Forms.Label();
            this.explain_input_button = new System.Windows.Forms.Button();
            this.check_time_evap = new System.Windows.Forms.CheckBox();
            this.check_time_infil = new System.Windows.Forms.CheckBox();
            this.check_time_rain = new System.Windows.Forms.CheckBox();
            this.check_time_till_fields = new System.Windows.Forms.CheckBox();
            this.check_time_landuse = new System.Windows.Forms.CheckBox();
            this.check_space_DTM = new System.Windows.Forms.CheckBox();
            this.tillfields_constant_textbox = new System.Windows.Forms.TextBox();
            this.tillfields_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.evap_constant_value_box = new System.Windows.Forms.TextBox();
            this.evap_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.infil_constant_value_box = new System.Windows.Forms.TextBox();
            this.infil_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.rainfall_constant_value_box = new System.Windows.Forms.TextBox();
            this.landuse_constant_value_box = new System.Windows.Forms.TextBox();
            this.soildepth_constant_value_box = new System.Windows.Forms.TextBox();
            this.landuse_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.soildepth_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.rain_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.dtm_input_filename_textbox = new System.Windows.Forms.TextBox();
            this.groupBox8 = new System.Windows.Forms.GroupBox();
            this.check_space_evap = new System.Windows.Forms.CheckBox();
            this.check_space_infil = new System.Windows.Forms.CheckBox();
            this.check_space_rain = new System.Windows.Forms.CheckBox();
            this.check_space_till_fields = new System.Windows.Forms.CheckBox();
            this.check_space_landuse = new System.Windows.Forms.CheckBox();
            this.check_space_soildepth = new System.Windows.Forms.CheckBox();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label23 = new System.Windows.Forms.Label();
            this.Processes = new System.Windows.Forms.TabPage();
            this.Process_tabs = new System.Windows.Forms.TabControl();
            this.Water = new System.Windows.Forms.TabPage();
            this.daily_water = new System.Windows.Forms.CheckBox();
            this.label87 = new System.Windows.Forms.Label();
            this.selectivity_constant_textbox = new System.Windows.Forms.TextBox();
            this.bio_protection_constant_textbox = new System.Windows.Forms.TextBox();
            this.erosion_threshold_textbox = new System.Windows.Forms.TextBox();
            this.rock_protection_constant_textbox = new System.Windows.Forms.TextBox();
            this.label90 = new System.Windows.Forms.Label();
            this.label91 = new System.Windows.Forms.Label();
            this.label92 = new System.Windows.Forms.Label();
            this.parameter_n_textbox = new System.Windows.Forms.TextBox();
            this.parameter_conv_textbox = new System.Windows.Forms.TextBox();
            this.parameter_K_textbox = new System.Windows.Forms.TextBox();
            this.parameter_m_textbox = new System.Windows.Forms.TextBox();
            this.only_waterflow_checkbox = new System.Windows.Forms.CheckBox();
            this.pictureBox1 = new System.Windows.Forms.PictureBox();
            this.label12 = new System.Windows.Forms.Label();
            this.label11 = new System.Windows.Forms.Label();
            this.label10 = new System.Windows.Forms.Label();
            this.label9 = new System.Windows.Forms.Label();
            this.Water_ero_checkbox = new System.Windows.Forms.CheckBox();
            this.Tillage = new System.Windows.Forms.TabPage();
            this.pictureBox2 = new System.Windows.Forms.PictureBox();
            this.label20 = new System.Windows.Forms.Label();
            this.trte = new System.Windows.Forms.Label();
            this.parameter_tillage_constant_textbox = new System.Windows.Forms.TextBox();
            this.parameter_ploughing_depth_textbox = new System.Windows.Forms.TextBox();
            this.Tillage_checkbox = new System.Windows.Forms.CheckBox();
            this.Creeper = new System.Windows.Forms.TabPage();
            this.creep_testing = new System.Windows.Forms.CheckBox();
            this.pictureBox3 = new System.Windows.Forms.PictureBox();
            this.label19 = new System.Windows.Forms.Label();
            this.parameter_diffusivity_textbox = new System.Windows.Forms.TextBox();
            this.creep_active_checkbox = new System.Windows.Forms.CheckBox();
            this.Solifluction = new System.Windows.Forms.TabPage();
            this.pictureBox5 = new System.Windows.Forms.PictureBox();
            this.Solifluction_checkbox = new System.Windows.Forms.CheckBox();
            this.Rock_weathering = new System.Windows.Forms.TabPage();
            this.rockweath_method = new System.Windows.Forms.ComboBox();
            this.pictureBox6 = new System.Windows.Forms.PictureBox();
            this.groupBox10 = new System.Windows.Forms.GroupBox();
            this.Frost_weathering_checkbox = new System.Windows.Forms.CheckBox();
            this.Tectonics = new System.Windows.Forms.TabPage();
            this.groupBox14 = new System.Windows.Forms.GroupBox();
            this.groupBox16 = new System.Windows.Forms.GroupBox();
            this.text_lift_col_less = new System.Windows.Forms.TextBox();
            this.text_lift_col_more = new System.Windows.Forms.TextBox();
            this.text_lift_row_less = new System.Windows.Forms.TextBox();
            this.text_lift_row_more = new System.Windows.Forms.TextBox();
            this.radio_lift_col_less_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_row_more_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_col_more_than = new System.Windows.Forms.RadioButton();
            this.radio_lift_row_less_than = new System.Windows.Forms.RadioButton();
            this.Uplift_rate_textbox = new System.Windows.Forms.TextBox();
            this.uplift_active_checkbox = new System.Windows.Forms.CheckBox();
            this.label39 = new System.Windows.Forms.Label();
            this.groupBox4 = new System.Windows.Forms.GroupBox();
            this.label38 = new System.Windows.Forms.Label();
            this.Tilting_rate_textbox = new System.Windows.Forms.TextBox();
            this.groupBox15 = new System.Windows.Forms.GroupBox();
            this.radio_tilt_col_max = new System.Windows.Forms.RadioButton();
            this.radio_tilt_row_zero = new System.Windows.Forms.RadioButton();
            this.radio_tilt_col_zero = new System.Windows.Forms.RadioButton();
            this.radio_tilt_row_max = new System.Windows.Forms.RadioButton();
            this.tilting_active_checkbox = new System.Windows.Forms.CheckBox();
            this.treefall = new System.Windows.Forms.TabPage();
            this.tf_freq = new System.Windows.Forms.TextBox();
            this.label112 = new System.Windows.Forms.Label();
            this.tf_age = new System.Windows.Forms.TextBox();
            this.label111 = new System.Windows.Forms.Label();
            this.tf_growth = new System.Windows.Forms.TextBox();
            this.label110 = new System.Windows.Forms.Label();
            this.tf_D = new System.Windows.Forms.TextBox();
            this.label95 = new System.Windows.Forms.Label();
            this.label107 = new System.Windows.Forms.Label();
            this.tf_W = new System.Windows.Forms.TextBox();
            this.treefall_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage6 = new System.Windows.Forms.TabPage();
            this.label129 = new System.Windows.Forms.Label();
            this.label128 = new System.Windows.Forms.Label();
            this.label127 = new System.Windows.Forms.Label();
            this.blockweath_textbox = new System.Windows.Forms.TextBox();
            this.blocksize_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerweath_textbox = new System.Windows.Forms.TextBox();
            this.label63 = new System.Windows.Forms.Label();
            this.label62 = new System.Windows.Forms.Label();
            this.hardlayerdensity_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerelevation_textbox = new System.Windows.Forms.TextBox();
            this.hardlayerthickness_textbox = new System.Windows.Forms.TextBox();
            this.label61 = new System.Windows.Forms.Label();
            this.blocks_active_checkbox = new System.Windows.Forms.CheckBox();
            this.Creep_Checkbox = new System.Windows.Forms.CheckBox();
            this.tabControl1 = new System.Windows.Forms.TabControl();
            this.tabPage1 = new System.Windows.Forms.TabPage();
            this.tabControl2 = new System.Windows.Forms.TabControl();
            this.physical = new System.Windows.Forms.TabPage();
            this.upper_particle_fine_clay_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_clay_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_silt_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_sand_textbox = new System.Windows.Forms.TextBox();
            this.upper_particle_coarse_textbox = new System.Windows.Forms.TextBox();
            this.physical_weath_constant2 = new System.Windows.Forms.TextBox();
            this.physical_weath_constant1 = new System.Windows.Forms.TextBox();
            this.Physical_weath_C1_textbox = new System.Windows.Forms.TextBox();
            this.soil_phys_weath_checkbox = new System.Windows.Forms.CheckBox();
            this.chemical = new System.Windows.Forms.TabPage();
            this.specific_area_fine_clay_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_clay_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_silt_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_sand_textbox = new System.Windows.Forms.TextBox();
            this.specific_area_coarse_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_specific_coefficient_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_depth_constant_textbox = new System.Windows.Forms.TextBox();
            this.chem_weath_rate_constant_textbox = new System.Windows.Forms.TextBox();
            this.soil_chem_weath_checkbox = new System.Windows.Forms.CheckBox();
            this.clay = new System.Windows.Forms.TabPage();
            this.ct_Jagercikova = new System.Windows.Forms.CheckBox();
            this.label109 = new System.Windows.Forms.Label();
            this.label108 = new System.Windows.Forms.Label();
            this.ct_dd_Jagercikova = new System.Windows.Forms.TextBox();
            this.ct_v0_Jagercikova = new System.Windows.Forms.TextBox();
            this.ct_depth_decay = new System.Windows.Forms.TextBox();
            this.CT_depth_decay_checkbox = new System.Windows.Forms.CheckBox();
            this.eluviation_coefficient_textbox = new System.Windows.Forms.TextBox();
            this.maximum_eluviation_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_C2_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_C1_textbox = new System.Windows.Forms.TextBox();
            this.clay_neoform_constant_textbox = new System.Windows.Forms.TextBox();
            this.soil_clay_transloc_checkbox = new System.Windows.Forms.CheckBox();
            this.bioturbation = new System.Windows.Forms.TabPage();
            this.bioturbation_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.potential_bioturbation_textbox = new System.Windows.Forms.TextBox();
            this.soil_bioturb_checkbox = new System.Windows.Forms.CheckBox();
            this.carbon = new System.Windows.Forms.TabPage();
            this.carbon_o_decomp_rate_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_decomp_rate_textbox = new System.Windows.Forms.TextBox();
            this.carbon_o_twi_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_twi_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_o_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_y_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_humification_fraction_textbox = new System.Windows.Forms.TextBox();
            this.carbon_depth_decay_textbox = new System.Windows.Forms.TextBox();
            this.carbon_input_textbox = new System.Windows.Forms.TextBox();
            this.soil_carbon_cycle_checkbox = new System.Windows.Forms.CheckBox();
            this.decalcification = new System.Windows.Forms.TabPage();
            this.label94 = new System.Windows.Forms.Label();
            this.ini_CaCO3_content = new System.Windows.Forms.TextBox();
            this.decalcification_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage3 = new System.Windows.Forms.TabPage();
            this.tabControl3 = new System.Windows.Forms.TabControl();
            this.tabPage4 = new System.Windows.Forms.TabPage();
            this.label137 = new System.Windows.Forms.Label();
            this.OSL_inherited_textbox = new System.Windows.Forms.TextBox();
            this.label122 = new System.Windows.Forms.Label();
            this.bleachingdepth_textbox = new System.Windows.Forms.TextBox();
            this.label121 = new System.Windows.Forms.Label();
            this.ngrains_textbox = new System.Windows.Forms.TextBox();
            this.OSL_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage5 = new System.Windows.Forms.TabPage();
            this.label780_cn = new System.Windows.Forms.Label();
            this.label1310_cn = new System.Windows.Forms.Label();
            this.label132_cn = new System.Windows.Forms.Label();
            this.isC14_mu_input_textbox = new System.Windows.Forms.TextBox();
            this.isBe10_mu_input_textbox = new System.Windows.Forms.TextBox();
            this.label131_cn = new System.Windows.Forms.Label();
            this.attenuationlength_mu_textbox = new System.Windows.Forms.TextBox();
            this.label138_CN = new System.Windows.Forms.Label();
            this.met_10Be_clayfrac = new System.Windows.Forms.TextBox();
            this.label_met10Be_dd = new System.Windows.Forms.Label();
            this.met10Be_dd = new System.Windows.Forms.TextBox();
            this.label136_cn = new System.Windows.Forms.Label();
            this.isC14_inherited_textbox = new System.Windows.Forms.TextBox();
            this.isBe10_inherited_textbox = new System.Windows.Forms.TextBox();
            this.label134 = new System.Windows.Forms.Label();
            this.metBe10_inherited_textbox = new System.Windows.Forms.TextBox();
            this.label133_cn = new System.Windows.Forms.Label();
            this.attenuationlength_sp_textbox = new System.Windows.Forms.TextBox();
            this.label130 = new System.Windows.Forms.Label();
            this.label79_cn = new System.Windows.Forms.Label();
            this.label78_cn = new System.Windows.Forms.Label();
            this.C14_decay_textbox = new System.Windows.Forms.TextBox();
            this.isC14_sp_input_textbox = new System.Windows.Forms.TextBox();
            this.label33_cn = new System.Windows.Forms.Label();
            this.label126 = new System.Windows.Forms.Label();
            this.label125 = new System.Windows.Forms.Label();
            this.isBe10_sp_input_textbox = new System.Windows.Forms.TextBox();
            this.Be10_decay_textbox = new System.Windows.Forms.TextBox();
            this.metBe10_input_textbox = new System.Windows.Forms.TextBox();
            this.label124 = new System.Windows.Forms.Label();
            this.label123 = new System.Windows.Forms.Label();
            this.CN_checkbox = new System.Windows.Forms.CheckBox();
            this.tabPage2 = new System.Windows.Forms.TabPage();
            this.check_scaling_daily_weather = new System.Windows.Forms.CheckBox();
            this.label106 = new System.Windows.Forms.Label();
            this.snow_threshold_textbox = new System.Windows.Forms.TextBox();
            this.label105 = new System.Windows.Forms.Label();
            this.snowmelt_factor_textbox = new System.Windows.Forms.TextBox();
            this.label104 = new System.Windows.Forms.Label();
            this.latitude_min = new System.Windows.Forms.TextBox();
            this.label103 = new System.Windows.Forms.Label();
            this.latitude_deg = new System.Windows.Forms.TextBox();
            this.label100 = new System.Windows.Forms.Label();
            this.label101 = new System.Windows.Forms.Label();
            this.label102 = new System.Windows.Forms.Label();
            this.dailyT_min = new System.Windows.Forms.TextBox();
            this.dailyT_max = new System.Windows.Forms.TextBox();
            this.dailyT_avg = new System.Windows.Forms.TextBox();
            this.label97 = new System.Windows.Forms.Label();
            this.daily_n = new System.Windows.Forms.TextBox();
            this.label96 = new System.Windows.Forms.Label();
            this.label93 = new System.Windows.Forms.Label();
            this.label89 = new System.Windows.Forms.Label();
            this.label40 = new System.Windows.Forms.Label();
            this.dailyET0 = new System.Windows.Forms.TextBox();
            this.dailyD = new System.Windows.Forms.TextBox();
            this.dailyP = new System.Windows.Forms.TextBox();
            this.timer1 = new System.Windows.Forms.Timer(this.components);
            label6 = new System.Windows.Forms.Label();
            Landsliding = new System.Windows.Forms.TabPage();
            label41 = new System.Windows.Forms.Label();
            label42 = new System.Windows.Forms.Label();
            label43 = new System.Windows.Forms.Label();
            label44 = new System.Windows.Forms.Label();
            label45 = new System.Windows.Forms.Label();
            label46 = new System.Windows.Forms.Label();
            label47 = new System.Windows.Forms.Label();
            label48 = new System.Windows.Forms.Label();
            label49 = new System.Windows.Forms.Label();
            label50 = new System.Windows.Forms.Label();
            label51 = new System.Windows.Forms.Label();
            label52 = new System.Windows.Forms.Label();
            label53 = new System.Windows.Forms.Label();
            label54 = new System.Windows.Forms.Label();
            label55 = new System.Windows.Forms.Label();
            label56 = new System.Windows.Forms.Label();
            label57 = new System.Windows.Forms.Label();
            label58 = new System.Windows.Forms.Label();
            label59 = new System.Windows.Forms.Label();
            label64 = new System.Windows.Forms.Label();
            label65 = new System.Windows.Forms.Label();
            label66 = new System.Windows.Forms.Label();
            label67 = new System.Windows.Forms.Label();
            label60 = new System.Windows.Forms.Label();
            label69 = new System.Windows.Forms.Label();
            label70 = new System.Windows.Forms.Label();
            eluviation_rate_constant = new System.Windows.Forms.Label();
            label72 = new System.Windows.Forms.Label();
            label68 = new System.Windows.Forms.Label();
            label71 = new System.Windows.Forms.Label();
            label73 = new System.Windows.Forms.Label();
            label74 = new System.Windows.Forms.Label();
            label75 = new System.Windows.Forms.Label();
            label76 = new System.Windows.Forms.Label();
            label77 = new System.Windows.Forms.Label();
            label81 = new System.Windows.Forms.Label();
            label80 = new System.Windows.Forms.Label();
            label82 = new System.Windows.Forms.Label();
            label83 = new System.Windows.Forms.Label();
            label84 = new System.Windows.Forms.Label();
            label85 = new System.Windows.Forms.Label();
            label86 = new System.Windows.Forms.Label();
            label13 = new System.Windows.Forms.Label();
            Landsliding.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.InfoStatusPanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.TimeStatusPanel)).BeginInit();
            ((System.ComponentModel.ISupportInitialize)(this.ScenarioStatusPanel)).BeginInit();
            this.groupBox13.SuspendLayout();
            this.groupBox3.SuspendLayout();
            this.groupBox9.SuspendLayout();
            this.Output.SuspendLayout();
            this.groupBox6.SuspendLayout();
            this.groupBox12.SuspendLayout();
            this.groupBox11.SuspendLayout();
            this.groupBox1.SuspendLayout();
            this.Run.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.uxNumberThreadsUpdown)).BeginInit();
            this.groupBox2.SuspendLayout();
            this.groupBox7.SuspendLayout();
            this.Input.SuspendLayout();
            this.groupBox8.SuspendLayout();
            this.Processes.SuspendLayout();
            this.Process_tabs.SuspendLayout();
            this.Water.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();
            this.Tillage.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();
            this.Creeper.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).BeginInit();
            this.Solifluction.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).BeginInit();
            this.Rock_weathering.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).BeginInit();
            this.groupBox10.SuspendLayout();
            this.Tectonics.SuspendLayout();
            this.groupBox14.SuspendLayout();
            this.groupBox16.SuspendLayout();
            this.groupBox4.SuspendLayout();
            this.groupBox15.SuspendLayout();
            this.treefall.SuspendLayout();
            this.tabPage6.SuspendLayout();
            this.tabControl1.SuspendLayout();
            this.tabPage1.SuspendLayout();
            this.tabControl2.SuspendLayout();
            this.physical.SuspendLayout();
            this.chemical.SuspendLayout();
            this.clay.SuspendLayout();
            this.bioturbation.SuspendLayout();
            this.carbon.SuspendLayout();
            this.decalcification.SuspendLayout();
            this.tabPage3.SuspendLayout();
            this.tabControl3.SuspendLayout();
            this.tabPage4.SuspendLayout();
            this.tabPage5.SuspendLayout();
            this.tabPage2.SuspendLayout();
            this.SuspendLayout();
            // 
            // label6
            // 
            label6.Location = new System.Drawing.Point(179, 22);
            label6.Name = "label6";
            label6.Size = new System.Drawing.Size(41, 24);
            label6.TabIndex = 109;
            label6.Text = "f(x,y)";
            label6.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(label6, "Check this for spatially variable inputs");
            // 
            // Landsliding
            // 
            Landsliding.Controls.Add(this.label36);
            Landsliding.Controls.Add(this.radio_ls_fraction);
            Landsliding.Controls.Add(this.radio_ls_absolute);
            Landsliding.Controls.Add(this.label35);
            Landsliding.Controls.Add(this.label34);
            Landsliding.Controls.Add(this.text_ls_rel_rain_intens);
            Landsliding.Controls.Add(this.textBox_ls_trans);
            Landsliding.Controls.Add(this.textBox_ls_bd);
            Landsliding.Controls.Add(this.textBox_ls_ifr);
            Landsliding.Controls.Add(this.textBox_ls_coh);
            Landsliding.Controls.Add(this.text_ls_abs_rain_intens);
            Landsliding.Controls.Add(this.label32);
            Landsliding.Controls.Add(this.label31);
            Landsliding.Controls.Add(this.label30);
            Landsliding.Controls.Add(this.label22);
            Landsliding.Controls.Add(this.label18);
            Landsliding.Controls.Add(this.pictureBox4);
            Landsliding.Controls.Add(this.Landslide_checkbox);
            Landsliding.Location = new System.Drawing.Point(4, 22);
            Landsliding.Name = "Landsliding";
            Landsliding.Size = new System.Drawing.Size(732, 250);
            Landsliding.TabIndex = 2;
            Landsliding.Text = "Landsliding";
            Landsliding.UseVisualStyleBackColor = true;
            // 
            // label36
            // 
            this.label36.AutoSize = true;
            this.label36.Location = new System.Drawing.Point(49, 115);
            this.label36.Name = "label36";
            this.label36.Size = new System.Drawing.Size(236, 13);
            this.label36.TabIndex = 30;
            this.label36.Text = "Parameters for critical rainfall intensity calculation";
            // 
            // radio_ls_fraction
            // 
            this.radio_ls_fraction.AutoSize = true;
            this.radio_ls_fraction.Checked = true;
            this.radio_ls_fraction.Location = new System.Drawing.Point(53, 83);
            this.radio_ls_fraction.Name = "radio_ls_fraction";
            this.radio_ls_fraction.Size = new System.Drawing.Size(14, 13);
            this.radio_ls_fraction.TabIndex = 29;
            this.radio_ls_fraction.TabStop = true;
            this.radio_ls_fraction.UseVisualStyleBackColor = true;
            // 
            // radio_ls_absolute
            // 
            this.radio_ls_absolute.AutoSize = true;
            this.radio_ls_absolute.Location = new System.Drawing.Point(53, 57);
            this.radio_ls_absolute.Name = "radio_ls_absolute";
            this.radio_ls_absolute.Size = new System.Drawing.Size(14, 13);
            this.radio_ls_absolute.TabIndex = 28;
            this.radio_ls_absolute.UseVisualStyleBackColor = true;
            // 
            // label35
            // 
            this.label35.AutoSize = true;
            this.label35.Enabled = false;
            this.label35.Location = new System.Drawing.Point(138, 57);
            this.label35.Name = "label35";
            this.label35.Size = new System.Drawing.Size(105, 13);
            this.label35.TabIndex = 27;
            this.label35.Text = "Absolute value [m/d]";
            // 
            // label34
            // 
            this.label34.AutoSize = true;
            this.label34.Location = new System.Drawing.Point(138, 83);
            this.label34.Name = "label34";
            this.label34.Size = new System.Drawing.Size(270, 13);
            this.label34.TabIndex = 26;
            this.label34.Text = "Fraction of total annual rainfall [between 1 and 0.00274]";
            // 
            // text_ls_rel_rain_intens
            // 
            this.text_ls_rel_rain_intens.Location = new System.Drawing.Point(79, 80);
            this.text_ls_rel_rain_intens.Name = "text_ls_rel_rain_intens";
            this.text_ls_rel_rain_intens.Size = new System.Drawing.Size(53, 20);
            this.text_ls_rel_rain_intens.TabIndex = 25;
            this.text_ls_rel_rain_intens.Text = "0.1";
            // 
            // textBox_ls_trans
            // 
            this.textBox_ls_trans.Location = new System.Drawing.Point(52, 210);
            this.textBox_ls_trans.Name = "textBox_ls_trans";
            this.textBox_ls_trans.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_trans.TabIndex = 23;
            this.textBox_ls_trans.Text = "15";
            // 
            // textBox_ls_bd
            // 
            this.textBox_ls_bd.Location = new System.Drawing.Point(52, 184);
            this.textBox_ls_bd.Name = "textBox_ls_bd";
            this.textBox_ls_bd.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_bd.TabIndex = 21;
            this.textBox_ls_bd.Text = "1.4";
            // 
            // textBox_ls_ifr
            // 
            this.textBox_ls_ifr.Location = new System.Drawing.Point(52, 158);
            this.textBox_ls_ifr.Name = "textBox_ls_ifr";
            this.textBox_ls_ifr.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_ifr.TabIndex = 19;
            this.textBox_ls_ifr.Text = "0.7";
            // 
            // textBox_ls_coh
            // 
            this.textBox_ls_coh.Location = new System.Drawing.Point(52, 131);
            this.textBox_ls_coh.Name = "textBox_ls_coh";
            this.textBox_ls_coh.Size = new System.Drawing.Size(53, 20);
            this.textBox_ls_coh.TabIndex = 17;
            this.textBox_ls_coh.Text = "0.15";
            // 
            // text_ls_abs_rain_intens
            // 
            this.text_ls_abs_rain_intens.Enabled = false;
            this.text_ls_abs_rain_intens.Location = new System.Drawing.Point(79, 54);
            this.text_ls_abs_rain_intens.Name = "text_ls_abs_rain_intens";
            this.text_ls_abs_rain_intens.Size = new System.Drawing.Size(53, 20);
            this.text_ls_abs_rain_intens.TabIndex = 15;
            this.text_ls_abs_rain_intens.Text = "0.1";
            // 
            // label32
            // 
            this.label32.AutoSize = true;
            this.label32.Location = new System.Drawing.Point(111, 213);
            this.label32.Name = "label32";
            this.label32.Size = new System.Drawing.Size(169, 13);
            this.label32.TabIndex = 24;
            this.label32.Text = "Saturated soil transmissivity [m2/d]";
            // 
            // label31
            // 
            this.label31.AutoSize = true;
            this.label31.Location = new System.Drawing.Point(111, 187);
            this.label31.Name = "label31";
            this.label31.Size = new System.Drawing.Size(105, 13);
            this.label31.TabIndex = 22;
            this.label31.Text = "Bulk density [kg m-3]";
            // 
            // label30
            // 
            this.label30.AutoSize = true;
            this.label30.Location = new System.Drawing.Point(111, 161);
            this.label30.Name = "label30";
            this.label30.Size = new System.Drawing.Size(152, 13);
            this.label30.TabIndex = 20;
            this.label30.Text = "Internal friction angle [degrees]";
            // 
            // label22
            // 
            this.label22.AutoSize = true;
            this.label22.Location = new System.Drawing.Point(111, 134);
            this.label22.Name = "label22";
            this.label22.Size = new System.Drawing.Size(112, 13);
            this.label22.TabIndex = 18;
            this.label22.Text = "Combined cohesion [-]";
            // 
            // label18
            // 
            this.label18.AutoSize = true;
            this.label18.Location = new System.Drawing.Point(50, 38);
            this.label18.Name = "label18";
            this.label18.Size = new System.Drawing.Size(117, 13);
            this.label18.TabIndex = 16;
            this.label18.Text = "Critical rainfall threshold";
            // 
            // pictureBox4
            // 
            this.pictureBox4.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox4.Image")));
            this.pictureBox4.Location = new System.Drawing.Point(480, 57);
            this.pictureBox4.Name = "pictureBox4";
            this.pictureBox4.Size = new System.Drawing.Size(180, 137);
            this.pictureBox4.TabIndex = 14;
            this.pictureBox4.TabStop = false;
            // 
            // Landslide_checkbox
            // 
            this.Landslide_checkbox.AutoSize = true;
            this.Landslide_checkbox.Location = new System.Drawing.Point(26, 14);
            this.Landslide_checkbox.Name = "Landslide_checkbox";
            this.Landslide_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Landslide_checkbox.TabIndex = 1;
            this.Landslide_checkbox.Text = "Activate this process";
            this.Landslide_checkbox.UseVisualStyleBackColor = true;
            // 
            // label41
            // 
            label41.AutoSize = true;
            label41.Location = new System.Drawing.Point(142, 49);
            label41.Name = "label41";
            label41.Size = new System.Drawing.Size(147, 13);
            label41.TabIndex = 10;
            label41.Text = "weathering rate constant [y-1]";
            // 
            // label42
            // 
            label42.AutoSize = true;
            label42.Location = new System.Drawing.Point(142, 72);
            label42.Name = "label42";
            label42.Size = new System.Drawing.Size(136, 13);
            label42.TabIndex = 11;
            label42.Text = "depth decay constant [m-1]";
            // 
            // label43
            // 
            label43.AutoSize = true;
            label43.Location = new System.Drawing.Point(142, 98);
            label43.Name = "label43";
            label43.Size = new System.Drawing.Size(123, 13);
            label43.TabIndex = 12;
            label43.Text = "particle size constant [m]";
            // 
            // label44
            // 
            label44.AutoSize = true;
            label44.Location = new System.Drawing.Point(409, 49);
            label44.Name = "label44";
            label44.Size = new System.Drawing.Size(77, 13);
            label44.TabIndex = 13;
            label44.Text = "coarse fraction";
            // 
            // label45
            // 
            label45.AutoSize = true;
            label45.Location = new System.Drawing.Point(409, 72);
            label45.Name = "label45";
            label45.Size = new System.Drawing.Size(68, 13);
            label45.TabIndex = 14;
            label45.Text = "sand fraction";
            // 
            // label46
            // 
            label46.AutoSize = true;
            label46.Location = new System.Drawing.Point(409, 98);
            label46.Name = "label46";
            label46.Size = new System.Drawing.Size(57, 13);
            label46.TabIndex = 15;
            label46.Text = "silt fraction";
            // 
            // label47
            // 
            label47.AutoSize = true;
            label47.Location = new System.Drawing.Point(409, 124);
            label47.Name = "label47";
            label47.Size = new System.Drawing.Size(64, 13);
            label47.TabIndex = 16;
            label47.Text = "clay fraction";
            // 
            // label48
            // 
            label48.AutoSize = true;
            label48.Location = new System.Drawing.Point(409, 150);
            label48.Name = "label48";
            label48.Size = new System.Drawing.Size(84, 13);
            label48.TabIndex = 17;
            label48.Text = "fine clay fraction";
            // 
            // label49
            // 
            label49.AutoSize = true;
            label49.Location = new System.Drawing.Point(300, 27);
            label49.Name = "label49";
            label49.Size = new System.Drawing.Size(229, 13);
            label49.TabIndex = 18;
            label49.Text = "upper limit of particle size for texture classes [m]";
            // 
            // label50
            // 
            label50.AutoSize = true;
            label50.Location = new System.Drawing.Point(136, 93);
            label50.Name = "label50";
            label50.Size = new System.Drawing.Size(0, 13);
            label50.TabIndex = 18;
            // 
            // label51
            // 
            label51.AutoSize = true;
            label51.Location = new System.Drawing.Point(136, 67);
            label51.Name = "label51";
            label51.Size = new System.Drawing.Size(136, 13);
            label51.TabIndex = 17;
            label51.Text = "depth decay constant [m-1]";
            // 
            // label52
            // 
            label52.AutoSize = true;
            label52.Location = new System.Drawing.Point(136, 38);
            label52.Name = "label52";
            label52.Size = new System.Drawing.Size(268, 13);
            label52.TabIndex = 16;
            label52.Text = "weathering rate constant [kg / m2 mineral surface area]";
            // 
            // label53
            // 
            label53.AutoSize = true;
            label53.Location = new System.Drawing.Point(135, 97);
            label53.Name = "label53";
            label53.Size = new System.Drawing.Size(131, 13);
            label53.TabIndex = 19;
            label53.Text = "specific area coefficient [-]";
            // 
            // label54
            // 
            label54.AutoSize = true;
            label54.Location = new System.Drawing.Point(417, 22);
            label54.Name = "label54";
            label54.Size = new System.Drawing.Size(239, 13);
            label54.TabIndex = 30;
            label54.Text = "specific surface area for texture classes [m2 / kg]";
            // 
            // label55
            // 
            label55.AutoSize = true;
            label55.Location = new System.Drawing.Point(526, 145);
            label55.Name = "label55";
            label55.Size = new System.Drawing.Size(84, 13);
            label55.TabIndex = 29;
            label55.Text = "fine clay fraction";
            // 
            // label56
            // 
            label56.AutoSize = true;
            label56.Location = new System.Drawing.Point(526, 119);
            label56.Name = "label56";
            label56.Size = new System.Drawing.Size(64, 13);
            label56.TabIndex = 28;
            label56.Text = "clay fraction";
            // 
            // label57
            // 
            label57.AutoSize = true;
            label57.Location = new System.Drawing.Point(526, 93);
            label57.Name = "label57";
            label57.Size = new System.Drawing.Size(57, 13);
            label57.TabIndex = 27;
            label57.Text = "silt fraction";
            // 
            // label58
            // 
            label58.AutoSize = true;
            label58.Location = new System.Drawing.Point(526, 67);
            label58.Name = "label58";
            label58.Size = new System.Drawing.Size(68, 13);
            label58.TabIndex = 26;
            label58.Text = "sand fraction";
            // 
            // label59
            // 
            label59.AutoSize = true;
            label59.Location = new System.Drawing.Point(526, 44);
            label59.Name = "label59";
            label59.Size = new System.Drawing.Size(77, 13);
            label59.TabIndex = 25;
            label59.Text = "coarse fraction";
            // 
            // label64
            // 
            label64.AutoSize = true;
            label64.Location = new System.Drawing.Point(131, 134);
            label64.Name = "label64";
            label64.Size = new System.Drawing.Size(83, 13);
            label64.TabIndex = 46;
            label64.Text = "constant 2 [m-1]";
            // 
            // label65
            // 
            label65.AutoSize = true;
            label65.Location = new System.Drawing.Point(132, 130);
            label65.Name = "label65";
            label65.Size = new System.Drawing.Size(0, 13);
            label65.TabIndex = 45;
            // 
            // label66
            // 
            label66.AutoSize = true;
            label66.Location = new System.Drawing.Point(132, 104);
            label66.Name = "label66";
            label66.Size = new System.Drawing.Size(60, 13);
            label66.TabIndex = 44;
            label66.Text = "constant 1 ";
            // 
            // label67
            // 
            label67.AutoSize = true;
            label67.Location = new System.Drawing.Point(132, 75);
            label67.Name = "label67";
            label67.Size = new System.Drawing.Size(121, 13);
            label67.TabIndex = 43;
            label67.Text = "neoformation constant []";
            // 
            // label60
            // 
            label60.AutoSize = true;
            label60.Location = new System.Drawing.Point(23, 59);
            label60.Name = "label60";
            label60.Size = new System.Drawing.Size(110, 13);
            label60.TabIndex = 39;
            label60.Text = "fine clay neoformation";
            // 
            // label69
            // 
            label69.AutoSize = true;
            label69.Location = new System.Drawing.Point(411, 130);
            label69.Name = "label69";
            label69.Size = new System.Drawing.Size(0, 13);
            label69.TabIndex = 53;
            // 
            // label70
            // 
            label70.AutoSize = true;
            label70.Location = new System.Drawing.Point(411, 104);
            label70.Name = "label70";
            label70.Size = new System.Drawing.Size(97, 13);
            label70.TabIndex = 52;
            label70.Text = "saturation constant";
            // 
            // eluviation_rate_constant
            // 
            eluviation_rate_constant.AutoSize = true;
            eluviation_rate_constant.Location = new System.Drawing.Point(411, 75);
            eluviation_rate_constant.Name = "eluviation_rate_constant";
            eluviation_rate_constant.Size = new System.Drawing.Size(119, 13);
            eluviation_rate_constant.TabIndex = 51;
            eluviation_rate_constant.Text = "maximum eluviation [kg]";
            // 
            // label72
            // 
            label72.AutoSize = true;
            label72.Location = new System.Drawing.Point(302, 59);
            label72.Name = "label72";
            label72.Size = new System.Drawing.Size(109, 13);
            label72.TabIndex = 47;
            label72.Text = "fine clay translocation";
            // 
            // label68
            // 
            label68.AutoSize = true;
            label68.Location = new System.Drawing.Point(133, 103);
            label68.Name = "label68";
            label68.Size = new System.Drawing.Size(0, 13);
            label68.TabIndex = 59;
            // 
            // label71
            // 
            label71.AutoSize = true;
            label71.Location = new System.Drawing.Point(133, 77);
            label71.Name = "label71";
            label71.Size = new System.Drawing.Size(99, 13);
            label71.TabIndex = 58;
            label71.Text = "depth decay rate [-]";
            // 
            // label73
            // 
            label73.AutoSize = true;
            label73.Location = new System.Drawing.Point(133, 48);
            label73.Name = "label73";
            label73.Size = new System.Drawing.Size(167, 13);
            label73.TabIndex = 57;
            label73.Text = "potential bioturbation [kg / m2 / y]";
            // 
            // label74
            // 
            label74.AutoSize = true;
            label74.Location = new System.Drawing.Point(130, 117);
            label74.Name = "label74";
            label74.Size = new System.Drawing.Size(0, 13);
            label74.TabIndex = 64;
            // 
            // label75
            // 
            label75.AutoSize = true;
            label75.Location = new System.Drawing.Point(130, 91);
            label75.Name = "label75";
            label75.Size = new System.Drawing.Size(124, 13);
            label75.TabIndex = 63;
            label75.Text = "depth limitation rate [m-1]";
            // 
            // label76
            // 
            label76.AutoSize = true;
            label76.Location = new System.Drawing.Point(130, 62);
            label76.Name = "label76";
            label76.Size = new System.Drawing.Size(205, 13);
            label76.TabIndex = 62;
            label76.Text = "potential organic matter input [kg / m2 / y]";
            // 
            // label77
            // 
            label77.AutoSize = true;
            label77.Location = new System.Drawing.Point(130, 172);
            label77.Name = "label77";
            label77.Size = new System.Drawing.Size(0, 13);
            label77.TabIndex = 69;
            // 
            // label81
            // 
            label81.AutoSize = true;
            label81.Location = new System.Drawing.Point(130, 117);
            label81.Name = "label81";
            label81.Size = new System.Drawing.Size(113, 13);
            label81.TabIndex = 67;
            label81.Text = "humification fraction [-]";
            // 
            // label80
            // 
            label80.AutoSize = true;
            label80.Location = new System.Drawing.Point(381, 62);
            label80.Name = "label80";
            label80.Size = new System.Drawing.Size(133, 26);
            label80.TabIndex = 70;
            label80.Text = "decomposition parameters \r\nfor two OM pools:";
            // 
            // label82
            // 
            label82.AutoSize = true;
            label82.Location = new System.Drawing.Point(382, 94);
            label82.Name = "label82";
            label82.Size = new System.Drawing.Size(36, 13);
            label82.TabIndex = 71;
            label82.Text = "young";
            // 
            // label83
            // 
            label83.AutoSize = true;
            label83.Location = new System.Drawing.Point(496, 94);
            label83.Name = "label83";
            label83.Size = new System.Drawing.Size(21, 13);
            label83.TabIndex = 72;
            label83.Text = "old";
            // 
            // label84
            // 
            label84.AutoSize = true;
            label84.Location = new System.Drawing.Point(558, 140);
            label84.Name = "label84";
            label84.Size = new System.Drawing.Size(136, 13);
            label84.TabIndex = 74;
            label84.Text = "depth decay constant [m-1]";
            // 
            // label85
            // 
            label85.AutoSize = true;
            label85.Location = new System.Drawing.Point(558, 166);
            label85.Name = "label85";
            label85.Size = new System.Drawing.Size(116, 13);
            label85.TabIndex = 77;
            label85.Text = "TWI decay constant [-]";
            // 
            // label86
            // 
            label86.AutoSize = true;
            label86.Location = new System.Drawing.Point(558, 114);
            label86.Name = "label86";
            label86.Size = new System.Drawing.Size(115, 13);
            label86.TabIndex = 80;
            label86.Text = "decomposition rate [/y]";
            // 
            // label13
            // 
            label13.AutoSize = true;
            label13.Location = new System.Drawing.Point(410, 172);
            label13.Name = "label13";
            label13.Size = new System.Drawing.Size(112, 13);
            label13.TabIndex = 56;
            label13.Text = "Depth decay constant";
            // 
            // mainMenu1
            // 
            this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItemConfigFile,
            this.Menu_About_box});
            // 
            // menuItemConfigFile
            // 
            this.menuItemConfigFile.Index = 0;
            this.menuItemConfigFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
            this.menuItemConfigFileOpen,
            this.menuItemConfigFileSaveAs,
            this.menuItemConfigFileSave});
            this.menuItemConfigFile.Text = "&RunFile";
            // 
            // menuItemConfigFileOpen
            // 
            this.menuItemConfigFileOpen.Index = 0;
            this.menuItemConfigFileOpen.Text = "&Open";
            this.menuItemConfigFileOpen.Click += new System.EventHandler(this.menuItemConfigFileOpen_Click);
            // 
            // menuItemConfigFileSaveAs
            // 
            this.menuItemConfigFileSaveAs.Index = 1;
            this.menuItemConfigFileSaveAs.Text = "Save &As";
            this.menuItemConfigFileSaveAs.Click += new System.EventHandler(this.menuItemConfigFileSave_Click);
            // 
            // menuItemConfigFileSave
            // 
            this.menuItemConfigFileSave.Index = 2;
            this.menuItemConfigFileSave.Text = "&Save";
            this.menuItemConfigFileSave.Click += new System.EventHandler(this.menuItemConfigFileSave_Click);
            // 
            // Menu_About_box
            // 
            this.Menu_About_box.Index = 1;
            this.Menu_About_box.Text = "";
            // 
            // statusBar1
            // 
            this.statusBar1.Location = new System.Drawing.Point(0, 468);
            this.statusBar1.Name = "statusBar1";
            this.statusBar1.Panels.AddRange(new System.Windows.Forms.StatusBarPanel[] {
            this.InfoStatusPanel,
            this.TimeStatusPanel,
            this.ScenarioStatusPanel});
            this.statusBar1.ShowPanels = true;
            this.statusBar1.Size = new System.Drawing.Size(940, 23);
            this.statusBar1.SizingGrip = false;
            this.statusBar1.TabIndex = 144;
            this.statusBar1.Text = "statusBar1";
            // 
            // InfoStatusPanel
            // 
            this.InfoStatusPanel.Name = "InfoStatusPanel";
            this.InfoStatusPanel.Text = "info";
            this.InfoStatusPanel.Width = 200;
            // 
            // TimeStatusPanel
            // 
            this.TimeStatusPanel.Name = "TimeStatusPanel";
            this.TimeStatusPanel.Text = "time";
            this.TimeStatusPanel.Width = 80;
            // 
            // ScenarioStatusPanel
            // 
            this.ScenarioStatusPanel.Name = "ScenarioStatusPanel";
            this.ScenarioStatusPanel.Text = "scen ";
            this.ScenarioStatusPanel.Width = 120;
            // 
            // start_button
            // 
            this.start_button.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.start_button.Location = new System.Drawing.Point(10, 337);
            this.start_button.Name = "start_button";
            this.start_button.Size = new System.Drawing.Size(88, 27);
            this.start_button.TabIndex = 146;
            this.start_button.Text = "Start";
            this.start_button.Click += new System.EventHandler(this.main_loop);
            // 
            // End_button
            // 
            this.End_button.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.End_button.Location = new System.Drawing.Point(105, 337);
            this.End_button.Name = "End_button";
            this.End_button.Size = new System.Drawing.Size(100, 27);
            this.End_button.TabIndex = 147;
            this.End_button.Text = "Quit";
            this.End_button.Click += new System.EventHandler(this.End_button_Click);
            // 
            // label2
            // 
            this.label2.Location = new System.Drawing.Point(19, 121);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(104, 24);
            this.label2.TabIndex = 97;
            this.label2.Text = "Rainfall data file";
            this.label2.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.toolTip1.SetToolTip(this.label2, "Hourly rainfall data - in an ascii format");
            // 
            // label25
            // 
            this.label25.Location = new System.Drawing.Point(19, 164);
            this.label25.Name = "label25";
            this.label25.Size = new System.Drawing.Size(143, 24);
            this.label25.TabIndex = 97;
            this.label25.Text = "mean annual rainfall [m]";
            this.label25.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label25, "Hourly rainfall data - in an ascii format");
            // 
            // label14
            // 
            this.label14.Location = new System.Drawing.Point(19, 190);
            this.label14.Name = "label14";
            this.label14.Size = new System.Drawing.Size(143, 24);
            this.label14.TabIndex = 115;
            this.label14.Text = "mean annual infiltration [m]";
            this.label14.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label14, "Hourly rainfall data - in an ascii format");
            // 
            // label15
            // 
            this.label15.Location = new System.Drawing.Point(19, 216);
            this.label15.Name = "label15";
            this.label15.Size = new System.Drawing.Size(151, 24);
            this.label15.TabIndex = 118;
            this.label15.Text = "mean annual evaporation [m]";
            this.label15.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label15, "Hourly rainfall data - in an ascii format");
            // 
            // label17
            // 
            this.label17.Location = new System.Drawing.Point(19, 140);
            this.label17.Name = "label17";
            this.label17.Size = new System.Drawing.Size(143, 24);
            this.label17.TabIndex = 121;
            this.label17.Text = "tillage fields [1/-9999]";
            this.label17.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label17, "Hourly rainfall data - in an ascii format");
            // 
            // fill_sinks_before_checkbox
            // 
            this.fill_sinks_before_checkbox.AutoSize = true;
            this.fill_sinks_before_checkbox.Location = new System.Drawing.Point(11, 22);
            this.fill_sinks_before_checkbox.Name = "fill_sinks_before_checkbox";
            this.fill_sinks_before_checkbox.Size = new System.Drawing.Size(131, 17);
            this.fill_sinks_before_checkbox.TabIndex = 132;
            this.fill_sinks_before_checkbox.Text = "remove sinks and flats";
            this.toolTip1.SetToolTip(this.fill_sinks_before_checkbox, resources.GetString("fill_sinks_before_checkbox.ToolTip"));
            this.fill_sinks_before_checkbox.UseVisualStyleBackColor = true;
            // 
            // label8
            // 
            this.label8.Location = new System.Drawing.Point(110, 31);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(54, 25);
            this.label8.TabIndex = 222;
            this.label8.Text = "timesteps";
            this.label8.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label8, "How often the avi file AND the other data files are saved");
            // 
            // fill_sinks_during_checkbox
            // 
            this.fill_sinks_during_checkbox.AutoSize = true;
            this.fill_sinks_during_checkbox.Location = new System.Drawing.Point(11, 25);
            this.fill_sinks_during_checkbox.Name = "fill_sinks_during_checkbox";
            this.fill_sinks_during_checkbox.Size = new System.Drawing.Size(131, 17);
            this.fill_sinks_during_checkbox.TabIndex = 132;
            this.fill_sinks_during_checkbox.Text = "remove sinks and flats";
            this.toolTip1.SetToolTip(this.fill_sinks_during_checkbox, resources.GetString("fill_sinks_during_checkbox.ToolTip"));
            this.fill_sinks_during_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox13
            // 
            this.groupBox13.Controls.Add(this.fill_sinks_during_checkbox);
            this.groupBox13.Location = new System.Drawing.Point(589, 91);
            this.groupBox13.Name = "groupBox13";
            this.groupBox13.Size = new System.Drawing.Size(158, 55);
            this.groupBox13.TabIndex = 135;
            this.groupBox13.TabStop = false;
            this.groupBox13.Text = "while running: ";
            this.toolTip1.SetToolTip(this.groupBox13, "LORICA");
            // 
            // label7
            // 
            this.label7.Location = new System.Drawing.Point(407, 22);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(134, 24);
            this.label7.TabIndex = 110;
            this.label7.Text = " constant value";
            this.label7.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label7, "\"constant value\" is only available for some inputs and only \r\nwhen neither f(t) n" +
        "or f(x,y) are checked");
            // 
            // label5
            // 
            this.label5.Location = new System.Drawing.Point(258, 23);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(51, 24);
            this.label5.TabIndex = 108;
            this.label5.Text = "filename";
            this.label5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label5, resources.GetString("label5.ToolTip"));
            // 
            // label29
            // 
            this.label29.Location = new System.Drawing.Point(217, 22);
            this.label29.Name = "label29";
            this.label29.Size = new System.Drawing.Size(24, 24);
            this.label29.TabIndex = 139;
            this.label29.Text = "f(t)";
            this.label29.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label29, "Check this for temporally variable inputs");
            // 
            // groupBox3
            // 
            this.groupBox3.Controls.Add(this.landuse_determinator_button);
            this.groupBox3.Location = new System.Drawing.Point(589, 152);
            this.groupBox3.Name = "groupBox3";
            this.groupBox3.Size = new System.Drawing.Size(158, 55);
            this.groupBox3.TabIndex = 136;
            this.groupBox3.TabStop = false;
            this.groupBox3.Text = "for landuse: ";
            this.toolTip1.SetToolTip(this.groupBox3, "LORICA");
            // 
            // landuse_determinator_button
            // 
            this.landuse_determinator_button.Location = new System.Drawing.Point(11, 19);
            this.landuse_determinator_button.Name = "landuse_determinator_button";
            this.landuse_determinator_button.Size = new System.Drawing.Size(122, 23);
            this.landuse_determinator_button.TabIndex = 0;
            this.landuse_determinator_button.Text = "determine effects";
            this.landuse_determinator_button.UseVisualStyleBackColor = true;
            this.landuse_determinator_button.Click += new System.EventHandler(this.landuse_determinator_button_Click);
            // 
            // groupBox9
            // 
            this.groupBox9.Controls.Add(this.parameter_k1_textbox);
            this.groupBox9.Controls.Add(this.label24);
            this.groupBox9.Controls.Add(this.label26);
            this.groupBox9.Controls.Add(this.label27);
            this.groupBox9.Controls.Add(this.label28);
            this.groupBox9.Controls.Add(this.parameter_k2_textbox);
            this.groupBox9.Controls.Add(this.parameter_Pa_textbox);
            this.groupBox9.Controls.Add(this.parameter_P0_textbox);
            this.groupBox9.Controls.Add(this.label21);
            this.groupBox9.Controls.Add(this.Biological_weathering_checkbox);
            this.groupBox9.Location = new System.Drawing.Point(12, 13);
            this.groupBox9.Name = "groupBox9";
            this.groupBox9.Size = new System.Drawing.Size(222, 180);
            this.groupBox9.TabIndex = 5;
            this.groupBox9.TabStop = false;
            this.groupBox9.Text = "Biological weathering (humped model)";
            this.toolTip1.SetToolTip(this.groupBox9, resources.GetString("groupBox9.ToolTip"));
            // 
            // parameter_k1_textbox
            // 
            this.parameter_k1_textbox.Location = new System.Drawing.Point(14, 80);
            this.parameter_k1_textbox.Name = "parameter_k1_textbox";
            this.parameter_k1_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_k1_textbox.TabIndex = 20;
            this.parameter_k1_textbox.Text = "0.1";
            // 
            // label24
            // 
            this.label24.AutoSize = true;
            this.label24.Location = new System.Drawing.Point(89, 135);
            this.label24.Name = "label24";
            this.label24.Size = new System.Drawing.Size(52, 13);
            this.label24.TabIndex = 19;
            this.label24.Text = "Pa (m t-1)";
            // 
            // label26
            // 
            this.label26.AutoSize = true;
            this.label26.Location = new System.Drawing.Point(89, 109);
            this.label26.Name = "label26";
            this.label26.Size = new System.Drawing.Size(40, 13);
            this.label26.TabIndex = 18;
            this.label26.Text = "k2 (t-1)";
            // 
            // label27
            // 
            this.label27.AutoSize = true;
            this.label27.Location = new System.Drawing.Point(89, 83);
            this.label27.Name = "label27";
            this.label27.Size = new System.Drawing.Size(40, 13);
            this.label27.TabIndex = 17;
            this.label27.Text = "k1 (t-1)";
            // 
            // label28
            // 
            this.label28.AutoSize = true;
            this.label28.Location = new System.Drawing.Point(89, 57);
            this.label28.Name = "label28";
            this.label28.Size = new System.Drawing.Size(52, 13);
            this.label28.TabIndex = 16;
            this.label28.Text = "P0 (m t-1)";
            // 
            // parameter_k2_textbox
            // 
            this.parameter_k2_textbox.Location = new System.Drawing.Point(14, 106);
            this.parameter_k2_textbox.Name = "parameter_k2_textbox";
            this.parameter_k2_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_k2_textbox.TabIndex = 14;
            this.parameter_k2_textbox.Text = "6";
            // 
            // parameter_Pa_textbox
            // 
            this.parameter_Pa_textbox.Location = new System.Drawing.Point(14, 132);
            this.parameter_Pa_textbox.Name = "parameter_Pa_textbox";
            this.parameter_Pa_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_Pa_textbox.TabIndex = 13;
            this.parameter_Pa_textbox.Text = "0.00002";
            // 
            // parameter_P0_textbox
            // 
            this.parameter_P0_textbox.Location = new System.Drawing.Point(14, 54);
            this.parameter_P0_textbox.Name = "parameter_P0_textbox";
            this.parameter_P0_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_P0_textbox.TabIndex = 12;
            this.parameter_P0_textbox.Text = "0.000033";
            // 
            // label21
            // 
            this.label21.AutoSize = true;
            this.label21.Location = new System.Drawing.Point(11, 11);
            this.label21.Name = "label21";
            this.label21.Size = new System.Drawing.Size(0, 13);
            this.label21.TabIndex = 4;
            // 
            // Biological_weathering_checkbox
            // 
            this.Biological_weathering_checkbox.AutoSize = true;
            this.Biological_weathering_checkbox.Location = new System.Drawing.Point(14, 19);
            this.Biological_weathering_checkbox.Name = "Biological_weathering_checkbox";
            this.Biological_weathering_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Biological_weathering_checkbox.TabIndex = 3;
            this.Biological_weathering_checkbox.Text = "Activate this process";
            this.Biological_weathering_checkbox.UseVisualStyleBackColor = true;
            // 
            // label98
            // 
            this.label98.Location = new System.Drawing.Point(19, 245);
            this.label98.Name = "label98";
            this.label98.Size = new System.Drawing.Size(151, 24);
            this.label98.TabIndex = 152;
            this.label98.Text = "mean annual temperature [C]";
            this.label98.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label98, "Hourly rainfall data - in an ascii format");
            // 
            // label99
            // 
            this.label99.Location = new System.Drawing.Point(52, 269);
            this.label99.Name = "label99";
            this.label99.Size = new System.Drawing.Size(151, 24);
            this.label99.TabIndex = 153;
            this.label99.Text = "Only with daily water balance";
            this.label99.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            this.toolTip1.SetToolTip(this.label99, "Hourly rainfall data - in an ascii format");
            // 
            // checkbox_t_intervene
            // 
            this.checkbox_t_intervene.AutoSize = true;
            this.checkbox_t_intervene.Location = new System.Drawing.Point(54, 61);
            this.checkbox_t_intervene.Name = "checkbox_t_intervene";
            this.checkbox_t_intervene.Size = new System.Drawing.Size(83, 17);
            this.checkbox_t_intervene.TabIndex = 4;
            this.checkbox_t_intervene.Text = "Start at year";
            this.toolTip1.SetToolTip(this.checkbox_t_intervene, "Select this checkbox when you want to run simulations starting with output from a" +
        "n earlier run. Model output should be available in the output directory for the " +
        "indicated year.");
            this.checkbox_t_intervene.UseVisualStyleBackColor = true;
            // 
            // UTMzonebox
            // 
            this.UTMzonebox.Location = new System.Drawing.Point(0, 0);
            this.UTMzonebox.Name = "UTMzonebox";
            this.UTMzonebox.Size = new System.Drawing.Size(100, 20);
            this.UTMzonebox.TabIndex = 0;
            // 
            // openFileDialog1
            // 
            this.openFileDialog1.FileName = "openFileDialog1";
            // 
            // label1
            // 
            this.label1.Location = new System.Drawing.Point(19, 49);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(104, 24);
            this.label1.TabIndex = 56;
            this.label1.Text = "DEM (.asc format)";
            this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            // 
            // button6
            // 
            this.button6.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)));
            this.button6.Location = new System.Drawing.Point(132, 235);
            this.button6.Name = "button6";
            this.button6.Size = new System.Drawing.Size(100, 24);
            this.button6.TabIndex = 7;
            this.button6.Text = "test data";
            // 
            // textBox1
            // 
            this.textBox1.Location = new System.Drawing.Point(131, 121);
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(120, 20);
            this.textBox1.TabIndex = 103;
            this.textBox1.Text = "null";
            // 
            // textBox2
            // 
            this.textBox2.Location = new System.Drawing.Point(131, 49);
            this.textBox2.Name = "textBox2";
            this.textBox2.Size = new System.Drawing.Size(120, 20);
            this.textBox2.TabIndex = 100;
            this.textBox2.Text = "whole9.dat";
            // 
            // Output
            // 
            this.Output.Controls.Add(this.profiles_button);
            this.Output.Controls.Add(this.timeseries_button);
            this.Output.Controls.Add(this.groupBox6);
            this.Output.Location = new System.Drawing.Point(4, 22);
            this.Output.Name = "Output";
            this.Output.Size = new System.Drawing.Size(803, 293);
            this.Output.TabIndex = 7;
            this.Output.Text = "Output";
            this.Output.UseVisualStyleBackColor = true;
            // 
            // profiles_button
            // 
            this.profiles_button.Location = new System.Drawing.Point(322, 69);
            this.profiles_button.Name = "profiles_button";
            this.profiles_button.Size = new System.Drawing.Size(149, 25);
            this.profiles_button.TabIndex = 224;
            this.profiles_button.Text = "profile outputs";
            this.profiles_button.UseVisualStyleBackColor = true;
            this.profiles_button.Click += new System.EventHandler(this.profiles_button_Click_1);
            // 
            // timeseries_button
            // 
            this.timeseries_button.Location = new System.Drawing.Point(322, 35);
            this.timeseries_button.Name = "timeseries_button";
            this.timeseries_button.Size = new System.Drawing.Size(149, 25);
            this.timeseries_button.TabIndex = 223;
            this.timeseries_button.Text = "timeseries outputs";
            this.timeseries_button.UseVisualStyleBackColor = true;
            this.timeseries_button.Click += new System.EventHandler(this.timeseries_button_Click_1);
            // 
            // groupBox6
            // 
            this.groupBox6.Controls.Add(this.groupBox12);
            this.groupBox6.Controls.Add(this.groupBox11);
            this.groupBox6.Controls.Add(this.groupBox1);
            this.groupBox6.Controls.Add(this.checkedListBox1);
            this.groupBox6.Location = new System.Drawing.Point(8, 16);
            this.groupBox6.Name = "groupBox6";
            this.groupBox6.Size = new System.Drawing.Size(294, 258);
            this.groupBox6.TabIndex = 222;
            this.groupBox6.TabStop = false;
            this.groupBox6.Text = "Normal outputs (ascii grids)";
            // 
            // groupBox12
            // 
            this.groupBox12.Controls.Add(this.annual_output_checkbox);
            this.groupBox12.Controls.Add(this.cumulative_output_checkbox);
            this.groupBox12.Location = new System.Drawing.Point(181, 19);
            this.groupBox12.Name = "groupBox12";
            this.groupBox12.Size = new System.Drawing.Size(102, 63);
            this.groupBox12.TabIndex = 227;
            this.groupBox12.TabStop = false;
            // 
            // annual_output_checkbox
            // 
            this.annual_output_checkbox.AutoSize = true;
            this.annual_output_checkbox.Location = new System.Drawing.Point(5, 35);
            this.annual_output_checkbox.Name = "annual_output_checkbox";
            this.annual_output_checkbox.Size = new System.Drawing.Size(57, 17);
            this.annual_output_checkbox.TabIndex = 1;
            this.annual_output_checkbox.Text = "annual";
            this.annual_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // cumulative_output_checkbox
            // 
            this.cumulative_output_checkbox.AutoSize = true;
            this.cumulative_output_checkbox.Checked = true;
            this.cumulative_output_checkbox.Location = new System.Drawing.Point(5, 12);
            this.cumulative_output_checkbox.Name = "cumulative_output_checkbox";
            this.cumulative_output_checkbox.Size = new System.Drawing.Size(76, 17);
            this.cumulative_output_checkbox.TabIndex = 0;
            this.cumulative_output_checkbox.TabStop = true;
            this.cumulative_output_checkbox.Text = "cumulative";
            this.cumulative_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox11
            // 
            this.groupBox11.Controls.Add(this.label8);
            this.groupBox11.Controls.Add(this.Regular_output_checkbox);
            this.groupBox11.Controls.Add(this.Final_output_checkbox);
            this.groupBox11.Controls.Add(this.Box_years_output);
            this.groupBox11.Location = new System.Drawing.Point(6, 19);
            this.groupBox11.Name = "groupBox11";
            this.groupBox11.Size = new System.Drawing.Size(166, 63);
            this.groupBox11.TabIndex = 226;
            this.groupBox11.TabStop = false;
            // 
            // Regular_output_checkbox
            // 
            this.Regular_output_checkbox.AutoSize = true;
            this.Regular_output_checkbox.Location = new System.Drawing.Point(6, 36);
            this.Regular_output_checkbox.Name = "Regular_output_checkbox";
            this.Regular_output_checkbox.Size = new System.Drawing.Size(55, 17);
            this.Regular_output_checkbox.TabIndex = 221;
            this.Regular_output_checkbox.Text = "every ";
            this.Regular_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Final_output_checkbox
            // 
            this.Final_output_checkbox.AutoSize = true;
            this.Final_output_checkbox.Checked = true;
            this.Final_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Final_output_checkbox.Location = new System.Drawing.Point(6, 13);
            this.Final_output_checkbox.Name = "Final_output_checkbox";
            this.Final_output_checkbox.Size = new System.Drawing.Size(81, 17);
            this.Final_output_checkbox.TabIndex = 220;
            this.Final_output_checkbox.Text = "when ready";
            this.Final_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Box_years_output
            // 
            this.Box_years_output.AcceptsTab = true;
            this.Box_years_output.Location = new System.Drawing.Point(67, 34);
            this.Box_years_output.Name = "Box_years_output";
            this.Box_years_output.Size = new System.Drawing.Size(44, 20);
            this.Box_years_output.TabIndex = 1;
            this.Box_years_output.Text = "3";
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.diagnostic_output_checkbox);
            this.groupBox1.Controls.Add(this.label37);
            this.groupBox1.Controls.Add(this.outputcode_textbox);
            this.groupBox1.Controls.Add(this.water_output_checkbox);
            this.groupBox1.Controls.Add(this.depressions_output_checkbox);
            this.groupBox1.Controls.Add(this.all_process_output_checkbox);
            this.groupBox1.Controls.Add(this.Soildepth_output_checkbox);
            this.groupBox1.Controls.Add(this.Alt_change_output_checkbox);
            this.groupBox1.Controls.Add(this.Altitude_output_checkbox);
            this.groupBox1.Location = new System.Drawing.Point(6, 85);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(277, 167);
            this.groupBox1.TabIndex = 225;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Outputs:";
            // 
            // diagnostic_output_checkbox
            // 
            this.diagnostic_output_checkbox.AutoSize = true;
            this.diagnostic_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.diagnostic_output_checkbox.Location = new System.Drawing.Point(125, 141);
            this.diagnostic_output_checkbox.Name = "diagnostic_output_checkbox";
            this.diagnostic_output_checkbox.Size = new System.Drawing.Size(81, 17);
            this.diagnostic_output_checkbox.TabIndex = 230;
            this.diagnostic_output_checkbox.Text = "Diagnostics";
            this.diagnostic_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // label37
            // 
            this.label37.AutoSize = true;
            this.label37.Location = new System.Drawing.Point(153, 31);
            this.label37.Name = "label37";
            this.label37.Size = new System.Drawing.Size(69, 13);
            this.label37.TabIndex = 229;
            this.label37.Text = "Output code:";
            // 
            // outputcode_textbox
            // 
            this.outputcode_textbox.Location = new System.Drawing.Point(156, 47);
            this.outputcode_textbox.Name = "outputcode_textbox";
            this.outputcode_textbox.Size = new System.Drawing.Size(100, 20);
            this.outputcode_textbox.TabIndex = 228;
            // 
            // water_output_checkbox
            // 
            this.water_output_checkbox.AutoSize = true;
            this.water_output_checkbox.Checked = true;
            this.water_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.water_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.water_output_checkbox.Location = new System.Drawing.Point(24, 118);
            this.water_output_checkbox.Name = "water_output_checkbox";
            this.water_output_checkbox.Size = new System.Drawing.Size(74, 17);
            this.water_output_checkbox.TabIndex = 227;
            this.water_output_checkbox.Text = "Waterflow";
            this.water_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // depressions_output_checkbox
            // 
            this.depressions_output_checkbox.AutoSize = true;
            this.depressions_output_checkbox.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Italic, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.depressions_output_checkbox.Location = new System.Drawing.Point(24, 141);
            this.depressions_output_checkbox.Name = "depressions_output_checkbox";
            this.depressions_output_checkbox.Size = new System.Drawing.Size(84, 17);
            this.depressions_output_checkbox.TabIndex = 226;
            this.depressions_output_checkbox.Text = "Depressions";
            this.depressions_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // all_process_output_checkbox
            // 
            this.all_process_output_checkbox.AutoSize = true;
            this.all_process_output_checkbox.Checked = true;
            this.all_process_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.all_process_output_checkbox.Location = new System.Drawing.Point(24, 95);
            this.all_process_output_checkbox.Name = "all_process_output_checkbox";
            this.all_process_output_checkbox.Size = new System.Drawing.Size(134, 17);
            this.all_process_output_checkbox.TabIndex = 225;
            this.all_process_output_checkbox.Text = "Indiv. process volumes";
            this.all_process_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Soildepth_output_checkbox
            // 
            this.Soildepth_output_checkbox.AutoSize = true;
            this.Soildepth_output_checkbox.Checked = true;
            this.Soildepth_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Soildepth_output_checkbox.Location = new System.Drawing.Point(24, 72);
            this.Soildepth_output_checkbox.Name = "Soildepth_output_checkbox";
            this.Soildepth_output_checkbox.Size = new System.Drawing.Size(70, 17);
            this.Soildepth_output_checkbox.TabIndex = 224;
            this.Soildepth_output_checkbox.Text = "Soildepth";
            this.Soildepth_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Alt_change_output_checkbox
            // 
            this.Alt_change_output_checkbox.AutoSize = true;
            this.Alt_change_output_checkbox.Checked = true;
            this.Alt_change_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Alt_change_output_checkbox.Location = new System.Drawing.Point(24, 49);
            this.Alt_change_output_checkbox.Name = "Alt_change_output_checkbox";
            this.Alt_change_output_checkbox.Size = new System.Drawing.Size(100, 17);
            this.Alt_change_output_checkbox.TabIndex = 223;
            this.Alt_change_output_checkbox.Text = "Altitude change";
            this.Alt_change_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // Altitude_output_checkbox
            // 
            this.Altitude_output_checkbox.AutoSize = true;
            this.Altitude_output_checkbox.Checked = true;
            this.Altitude_output_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Altitude_output_checkbox.Location = new System.Drawing.Point(24, 26);
            this.Altitude_output_checkbox.Name = "Altitude_output_checkbox";
            this.Altitude_output_checkbox.Size = new System.Drawing.Size(61, 17);
            this.Altitude_output_checkbox.TabIndex = 222;
            this.Altitude_output_checkbox.Text = "Altitude";
            this.Altitude_output_checkbox.UseVisualStyleBackColor = true;
            // 
            // checkedListBox1
            // 
            this.checkedListBox1.FormattingEnabled = true;
            this.checkedListBox1.Items.AddRange(new object[] {
            "altitude",
            "altitude change",
            "soildepth",
            "soildepth change",
            "redistribution all processes",
            "redistribution per process",
            "weathering all processes",
            "weathering per process"});
            this.checkedListBox1.Location = new System.Drawing.Point(119, 96);
            this.checkedListBox1.Name = "checkedListBox1";
            this.checkedListBox1.Size = new System.Drawing.Size(152, 4);
            this.checkedListBox1.TabIndex = 0;
            this.checkedListBox1.Visible = false;
            // 
            // textBox6
            // 
            this.textBox6.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.textBox6.Location = new System.Drawing.Point(6, 17);
            this.textBox6.Multiline = true;
            this.textBox6.Name = "textBox6";
            this.textBox6.ReadOnly = true;
            this.textBox6.Size = new System.Drawing.Size(87, 22);
            this.textBox6.TabIndex = 196;
            this.textBox6.Text = "UTM zone (1-60)";
            // 
            // UTMsouthcheck
            // 
            this.UTMsouthcheck.Location = new System.Drawing.Point(0, 0);
            this.UTMsouthcheck.Name = "UTMsouthcheck";
            this.UTMsouthcheck.Size = new System.Drawing.Size(104, 24);
            this.UTMsouthcheck.TabIndex = 0;
            // 
            // Run
            // 
            this.Run.Controls.Add(this.CarboZALF_calib_stabilizationages_checkbox);
            this.Run.Controls.Add(this.version_CarboZALF_checkbox);
            this.Run.Controls.Add(this.ux_number_Processors_label);
            this.Run.Controls.Add(this.version_Konza_checkbox);
            this.Run.Controls.Add(this.uxThreadLabel);
            this.Run.Controls.Add(this.uxNumberCoresLabel);
            this.Run.Controls.Add(this.uxNumberLogicalProcessorsLabel);
            this.Run.Controls.Add(this.uxNumberThreadsUpdown);
            this.Run.Controls.Add(this.button4);
            this.Run.Controls.Add(this.version_lux_checkbox);
            this.Run.Controls.Add(this.groupBox2);
            this.Run.Controls.Add(this.calibration);
            this.Run.Controls.Add(this.Spitsbergen_case_study);
            this.Run.Controls.Add(this.groupBox7);
            this.Run.Location = new System.Drawing.Point(4, 22);
            this.Run.Name = "Run";
            this.Run.Size = new System.Drawing.Size(803, 293);
            this.Run.TabIndex = 8;
            this.Run.Text = "Run";
            this.Run.UseVisualStyleBackColor = true;
            // 
            // CarboZALF_calib_stabilizationages_checkbox
            // 
            this.CarboZALF_calib_stabilizationages_checkbox.AutoSize = true;
            this.CarboZALF_calib_stabilizationages_checkbox.Location = new System.Drawing.Point(174, 170);
            this.CarboZALF_calib_stabilizationages_checkbox.Name = "CarboZALF_calib_stabilizationages_checkbox";
            this.CarboZALF_calib_stabilizationages_checkbox.Size = new System.Drawing.Size(150, 17);
            this.CarboZALF_calib_stabilizationages_checkbox.TabIndex = 15;
            this.CarboZALF_calib_stabilizationages_checkbox.Text = "Calibrate stabilization ages";
            this.CarboZALF_calib_stabilizationages_checkbox.UseVisualStyleBackColor = true;
            // 
            // version_CarboZALF_checkbox
            // 
            this.version_CarboZALF_checkbox.AutoSize = true;
            this.version_CarboZALF_checkbox.Location = new System.Drawing.Point(48, 170);
            this.version_CarboZALF_checkbox.Name = "version_CarboZALF_checkbox";
            this.version_CarboZALF_checkbox.Size = new System.Drawing.Size(117, 17);
            this.version_CarboZALF_checkbox.TabIndex = 14;
            this.version_CarboZALF_checkbox.Text = "CarboZALF version";
            this.version_CarboZALF_checkbox.UseVisualStyleBackColor = true;
            // 
            // ux_number_Processors_label
            // 
            this.ux_number_Processors_label.AutoSize = true;
            this.ux_number_Processors_label.Location = new System.Drawing.Point(135, 231);
            this.ux_number_Processors_label.Name = "ux_number_Processors_label";
            this.ux_number_Processors_label.Size = new System.Drawing.Size(60, 13);
            this.ux_number_Processors_label.TabIndex = 13;
            this.ux_number_Processors_label.Text = "cores, and ";
            // 
            // version_Konza_checkbox
            // 
            this.version_Konza_checkbox.AutoSize = true;
            this.version_Konza_checkbox.Location = new System.Drawing.Point(174, 126);
            this.version_Konza_checkbox.Name = "version_Konza_checkbox";
            this.version_Konza_checkbox.Size = new System.Drawing.Size(93, 17);
            this.version_Konza_checkbox.TabIndex = 12;
            this.version_Konza_checkbox.Text = "Konza version";
            this.version_Konza_checkbox.UseVisualStyleBackColor = true;
            // 
            // uxThreadLabel
            // 
            this.uxThreadLabel.AutoSize = true;
            this.uxThreadLabel.Location = new System.Drawing.Point(263, 260);
            this.uxThreadLabel.Name = "uxThreadLabel";
            this.uxThreadLabel.Size = new System.Drawing.Size(46, 13);
            this.uxThreadLabel.TabIndex = 11;
            this.uxThreadLabel.Text = "Threads";
            // 
            // uxNumberCoresLabel
            // 
            this.uxNumberCoresLabel.AutoSize = true;
            this.uxNumberCoresLabel.Location = new System.Drawing.Point(26, 231);
            this.uxNumberCoresLabel.Name = "uxNumberCoresLabel";
            this.uxNumberCoresLabel.Size = new System.Drawing.Size(93, 13);
            this.uxNumberCoresLabel.TabIndex = 10;
            this.uxNumberCoresLabel.Text = "This machine has ";
            // 
            // uxNumberLogicalProcessorsLabel
            // 
            this.uxNumberLogicalProcessorsLabel.AutoSize = true;
            this.uxNumberLogicalProcessorsLabel.Location = new System.Drawing.Point(210, 231);
            this.uxNumberLogicalProcessorsLabel.Name = "uxNumberLogicalProcessorsLabel";
            this.uxNumberLogicalProcessorsLabel.Size = new System.Drawing.Size(94, 13);
            this.uxNumberLogicalProcessorsLabel.TabIndex = 9;
            this.uxNumberLogicalProcessorsLabel.Text = "logical  processors";
            // 
            // uxNumberThreadsUpdown
            // 
            this.uxNumberThreadsUpdown.Location = new System.Drawing.Point(202, 258);
            this.uxNumberThreadsUpdown.Maximum = new decimal(new int[] {
            64,
            0,
            0,
            0});
            this.uxNumberThreadsUpdown.Minimum = new decimal(new int[] {
            1,
            0,
            0,
            0});
            this.uxNumberThreadsUpdown.Name = "uxNumberThreadsUpdown";
            this.uxNumberThreadsUpdown.Size = new System.Drawing.Size(55, 20);
            this.uxNumberThreadsUpdown.TabIndex = 8;
            this.uxNumberThreadsUpdown.Value = new decimal(new int[] {
            1,
            0,
            0,
            0});
            // 
            // button4
            // 
            this.button4.Location = new System.Drawing.Point(48, 187);
            this.button4.Name = "button4";
            this.button4.Size = new System.Drawing.Size(163, 41);
            this.button4.TabIndex = 7;
            this.button4.Text = "now purely calculate terrain derivatives";
            this.button4.UseVisualStyleBackColor = true;
            this.button4.Click += new System.EventHandler(this.button4_Click);
            // 
            // version_lux_checkbox
            // 
            this.version_lux_checkbox.AutoSize = true;
            this.version_lux_checkbox.Location = new System.Drawing.Point(48, 147);
            this.version_lux_checkbox.Name = "version_lux_checkbox";
            this.version_lux_checkbox.Size = new System.Drawing.Size(115, 17);
            this.version_lux_checkbox.TabIndex = 6;
            this.version_lux_checkbox.Text = "Luxemburg version";
            this.version_lux_checkbox.UseVisualStyleBackColor = true;
            // 
            // groupBox2
            // 
            this.groupBox2.Controls.Add(this.num_cal_paras_textbox);
            this.groupBox2.Controls.Add(this.label33);
            this.groupBox2.Controls.Add(this.obsfile_textbox);
            this.groupBox2.Controls.Add(this.label120);
            this.groupBox2.Controls.Add(this.calibration_ratio_reduction_parameter_textbox);
            this.groupBox2.Controls.Add(this.label119);
            this.groupBox2.Controls.Add(this.calibration_levels_textbox);
            this.groupBox2.Controls.Add(this.label116);
            this.groupBox2.Controls.Add(this.label118);
            this.groupBox2.Controls.Add(this.label117);
            this.groupBox2.Controls.Add(this.label115);
            this.groupBox2.Controls.Add(this.label114);
            this.groupBox2.Controls.Add(this.Sensitivity_button);
            this.groupBox2.Controls.Add(this.Calibration_button);
            this.groupBox2.Controls.Add(this.label113);
            this.groupBox2.Controls.Add(this.calibration_ratios_textbox);
            this.groupBox2.Location = new System.Drawing.Point(346, 32);
            this.groupBox2.Name = "groupBox2";
            this.groupBox2.Size = new System.Drawing.Size(422, 246);
            this.groupBox2.TabIndex = 4;
            this.groupBox2.TabStop = false;
            this.groupBox2.Text = "Calibration / sensitivity options";
            // 
            // num_cal_paras_textbox
            // 
            this.num_cal_paras_textbox.Location = new System.Drawing.Point(338, 73);
            this.num_cal_paras_textbox.Name = "num_cal_paras_textbox";
            this.num_cal_paras_textbox.Size = new System.Drawing.Size(65, 20);
            this.num_cal_paras_textbox.TabIndex = 16;
            this.num_cal_paras_textbox.Text = "1";
            // 
            // label33
            // 
            this.label33.AutoSize = true;
            this.label33.Location = new System.Drawing.Point(39, 177);
            this.label33.Name = "label33";
            this.label33.Size = new System.Drawing.Size(116, 13);
            this.label33.TabIndex = 15;
            this.label33.Text = "observations (optional):";
            // 
            // obsfile_textbox
            // 
            this.obsfile_textbox.Location = new System.Drawing.Point(218, 174);
            this.obsfile_textbox.Name = "obsfile_textbox";
            this.obsfile_textbox.Size = new System.Drawing.Size(186, 20);
            this.obsfile_textbox.TabIndex = 14;
            this.obsfile_textbox.Text = "..";
            this.obsfile_textbox.Click += new System.EventHandler(this.obsfile_textbox_Click);
            // 
            // label120
            // 
            this.label120.AutoSize = true;
            this.label120.Location = new System.Drawing.Point(39, 226);
            this.label120.Name = "label120";
            this.label120.Size = new System.Drawing.Size(199, 13);
            this.label120.TabIndex = 13;
            this.label120.Text = "1. describe the parameter values in code";
            // 
            // calibration_ratio_reduction_parameter_textbox
            // 
            this.calibration_ratio_reduction_parameter_textbox.Location = new System.Drawing.Point(338, 148);
            this.calibration_ratio_reduction_parameter_textbox.Name = "calibration_ratio_reduction_parameter_textbox";
            this.calibration_ratio_reduction_parameter_textbox.Size = new System.Drawing.Size(66, 20);
            this.calibration_ratio_reduction_parameter_textbox.TabIndex = 12;
            this.calibration_ratio_reduction_parameter_textbox.Text = "1.5";
            // 
            // label119
            // 
            this.label119.AutoSize = true;
            this.label119.Location = new System.Drawing.Point(39, 151);
            this.label119.Name = "label119";
            this.label119.Size = new System.Drawing.Size(208, 13);
            this.label119.TabIndex = 11;
            this.label119.Text = "5. reduction of variations per level (if smart)";
            // 
            // calibration_levels_textbox
            // 
            this.calibration_levels_textbox.Location = new System.Drawing.Point(338, 124);
            this.calibration_levels_textbox.Name = "calibration_levels_textbox";
            this.calibration_levels_textbox.Size = new System.Drawing.Size(66, 20);
            this.calibration_levels_textbox.TabIndex = 10;
            this.calibration_levels_textbox.Text = "3";
            // 
            // label116
            // 
            this.label116.AutoSize = true;
            this.label116.Location = new System.Drawing.Point(194, 35);
            this.label116.Name = "label116";
            this.label116.Size = new System.Drawing.Size(210, 13);
            this.label116.TabIndex = 9;
            this.label116.Text = "The optimal set of parameters will be stored";
            // 
            // label118
            // 
            this.label118.AutoSize = true;
            this.label118.Location = new System.Drawing.Point(39, 127);
            this.label118.Name = "label118";
            this.label118.Size = new System.Drawing.Size(97, 13);
            this.label118.TabIndex = 8;
            this.label118.Text = "4. levels (iterations)";
            // 
            // label117
            // 
            this.label117.AutoSize = true;
            this.label117.Location = new System.Drawing.Point(39, 80);
            this.label117.Name = "label117";
            this.label117.Size = new System.Drawing.Size(176, 13);
            this.label117.TabIndex = 7;
            this.label117.Text = "2. number of parameters to calibrate";
            // 
            // label115
            // 
            this.label115.AutoSize = true;
            this.label115.Location = new System.Drawing.Point(39, 56);
            this.label115.Name = "label115";
            this.label115.Size = new System.Drawing.Size(350, 13);
            this.label115.TabIndex = 5;
            this.label115.Text = "1. define objective function in code, and describe parameters to calibrate";
            // 
            // label114
            // 
            this.label114.AutoSize = true;
            this.label114.Location = new System.Drawing.Point(39, 102);
            this.label114.Name = "label114";
            this.label114.Size = new System.Drawing.Size(132, 13);
            this.label114.TabIndex = 4;
            this.label114.Text = "3. variations per parameter";
            // 
            // Sensitivity_button
            // 
            this.Sensitivity_button.AutoSize = true;
            this.Sensitivity_button.Location = new System.Drawing.Point(22, 195);
            this.Sensitivity_button.Name = "Sensitivity_button";
            this.Sensitivity_button.Size = new System.Drawing.Size(200, 17);
            this.Sensitivity_button.TabIndex = 3;
            this.Sensitivity_button.Text = "Run sensitivity analysis (non-iterative)";
            this.Sensitivity_button.UseVisualStyleBackColor = true;
            this.Sensitivity_button.CheckedChanged += new System.EventHandler(this.radioButton2_CheckedChanged);
            // 
            // Calibration_button
            // 
            this.Calibration_button.AutoSize = true;
            this.Calibration_button.Location = new System.Drawing.Point(22, 33);
            this.Calibration_button.Name = "Calibration_button";
            this.Calibration_button.Size = new System.Drawing.Size(142, 17);
            this.Calibration_button.TabIndex = 2;
            this.Calibration_button.Text = "Run calibration (iterative)";
            this.Calibration_button.UseVisualStyleBackColor = true;
            this.Calibration_button.CheckedChanged += new System.EventHandler(this.radioButton1_CheckedChanged);
            // 
            // label113
            // 
            this.label113.AutoSize = true;
            this.label113.Location = new System.Drawing.Point(73, 39);
            this.label113.Name = "label113";
            this.label113.Size = new System.Drawing.Size(0, 13);
            this.label113.TabIndex = 1;
            // 
            // calibration_ratios_textbox
            // 
            this.calibration_ratios_textbox.Location = new System.Drawing.Point(218, 99);
            this.calibration_ratios_textbox.Name = "calibration_ratios_textbox";
            this.calibration_ratios_textbox.Size = new System.Drawing.Size(186, 20);
            this.calibration_ratios_textbox.TabIndex = 0;
            this.calibration_ratios_textbox.Text = "0.25;0.5;1;2;4";
            // 
            // calibration
            // 
            this.calibration.AutoSize = true;
            this.calibration.Location = new System.Drawing.Point(174, 147);
            this.calibration.Name = "calibration";
            this.calibration.Size = new System.Drawing.Size(125, 17);
            this.calibration.TabIndex = 5;
            this.calibration.Text = "Lessivage calibration";
            this.calibration.UseVisualStyleBackColor = true;
            // 
            // Spitsbergen_case_study
            // 
            this.Spitsbergen_case_study.AutoSize = true;
            this.Spitsbergen_case_study.Location = new System.Drawing.Point(48, 126);
            this.Spitsbergen_case_study.Name = "Spitsbergen_case_study";
            this.Spitsbergen_case_study.Size = new System.Drawing.Size(119, 17);
            this.Spitsbergen_case_study.TabIndex = 4;
            this.Spitsbergen_case_study.Text = "Spitsbergen version";
            this.Spitsbergen_case_study.UseVisualStyleBackColor = true;
            // 
            // groupBox7
            // 
            this.groupBox7.Controls.Add(this.checkbox_t_intervene);
            this.groupBox7.Controls.Add(this.textbox_t_intervene);
            this.groupBox7.Controls.Add(this.runs_checkbox);
            this.groupBox7.Controls.Add(this.label16);
            this.groupBox7.Controls.Add(this.Number_runs_textbox);
            this.groupBox7.Location = new System.Drawing.Point(48, 32);
            this.groupBox7.Name = "groupBox7";
            this.groupBox7.Size = new System.Drawing.Size(277, 88);
            this.groupBox7.TabIndex = 3;
            this.groupBox7.TabStop = false;
            this.groupBox7.Text = "Please specify  the number of timesteps per run";
            // 
            // textbox_t_intervene
            // 
            this.textbox_t_intervene.Location = new System.Drawing.Point(190, 60);
            this.textbox_t_intervene.Name = "textbox_t_intervene";
            this.textbox_t_intervene.Size = new System.Drawing.Size(55, 20);
            this.textbox_t_intervene.TabIndex = 3;
            this.textbox_t_intervene.Text = "0";
            // 
            // runs_checkbox
            // 
            this.runs_checkbox.AutoSize = true;
            this.runs_checkbox.Checked = true;
            this.runs_checkbox.Location = new System.Drawing.Point(54, 33);
            this.runs_checkbox.Name = "runs_checkbox";
            this.runs_checkbox.Size = new System.Drawing.Size(79, 17);
            this.runs_checkbox.TabIndex = 2;
            this.runs_checkbox.TabStop = true;
            this.runs_checkbox.Text = "runs (years)";
            this.runs_checkbox.UseVisualStyleBackColor = true;
            // 
            // label16
            // 
            this.label16.AutoSize = true;
            this.label16.Location = new System.Drawing.Point(73, 39);
            this.label16.Name = "label16";
            this.label16.Size = new System.Drawing.Size(0, 13);
            this.label16.TabIndex = 1;
            // 
            // Number_runs_textbox
            // 
            this.Number_runs_textbox.Location = new System.Drawing.Point(190, 30);
            this.Number_runs_textbox.Name = "Number_runs_textbox";
            this.Number_runs_textbox.Size = new System.Drawing.Size(55, 20);
            this.Number_runs_textbox.TabIndex = 0;
            this.Number_runs_textbox.Text = "1";
            // 
            // Input
            // 
            this.Input.Controls.Add(this.textbox_layer_thickness);
            this.Input.Controls.Add(this.checkbox_layer_thickness);
            this.Input.Controls.Add(this.label_max_soil_layers);
            this.Input.Controls.Add(this.textbox_max_soil_layers);
            this.Input.Controls.Add(this.check_time_T);
            this.Input.Controls.Add(this.label99);
            this.Input.Controls.Add(this.label98);
            this.Input.Controls.Add(this.temp_input_filename_textbox);
            this.Input.Controls.Add(this.temp_constant_value_box);
            this.Input.Controls.Add(this.soil_specify_button);
            this.Input.Controls.Add(this.label88);
            this.Input.Controls.Add(this.groupBox3);
            this.Input.Controls.Add(this.explain_input_button);
            this.Input.Controls.Add(this.check_time_evap);
            this.Input.Controls.Add(this.check_time_infil);
            this.Input.Controls.Add(this.check_time_rain);
            this.Input.Controls.Add(this.check_time_till_fields);
            this.Input.Controls.Add(this.check_time_landuse);
            this.Input.Controls.Add(this.label29);
            this.Input.Controls.Add(this.check_space_DTM);
            this.Input.Controls.Add(this.groupBox13);
            this.Input.Controls.Add(this.tillfields_constant_textbox);
            this.Input.Controls.Add(this.tillfields_input_filename_textbox);
            this.Input.Controls.Add(this.evap_constant_value_box);
            this.Input.Controls.Add(this.evap_input_filename_textbox);
            this.Input.Controls.Add(this.infil_constant_value_box);
            this.Input.Controls.Add(this.infil_input_filename_textbox);
            this.Input.Controls.Add(this.rainfall_constant_value_box);
            this.Input.Controls.Add(this.landuse_constant_value_box);
            this.Input.Controls.Add(this.soildepth_constant_value_box);
            this.Input.Controls.Add(this.landuse_input_filename_textbox);
            this.Input.Controls.Add(this.soildepth_input_filename_textbox);
            this.Input.Controls.Add(this.rain_input_filename_textbox);
            this.Input.Controls.Add(this.dtm_input_filename_textbox);
            this.Input.Controls.Add(this.groupBox8);
            this.Input.Controls.Add(this.check_space_evap);
            this.Input.Controls.Add(this.check_space_infil);
            this.Input.Controls.Add(this.check_space_rain);
            this.Input.Controls.Add(this.check_space_till_fields);
            this.Input.Controls.Add(this.check_space_landuse);
            this.Input.Controls.Add(this.check_space_soildepth);
            this.Input.Controls.Add(this.label17);
            this.Input.Controls.Add(this.label15);
            this.Input.Controls.Add(this.label14);
            this.Input.Controls.Add(this.label7);
            this.Input.Controls.Add(label6);
            this.Input.Controls.Add(this.label5);
            this.Input.Controls.Add(this.label4);
            this.Input.Controls.Add(this.label3);
            this.Input.Controls.Add(this.label25);
            this.Input.Controls.Add(this.label23);
            this.Input.Location = new System.Drawing.Point(4, 22);
            this.Input.Name = "Input";
            this.Input.Size = new System.Drawing.Size(803, 293);
            this.Input.TabIndex = 0;
            this.Input.Text = "Inputs";
            this.Input.UseVisualStyleBackColor = true;
            // 
            // textbox_layer_thickness
            // 
            this.textbox_layer_thickness.Location = new System.Drawing.Point(736, 265);
            this.textbox_layer_thickness.Name = "textbox_layer_thickness";
            this.textbox_layer_thickness.Size = new System.Drawing.Size(50, 20);
            this.textbox_layer_thickness.TabIndex = 158;
            this.textbox_layer_thickness.Text = "0.10";
            // 
            // checkbox_layer_thickness
            // 
            this.checkbox_layer_thickness.AutoSize = true;
            this.checkbox_layer_thickness.Checked = true;
            this.checkbox_layer_thickness.CheckState = System.Windows.Forms.CheckState.Checked;
            this.checkbox_layer_thickness.Location = new System.Drawing.Point(558, 266);
            this.checkbox_layer_thickness.Name = "checkbox_layer_thickness";
            this.checkbox_layer_thickness.Size = new System.Drawing.Size(130, 17);
            this.checkbox_layer_thickness.TabIndex = 157;
            this.checkbox_layer_thickness.Text = "Fixed layer thickness?";
            this.checkbox_layer_thickness.UseVisualStyleBackColor = true;
            this.checkbox_layer_thickness.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged_3);
            // 
            // label_max_soil_layers
            // 
            this.label_max_soil_layers.AutoSize = true;
            this.label_max_soil_layers.Location = new System.Drawing.Point(586, 242);
            this.label_max_soil_layers.Name = "label_max_soil_layers";
            this.label_max_soil_layers.Size = new System.Drawing.Size(104, 13);
            this.label_max_soil_layers.TabIndex = 156;
            this.label_max_soil_layers.Text = "Number of soil layers";
            // 
            // textbox_max_soil_layers
            // 
            this.textbox_max_soil_layers.Location = new System.Drawing.Point(736, 241);
            this.textbox_max_soil_layers.Name = "textbox_max_soil_layers";
            this.textbox_max_soil_layers.Size = new System.Drawing.Size(50, 20);
            this.textbox_max_soil_layers.TabIndex = 155;
            this.textbox_max_soil_layers.Text = "25";
            // 
            // check_time_T
            // 
            this.check_time_T.AutoSize = true;
            this.check_time_T.Enabled = false;
            this.check_time_T.Location = new System.Drawing.Point(220, 251);
            this.check_time_T.Name = "check_time_T";
            this.check_time_T.Size = new System.Drawing.Size(15, 14);
            this.check_time_T.TabIndex = 154;
            this.check_time_T.UseVisualStyleBackColor = true;
            // 
            // temp_input_filename_textbox
            // 
            this.temp_input_filename_textbox.Enabled = false;
            this.temp_input_filename_textbox.Location = new System.Drawing.Point(258, 245);
            this.temp_input_filename_textbox.Name = "temp_input_filename_textbox";
            this.temp_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.temp_input_filename_textbox.TabIndex = 151;
            this.temp_input_filename_textbox.Text = "..";
            this.temp_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // temp_constant_value_box
            // 
            this.temp_constant_value_box.Enabled = false;
            this.temp_constant_value_box.Location = new System.Drawing.Point(410, 245);
            this.temp_constant_value_box.Name = "temp_constant_value_box";
            this.temp_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.temp_constant_value_box.TabIndex = 150;
            this.temp_constant_value_box.Text = "10";
            // 
            // soil_specify_button
            // 
            this.soil_specify_button.Location = new System.Drawing.Point(188, 95);
            this.soil_specify_button.Name = "soil_specify_button";
            this.soil_specify_button.Size = new System.Drawing.Size(63, 20);
            this.soil_specify_button.TabIndex = 149;
            this.soil_specify_button.Text = "specify ..";
            this.soil_specify_button.UseVisualStyleBackColor = true;
            this.soil_specify_button.Click += new System.EventHandler(this.soil_specify_button_Click);
            // 
            // label88
            // 
            this.label88.Location = new System.Drawing.Point(19, 95);
            this.label88.Name = "label88";
            this.label88.Size = new System.Drawing.Size(104, 24);
            this.label88.TabIndex = 148;
            this.label88.Text = "soilproperties";
            this.label88.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // explain_input_button
            // 
            this.explain_input_button.Location = new System.Drawing.Point(315, 25);
            this.explain_input_button.Name = "explain_input_button";
            this.explain_input_button.Size = new System.Drawing.Size(63, 20);
            this.explain_input_button.TabIndex = 147;
            this.explain_input_button.Text = "explain..";
            this.explain_input_button.UseVisualStyleBackColor = true;
            this.explain_input_button.Click += new System.EventHandler(this.button8_Click);
            // 
            // check_time_evap
            // 
            this.check_time_evap.AutoSize = true;
            this.check_time_evap.Location = new System.Drawing.Point(220, 222);
            this.check_time_evap.Name = "check_time_evap";
            this.check_time_evap.Size = new System.Drawing.Size(15, 14);
            this.check_time_evap.TabIndex = 145;
            this.check_time_evap.UseVisualStyleBackColor = true;
            this.check_time_evap.CheckedChanged += new System.EventHandler(this.check_time_evap_CheckedChanged);
            // 
            // check_time_infil
            // 
            this.check_time_infil.AutoSize = true;
            this.check_time_infil.Location = new System.Drawing.Point(220, 198);
            this.check_time_infil.Name = "check_time_infil";
            this.check_time_infil.Size = new System.Drawing.Size(15, 14);
            this.check_time_infil.TabIndex = 144;
            this.check_time_infil.UseVisualStyleBackColor = true;
            this.check_time_infil.CheckedChanged += new System.EventHandler(this.check_time_infil_CheckedChanged);
            // 
            // check_time_rain
            // 
            this.check_time_rain.AutoSize = true;
            this.check_time_rain.Location = new System.Drawing.Point(220, 174);
            this.check_time_rain.Name = "check_time_rain";
            this.check_time_rain.Size = new System.Drawing.Size(15, 14);
            this.check_time_rain.TabIndex = 143;
            this.check_time_rain.UseVisualStyleBackColor = true;
            this.check_time_rain.CheckedChanged += new System.EventHandler(this.check_time_rain_CheckedChanged);
            // 
            // check_time_till_fields
            // 
            this.check_time_till_fields.AutoSize = true;
            this.check_time_till_fields.Location = new System.Drawing.Point(220, 150);
            this.check_time_till_fields.Name = "check_time_till_fields";
            this.check_time_till_fields.Size = new System.Drawing.Size(15, 14);
            this.check_time_till_fields.TabIndex = 142;
            this.check_time_till_fields.UseVisualStyleBackColor = true;
            this.check_time_till_fields.CheckedChanged += new System.EventHandler(this.check_time_tillage_CheckedChanged);
            // 
            // check_time_landuse
            // 
            this.check_time_landuse.AutoSize = true;
            this.check_time_landuse.Location = new System.Drawing.Point(220, 123);
            this.check_time_landuse.Name = "check_time_landuse";
            this.check_time_landuse.Size = new System.Drawing.Size(15, 14);
            this.check_time_landuse.TabIndex = 141;
            this.check_time_landuse.UseVisualStyleBackColor = true;
            this.check_time_landuse.CheckedChanged += new System.EventHandler(this.check_time_landuse_CheckedChanged);
            // 
            // check_space_DTM
            // 
            this.check_space_DTM.AutoSize = true;
            this.check_space_DTM.Checked = true;
            this.check_space_DTM.CheckState = System.Windows.Forms.CheckState.Checked;
            this.check_space_DTM.Enabled = false;
            this.check_space_DTM.Location = new System.Drawing.Point(188, 51);
            this.check_space_DTM.Name = "check_space_DTM";
            this.check_space_DTM.Size = new System.Drawing.Size(15, 14);
            this.check_space_DTM.TabIndex = 138;
            this.check_space_DTM.UseVisualStyleBackColor = true;
            // 
            // tillfields_constant_textbox
            // 
            this.tillfields_constant_textbox.Location = new System.Drawing.Point(410, 145);
            this.tillfields_constant_textbox.Name = "tillfields_constant_textbox";
            this.tillfields_constant_textbox.ReadOnly = true;
            this.tillfields_constant_textbox.Size = new System.Drawing.Size(120, 20);
            this.tillfields_constant_textbox.TabIndex = 123;
            this.tillfields_constant_textbox.Text = "1";
            // 
            // tillfields_input_filename_textbox
            // 
            this.tillfields_input_filename_textbox.Enabled = false;
            this.tillfields_input_filename_textbox.Location = new System.Drawing.Point(258, 145);
            this.tillfields_input_filename_textbox.Name = "tillfields_input_filename_textbox";
            this.tillfields_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.tillfields_input_filename_textbox.TabIndex = 122;
            this.tillfields_input_filename_textbox.Text = "..";
            this.tillfields_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.tillfields_input_filename_textbox.Click += new System.EventHandler(this.tillfields_input_filename_textbox_TextChanged);
            // 
            // evap_constant_value_box
            // 
            this.evap_constant_value_box.Location = new System.Drawing.Point(410, 219);
            this.evap_constant_value_box.Name = "evap_constant_value_box";
            this.evap_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.evap_constant_value_box.TabIndex = 120;
            this.evap_constant_value_box.Text = "0.35";
            // 
            // evap_input_filename_textbox
            // 
            this.evap_input_filename_textbox.Enabled = false;
            this.evap_input_filename_textbox.Location = new System.Drawing.Point(258, 219);
            this.evap_input_filename_textbox.Name = "evap_input_filename_textbox";
            this.evap_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.evap_input_filename_textbox.TabIndex = 119;
            this.evap_input_filename_textbox.Text = "..";
            this.evap_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.evap_input_filename_textbox.Click += new System.EventHandler(this.evap_input_filename_textbox_TextChanged);
            // 
            // infil_constant_value_box
            // 
            this.infil_constant_value_box.Location = new System.Drawing.Point(410, 193);
            this.infil_constant_value_box.Name = "infil_constant_value_box";
            this.infil_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.infil_constant_value_box.TabIndex = 117;
            this.infil_constant_value_box.Text = "0.150";
            // 
            // infil_input_filename_textbox
            // 
            this.infil_input_filename_textbox.Enabled = false;
            this.infil_input_filename_textbox.Location = new System.Drawing.Point(258, 193);
            this.infil_input_filename_textbox.Name = "infil_input_filename_textbox";
            this.infil_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.infil_input_filename_textbox.TabIndex = 116;
            this.infil_input_filename_textbox.Text = "..";
            this.infil_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.infil_input_filename_textbox.Click += new System.EventHandler(this.infil_input_filename_textbox_TextChanged);
            // 
            // rainfall_constant_value_box
            // 
            this.rainfall_constant_value_box.Location = new System.Drawing.Point(410, 169);
            this.rainfall_constant_value_box.Name = "rainfall_constant_value_box";
            this.rainfall_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.rainfall_constant_value_box.TabIndex = 114;
            this.rainfall_constant_value_box.Text = "0.700";
            // 
            // landuse_constant_value_box
            // 
            this.landuse_constant_value_box.Location = new System.Drawing.Point(410, 120);
            this.landuse_constant_value_box.Name = "landuse_constant_value_box";
            this.landuse_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.landuse_constant_value_box.TabIndex = 113;
            this.landuse_constant_value_box.Text = "1";
            // 
            // soildepth_constant_value_box
            // 
            this.soildepth_constant_value_box.Location = new System.Drawing.Point(410, 76);
            this.soildepth_constant_value_box.Name = "soildepth_constant_value_box";
            this.soildepth_constant_value_box.Size = new System.Drawing.Size(120, 20);
            this.soildepth_constant_value_box.TabIndex = 112;
            this.soildepth_constant_value_box.Text = "5";
            // 
            // landuse_input_filename_textbox
            // 
            this.landuse_input_filename_textbox.Location = new System.Drawing.Point(258, 118);
            this.landuse_input_filename_textbox.Name = "landuse_input_filename_textbox";
            this.landuse_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.landuse_input_filename_textbox.TabIndex = 107;
            this.landuse_input_filename_textbox.Text = "..";
            this.landuse_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.landuse_input_filename_textbox.Click += new System.EventHandler(this.landuse_input_filename_textbox_TextChanged);
            // 
            // soildepth_input_filename_textbox
            // 
            this.soildepth_input_filename_textbox.Location = new System.Drawing.Point(258, 76);
            this.soildepth_input_filename_textbox.Name = "soildepth_input_filename_textbox";
            this.soildepth_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.soildepth_input_filename_textbox.TabIndex = 105;
            this.soildepth_input_filename_textbox.Text = "..";
            this.soildepth_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.soildepth_input_filename_textbox.Click += new System.EventHandler(this.soildepth_input_filename_textbox_TextChanged);
            // 
            // rain_input_filename_textbox
            // 
            this.rain_input_filename_textbox.Enabled = false;
            this.rain_input_filename_textbox.Location = new System.Drawing.Point(258, 169);
            this.rain_input_filename_textbox.Name = "rain_input_filename_textbox";
            this.rain_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.rain_input_filename_textbox.TabIndex = 103;
            this.rain_input_filename_textbox.Text = "..";
            this.rain_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.rain_input_filename_textbox.Click += new System.EventHandler(this.rain_input_filename_textbox_TextChanged);
            // 
            // dtm_input_filename_textbox
            // 
            this.dtm_input_filename_textbox.Location = new System.Drawing.Point(258, 50);
            this.dtm_input_filename_textbox.Name = "dtm_input_filename_textbox";
            this.dtm_input_filename_textbox.Size = new System.Drawing.Size(120, 20);
            this.dtm_input_filename_textbox.TabIndex = 100;
            this.dtm_input_filename_textbox.Text = "..";
            this.dtm_input_filename_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            this.dtm_input_filename_textbox.Click += new System.EventHandler(this.dtm_input_filename_textbox_Click);
            // 
            // groupBox8
            // 
            this.groupBox8.Controls.Add(this.fill_sinks_before_checkbox);
            this.groupBox8.Location = new System.Drawing.Point(589, 37);
            this.groupBox8.Name = "groupBox8";
            this.groupBox8.Size = new System.Drawing.Size(158, 48);
            this.groupBox8.TabIndex = 134;
            this.groupBox8.TabStop = false;
            this.groupBox8.Text = "before running: ";
            // 
            // check_space_evap
            // 
            this.check_space_evap.AutoSize = true;
            this.check_space_evap.Location = new System.Drawing.Point(188, 222);
            this.check_space_evap.Name = "check_space_evap";
            this.check_space_evap.Size = new System.Drawing.Size(15, 14);
            this.check_space_evap.TabIndex = 130;
            this.check_space_evap.UseVisualStyleBackColor = true;
            this.check_space_evap.CheckedChanged += new System.EventHandler(this.check_cnst_evap_CheckedChanged);
            // 
            // check_space_infil
            // 
            this.check_space_infil.AutoSize = true;
            this.check_space_infil.Location = new System.Drawing.Point(188, 198);
            this.check_space_infil.Name = "check_space_infil";
            this.check_space_infil.Size = new System.Drawing.Size(15, 14);
            this.check_space_infil.TabIndex = 129;
            this.check_space_infil.UseVisualStyleBackColor = true;
            this.check_space_infil.CheckedChanged += new System.EventHandler(this.check_cnst_infil_CheckedChanged);
            // 
            // check_space_rain
            // 
            this.check_space_rain.AutoSize = true;
            this.check_space_rain.Location = new System.Drawing.Point(188, 174);
            this.check_space_rain.Name = "check_space_rain";
            this.check_space_rain.Size = new System.Drawing.Size(15, 14);
            this.check_space_rain.TabIndex = 128;
            this.check_space_rain.UseVisualStyleBackColor = true;
            this.check_space_rain.CheckedChanged += new System.EventHandler(this.check_cnst_rain_CheckedChanged_1);
            // 
            // check_space_till_fields
            // 
            this.check_space_till_fields.AutoSize = true;
            this.check_space_till_fields.Location = new System.Drawing.Point(188, 150);
            this.check_space_till_fields.Name = "check_space_till_fields";
            this.check_space_till_fields.Size = new System.Drawing.Size(15, 14);
            this.check_space_till_fields.TabIndex = 127;
            this.check_space_till_fields.UseVisualStyleBackColor = true;
            this.check_space_till_fields.CheckedChanged += new System.EventHandler(this.check_cnst_till_fields_CheckedChanged);
            // 
            // check_space_landuse
            // 
            this.check_space_landuse.AutoSize = true;
            this.check_space_landuse.Location = new System.Drawing.Point(188, 123);
            this.check_space_landuse.Name = "check_space_landuse";
            this.check_space_landuse.Size = new System.Drawing.Size(15, 14);
            this.check_space_landuse.TabIndex = 126;
            this.check_space_landuse.UseVisualStyleBackColor = true;
            this.check_space_landuse.CheckedChanged += new System.EventHandler(this.check_cnst_landuse_CheckedChanged_1);
            // 
            // check_space_soildepth
            // 
            this.check_space_soildepth.AutoSize = true;
            this.check_space_soildepth.Location = new System.Drawing.Point(188, 76);
            this.check_space_soildepth.Name = "check_space_soildepth";
            this.check_space_soildepth.Size = new System.Drawing.Size(15, 14);
            this.check_space_soildepth.TabIndex = 125;
            this.check_space_soildepth.UseVisualStyleBackColor = true;
            this.check_space_soildepth.CheckedChanged += new System.EventHandler(this.check_cnst_soildepth_CheckedChanged_1);
            // 
            // label4
            // 
            this.label4.Location = new System.Drawing.Point(19, 116);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(104, 24);
            this.label4.TabIndex = 106;
            this.label4.Text = "landuse (classes)";
            this.label4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label3
            // 
            this.label3.Location = new System.Drawing.Point(19, 71);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(104, 24);
            this.label3.TabIndex = 104;
            this.label3.Text = "soildepth [m]";
            this.label3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // label23
            // 
            this.label23.Location = new System.Drawing.Point(19, 45);
            this.label23.Name = "label23";
            this.label23.Size = new System.Drawing.Size(134, 24);
            this.label23.TabIndex = 56;
            this.label23.Text = "Digital Elevation Model [m]";
            this.label23.TextAlign = System.Drawing.ContentAlignment.MiddleLeft;
            // 
            // Processes
            // 
            this.Processes.Controls.Add(this.Process_tabs);
            this.Processes.Location = new System.Drawing.Point(4, 22);
            this.Processes.Name = "Processes";
            this.Processes.Size = new System.Drawing.Size(803, 293);
            this.Processes.TabIndex = 6;
            this.Processes.Text = "Geomorphic processes";
            this.Processes.UseVisualStyleBackColor = true;
            // 
            // Process_tabs
            // 
            this.Process_tabs.Controls.Add(this.Water);
            this.Process_tabs.Controls.Add(this.Tillage);
            this.Process_tabs.Controls.Add(this.Creeper);
            this.Process_tabs.Controls.Add(Landsliding);
            this.Process_tabs.Controls.Add(this.Solifluction);
            this.Process_tabs.Controls.Add(this.Rock_weathering);
            this.Process_tabs.Controls.Add(this.Tectonics);
            this.Process_tabs.Controls.Add(this.treefall);
            this.Process_tabs.Controls.Add(this.tabPage6);
            this.Process_tabs.Location = new System.Drawing.Point(8, 14);
            this.Process_tabs.MaximumSize = new System.Drawing.Size(740, 276);
            this.Process_tabs.MinimumSize = new System.Drawing.Size(740, 276);
            this.Process_tabs.Name = "Process_tabs";
            this.Process_tabs.SelectedIndex = 0;
            this.Process_tabs.Size = new System.Drawing.Size(740, 276);
            this.Process_tabs.TabIndex = 0;
            // 
            // Water
            // 
            this.Water.Controls.Add(this.daily_water);
            this.Water.Controls.Add(this.label87);
            this.Water.Controls.Add(this.selectivity_constant_textbox);
            this.Water.Controls.Add(this.bio_protection_constant_textbox);
            this.Water.Controls.Add(this.erosion_threshold_textbox);
            this.Water.Controls.Add(this.rock_protection_constant_textbox);
            this.Water.Controls.Add(this.label90);
            this.Water.Controls.Add(this.label91);
            this.Water.Controls.Add(this.label92);
            this.Water.Controls.Add(this.parameter_n_textbox);
            this.Water.Controls.Add(this.parameter_conv_textbox);
            this.Water.Controls.Add(this.parameter_K_textbox);
            this.Water.Controls.Add(this.parameter_m_textbox);
            this.Water.Controls.Add(this.only_waterflow_checkbox);
            this.Water.Controls.Add(this.pictureBox1);
            this.Water.Controls.Add(this.label12);
            this.Water.Controls.Add(this.label11);
            this.Water.Controls.Add(this.label10);
            this.Water.Controls.Add(this.label9);
            this.Water.Controls.Add(this.Water_ero_checkbox);
            this.Water.Location = new System.Drawing.Point(4, 22);
            this.Water.Name = "Water";
            this.Water.Padding = new System.Windows.Forms.Padding(3);
            this.Water.Size = new System.Drawing.Size(732, 250);
            this.Water.TabIndex = 0;
            this.Water.Text = "Water erosion and deposition";
            this.Water.UseVisualStyleBackColor = true;
            // 
            // daily_water
            // 
            this.daily_water.AutoSize = true;
            this.daily_water.Location = new System.Drawing.Point(392, 16);
            this.daily_water.Name = "daily_water";
            this.daily_water.Size = new System.Drawing.Size(100, 17);
            this.daily_water.TabIndex = 29;
            this.daily_water.Text = "Daily water flow";
            this.daily_water.UseVisualStyleBackColor = true;
            this.daily_water.CheckedChanged += new System.EventHandler(this.daily_water_CheckedChanged);
            // 
            // label87
            // 
            this.label87.AutoSize = true;
            this.label87.Location = new System.Drawing.Point(101, 228);
            this.label87.Name = "label87";
            this.label87.Size = new System.Drawing.Size(136, 13);
            this.label87.TabIndex = 28;
            this.label87.Text = "selectivity change constant";
            // 
            // selectivity_constant_textbox
            // 
            this.selectivity_constant_textbox.Location = new System.Drawing.Point(26, 225);
            this.selectivity_constant_textbox.Name = "selectivity_constant_textbox";
            this.selectivity_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.selectivity_constant_textbox.TabIndex = 27;
            this.selectivity_constant_textbox.Text = "0";
            // 
            // bio_protection_constant_textbox
            // 
            this.bio_protection_constant_textbox.Location = new System.Drawing.Point(26, 199);
            this.bio_protection_constant_textbox.Name = "bio_protection_constant_textbox";
            this.bio_protection_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.bio_protection_constant_textbox.TabIndex = 21;
            this.bio_protection_constant_textbox.Text = "1";
            // 
            // erosion_threshold_textbox
            // 
            this.erosion_threshold_textbox.Location = new System.Drawing.Point(26, 147);
            this.erosion_threshold_textbox.Name = "erosion_threshold_textbox";
            this.erosion_threshold_textbox.Size = new System.Drawing.Size(53, 20);
            this.erosion_threshold_textbox.TabIndex = 20;
            this.erosion_threshold_textbox.Text = "0.01";
            // 
            // rock_protection_constant_textbox
            // 
            this.rock_protection_constant_textbox.Location = new System.Drawing.Point(26, 173);
            this.rock_protection_constant_textbox.Name = "rock_protection_constant_textbox";
            this.rock_protection_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.rock_protection_constant_textbox.TabIndex = 17;
            this.rock_protection_constant_textbox.Text = "1";
            // 
            // label90
            // 
            this.label90.AutoSize = true;
            this.label90.Location = new System.Drawing.Point(101, 150);
            this.label90.Name = "label90";
            this.label90.Size = new System.Drawing.Size(87, 13);
            this.label90.TabIndex = 24;
            this.label90.Text = "erosion threshold";
            // 
            // label91
            // 
            this.label91.AutoSize = true;
            this.label91.Location = new System.Drawing.Point(101, 202);
            this.label91.Name = "label91";
            this.label91.Size = new System.Drawing.Size(115, 13);
            this.label91.TabIndex = 23;
            this.label91.Text = "bio protection constant";
            // 
            // label92
            // 
            this.label92.AutoSize = true;
            this.label92.Location = new System.Drawing.Point(101, 176);
            this.label92.Name = "label92";
            this.label92.Size = new System.Drawing.Size(122, 13);
            this.label92.TabIndex = 22;
            this.label92.Text = "rock protection constant";
            // 
            // parameter_n_textbox
            // 
            this.parameter_n_textbox.Location = new System.Drawing.Point(26, 96);
            this.parameter_n_textbox.Name = "parameter_n_textbox";
            this.parameter_n_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_n_textbox.TabIndex = 7;
            this.parameter_n_textbox.Text = "1.3";
            // 
            // parameter_conv_textbox
            // 
            this.parameter_conv_textbox.Location = new System.Drawing.Point(26, 47);
            this.parameter_conv_textbox.Name = "parameter_conv_textbox";
            this.parameter_conv_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_conv_textbox.TabIndex = 6;
            this.parameter_conv_textbox.Text = "2";
            // 
            // parameter_K_textbox
            // 
            this.parameter_K_textbox.Location = new System.Drawing.Point(26, 121);
            this.parameter_K_textbox.Name = "parameter_K_textbox";
            this.parameter_K_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_K_textbox.TabIndex = 5;
            this.parameter_K_textbox.Text = "0.0003";
            // 
            // parameter_m_textbox
            // 
            this.parameter_m_textbox.Location = new System.Drawing.Point(26, 70);
            this.parameter_m_textbox.Name = "parameter_m_textbox";
            this.parameter_m_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_m_textbox.TabIndex = 1;
            this.parameter_m_textbox.Text = "1.67";
            // 
            // only_waterflow_checkbox
            // 
            this.only_waterflow_checkbox.AutoSize = true;
            this.only_waterflow_checkbox.Location = new System.Drawing.Point(156, 16);
            this.only_waterflow_checkbox.Name = "only_waterflow_checkbox";
            this.only_waterflow_checkbox.Size = new System.Drawing.Size(219, 17);
            this.only_waterflow_checkbox.TabIndex = 14;
            this.only_waterflow_checkbox.Text = "Only calculate waterflow, no ero and dep";
            this.only_waterflow_checkbox.UseVisualStyleBackColor = true;
            // 
            // pictureBox1
            // 
            this.pictureBox1.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox1.Image")));
            this.pictureBox1.Location = new System.Drawing.Point(266, 53);
            this.pictureBox1.Name = "pictureBox1";
            this.pictureBox1.Size = new System.Drawing.Size(180, 137);
            this.pictureBox1.TabIndex = 13;
            this.pictureBox1.TabStop = false;
            // 
            // label12
            // 
            this.label12.AutoSize = true;
            this.label12.Location = new System.Drawing.Point(101, 124);
            this.label12.Name = "label12";
            this.label12.Size = new System.Drawing.Size(66, 13);
            this.label12.TabIndex = 11;
            this.label12.Text = "K (erodibility)";
            // 
            // label11
            // 
            this.label11.AutoSize = true;
            this.label11.Location = new System.Drawing.Point(101, 50);
            this.label11.Name = "label11";
            this.label11.Size = new System.Drawing.Size(109, 13);
            this.label11.TabIndex = 10;
            this.label11.Text = "p (multiple flow factor)";
            // 
            // label10
            // 
            this.label10.AutoSize = true;
            this.label10.Location = new System.Drawing.Point(101, 99);
            this.label10.Name = "label10";
            this.label10.Size = new System.Drawing.Size(106, 13);
            this.label10.TabIndex = 9;
            this.label10.Text = "n (exponent of slope)";
            // 
            // label9
            // 
            this.label9.AutoSize = true;
            this.label9.Location = new System.Drawing.Point(101, 73);
            this.label9.Name = "label9";
            this.label9.Size = new System.Drawing.Size(146, 13);
            this.label9.TabIndex = 8;
            this.label9.Text = "m (exponent of overland flow)";
            // 
            // Water_ero_checkbox
            // 
            this.Water_ero_checkbox.AutoSize = true;
            this.Water_ero_checkbox.Checked = true;
            this.Water_ero_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.Water_ero_checkbox.Location = new System.Drawing.Point(26, 16);
            this.Water_ero_checkbox.Name = "Water_ero_checkbox";
            this.Water_ero_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Water_ero_checkbox.TabIndex = 0;
            this.Water_ero_checkbox.Text = "Activate this process";
            this.Water_ero_checkbox.UseVisualStyleBackColor = true;
            this.Water_ero_checkbox.CheckedChanged += new System.EventHandler(this.Water_ero_checkbox_CheckedChanged);
            // 
            // Tillage
            // 
            this.Tillage.Controls.Add(this.pictureBox2);
            this.Tillage.Controls.Add(this.label20);
            this.Tillage.Controls.Add(this.trte);
            this.Tillage.Controls.Add(this.parameter_tillage_constant_textbox);
            this.Tillage.Controls.Add(this.parameter_ploughing_depth_textbox);
            this.Tillage.Controls.Add(this.Tillage_checkbox);
            this.Tillage.Location = new System.Drawing.Point(4, 22);
            this.Tillage.Name = "Tillage";
            this.Tillage.Padding = new System.Windows.Forms.Padding(3);
            this.Tillage.Size = new System.Drawing.Size(732, 250);
            this.Tillage.TabIndex = 1;
            this.Tillage.Text = "Tillage";
            this.Tillage.UseVisualStyleBackColor = true;
            // 
            // pictureBox2
            // 
            this.pictureBox2.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox2.Image")));
            this.pictureBox2.Location = new System.Drawing.Point(276, 57);
            this.pictureBox2.Name = "pictureBox2";
            this.pictureBox2.Size = new System.Drawing.Size(180, 137);
            this.pictureBox2.TabIndex = 20;
            this.pictureBox2.TabStop = false;
            // 
            // label20
            // 
            this.label20.AutoSize = true;
            this.label20.Location = new System.Drawing.Point(128, 87);
            this.label20.Name = "label20";
            this.label20.Size = new System.Drawing.Size(78, 13);
            this.label20.TabIndex = 19;
            this.label20.Text = "tillage constant";
            // 
            // trte
            // 
            this.trte.AutoSize = true;
            this.trte.Location = new System.Drawing.Point(128, 61);
            this.trte.Name = "trte";
            this.trte.Size = new System.Drawing.Size(83, 13);
            this.trte.TabIndex = 18;
            this.trte.Text = "ploughing depth";
            // 
            // parameter_tillage_constant_textbox
            // 
            this.parameter_tillage_constant_textbox.Location = new System.Drawing.Point(53, 84);
            this.parameter_tillage_constant_textbox.Name = "parameter_tillage_constant_textbox";
            this.parameter_tillage_constant_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_tillage_constant_textbox.TabIndex = 17;
            this.parameter_tillage_constant_textbox.Text = "1";
            // 
            // parameter_ploughing_depth_textbox
            // 
            this.parameter_ploughing_depth_textbox.AcceptsTab = true;
            this.parameter_ploughing_depth_textbox.Location = new System.Drawing.Point(53, 58);
            this.parameter_ploughing_depth_textbox.Name = "parameter_ploughing_depth_textbox";
            this.parameter_ploughing_depth_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_ploughing_depth_textbox.TabIndex = 13;
            this.parameter_ploughing_depth_textbox.Text = "0.25";
            // 
            // Tillage_checkbox
            // 
            this.Tillage_checkbox.AutoSize = true;
            this.Tillage_checkbox.Location = new System.Drawing.Point(26, 16);
            this.Tillage_checkbox.Name = "Tillage_checkbox";
            this.Tillage_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Tillage_checkbox.TabIndex = 1;
            this.Tillage_checkbox.Text = "Activate this process";
            this.Tillage_checkbox.UseVisualStyleBackColor = true;
            // 
            // Creeper
            // 
            this.Creeper.Controls.Add(this.creep_testing);
            this.Creeper.Controls.Add(this.pictureBox3);
            this.Creeper.Controls.Add(this.label19);
            this.Creeper.Controls.Add(this.parameter_diffusivity_textbox);
            this.Creeper.Controls.Add(this.creep_active_checkbox);
            this.Creeper.Location = new System.Drawing.Point(4, 22);
            this.Creeper.Name = "Creeper";
            this.Creeper.Size = new System.Drawing.Size(732, 250);
            this.Creeper.TabIndex = 6;
            this.Creeper.Text = "Creep";
            this.Creeper.UseVisualStyleBackColor = true;
            // 
            // creep_testing
            // 
            this.creep_testing.AutoSize = true;
            this.creep_testing.Location = new System.Drawing.Point(26, 108);
            this.creep_testing.Name = "creep_testing";
            this.creep_testing.Size = new System.Drawing.Size(88, 17);
            this.creep_testing.TabIndex = 26;
            this.creep_testing.Text = "Creep testing";
            this.creep_testing.UseVisualStyleBackColor = true;
            // 
            // pictureBox3
            // 
            this.pictureBox3.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox3.Image")));
            this.pictureBox3.Location = new System.Drawing.Point(276, 57);
            this.pictureBox3.Name = "pictureBox3";
            this.pictureBox3.Size = new System.Drawing.Size(180, 137);
            this.pictureBox3.TabIndex = 25;
            this.pictureBox3.TabStop = false;
            // 
            // label19
            // 
            this.label19.AutoSize = true;
            this.label19.Location = new System.Drawing.Point(128, 63);
            this.label19.Name = "label19";
            this.label19.Size = new System.Drawing.Size(127, 13);
            this.label19.TabIndex = 23;
            this.label19.Text = "potential creep [kg/m2/y]";
            // 
            // parameter_diffusivity_textbox
            // 
            this.parameter_diffusivity_textbox.AcceptsTab = true;
            this.parameter_diffusivity_textbox.Location = new System.Drawing.Point(53, 60);
            this.parameter_diffusivity_textbox.Name = "parameter_diffusivity_textbox";
            this.parameter_diffusivity_textbox.Size = new System.Drawing.Size(53, 20);
            this.parameter_diffusivity_textbox.TabIndex = 21;
            this.parameter_diffusivity_textbox.Text = "4.5";
            // 
            // creep_active_checkbox
            // 
            this.creep_active_checkbox.AutoSize = true;
            this.creep_active_checkbox.Location = new System.Drawing.Point(26, 18);
            this.creep_active_checkbox.Name = "creep_active_checkbox";
            this.creep_active_checkbox.Size = new System.Drawing.Size(124, 17);
            this.creep_active_checkbox.TabIndex = 20;
            this.creep_active_checkbox.Text = "Activate this process";
            this.creep_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // Solifluction
            // 
            this.Solifluction.Controls.Add(this.pictureBox5);
            this.Solifluction.Controls.Add(this.Solifluction_checkbox);
            this.Solifluction.Location = new System.Drawing.Point(4, 22);
            this.Solifluction.Name = "Solifluction";
            this.Solifluction.Size = new System.Drawing.Size(732, 250);
            this.Solifluction.TabIndex = 4;
            this.Solifluction.Text = "Solifluction";
            this.Solifluction.UseVisualStyleBackColor = true;
            // 
            // pictureBox5
            // 
            this.pictureBox5.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox5.Image")));
            this.pictureBox5.Location = new System.Drawing.Point(276, 57);
            this.pictureBox5.Name = "pictureBox5";
            this.pictureBox5.Size = new System.Drawing.Size(180, 137);
            this.pictureBox5.TabIndex = 14;
            this.pictureBox5.TabStop = false;
            // 
            // Solifluction_checkbox
            // 
            this.Solifluction_checkbox.AutoSize = true;
            this.Solifluction_checkbox.Enabled = false;
            this.Solifluction_checkbox.Location = new System.Drawing.Point(36, 24);
            this.Solifluction_checkbox.Name = "Solifluction_checkbox";
            this.Solifluction_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Solifluction_checkbox.TabIndex = 2;
            this.Solifluction_checkbox.Text = "Activate this process";
            this.Solifluction_checkbox.UseVisualStyleBackColor = true;
            // 
            // Rock_weathering
            // 
            this.Rock_weathering.Controls.Add(this.rockweath_method);
            this.Rock_weathering.Controls.Add(this.pictureBox6);
            this.Rock_weathering.Controls.Add(this.groupBox10);
            this.Rock_weathering.Controls.Add(this.groupBox9);
            this.Rock_weathering.Location = new System.Drawing.Point(4, 22);
            this.Rock_weathering.Name = "Rock_weathering";
            this.Rock_weathering.Size = new System.Drawing.Size(732, 250);
            this.Rock_weathering.TabIndex = 5;
            this.Rock_weathering.Text = "Rock weathering";
            this.Rock_weathering.UseVisualStyleBackColor = true;
            // 
            // rockweath_method
            // 
            this.rockweath_method.AllowDrop = true;
            this.rockweath_method.FormattingEnabled = true;
            this.rockweath_method.Items.AddRange(new object[] {
            "Humped",
            "Exponential (-P0 exp(-k1*dsoil))",
            "Function of infiltration (only with daily water flow)"});
            this.rockweath_method.Location = new System.Drawing.Point(26, 200);
            this.rockweath_method.Name = "rockweath_method";
            this.rockweath_method.Size = new System.Drawing.Size(121, 21);
            this.rockweath_method.TabIndex = 15;
            this.rockweath_method.Text = "Humped";
            // 
            // pictureBox6
            // 
            this.pictureBox6.Image = ((System.Drawing.Image)(resources.GetObject("pictureBox6.Image")));
            this.pictureBox6.Location = new System.Drawing.Point(276, 57);
            this.pictureBox6.Name = "pictureBox6";
            this.pictureBox6.Size = new System.Drawing.Size(180, 137);
            this.pictureBox6.TabIndex = 14;
            this.pictureBox6.TabStop = false;
            // 
            // groupBox10
            // 
            this.groupBox10.Controls.Add(this.Frost_weathering_checkbox);
            this.groupBox10.Enabled = false;
            this.groupBox10.Location = new System.Drawing.Point(250, 14);
            this.groupBox10.Name = "groupBox10";
            this.groupBox10.Size = new System.Drawing.Size(222, 179);
            this.groupBox10.TabIndex = 6;
            this.groupBox10.TabStop = false;
            this.groupBox10.Text = "Frost weathering ";
            this.groupBox10.Visible = false;
            // 
            // Frost_weathering_checkbox
            // 
            this.Frost_weathering_checkbox.AutoSize = true;
            this.Frost_weathering_checkbox.Enabled = false;
            this.Frost_weathering_checkbox.Location = new System.Drawing.Point(14, 19);
            this.Frost_weathering_checkbox.Name = "Frost_weathering_checkbox";
            this.Frost_weathering_checkbox.Size = new System.Drawing.Size(124, 17);
            this.Frost_weathering_checkbox.TabIndex = 3;
            this.Frost_weathering_checkbox.Text = "Activate this process";
            this.Frost_weathering_checkbox.UseVisualStyleBackColor = true;
            // 
            // Tectonics
            // 
            this.Tectonics.Controls.Add(this.groupBox14);
            this.Tectonics.Controls.Add(this.groupBox4);
            this.Tectonics.Location = new System.Drawing.Point(4, 22);
            this.Tectonics.Name = "Tectonics";
            this.Tectonics.Padding = new System.Windows.Forms.Padding(3);
            this.Tectonics.Size = new System.Drawing.Size(732, 250);
            this.Tectonics.TabIndex = 7;
            this.Tectonics.Text = "Tectonics";
            this.Tectonics.UseVisualStyleBackColor = true;
            // 
            // groupBox14
            // 
            this.groupBox14.Controls.Add(this.groupBox16);
            this.groupBox14.Controls.Add(this.Uplift_rate_textbox);
            this.groupBox14.Controls.Add(this.uplift_active_checkbox);
            this.groupBox14.Controls.Add(this.label39);
            this.groupBox14.Location = new System.Drawing.Point(176, 16);
            this.groupBox14.Name = "groupBox14";
            this.groupBox14.Size = new System.Drawing.Size(158, 209);
            this.groupBox14.TabIndex = 4;
            this.groupBox14.TabStop = false;
            this.groupBox14.Text = "Vertical uplift";
            // 
            // groupBox16
            // 
            this.groupBox16.Controls.Add(this.text_lift_col_less);
            this.groupBox16.Controls.Add(this.text_lift_col_more);
            this.groupBox16.Controls.Add(this.text_lift_row_less);
            this.groupBox16.Controls.Add(this.text_lift_row_more);
            this.groupBox16.Controls.Add(this.radio_lift_col_less_than);
            this.groupBox16.Controls.Add(this.radio_lift_row_more_than);
            this.groupBox16.Controls.Add(this.radio_lift_col_more_than);
            this.groupBox16.Controls.Add(this.radio_lift_row_less_than);
            this.groupBox16.Location = new System.Drawing.Point(13, 51);
            this.groupBox16.Name = "groupBox16";
            this.groupBox16.Size = new System.Drawing.Size(129, 105);
            this.groupBox16.TabIndex = 7;
            this.groupBox16.TabStop = false;
            this.groupBox16.Text = "For cells with:";
            // 
            // text_lift_col_less
            // 
            this.text_lift_col_less.Location = new System.Drawing.Point(63, 75);
            this.text_lift_col_less.Name = "text_lift_col_less";
            this.text_lift_col_less.Size = new System.Drawing.Size(54, 20);
            this.text_lift_col_less.TabIndex = 9;
            // 
            // text_lift_col_more
            // 
            this.text_lift_col_more.Location = new System.Drawing.Point(63, 56);
            this.text_lift_col_more.Name = "text_lift_col_more";
            this.text_lift_col_more.Size = new System.Drawing.Size(54, 20);
            this.text_lift_col_more.TabIndex = 8;
            // 
            // text_lift_row_less
            // 
            this.text_lift_row_less.Location = new System.Drawing.Point(63, 36);
            this.text_lift_row_less.Name = "text_lift_row_less";
            this.text_lift_row_less.Size = new System.Drawing.Size(54, 20);
            this.text_lift_row_less.TabIndex = 7;
            // 
            // text_lift_row_more
            // 
            this.text_lift_row_more.Location = new System.Drawing.Point(63, 16);
            this.text_lift_row_more.Name = "text_lift_row_more";
            this.text_lift_row_more.Size = new System.Drawing.Size(54, 20);
            this.text_lift_row_more.TabIndex = 6;
            // 
            // radio_lift_col_less_than
            // 
            this.radio_lift_col_less_than.AutoSize = true;
            this.radio_lift_col_less_than.Location = new System.Drawing.Point(6, 75);
            this.radio_lift_col_less_than.Name = "radio_lift_col_less_than";
            this.radio_lift_col_less_than.Size = new System.Drawing.Size(48, 17);
            this.radio_lift_col_less_than.TabIndex = 5;
            this.radio_lift_col_less_than.TabStop = true;
            this.radio_lift_col_less_than.Text = "col <";
            this.radio_lift_col_less_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_row_more_than
            // 
            this.radio_lift_row_more_than.AutoSize = true;
            this.radio_lift_row_more_than.Location = new System.Drawing.Point(6, 16);
            this.radio_lift_row_more_than.Name = "radio_lift_row_more_than";
            this.radio_lift_row_more_than.Size = new System.Drawing.Size(51, 17);
            this.radio_lift_row_more_than.TabIndex = 4;
            this.radio_lift_row_more_than.TabStop = true;
            this.radio_lift_row_more_than.Text = "row >";
            this.radio_lift_row_more_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_col_more_than
            // 
            this.radio_lift_col_more_than.AutoSize = true;
            this.radio_lift_col_more_than.Location = new System.Drawing.Point(6, 56);
            this.radio_lift_col_more_than.Name = "radio_lift_col_more_than";
            this.radio_lift_col_more_than.Size = new System.Drawing.Size(48, 17);
            this.radio_lift_col_more_than.TabIndex = 3;
            this.radio_lift_col_more_than.TabStop = true;
            this.radio_lift_col_more_than.Text = "col >";
            this.radio_lift_col_more_than.UseVisualStyleBackColor = true;
            // 
            // radio_lift_row_less_than
            // 
            this.radio_lift_row_less_than.AutoSize = true;
            this.radio_lift_row_less_than.Location = new System.Drawing.Point(6, 36);
            this.radio_lift_row_less_than.Name = "radio_lift_row_less_than";
            this.radio_lift_row_less_than.Size = new System.Drawing.Size(51, 17);
            this.radio_lift_row_less_than.TabIndex = 2;
            this.radio_lift_row_less_than.TabStop = true;
            this.radio_lift_row_less_than.Text = "row <";
            this.radio_lift_row_less_than.UseVisualStyleBackColor = true;
            // 
            // Uplift_rate_textbox
            // 
            this.Uplift_rate_textbox.Location = new System.Drawing.Point(13, 184);
            this.Uplift_rate_textbox.Name = "Uplift_rate_textbox";
            this.Uplift_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.Uplift_rate_textbox.TabIndex = 3;
            // 
            // uplift_active_checkbox
            // 
            this.uplift_active_checkbox.AutoSize = true;
            this.uplift_active_checkbox.Location = new System.Drawing.Point(13, 19);
            this.uplift_active_checkbox.Name = "uplift_active_checkbox";
            this.uplift_active_checkbox.Size = new System.Drawing.Size(65, 17);
            this.uplift_active_checkbox.TabIndex = 1;
            this.uplift_active_checkbox.Text = "Activate";
            this.uplift_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // label39
            // 
            this.label39.AutoSize = true;
            this.label39.Location = new System.Drawing.Point(10, 168);
            this.label39.Name = "label39";
            this.label39.Size = new System.Drawing.Size(83, 13);
            this.label39.TabIndex = 2;
            this.label39.Text = "Uplift rate [m/a]:";
            // 
            // groupBox4
            // 
            this.groupBox4.Controls.Add(this.label38);
            this.groupBox4.Controls.Add(this.Tilting_rate_textbox);
            this.groupBox4.Controls.Add(this.groupBox15);
            this.groupBox4.Controls.Add(this.tilting_active_checkbox);
            this.groupBox4.Location = new System.Drawing.Point(13, 16);
            this.groupBox4.Name = "groupBox4";
            this.groupBox4.Size = new System.Drawing.Size(153, 210);
            this.groupBox4.TabIndex = 3;
            this.groupBox4.TabStop = false;
            this.groupBox4.Text = "Tilting";
            // 
            // label38
            // 
            this.label38.AutoSize = true;
            this.label38.Location = new System.Drawing.Point(9, 168);
            this.label38.Name = "label38";
            this.label38.Size = new System.Drawing.Size(114, 13);
            this.label38.TabIndex = 8;
            this.label38.Text = "Max alt change [m/a]: ";
            // 
            // Tilting_rate_textbox
            // 
            this.Tilting_rate_textbox.Location = new System.Drawing.Point(6, 184);
            this.Tilting_rate_textbox.Name = "Tilting_rate_textbox";
            this.Tilting_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.Tilting_rate_textbox.TabIndex = 7;
            // 
            // groupBox15
            // 
            this.groupBox15.Controls.Add(this.radio_tilt_col_max);
            this.groupBox15.Controls.Add(this.radio_tilt_row_zero);
            this.groupBox15.Controls.Add(this.radio_tilt_col_zero);
            this.groupBox15.Controls.Add(this.radio_tilt_row_max);
            this.groupBox15.Location = new System.Drawing.Point(6, 51);
            this.groupBox15.Name = "groupBox15";
            this.groupBox15.Size = new System.Drawing.Size(113, 105);
            this.groupBox15.TabIndex = 6;
            this.groupBox15.TabStop = false;
            this.groupBox15.Text = "Stability along:";
            // 
            // radio_tilt_col_max
            // 
            this.radio_tilt_col_max.AutoSize = true;
            this.radio_tilt_col_max.Location = new System.Drawing.Point(6, 79);
            this.radio_tilt_col_max.Name = "radio_tilt_col_max";
            this.radio_tilt_col_max.Size = new System.Drawing.Size(87, 17);
            this.radio_tilt_col_max.TabIndex = 5;
            this.radio_tilt_col_max.TabStop = true;
            this.radio_tilt_col_max.Text = "col = max col";
            this.radio_tilt_col_max.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_row_zero
            // 
            this.radio_tilt_row_zero.AutoSize = true;
            this.radio_tilt_row_zero.Location = new System.Drawing.Point(6, 16);
            this.radio_tilt_row_zero.Name = "radio_tilt_row_zero";
            this.radio_tilt_row_zero.Size = new System.Drawing.Size(60, 17);
            this.radio_tilt_row_zero.TabIndex = 4;
            this.radio_tilt_row_zero.TabStop = true;
            this.radio_tilt_row_zero.Text = "row = 0";
            this.radio_tilt_row_zero.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_col_zero
            // 
            this.radio_tilt_col_zero.AutoSize = true;
            this.radio_tilt_col_zero.Location = new System.Drawing.Point(6, 56);
            this.radio_tilt_col_zero.Name = "radio_tilt_col_zero";
            this.radio_tilt_col_zero.Size = new System.Drawing.Size(57, 17);
            this.radio_tilt_col_zero.TabIndex = 3;
            this.radio_tilt_col_zero.TabStop = true;
            this.radio_tilt_col_zero.Text = "col = 0";
            this.radio_tilt_col_zero.UseVisualStyleBackColor = true;
            // 
            // radio_tilt_row_max
            // 
            this.radio_tilt_row_max.AutoSize = true;
            this.radio_tilt_row_max.Location = new System.Drawing.Point(6, 36);
            this.radio_tilt_row_max.Name = "radio_tilt_row_max";
            this.radio_tilt_row_max.Size = new System.Drawing.Size(93, 17);
            this.radio_tilt_row_max.TabIndex = 2;
            this.radio_tilt_row_max.TabStop = true;
            this.radio_tilt_row_max.Text = "row = max row";
            this.radio_tilt_row_max.UseVisualStyleBackColor = true;
            // 
            // tilting_active_checkbox
            // 
            this.tilting_active_checkbox.AutoSize = true;
            this.tilting_active_checkbox.Location = new System.Drawing.Point(6, 19);
            this.tilting_active_checkbox.Name = "tilting_active_checkbox";
            this.tilting_active_checkbox.Size = new System.Drawing.Size(65, 17);
            this.tilting_active_checkbox.TabIndex = 0;
            this.tilting_active_checkbox.Text = "Activate";
            this.tilting_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // treefall
            // 
            this.treefall.Controls.Add(this.tf_freq);
            this.treefall.Controls.Add(this.label112);
            this.treefall.Controls.Add(this.tf_age);
            this.treefall.Controls.Add(this.label111);
            this.treefall.Controls.Add(this.tf_growth);
            this.treefall.Controls.Add(this.label110);
            this.treefall.Controls.Add(this.tf_D);
            this.treefall.Controls.Add(this.label95);
            this.treefall.Controls.Add(this.label107);
            this.treefall.Controls.Add(this.tf_W);
            this.treefall.Controls.Add(this.treefall_checkbox);
            this.treefall.Location = new System.Drawing.Point(4, 22);
            this.treefall.Name = "treefall";
            this.treefall.Size = new System.Drawing.Size(732, 250);
            this.treefall.TabIndex = 8;
            this.treefall.Text = "Tree fall";
            this.treefall.UseVisualStyleBackColor = true;
            // 
            // tf_freq
            // 
            this.tf_freq.Location = new System.Drawing.Point(25, 162);
            this.tf_freq.Name = "tf_freq";
            this.tf_freq.Size = new System.Drawing.Size(53, 20);
            this.tf_freq.TabIndex = 30;
            this.tf_freq.Text = "0.00002";
            // 
            // label112
            // 
            this.label112.AutoSize = true;
            this.label112.Location = new System.Drawing.Point(100, 165);
            this.label112.Name = "label112";
            this.label112.Size = new System.Drawing.Size(132, 13);
            this.label112.TabIndex = 29;
            this.label112.Text = "fall frequency [trees/m2/a]";
            // 
            // tf_age
            // 
            this.tf_age.Location = new System.Drawing.Point(25, 131);
            this.tf_age.Name = "tf_age";
            this.tf_age.Size = new System.Drawing.Size(53, 20);
            this.tf_age.TabIndex = 28;
            this.tf_age.Text = "300";
            // 
            // label111
            // 
            this.label111.AutoSize = true;
            this.label111.Location = new System.Drawing.Point(100, 134);
            this.label111.Name = "label111";
            this.label111.Size = new System.Drawing.Size(119, 13);
            this.label111.TabIndex = 27;
            this.label111.Text = "maximum age of tree [a]";
            // 
            // tf_growth
            // 
            this.tf_growth.Location = new System.Drawing.Point(25, 103);
            this.tf_growth.Name = "tf_growth";
            this.tf_growth.Size = new System.Drawing.Size(53, 20);
            this.tf_growth.TabIndex = 26;
            this.tf_growth.Text = "150";
            // 
            // label110
            // 
            this.label110.AutoSize = true;
            this.label110.Location = new System.Drawing.Point(100, 106);
            this.label110.Name = "label110";
            this.label110.Size = new System.Drawing.Size(204, 13);
            this.label110.TabIndex = 25;
            this.label110.Text = "time it takes to reach these dimensions [a]";
            // 
            // tf_D
            // 
            this.tf_D.Location = new System.Drawing.Point(25, 77);
            this.tf_D.Name = "tf_D";
            this.tf_D.Size = new System.Drawing.Size(53, 20);
            this.tf_D.TabIndex = 24;
            this.tf_D.Text = "0.7";
            // 
            // label95
            // 
            this.label95.AutoSize = true;
            this.label95.Location = new System.Drawing.Point(100, 80);
            this.label95.Name = "label95";
            this.label95.Size = new System.Drawing.Size(145, 13);
            this.label95.TabIndex = 23;
            this.label95.Text = "maximum depth root mass [m]";
            // 
            // label107
            // 
            this.label107.AutoSize = true;
            this.label107.Location = new System.Drawing.Point(100, 54);
            this.label107.Name = "label107";
            this.label107.Size = new System.Drawing.Size(158, 13);
            this.label107.TabIndex = 22;
            this.label107.Text = "maximum diameter root mass [m]";
            // 
            // tf_W
            // 
            this.tf_W.Location = new System.Drawing.Point(25, 51);
            this.tf_W.Name = "tf_W";
            this.tf_W.Size = new System.Drawing.Size(53, 20);
            this.tf_W.TabIndex = 21;
            this.tf_W.Text = "4";
            // 
            // treefall_checkbox
            // 
            this.treefall_checkbox.AutoSize = true;
            this.treefall_checkbox.Location = new System.Drawing.Point(25, 16);
            this.treefall_checkbox.Name = "treefall_checkbox";
            this.treefall_checkbox.Size = new System.Drawing.Size(124, 17);
            this.treefall_checkbox.TabIndex = 0;
            this.treefall_checkbox.Text = "Activate this process";
            this.treefall_checkbox.UseVisualStyleBackColor = true;
            // 
            // tabPage6
            // 
            this.tabPage6.Controls.Add(this.label129);
            this.tabPage6.Controls.Add(this.label128);
            this.tabPage6.Controls.Add(this.label127);
            this.tabPage6.Controls.Add(this.blockweath_textbox);
            this.tabPage6.Controls.Add(this.blocksize_textbox);
            this.tabPage6.Controls.Add(this.hardlayerweath_textbox);
            this.tabPage6.Controls.Add(this.label63);
            this.tabPage6.Controls.Add(this.label62);
            this.tabPage6.Controls.Add(this.hardlayerdensity_textbox);
            this.tabPage6.Controls.Add(this.hardlayerelevation_textbox);
            this.tabPage6.Controls.Add(this.hardlayerthickness_textbox);
            this.tabPage6.Controls.Add(this.label61);
            this.tabPage6.Controls.Add(this.blocks_active_checkbox);
            this.tabPage6.Location = new System.Drawing.Point(4, 22);
            this.tabPage6.Name = "tabPage6";
            this.tabPage6.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage6.Size = new System.Drawing.Size(732, 250);
            this.tabPage6.TabIndex = 9;
            this.tabPage6.Text = "Blocks";
            this.tabPage6.UseVisualStyleBackColor = true;
            // 
            // label129
            // 
            this.label129.AutoSize = true;
            this.label129.Location = new System.Drawing.Point(129, 162);
            this.label129.Name = "label129";
            this.label129.Size = new System.Drawing.Size(115, 13);
            this.label129.TabIndex = 21;
            this.label129.Text = "Minimum block size (m)";
            // 
            // label128
            // 
            this.label128.AutoSize = true;
            this.label128.Location = new System.Drawing.Point(129, 136);
            this.label128.Name = "label128";
            this.label128.Size = new System.Drawing.Size(110, 13);
            this.label128.TabIndex = 20;
            this.label128.Text = "Block weathering rate";
            // 
            // label127
            // 
            this.label127.AutoSize = true;
            this.label127.Location = new System.Drawing.Point(129, 110);
            this.label127.Name = "label127";
            this.label127.Size = new System.Drawing.Size(110, 13);
            this.label127.TabIndex = 19;
            this.label127.Text = "Hard layer weathering";
            // 
            // blockweath_textbox
            // 
            this.blockweath_textbox.Location = new System.Drawing.Point(6, 133);
            this.blockweath_textbox.Name = "blockweath_textbox";
            this.blockweath_textbox.Size = new System.Drawing.Size(100, 20);
            this.blockweath_textbox.TabIndex = 18;
            this.blockweath_textbox.Text = "0.01";
            // 
            // blocksize_textbox
            // 
            this.blocksize_textbox.Location = new System.Drawing.Point(6, 159);
            this.blocksize_textbox.Name = "blocksize_textbox";
            this.blocksize_textbox.Size = new System.Drawing.Size(100, 20);
            this.blocksize_textbox.TabIndex = 17;
            this.blocksize_textbox.Text = "0.15";
            // 
            // hardlayerweath_textbox
            // 
            this.hardlayerweath_textbox.Location = new System.Drawing.Point(6, 107);
            this.hardlayerweath_textbox.Name = "hardlayerweath_textbox";
            this.hardlayerweath_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerweath_textbox.TabIndex = 16;
            this.hardlayerweath_textbox.Text = "0.01";
            // 
            // label63
            // 
            this.label63.AutoSize = true;
            this.label63.Location = new System.Drawing.Point(129, 84);
            this.label63.Name = "label63";
            this.label63.Size = new System.Drawing.Size(131, 13);
            this.label63.TabIndex = 15;
            this.label63.Text = "Hard layer density (kg/m3)";
            // 
            // label62
            // 
            this.label62.AutoSize = true;
            this.label62.Location = new System.Drawing.Point(129, 58);
            this.label62.Name = "label62";
            this.label62.Size = new System.Drawing.Size(118, 13);
            this.label62.TabIndex = 14;
            this.label62.Text = "Hard layer elevation (m)";
            // 
            // hardlayerdensity_textbox
            // 
            this.hardlayerdensity_textbox.Location = new System.Drawing.Point(6, 81);
            this.hardlayerdensity_textbox.Name = "hardlayerdensity_textbox";
            this.hardlayerdensity_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerdensity_textbox.TabIndex = 13;
            this.hardlayerdensity_textbox.Text = "2500";
            // 
            // hardlayerelevation_textbox
            // 
            this.hardlayerelevation_textbox.Location = new System.Drawing.Point(6, 55);
            this.hardlayerelevation_textbox.Name = "hardlayerelevation_textbox";
            this.hardlayerelevation_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerelevation_textbox.TabIndex = 12;
            this.hardlayerelevation_textbox.Text = "1";
            // 
            // hardlayerthickness_textbox
            // 
            this.hardlayerthickness_textbox.Location = new System.Drawing.Point(6, 29);
            this.hardlayerthickness_textbox.Name = "hardlayerthickness_textbox";
            this.hardlayerthickness_textbox.Size = new System.Drawing.Size(100, 20);
            this.hardlayerthickness_textbox.TabIndex = 11;
            this.hardlayerthickness_textbox.Text = "1";
            // 
            // label61
            // 
            this.label61.AutoSize = true;
            this.label61.Location = new System.Drawing.Point(129, 32);
            this.label61.Name = "label61";
            this.label61.Size = new System.Drawing.Size(120, 13);
            this.label61.TabIndex = 10;
            this.label61.Text = "Hard layer thickness (m)";
            // 
            // blocks_active_checkbox
            // 
            this.blocks_active_checkbox.AutoSize = true;
            this.blocks_active_checkbox.Location = new System.Drawing.Point(6, 6);
            this.blocks_active_checkbox.Name = "blocks_active_checkbox";
            this.blocks_active_checkbox.Size = new System.Drawing.Size(124, 17);
            this.blocks_active_checkbox.TabIndex = 9;
            this.blocks_active_checkbox.Text = "Activate this process";
            this.blocks_active_checkbox.UseVisualStyleBackColor = true;
            // 
            // Creep_Checkbox
            // 
            this.Creep_Checkbox.AutoSize = true;
            this.Creep_Checkbox.Enabled = false;
            this.Creep_Checkbox.Location = new System.Drawing.Point(26, 16);
            this.Creep_Checkbox.Name = "Creep_Checkbox";
            this.Creep_Checkbox.Size = new System.Drawing.Size(124, 17);
            this.Creep_Checkbox.TabIndex = 1;
            this.Creep_Checkbox.Text = "Activate this process";
            this.Creep_Checkbox.UseVisualStyleBackColor = true;
            // 
            // tabControl1
            // 
            this.tabControl1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) 
            | System.Windows.Forms.AnchorStyles.Left) 
            | System.Windows.Forms.AnchorStyles.Right)));
            this.tabControl1.Controls.Add(this.Processes);
            this.tabControl1.Controls.Add(this.tabPage1);
            this.tabControl1.Controls.Add(this.tabPage3);
            this.tabControl1.Controls.Add(this.tabPage2);
            this.tabControl1.Controls.Add(this.Input);
            this.tabControl1.Controls.Add(this.Run);
            this.tabControl1.Controls.Add(this.Output);
            this.tabControl1.Location = new System.Drawing.Point(4, 12);
            this.tabControl1.MaximumSize = new System.Drawing.Size(811, 319);
            this.tabControl1.MinimumSize = new System.Drawing.Size(811, 319);
            this.tabControl1.Name = "tabControl1";
            this.tabControl1.SelectedIndex = 0;
            this.tabControl1.Size = new System.Drawing.Size(811, 319);
            this.tabControl1.TabIndex = 143;
            // 
            // tabPage1
            // 
            this.tabPage1.Controls.Add(this.tabControl2);
            this.tabPage1.Location = new System.Drawing.Point(4, 22);
            this.tabPage1.Name = "tabPage1";
            this.tabPage1.Size = new System.Drawing.Size(803, 293);
            this.tabPage1.TabIndex = 9;
            this.tabPage1.Text = "Soil forming processes";
            this.tabPage1.UseVisualStyleBackColor = true;
            // 
            // tabControl2
            // 
            this.tabControl2.Controls.Add(this.physical);
            this.tabControl2.Controls.Add(this.chemical);
            this.tabControl2.Controls.Add(this.clay);
            this.tabControl2.Controls.Add(this.bioturbation);
            this.tabControl2.Controls.Add(this.carbon);
            this.tabControl2.Controls.Add(this.decalcification);
            this.tabControl2.Location = new System.Drawing.Point(16, 15);
            this.tabControl2.Name = "tabControl2";
            this.tabControl2.SelectedIndex = 0;
            this.tabControl2.Size = new System.Drawing.Size(759, 261);
            this.tabControl2.TabIndex = 0;
            // 
            // physical
            // 
            this.physical.Controls.Add(label49);
            this.physical.Controls.Add(label48);
            this.physical.Controls.Add(label47);
            this.physical.Controls.Add(label46);
            this.physical.Controls.Add(label45);
            this.physical.Controls.Add(label44);
            this.physical.Controls.Add(label43);
            this.physical.Controls.Add(label42);
            this.physical.Controls.Add(label41);
            this.physical.Controls.Add(this.upper_particle_fine_clay_textbox);
            this.physical.Controls.Add(this.upper_particle_clay_textbox);
            this.physical.Controls.Add(this.upper_particle_silt_textbox);
            this.physical.Controls.Add(this.upper_particle_sand_textbox);
            this.physical.Controls.Add(this.upper_particle_coarse_textbox);
            this.physical.Controls.Add(this.physical_weath_constant2);
            this.physical.Controls.Add(this.physical_weath_constant1);
            this.physical.Controls.Add(this.Physical_weath_C1_textbox);
            this.physical.Controls.Add(this.soil_phys_weath_checkbox);
            this.physical.Location = new System.Drawing.Point(4, 22);
            this.physical.Name = "physical";
            this.physical.Padding = new System.Windows.Forms.Padding(3);
            this.physical.Size = new System.Drawing.Size(751, 235);
            this.physical.TabIndex = 0;
            this.physical.Text = "Physical weathering";
            this.physical.UseVisualStyleBackColor = true;
            // 
            // upper_particle_fine_clay_textbox
            // 
            this.upper_particle_fine_clay_textbox.Location = new System.Drawing.Point(303, 147);
            this.upper_particle_fine_clay_textbox.Name = "upper_particle_fine_clay_textbox";
            this.upper_particle_fine_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_fine_clay_textbox.TabIndex = 9;
            this.upper_particle_fine_clay_textbox.Text = "0.0000001";
            // 
            // upper_particle_clay_textbox
            // 
            this.upper_particle_clay_textbox.Location = new System.Drawing.Point(303, 121);
            this.upper_particle_clay_textbox.Name = "upper_particle_clay_textbox";
            this.upper_particle_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_clay_textbox.TabIndex = 8;
            this.upper_particle_clay_textbox.Text = "0.000002";
            // 
            // upper_particle_silt_textbox
            // 
            this.upper_particle_silt_textbox.Location = new System.Drawing.Point(303, 95);
            this.upper_particle_silt_textbox.Name = "upper_particle_silt_textbox";
            this.upper_particle_silt_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_silt_textbox.TabIndex = 7;
            this.upper_particle_silt_textbox.Text = "0.00005";
            // 
            // upper_particle_sand_textbox
            // 
            this.upper_particle_sand_textbox.Location = new System.Drawing.Point(303, 69);
            this.upper_particle_sand_textbox.Name = "upper_particle_sand_textbox";
            this.upper_particle_sand_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_sand_textbox.TabIndex = 6;
            this.upper_particle_sand_textbox.Text = "0.002";
            // 
            // upper_particle_coarse_textbox
            // 
            this.upper_particle_coarse_textbox.Location = new System.Drawing.Point(303, 43);
            this.upper_particle_coarse_textbox.Name = "upper_particle_coarse_textbox";
            this.upper_particle_coarse_textbox.Size = new System.Drawing.Size(100, 20);
            this.upper_particle_coarse_textbox.TabIndex = 5;
            this.upper_particle_coarse_textbox.Text = "0.01";
            // 
            // physical_weath_constant2
            // 
            this.physical_weath_constant2.Location = new System.Drawing.Point(35, 95);
            this.physical_weath_constant2.Name = "physical_weath_constant2";
            this.physical_weath_constant2.Size = new System.Drawing.Size(100, 20);
            this.physical_weath_constant2.TabIndex = 4;
            this.physical_weath_constant2.Text = "5";
            // 
            // physical_weath_constant1
            // 
            this.physical_weath_constant1.Location = new System.Drawing.Point(35, 69);
            this.physical_weath_constant1.Name = "physical_weath_constant1";
            this.physical_weath_constant1.Size = new System.Drawing.Size(100, 20);
            this.physical_weath_constant1.TabIndex = 3;
            this.physical_weath_constant1.Text = "0.5";
            // 
            // Physical_weath_C1_textbox
            // 
            this.Physical_weath_C1_textbox.Location = new System.Drawing.Point(35, 43);
            this.Physical_weath_C1_textbox.Name = "Physical_weath_C1_textbox";
            this.Physical_weath_C1_textbox.Size = new System.Drawing.Size(100, 20);
            this.Physical_weath_C1_textbox.TabIndex = 2;
            this.Physical_weath_C1_textbox.Text = "0.000000004";
            // 
            // soil_phys_weath_checkbox
            // 
            this.soil_phys_weath_checkbox.AutoSize = true;
            this.soil_phys_weath_checkbox.Checked = true;
            this.soil_phys_weath_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_phys_weath_checkbox.Location = new System.Drawing.Point(21, 6);
            this.soil_phys_weath_checkbox.Name = "soil_phys_weath_checkbox";
            this.soil_phys_weath_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_phys_weath_checkbox.TabIndex = 1;
            this.soil_phys_weath_checkbox.Text = "Activate this process";
            this.soil_phys_weath_checkbox.UseVisualStyleBackColor = true;
            // 
            // chemical
            // 
            this.chemical.Controls.Add(label54);
            this.chemical.Controls.Add(label55);
            this.chemical.Controls.Add(label56);
            this.chemical.Controls.Add(label57);
            this.chemical.Controls.Add(label58);
            this.chemical.Controls.Add(label59);
            this.chemical.Controls.Add(this.specific_area_fine_clay_textbox);
            this.chemical.Controls.Add(this.specific_area_clay_textbox);
            this.chemical.Controls.Add(this.specific_area_silt_textbox);
            this.chemical.Controls.Add(this.specific_area_sand_textbox);
            this.chemical.Controls.Add(this.specific_area_coarse_textbox);
            this.chemical.Controls.Add(label53);
            this.chemical.Controls.Add(label50);
            this.chemical.Controls.Add(label51);
            this.chemical.Controls.Add(label52);
            this.chemical.Controls.Add(this.chem_weath_specific_coefficient_textbox);
            this.chemical.Controls.Add(this.chem_weath_depth_constant_textbox);
            this.chemical.Controls.Add(this.chem_weath_rate_constant_textbox);
            this.chemical.Controls.Add(this.soil_chem_weath_checkbox);
            this.chemical.Location = new System.Drawing.Point(4, 22);
            this.chemical.Name = "chemical";
            this.chemical.Padding = new System.Windows.Forms.Padding(3);
            this.chemical.Size = new System.Drawing.Size(751, 235);
            this.chemical.TabIndex = 1;
            this.chemical.Text = "Chemical weathering";
            this.chemical.UseVisualStyleBackColor = true;
            // 
            // specific_area_fine_clay_textbox
            // 
            this.specific_area_fine_clay_textbox.Location = new System.Drawing.Point(420, 142);
            this.specific_area_fine_clay_textbox.Name = "specific_area_fine_clay_textbox";
            this.specific_area_fine_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_fine_clay_textbox.TabIndex = 24;
            this.specific_area_fine_clay_textbox.Text = "100000";
            // 
            // specific_area_clay_textbox
            // 
            this.specific_area_clay_textbox.Location = new System.Drawing.Point(420, 116);
            this.specific_area_clay_textbox.Name = "specific_area_clay_textbox";
            this.specific_area_clay_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_clay_textbox.TabIndex = 23;
            this.specific_area_clay_textbox.Text = "50000";
            // 
            // specific_area_silt_textbox
            // 
            this.specific_area_silt_textbox.Location = new System.Drawing.Point(420, 90);
            this.specific_area_silt_textbox.Name = "specific_area_silt_textbox";
            this.specific_area_silt_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_silt_textbox.TabIndex = 22;
            this.specific_area_silt_textbox.Text = "1000";
            // 
            // specific_area_sand_textbox
            // 
            this.specific_area_sand_textbox.Location = new System.Drawing.Point(420, 64);
            this.specific_area_sand_textbox.Name = "specific_area_sand_textbox";
            this.specific_area_sand_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_sand_textbox.TabIndex = 21;
            this.specific_area_sand_textbox.Text = "100";
            // 
            // specific_area_coarse_textbox
            // 
            this.specific_area_coarse_textbox.Location = new System.Drawing.Point(420, 38);
            this.specific_area_coarse_textbox.Name = "specific_area_coarse_textbox";
            this.specific_area_coarse_textbox.Size = new System.Drawing.Size(100, 20);
            this.specific_area_coarse_textbox.TabIndex = 20;
            this.specific_area_coarse_textbox.Text = "10";
            // 
            // chem_weath_specific_coefficient_textbox
            // 
            this.chem_weath_specific_coefficient_textbox.Location = new System.Drawing.Point(29, 90);
            this.chem_weath_specific_coefficient_textbox.Name = "chem_weath_specific_coefficient_textbox";
            this.chem_weath_specific_coefficient_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_specific_coefficient_textbox.TabIndex = 15;
            this.chem_weath_specific_coefficient_textbox.Text = "1";
            // 
            // chem_weath_depth_constant_textbox
            // 
            this.chem_weath_depth_constant_textbox.Location = new System.Drawing.Point(29, 64);
            this.chem_weath_depth_constant_textbox.Name = "chem_weath_depth_constant_textbox";
            this.chem_weath_depth_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_depth_constant_textbox.TabIndex = 14;
            this.chem_weath_depth_constant_textbox.Text = "2.5";
            // 
            // chem_weath_rate_constant_textbox
            // 
            this.chem_weath_rate_constant_textbox.Location = new System.Drawing.Point(29, 38);
            this.chem_weath_rate_constant_textbox.Name = "chem_weath_rate_constant_textbox";
            this.chem_weath_rate_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.chem_weath_rate_constant_textbox.TabIndex = 13;
            this.chem_weath_rate_constant_textbox.Text = "0.000000004";
            // 
            // soil_chem_weath_checkbox
            // 
            this.soil_chem_weath_checkbox.AutoSize = true;
            this.soil_chem_weath_checkbox.Checked = true;
            this.soil_chem_weath_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_chem_weath_checkbox.Location = new System.Drawing.Point(29, 6);
            this.soil_chem_weath_checkbox.Name = "soil_chem_weath_checkbox";
            this.soil_chem_weath_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_chem_weath_checkbox.TabIndex = 1;
            this.soil_chem_weath_checkbox.Text = "Activate this process";
            this.soil_chem_weath_checkbox.UseVisualStyleBackColor = true;
            // 
            // clay
            // 
            this.clay.Controls.Add(this.ct_Jagercikova);
            this.clay.Controls.Add(this.label109);
            this.clay.Controls.Add(this.label108);
            this.clay.Controls.Add(this.ct_dd_Jagercikova);
            this.clay.Controls.Add(this.ct_v0_Jagercikova);
            this.clay.Controls.Add(label13);
            this.clay.Controls.Add(this.ct_depth_decay);
            this.clay.Controls.Add(this.CT_depth_decay_checkbox);
            this.clay.Controls.Add(label69);
            this.clay.Controls.Add(label70);
            this.clay.Controls.Add(eluviation_rate_constant);
            this.clay.Controls.Add(this.eluviation_coefficient_textbox);
            this.clay.Controls.Add(this.maximum_eluviation_textbox);
            this.clay.Controls.Add(label72);
            this.clay.Controls.Add(label64);
            this.clay.Controls.Add(label65);
            this.clay.Controls.Add(label66);
            this.clay.Controls.Add(label67);
            this.clay.Controls.Add(this.clay_neoform_C2_textbox);
            this.clay.Controls.Add(this.clay_neoform_C1_textbox);
            this.clay.Controls.Add(this.clay_neoform_constant_textbox);
            this.clay.Controls.Add(label60);
            this.clay.Controls.Add(this.soil_clay_transloc_checkbox);
            this.clay.Location = new System.Drawing.Point(4, 22);
            this.clay.Name = "clay";
            this.clay.Size = new System.Drawing.Size(751, 235);
            this.clay.TabIndex = 2;
            this.clay.Text = "Clay dynamics";
            this.clay.UseVisualStyleBackColor = true;
            // 
            // ct_Jagercikova
            // 
            this.ct_Jagercikova.AutoSize = true;
            this.ct_Jagercikova.Location = new System.Drawing.Point(540, 52);
            this.ct_Jagercikova.Name = "ct_Jagercikova";
            this.ct_Jagercikova.Size = new System.Drawing.Size(179, 17);
            this.ct_Jagercikova.TabIndex = 62;
            this.ct_Jagercikova.Text = "Advection equation Jagercikova";
            this.ct_Jagercikova.UseVisualStyleBackColor = true;
            // 
            // label109
            // 
            this.label109.AutoSize = true;
            this.label109.Location = new System.Drawing.Point(602, 108);
            this.label109.Name = "label109";
            this.label109.Size = new System.Drawing.Size(98, 13);
            this.label109.TabIndex = 61;
            this.label109.Text = "depth decay [cm-1]";
            // 
            // label108
            // 
            this.label108.AutoSize = true;
            this.label108.Location = new System.Drawing.Point(597, 78);
            this.label108.Name = "label108";
            this.label108.Size = new System.Drawing.Size(148, 13);
            this.label108.TabIndex = 60;
            this.label108.Text = "surface advection v0 [cm a-1]";
            // 
            // ct_dd_Jagercikova
            // 
            this.ct_dd_Jagercikova.Location = new System.Drawing.Point(540, 104);
            this.ct_dd_Jagercikova.Name = "ct_dd_Jagercikova";
            this.ct_dd_Jagercikova.Size = new System.Drawing.Size(51, 20);
            this.ct_dd_Jagercikova.TabIndex = 58;
            this.ct_dd_Jagercikova.Text = "0.09";
            // 
            // ct_v0_Jagercikova
            // 
            this.ct_v0_Jagercikova.Location = new System.Drawing.Point(540, 75);
            this.ct_v0_Jagercikova.Name = "ct_v0_Jagercikova";
            this.ct_v0_Jagercikova.Size = new System.Drawing.Size(51, 20);
            this.ct_v0_Jagercikova.TabIndex = 57;
            this.ct_v0_Jagercikova.Text = "0.18";
            // 
            // ct_depth_decay
            // 
            this.ct_depth_decay.Location = new System.Drawing.Point(303, 169);
            this.ct_depth_decay.Name = "ct_depth_decay";
            this.ct_depth_decay.Size = new System.Drawing.Size(100, 20);
            this.ct_depth_decay.TabIndex = 55;
            this.ct_depth_decay.Text = "2";
            // 
            // CT_depth_decay_checkbox
            // 
            this.CT_depth_decay_checkbox.AutoSize = true;
            this.CT_depth_decay_checkbox.Checked = true;
            this.CT_depth_decay_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.CT_depth_decay_checkbox.Location = new System.Drawing.Point(304, 146);
            this.CT_depth_decay_checkbox.Name = "CT_depth_decay_checkbox";
            this.CT_depth_decay_checkbox.Size = new System.Drawing.Size(137, 17);
            this.CT_depth_decay_checkbox.TabIndex = 54;
            this.CT_depth_decay_checkbox.Text = "Depth decay constant?";
            this.CT_depth_decay_checkbox.UseVisualStyleBackColor = true;
            // 
            // eluviation_coefficient_textbox
            // 
            this.eluviation_coefficient_textbox.Location = new System.Drawing.Point(304, 101);
            this.eluviation_coefficient_textbox.Name = "eluviation_coefficient_textbox";
            this.eluviation_coefficient_textbox.Size = new System.Drawing.Size(100, 20);
            this.eluviation_coefficient_textbox.TabIndex = 49;
            this.eluviation_coefficient_textbox.Text = "2";
            // 
            // maximum_eluviation_textbox
            // 
            this.maximum_eluviation_textbox.Location = new System.Drawing.Point(304, 75);
            this.maximum_eluviation_textbox.Name = "maximum_eluviation_textbox";
            this.maximum_eluviation_textbox.Size = new System.Drawing.Size(100, 20);
            this.maximum_eluviation_textbox.TabIndex = 48;
            this.maximum_eluviation_textbox.Text = "0.007";
            // 
            // clay_neoform_C2_textbox
            // 
            this.clay_neoform_C2_textbox.Location = new System.Drawing.Point(25, 127);
            this.clay_neoform_C2_textbox.Name = "clay_neoform_C2_textbox";
            this.clay_neoform_C2_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_C2_textbox.TabIndex = 42;
            this.clay_neoform_C2_textbox.Text = "20";
            // 
            // clay_neoform_C1_textbox
            // 
            this.clay_neoform_C1_textbox.Location = new System.Drawing.Point(25, 101);
            this.clay_neoform_C1_textbox.Name = "clay_neoform_C1_textbox";
            this.clay_neoform_C1_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_C1_textbox.TabIndex = 41;
            this.clay_neoform_C1_textbox.Text = "1";
            // 
            // clay_neoform_constant_textbox
            // 
            this.clay_neoform_constant_textbox.Location = new System.Drawing.Point(25, 75);
            this.clay_neoform_constant_textbox.Name = "clay_neoform_constant_textbox";
            this.clay_neoform_constant_textbox.Size = new System.Drawing.Size(100, 20);
            this.clay_neoform_constant_textbox.TabIndex = 40;
            this.clay_neoform_constant_textbox.Text = "0.5";
            // 
            // soil_clay_transloc_checkbox
            // 
            this.soil_clay_transloc_checkbox.AutoSize = true;
            this.soil_clay_transloc_checkbox.Checked = true;
            this.soil_clay_transloc_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_clay_transloc_checkbox.Location = new System.Drawing.Point(26, 12);
            this.soil_clay_transloc_checkbox.Name = "soil_clay_transloc_checkbox";
            this.soil_clay_transloc_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_clay_transloc_checkbox.TabIndex = 1;
            this.soil_clay_transloc_checkbox.Text = "Activate this process";
            this.soil_clay_transloc_checkbox.UseVisualStyleBackColor = true;
            // 
            // bioturbation
            // 
            this.bioturbation.Controls.Add(label68);
            this.bioturbation.Controls.Add(label71);
            this.bioturbation.Controls.Add(label73);
            this.bioturbation.Controls.Add(this.bioturbation_depth_decay_textbox);
            this.bioturbation.Controls.Add(this.potential_bioturbation_textbox);
            this.bioturbation.Controls.Add(this.soil_bioturb_checkbox);
            this.bioturbation.Location = new System.Drawing.Point(4, 22);
            this.bioturbation.Name = "bioturbation";
            this.bioturbation.Size = new System.Drawing.Size(751, 235);
            this.bioturbation.TabIndex = 3;
            this.bioturbation.Text = "Bioturbation";
            this.bioturbation.UseVisualStyleBackColor = true;
            // 
            // bioturbation_depth_decay_textbox
            // 
            this.bioturbation_depth_decay_textbox.Location = new System.Drawing.Point(26, 74);
            this.bioturbation_depth_decay_textbox.Name = "bioturbation_depth_decay_textbox";
            this.bioturbation_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.bioturbation_depth_decay_textbox.TabIndex = 56;
            this.bioturbation_depth_decay_textbox.Text = "2.5";
            // 
            // potential_bioturbation_textbox
            // 
            this.potential_bioturbation_textbox.Location = new System.Drawing.Point(26, 48);
            this.potential_bioturbation_textbox.Name = "potential_bioturbation_textbox";
            this.potential_bioturbation_textbox.Size = new System.Drawing.Size(100, 20);
            this.potential_bioturbation_textbox.TabIndex = 55;
            this.potential_bioturbation_textbox.Text = "4.3";
            // 
            // soil_bioturb_checkbox
            // 
            this.soil_bioturb_checkbox.AutoSize = true;
            this.soil_bioturb_checkbox.Checked = true;
            this.soil_bioturb_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_bioturb_checkbox.Location = new System.Drawing.Point(26, 12);
            this.soil_bioturb_checkbox.Name = "soil_bioturb_checkbox";
            this.soil_bioturb_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_bioturb_checkbox.TabIndex = 1;
            this.soil_bioturb_checkbox.Text = "Activate this process";
            this.soil_bioturb_checkbox.UseVisualStyleBackColor = true;
            // 
            // carbon
            // 
            this.carbon.Controls.Add(this.carbon_o_decomp_rate_textbox);
            this.carbon.Controls.Add(label86);
            this.carbon.Controls.Add(this.carbon_y_decomp_rate_textbox);
            this.carbon.Controls.Add(this.carbon_o_twi_decay_textbox);
            this.carbon.Controls.Add(label85);
            this.carbon.Controls.Add(this.carbon_y_twi_decay_textbox);
            this.carbon.Controls.Add(this.carbon_o_depth_decay_textbox);
            this.carbon.Controls.Add(label84);
            this.carbon.Controls.Add(this.carbon_y_depth_decay_textbox);
            this.carbon.Controls.Add(label83);
            this.carbon.Controls.Add(label82);
            this.carbon.Controls.Add(label80);
            this.carbon.Controls.Add(label77);
            this.carbon.Controls.Add(label81);
            this.carbon.Controls.Add(this.carbon_humification_fraction_textbox);
            this.carbon.Controls.Add(label74);
            this.carbon.Controls.Add(label75);
            this.carbon.Controls.Add(label76);
            this.carbon.Controls.Add(this.carbon_depth_decay_textbox);
            this.carbon.Controls.Add(this.carbon_input_textbox);
            this.carbon.Controls.Add(this.soil_carbon_cycle_checkbox);
            this.carbon.Location = new System.Drawing.Point(4, 22);
            this.carbon.Name = "carbon";
            this.carbon.Size = new System.Drawing.Size(751, 235);
            this.carbon.TabIndex = 4;
            this.carbon.Text = "Carbon Cycle";
            this.carbon.UseVisualStyleBackColor = true;
            // 
            // carbon_o_decomp_rate_textbox
            // 
            this.carbon_o_decomp_rate_textbox.Location = new System.Drawing.Point(453, 111);
            this.carbon_o_decomp_rate_textbox.Name = "carbon_o_decomp_rate_textbox";
            this.carbon_o_decomp_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_decomp_rate_textbox.TabIndex = 81;
            this.carbon_o_decomp_rate_textbox.Text = "0.005";
            // 
            // carbon_y_decomp_rate_textbox
            // 
            this.carbon_y_decomp_rate_textbox.Location = new System.Drawing.Point(347, 111);
            this.carbon_y_decomp_rate_textbox.Name = "carbon_y_decomp_rate_textbox";
            this.carbon_y_decomp_rate_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_decomp_rate_textbox.TabIndex = 79;
            this.carbon_y_decomp_rate_textbox.Text = "0.01";
            // 
            // carbon_o_twi_decay_textbox
            // 
            this.carbon_o_twi_decay_textbox.Location = new System.Drawing.Point(453, 163);
            this.carbon_o_twi_decay_textbox.Name = "carbon_o_twi_decay_textbox";
            this.carbon_o_twi_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_twi_decay_textbox.TabIndex = 78;
            this.carbon_o_twi_decay_textbox.Text = "0.03";
            // 
            // carbon_y_twi_decay_textbox
            // 
            this.carbon_y_twi_decay_textbox.Location = new System.Drawing.Point(347, 163);
            this.carbon_y_twi_decay_textbox.Name = "carbon_y_twi_decay_textbox";
            this.carbon_y_twi_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_twi_decay_textbox.TabIndex = 76;
            this.carbon_y_twi_decay_textbox.Text = "0.03";
            // 
            // carbon_o_depth_decay_textbox
            // 
            this.carbon_o_depth_decay_textbox.Location = new System.Drawing.Point(453, 137);
            this.carbon_o_depth_decay_textbox.Name = "carbon_o_depth_decay_textbox";
            this.carbon_o_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_o_depth_decay_textbox.TabIndex = 75;
            this.carbon_o_depth_decay_textbox.Text = "8";
            // 
            // carbon_y_depth_decay_textbox
            // 
            this.carbon_y_depth_decay_textbox.Location = new System.Drawing.Point(347, 137);
            this.carbon_y_depth_decay_textbox.Name = "carbon_y_depth_decay_textbox";
            this.carbon_y_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_y_depth_decay_textbox.TabIndex = 73;
            this.carbon_y_depth_decay_textbox.Text = "8";
            // 
            // carbon_humification_fraction_textbox
            // 
            this.carbon_humification_fraction_textbox.Location = new System.Drawing.Point(23, 117);
            this.carbon_humification_fraction_textbox.Name = "carbon_humification_fraction_textbox";
            this.carbon_humification_fraction_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_humification_fraction_textbox.TabIndex = 65;
            this.carbon_humification_fraction_textbox.Text = "0.8";
            // 
            // carbon_depth_decay_textbox
            // 
            this.carbon_depth_decay_textbox.Location = new System.Drawing.Point(23, 88);
            this.carbon_depth_decay_textbox.Name = "carbon_depth_decay_textbox";
            this.carbon_depth_decay_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_depth_decay_textbox.TabIndex = 61;
            this.carbon_depth_decay_textbox.Text = "8";
            // 
            // carbon_input_textbox
            // 
            this.carbon_input_textbox.Location = new System.Drawing.Point(23, 62);
            this.carbon_input_textbox.Name = "carbon_input_textbox";
            this.carbon_input_textbox.Size = new System.Drawing.Size(100, 20);
            this.carbon_input_textbox.TabIndex = 60;
            this.carbon_input_textbox.Text = "1.5";
            // 
            // soil_carbon_cycle_checkbox
            // 
            this.soil_carbon_cycle_checkbox.AutoSize = true;
            this.soil_carbon_cycle_checkbox.Checked = true;
            this.soil_carbon_cycle_checkbox.CheckState = System.Windows.Forms.CheckState.Checked;
            this.soil_carbon_cycle_checkbox.Location = new System.Drawing.Point(25, 14);
            this.soil_carbon_cycle_checkbox.Name = "soil_carbon_cycle_checkbox";
            this.soil_carbon_cycle_checkbox.Size = new System.Drawing.Size(124, 17);
            this.soil_carbon_cycle_checkbox.TabIndex = 2;
            this.soil_carbon_cycle_checkbox.Text = "Activate this process";
            this.soil_carbon_cycle_checkbox.UseVisualStyleBackColor = true;
            // 
            // decalcification
            // 
            this.decalcification.Controls.Add(this.label94);
            this.decalcification.Controls.Add(this.ini_CaCO3_content);
            this.decalcification.Controls.Add(this.decalcification_checkbox);
            this.decalcification.Location = new System.Drawing.Point(4, 22);
            this.decalcification.Name = "decalcification";
            this.decalcification.Size = new System.Drawing.Size(751, 235);
            this.decalcification.TabIndex = 5;
            this.decalcification.Text = "Decalcification";
            this.decalcification.UseVisualStyleBackColor = true;
            // 
            // label94
            // 
            this.label94.AutoSize = true;
            this.label94.Location = new System.Drawing.Point(138, 42);
            this.label94.Name = "label94";
            this.label94.Size = new System.Drawing.Size(107, 13);
            this.label94.TabIndex = 2;
            this.label94.Text = "Initial CaCO3 content";
            // 
            // ini_CaCO3_content
            // 
            this.ini_CaCO3_content.Location = new System.Drawing.Point(32, 39);
            this.ini_CaCO3_content.Name = "ini_CaCO3_content";
            this.ini_CaCO3_content.Size = new System.Drawing.Size(100, 20);
            this.ini_CaCO3_content.TabIndex = 1;
            this.ini_CaCO3_content.Text = "0.1";
            // 
            // decalcification_checkbox
            // 
            this.decalcification_checkbox.AutoSize = true;
            this.decalcification_checkbox.Location = new System.Drawing.Point(32, 15);
            this.decalcification_checkbox.Name = "decalcification_checkbox";
            this.decalcification_checkbox.Size = new System.Drawing.Size(124, 17);
            this.decalcification_checkbox.TabIndex = 0;
            this.decalcification_checkbox.Text = "Activate this process";
            this.decalcification_checkbox.UseVisualStyleBackColor = true;
            // 
            // tabPage3
            // 
            this.tabPage3.Controls.Add(this.tabControl3);
            this.tabPage3.Location = new System.Drawing.Point(4, 22);
            this.tabPage3.Name = "tabPage3";
            this.tabPage3.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage3.Size = new System.Drawing.Size(803, 293);
            this.tabPage3.TabIndex = 11;
            this.tabPage3.Text = "Geochronological tracers";
            this.tabPage3.UseVisualStyleBackColor = true;
            // 
            // tabControl3
            // 
            this.tabControl3.Controls.Add(this.tabPage4);
            this.tabControl3.Controls.Add(this.tabPage5);
            this.tabControl3.Location = new System.Drawing.Point(6, 6);
            this.tabControl3.Name = "tabControl3";
            this.tabControl3.SelectedIndex = 0;
            this.tabControl3.Size = new System.Drawing.Size(797, 278);
            this.tabControl3.TabIndex = 0;
            // 
            // tabPage4
            // 
            this.tabPage4.Controls.Add(this.label137);
            this.tabPage4.Controls.Add(this.OSL_inherited_textbox);
            this.tabPage4.Controls.Add(this.label122);
            this.tabPage4.Controls.Add(this.bleachingdepth_textbox);
            this.tabPage4.Controls.Add(this.label121);
            this.tabPage4.Controls.Add(this.ngrains_textbox);
            this.tabPage4.Controls.Add(this.OSL_checkbox);
            this.tabPage4.Location = new System.Drawing.Point(4, 22);
            this.tabPage4.Name = "tabPage4";
            this.tabPage4.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage4.Size = new System.Drawing.Size(789, 252);
            this.tabPage4.TabIndex = 0;
            this.tabPage4.Text = "Particle ages";
            this.tabPage4.UseVisualStyleBackColor = true;
            // 
            // label137
            // 
            this.label137.AutoSize = true;
            this.label137.Location = new System.Drawing.Point(64, 103);
            this.label137.Name = "label137";
            this.label137.Size = new System.Drawing.Size(84, 13);
            this.label137.TabIndex = 16;
            this.label137.Text = "Inherited age [a]";
            // 
            // OSL_inherited_textbox
            // 
            this.OSL_inherited_textbox.Location = new System.Drawing.Point(6, 97);
            this.OSL_inherited_textbox.Name = "OSL_inherited_textbox";
            this.OSL_inherited_textbox.Size = new System.Drawing.Size(45, 20);
            this.OSL_inherited_textbox.TabIndex = 15;
            this.OSL_inherited_textbox.Text = "0";
            // 
            // label122
            // 
            this.label122.AutoSize = true;
            this.label122.Location = new System.Drawing.Point(64, 70);
            this.label122.Name = "label122";
            this.label122.Size = new System.Drawing.Size(101, 13);
            this.label122.TabIndex = 14;
            this.label122.Text = "Bleaching depth [m]";
            // 
            // bleachingdepth_textbox
            // 
            this.bleachingdepth_textbox.Location = new System.Drawing.Point(6, 64);
            this.bleachingdepth_textbox.Name = "bleachingdepth_textbox";
            this.bleachingdepth_textbox.Size = new System.Drawing.Size(45, 20);
            this.bleachingdepth_textbox.TabIndex = 13;
            this.bleachingdepth_textbox.Text = "0.005";
            // 
            // label121
            // 
            this.label121.AutoSize = true;
            this.label121.Location = new System.Drawing.Point(60, 39);
            this.label121.Name = "label121";
            this.label121.Size = new System.Drawing.Size(190, 13);
            this.label121.TabIndex = 12;
            this.label121.Text = "Initial number of grains per kg/m2 sand";
            // 
            // ngrains_textbox
            // 
            this.ngrains_textbox.Location = new System.Drawing.Point(6, 33);
            this.ngrains_textbox.Name = "ngrains_textbox";
            this.ngrains_textbox.Size = new System.Drawing.Size(45, 20);
            this.ngrains_textbox.TabIndex = 10;
            this.ngrains_textbox.Text = "2";
            // 
            // OSL_checkbox
            // 
            this.OSL_checkbox.AutoSize = true;
            this.OSL_checkbox.Location = new System.Drawing.Point(9, 9);
            this.OSL_checkbox.Name = "OSL_checkbox";
            this.OSL_checkbox.Size = new System.Drawing.Size(124, 17);
            this.OSL_checkbox.TabIndex = 9;
            this.OSL_checkbox.Text = "Activate this process";
            this.OSL_checkbox.UseVisualStyleBackColor = true;
            // 
            // tabPage5
            // 
            this.tabPage5.Controls.Add(this.label780_cn);
            this.tabPage5.Controls.Add(this.label1310_cn);
            this.tabPage5.Controls.Add(this.label132_cn);
            this.tabPage5.Controls.Add(this.isC14_mu_input_textbox);
            this.tabPage5.Controls.Add(this.isBe10_mu_input_textbox);
            this.tabPage5.Controls.Add(this.label131_cn);
            this.tabPage5.Controls.Add(this.attenuationlength_mu_textbox);
            this.tabPage5.Controls.Add(this.label138_CN);
            this.tabPage5.Controls.Add(this.met_10Be_clayfrac);
            this.tabPage5.Controls.Add(this.label_met10Be_dd);
            this.tabPage5.Controls.Add(this.met10Be_dd);
            this.tabPage5.Controls.Add(this.label136_cn);
            this.tabPage5.Controls.Add(this.isC14_inherited_textbox);
            this.tabPage5.Controls.Add(this.isBe10_inherited_textbox);
            this.tabPage5.Controls.Add(this.label134);
            this.tabPage5.Controls.Add(this.metBe10_inherited_textbox);
            this.tabPage5.Controls.Add(this.label133_cn);
            this.tabPage5.Controls.Add(this.attenuationlength_sp_textbox);
            this.tabPage5.Controls.Add(this.label130);
            this.tabPage5.Controls.Add(this.label79_cn);
            this.tabPage5.Controls.Add(this.label78_cn);
            this.tabPage5.Controls.Add(this.C14_decay_textbox);
            this.tabPage5.Controls.Add(this.isC14_sp_input_textbox);
            this.tabPage5.Controls.Add(this.label33_cn);
            this.tabPage5.Controls.Add(this.label126);
            this.tabPage5.Controls.Add(this.label125);
            this.tabPage5.Controls.Add(this.isBe10_sp_input_textbox);
            this.tabPage5.Controls.Add(this.Be10_decay_textbox);
            this.tabPage5.Controls.Add(this.metBe10_input_textbox);
            this.tabPage5.Controls.Add(this.label124);
            this.tabPage5.Controls.Add(this.label123);
            this.tabPage5.Controls.Add(this.CN_checkbox);
            this.tabPage5.Location = new System.Drawing.Point(4, 22);
            this.tabPage5.Name = "tabPage5";
            this.tabPage5.Padding = new System.Windows.Forms.Padding(3);
            this.tabPage5.Size = new System.Drawing.Size(789, 252);
            this.tabPage5.TabIndex = 1;
            this.tabPage5.Text = "Cosmogenic nuclides";
            this.tabPage5.UseVisualStyleBackColor = true;
            // 
            // label780_cn
            // 
            this.label780_cn.AutoSize = true;
            this.label780_cn.Location = new System.Drawing.Point(510, 117);
            this.label780_cn.Name = "label780_cn";
            this.label780_cn.Size = new System.Drawing.Size(108, 13);
            this.label780_cn.TabIndex = 47;
            this.label780_cn.Text = "[atoms g quartz-1 y-1]";
            // 
            // label1310_cn
            // 
            this.label1310_cn.AutoSize = true;
            this.label1310_cn.Location = new System.Drawing.Point(795, 183);
            this.label1310_cn.Name = "label1310_cn";
            this.label1310_cn.Size = new System.Drawing.Size(108, 13);
            this.label1310_cn.TabIndex = 46;
            this.label1310_cn.Text = "[atoms g quartz-1 y-1]";
            // 
            // label132_cn
            // 
            this.label132_cn.AutoSize = true;
            this.label132_cn.Location = new System.Drawing.Point(507, 101);
            this.label132_cn.Name = "label132_cn";
            this.label132_cn.Size = new System.Drawing.Size(176, 13);
            this.label132_cn.TabIndex = 45;
            this.label132_cn.Text = "Muon production rate at the surface";
            // 
            // isC14_mu_input_textbox
            // 
            this.isC14_mu_input_textbox.Location = new System.Drawing.Point(444, 105);
            this.isC14_mu_input_textbox.Name = "isC14_mu_input_textbox";
            this.isC14_mu_input_textbox.Size = new System.Drawing.Size(57, 20);
            this.isC14_mu_input_textbox.TabIndex = 44;
            this.isC14_mu_input_textbox.Text = "0";
            // 
            // isBe10_mu_input_textbox
            // 
            this.isBe10_mu_input_textbox.Location = new System.Drawing.Point(320, 105);
            this.isBe10_mu_input_textbox.Name = "isBe10_mu_input_textbox";
            this.isBe10_mu_input_textbox.Size = new System.Drawing.Size(57, 20);
            this.isBe10_mu_input_textbox.TabIndex = 43;
            this.isBe10_mu_input_textbox.Text = "0.084";
            // 
            // label131_cn
            // 
            this.label131_cn.AutoSize = true;
            this.label131_cn.Location = new System.Drawing.Point(379, 225);
            this.label131_cn.Name = "label131_cn";
            this.label131_cn.Size = new System.Drawing.Size(217, 13);
            this.label131_cn.TabIndex = 42;
            this.label131_cn.Text = "Attenuation length in-situ CNs Muon [kg m-2]";
            // 
            // attenuationlength_mu_textbox
            // 
            this.attenuationlength_mu_textbox.Location = new System.Drawing.Point(316, 222);
            this.attenuationlength_mu_textbox.Name = "attenuationlength_mu_textbox";
            this.attenuationlength_mu_textbox.Size = new System.Drawing.Size(57, 20);
            this.attenuationlength_mu_textbox.TabIndex = 41;
            this.attenuationlength_mu_textbox.Text = "25000";
            // 
            // label138_CN
            // 
            this.label138_CN.AutoSize = true;
            this.label138_CN.Location = new System.Drawing.Point(75, 176);
            this.label138_CN.Margin = new System.Windows.Forms.Padding(3, 0, 2, 0);
            this.label138_CN.Name = "label138_CN";
            this.label138_CN.Size = new System.Drawing.Size(133, 13);
            this.label138_CN.TabIndex = 40;
            this.label138_CN.Text = "Fraction associated to clay";
            // 
            // met_10Be_clayfrac
            // 
            this.met_10Be_clayfrac.Location = new System.Drawing.Point(12, 171);
            this.met_10Be_clayfrac.Name = "met_10Be_clayfrac";
            this.met_10Be_clayfrac.Size = new System.Drawing.Size(56, 20);
            this.met_10Be_clayfrac.TabIndex = 39;
            this.met_10Be_clayfrac.Text = "0.8";
            // 
            // label_met10Be_dd
            // 
            this.label_met10Be_dd.AutoSize = true;
            this.label_met10Be_dd.Cursor = System.Windows.Forms.Cursors.Arrow;
            this.label_met10Be_dd.Location = new System.Drawing.Point(74, 108);
            this.label_met10Be_dd.Name = "label_met10Be_dd";
            this.label_met10Be_dd.Size = new System.Drawing.Size(109, 13);
            this.label_met10Be_dd.TabIndex = 38;
            this.label_met10Be_dd.Text = "Adsorption coefficient";
            // 
            // met10Be_dd
            // 
            this.met10Be_dd.Location = new System.Drawing.Point(11, 103);
            this.met10Be_dd.Name = "met10Be_dd";
            this.met10Be_dd.Size = new System.Drawing.Size(56, 20);
            this.met10Be_dd.TabIndex = 37;
            this.met10Be_dd.Text = "4";
            // 
            // label136_cn
            // 
            this.label136_cn.AutoSize = true;
            this.label136_cn.Location = new System.Drawing.Point(508, 173);
            this.label136_cn.Name = "label136_cn";
            this.label136_cn.Size = new System.Drawing.Size(105, 13);
            this.label136_cn.TabIndex = 36;
            this.label136_cn.Text = "Inherited atoms cm-2";
            // 
            // isC14_inherited_textbox
            // 
            this.isC14_inherited_textbox.Location = new System.Drawing.Point(445, 168);
            this.isC14_inherited_textbox.Name = "isC14_inherited_textbox";
            this.isC14_inherited_textbox.Size = new System.Drawing.Size(56, 20);
            this.isC14_inherited_textbox.TabIndex = 35;
            this.isC14_inherited_textbox.Text = "0";
            // 
            // isBe10_inherited_textbox
            // 
            this.isBe10_inherited_textbox.Location = new System.Drawing.Point(317, 167);
            this.isBe10_inherited_textbox.Name = "isBe10_inherited_textbox";
            this.isBe10_inherited_textbox.Size = new System.Drawing.Size(56, 20);
            this.isBe10_inherited_textbox.TabIndex = 33;
            this.isBe10_inherited_textbox.Text = "0";
            // 
            // label134
            // 
            this.label134.AutoSize = true;
            this.label134.Location = new System.Drawing.Point(74, 206);
            this.label134.Name = "label134";
            this.label134.Size = new System.Drawing.Size(105, 13);
            this.label134.TabIndex = 32;
            this.label134.Text = "Inherited atoms cm-2";
            // 
            // metBe10_inherited_textbox
            // 
            this.metBe10_inherited_textbox.Location = new System.Drawing.Point(11, 201);
            this.metBe10_inherited_textbox.Name = "metBe10_inherited_textbox";
            this.metBe10_inherited_textbox.Size = new System.Drawing.Size(56, 20);
            this.metBe10_inherited_textbox.TabIndex = 31;
            this.metBe10_inherited_textbox.Text = "0";
            // 
            // label133_cn
            // 
            this.label133_cn.AutoSize = true;
            this.label133_cn.Location = new System.Drawing.Point(380, 199);
            this.label133_cn.Name = "label133_cn";
            this.label133_cn.Size = new System.Drawing.Size(236, 13);
            this.label133_cn.TabIndex = 30;
            this.label133_cn.Text = "Attenuation length in-situ CNs Spallation [kg m-2]";
            // 
            // attenuationlength_sp_textbox
            // 
            this.attenuationlength_sp_textbox.Location = new System.Drawing.Point(317, 196);
            this.attenuationlength_sp_textbox.Name = "attenuationlength_sp_textbox";
            this.attenuationlength_sp_textbox.Size = new System.Drawing.Size(57, 20);
            this.attenuationlength_sp_textbox.TabIndex = 29;
            this.attenuationlength_sp_textbox.Text = "1600";
            // 
            // label130
            // 
            this.label130.AutoSize = true;
            this.label130.Location = new System.Drawing.Point(508, 139);
            this.label130.Name = "label130";
            this.label130.Size = new System.Drawing.Size(61, 13);
            this.label130.TabIndex = 26;
            this.label130.Text = "Decay [y-1]";
            // 
            // label79_cn
            // 
            this.label79_cn.AutoSize = true;
            this.label79_cn.Location = new System.Drawing.Point(508, 81);
            this.label79_cn.Name = "label79_cn";
            this.label79_cn.Size = new System.Drawing.Size(108, 13);
            this.label79_cn.TabIndex = 25;
            this.label79_cn.Text = "[atoms g quartz-1 y-1]";
            // 
            // label78_cn
            // 
            this.label78_cn.AutoSize = true;
            this.label78_cn.Location = new System.Drawing.Point(508, 65);
            this.label78_cn.Name = "label78_cn";
            this.label78_cn.Size = new System.Drawing.Size(195, 13);
            this.label78_cn.TabIndex = 24;
            this.label78_cn.Text = "Spallation production rate at the surface";
            // 
            // C14_decay_textbox
            // 
            this.C14_decay_textbox.Location = new System.Drawing.Point(445, 136);
            this.C14_decay_textbox.Name = "C14_decay_textbox";
            this.C14_decay_textbox.Size = new System.Drawing.Size(57, 20);
            this.C14_decay_textbox.TabIndex = 22;
            this.C14_decay_textbox.Text = "1.21E-4";
            // 
            // isC14_sp_input_textbox
            // 
            this.isC14_sp_input_textbox.Location = new System.Drawing.Point(445, 69);
            this.isC14_sp_input_textbox.Name = "isC14_sp_input_textbox";
            this.isC14_sp_input_textbox.Size = new System.Drawing.Size(57, 20);
            this.isC14_sp_input_textbox.TabIndex = 21;
            this.isC14_sp_input_textbox.Text = "15.7";
            // 
            // label33_cn
            // 
            this.label33_cn.AutoSize = true;
            this.label33_cn.Location = new System.Drawing.Point(445, 49);
            this.label33_cn.Name = "label33_cn";
            this.label33_cn.Size = new System.Drawing.Size(87, 13);
            this.label33_cn.TabIndex = 20;
            this.label33_cn.Text = "In-situ Carbon-14";
            // 
            // label126
            // 
            this.label126.AutoSize = true;
            this.label126.Location = new System.Drawing.Point(74, 145);
            this.label126.Name = "label126";
            this.label126.Size = new System.Drawing.Size(61, 13);
            this.label126.TabIndex = 19;
            this.label126.Text = "Decay [y-1]";
            // 
            // label125
            // 
            this.label125.AutoSize = true;
            this.label125.Location = new System.Drawing.Point(74, 76);
            this.label125.Name = "label125";
            this.label125.Size = new System.Drawing.Size(111, 13);
            this.label125.TabIndex = 18;
            this.label125.Text = "Input [atoms cm-2 y-1]";
            // 
            // isBe10_sp_input_textbox
            // 
            this.isBe10_sp_input_textbox.Location = new System.Drawing.Point(321, 69);
            this.isBe10_sp_input_textbox.Name = "isBe10_sp_input_textbox";
            this.isBe10_sp_input_textbox.Size = new System.Drawing.Size(57, 20);
            this.isBe10_sp_input_textbox.TabIndex = 15;
            this.isBe10_sp_input_textbox.Text = "4.76";
            // 
            // Be10_decay_textbox
            // 
            this.Be10_decay_textbox.Location = new System.Drawing.Point(11, 140);
            this.Be10_decay_textbox.Name = "Be10_decay_textbox";
            this.Be10_decay_textbox.Size = new System.Drawing.Size(56, 20);
            this.Be10_decay_textbox.TabIndex = 14;
            this.Be10_decay_textbox.Text = "4.997E-7";
            // 
            // metBe10_input_textbox
            // 
            this.metBe10_input_textbox.Location = new System.Drawing.Point(12, 71);
            this.metBe10_input_textbox.Name = "metBe10_input_textbox";
            this.metBe10_input_textbox.Size = new System.Drawing.Size(56, 20);
            this.metBe10_input_textbox.TabIndex = 13;
            this.metBe10_input_textbox.Text = "1000000";
            // 
            // label124
            // 
            this.label124.AutoSize = true;
            this.label124.Location = new System.Drawing.Point(321, 48);
            this.label124.Name = "label124";
            this.label124.Size = new System.Drawing.Size(94, 13);
            this.label124.TabIndex = 12;
            this.label124.Text = "In-situ Beryllium-10";
            // 
            // label123
            // 
            this.label123.AutoSize = true;
            this.label123.Location = new System.Drawing.Point(12, 48);
            this.label123.Name = "label123";
            this.label123.Size = new System.Drawing.Size(107, 13);
            this.label123.TabIndex = 11;
            this.label123.Text = "Meteoric Beryllium-10";
            // 
            // CN_checkbox
            // 
            this.CN_checkbox.AutoSize = true;
            this.CN_checkbox.Location = new System.Drawing.Point(9, 9);
            this.CN_checkbox.Name = "CN_checkbox";
            this.CN_checkbox.Size = new System.Drawing.Size(124, 17);
            this.CN_checkbox.TabIndex = 10;
            this.CN_checkbox.Text = "Activate this process";
            this.CN_checkbox.UseVisualStyleBackColor = true;
            // 
            // tabPage2
            // 
            this.tabPage2.Controls.Add(this.check_scaling_daily_weather);
            this.tabPage2.Controls.Add(this.label106);
            this.tabPage2.Controls.Add(this.snow_threshold_textbox);
            this.tabPage2.Controls.Add(this.label105);
            this.tabPage2.Controls.Add(this.snowmelt_factor_textbox);
            this.tabPage2.Controls.Add(this.label104);
            this.tabPage2.Controls.Add(this.latitude_min);
            this.tabPage2.Controls.Add(this.label103);
            this.tabPage2.Controls.Add(this.latitude_deg);
            this.tabPage2.Controls.Add(this.label100);
            this.tabPage2.Controls.Add(this.label101);
            this.tabPage2.Controls.Add(this.label102);
            this.tabPage2.Controls.Add(this.dailyT_min);
            this.tabPage2.Controls.Add(this.dailyT_max);
            this.tabPage2.Controls.Add(this.dailyT_avg);
            this.tabPage2.Controls.Add(this.label97);
            this.tabPage2.Controls.Add(this.daily_n);
            this.tabPage2.Controls.Add(this.label96);
            this.tabPage2.Controls.Add(this.label93);
            this.tabPage2.Controls.Add(this.label89);
            this.tabPage2.Controls.Add(this.label40);
            this.tabPage2.Controls.Add(this.dailyET0);
            this.tabPage2.Controls.Add(this.dailyD);
            this.tabPage2.Controls.Add(this.dailyP);
            this.tabPage2.Location = new System.Drawing.Point(4, 22);
            this.tabPage2.Name = "tabPage2";
            this.tabPage2.Size = new System.Drawing.Size(803, 293);
            this.tabPage2.TabIndex = 10;
            this.tabPage2.Text = "Hydrological parameters";
            this.tabPage2.UseVisualStyleBackColor = true;
            // 
            // check_scaling_daily_weather
            // 
            this.check_scaling_daily_weather.AutoSize = true;
            this.check_scaling_daily_weather.Location = new System.Drawing.Point(125, 227);
            this.check_scaling_daily_weather.Name = "check_scaling_daily_weather";
            this.check_scaling_daily_weather.Size = new System.Drawing.Size(230, 17);
            this.check_scaling_daily_weather.TabIndex = 71;
            this.check_scaling_daily_weather.Text = "Scale daily weather with annual timeseries?";
            this.check_scaling_daily_weather.UseVisualStyleBackColor = true;
            // 
            // label106
            // 
            this.label106.AutoSize = true;
            this.label106.Location = new System.Drawing.Point(394, 114);
            this.label106.Name = "label106";
            this.label106.Size = new System.Drawing.Size(236, 13);
            this.label106.TabIndex = 70;
            this.label106.Text = "Snowfall and snowmelt temperature threshold [C]";
            // 
            // snow_threshold_textbox
            // 
            this.snow_threshold_textbox.Enabled = false;
            this.snow_threshold_textbox.Location = new System.Drawing.Point(340, 111);
            this.snow_threshold_textbox.Name = "snow_threshold_textbox";
            this.snow_threshold_textbox.Size = new System.Drawing.Size(40, 20);
            this.snow_threshold_textbox.TabIndex = 69;
            this.snow_threshold_textbox.Text = "0";
            this.snow_threshold_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label105
            // 
            this.label105.AutoSize = true;
            this.label105.Location = new System.Drawing.Point(394, 76);
            this.label105.Name = "label105";
            this.label105.Size = new System.Drawing.Size(174, 13);
            this.label105.TabIndex = 68;
            this.label105.Text = "Snowmelt factor [m degree-1 day-1]";
            // 
            // snowmelt_factor_textbox
            // 
            this.snowmelt_factor_textbox.Enabled = false;
            this.snowmelt_factor_textbox.Location = new System.Drawing.Point(340, 73);
            this.snowmelt_factor_textbox.Name = "snowmelt_factor_textbox";
            this.snowmelt_factor_textbox.Size = new System.Drawing.Size(40, 20);
            this.snowmelt_factor_textbox.TabIndex = 67;
            this.snowmelt_factor_textbox.Text = "0.004";
            this.snowmelt_factor_textbox.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label104
            // 
            this.label104.AutoSize = true;
            this.label104.Location = new System.Drawing.Point(333, 15);
            this.label104.Name = "label104";
            this.label104.Size = new System.Drawing.Size(118, 13);
            this.label104.TabIndex = 66;
            this.label104.Text = "Properties of study area";
            // 
            // latitude_min
            // 
            this.latitude_min.Enabled = false;
            this.latitude_min.Location = new System.Drawing.Point(397, 35);
            this.latitude_min.Name = "latitude_min";
            this.latitude_min.Size = new System.Drawing.Size(44, 20);
            this.latitude_min.TabIndex = 65;
            this.latitude_min.Text = "22";
            this.latitude_min.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label103
            // 
            this.label103.AutoSize = true;
            this.label103.Location = new System.Drawing.Point(446, 38);
            this.label103.Name = "label103";
            this.label103.Size = new System.Drawing.Size(100, 13);
            this.label103.TabIndex = 64;
            this.label103.Text = "Latitude [deg], [min]";
            // 
            // latitude_deg
            // 
            this.latitude_deg.Enabled = false;
            this.latitude_deg.Location = new System.Drawing.Point(340, 35);
            this.latitude_deg.Name = "latitude_deg";
            this.latitude_deg.Size = new System.Drawing.Size(40, 20);
            this.latitude_deg.TabIndex = 63;
            this.latitude_deg.Text = "53";
            this.latitude_deg.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label100
            // 
            this.label100.AutoSize = true;
            this.label100.Location = new System.Drawing.Point(143, 148);
            this.label100.Name = "label100";
            this.label100.Size = new System.Drawing.Size(59, 13);
            this.label100.TabIndex = 62;
            this.label100.Text = "Daily T min";
            // 
            // label101
            // 
            this.label101.AutoSize = true;
            this.label101.Location = new System.Drawing.Point(143, 174);
            this.label101.Name = "label101";
            this.label101.Size = new System.Drawing.Size(62, 13);
            this.label101.TabIndex = 61;
            this.label101.Text = "Daily T max";
            // 
            // label102
            // 
            this.label102.AutoSize = true;
            this.label102.Location = new System.Drawing.Point(143, 117);
            this.label102.Name = "label102";
            this.label102.Size = new System.Drawing.Size(82, 13);
            this.label102.TabIndex = 60;
            this.label102.Text = "Daily T average";
            // 
            // dailyT_min
            // 
            this.dailyT_min.Enabled = false;
            this.dailyT_min.Location = new System.Drawing.Point(37, 145);
            this.dailyT_min.Name = "dailyT_min";
            this.dailyT_min.Size = new System.Drawing.Size(100, 20);
            this.dailyT_min.TabIndex = 59;
            this.dailyT_min.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tminday_grunow.csv" +
    "";
            this.dailyT_min.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyT_max
            // 
            this.dailyT_max.Enabled = false;
            this.dailyT_max.Location = new System.Drawing.Point(37, 171);
            this.dailyT_max.Name = "dailyT_max";
            this.dailyT_max.Size = new System.Drawing.Size(100, 20);
            this.dailyT_max.TabIndex = 58;
            this.dailyT_max.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tmaxday_grunow.csv" +
    "";
            this.dailyT_max.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyT_avg
            // 
            this.dailyT_avg.Enabled = false;
            this.dailyT_avg.Location = new System.Drawing.Point(37, 114);
            this.dailyT_avg.Name = "dailyT_avg";
            this.dailyT_avg.Size = new System.Drawing.Size(100, 20);
            this.dailyT_avg.TabIndex = 57;
            this.dailyT_avg.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Tavgday_grunow.csv" +
    "";
            this.dailyT_avg.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label97
            // 
            this.label97.AutoSize = true;
            this.label97.Location = new System.Drawing.Point(142, 204);
            this.label97.Name = "label97";
            this.label97.Size = new System.Drawing.Size(83, 13);
            this.label97.TabIndex = 56;
            this.label97.Text = "Amount of years";
            // 
            // daily_n
            // 
            this.daily_n.Enabled = false;
            this.daily_n.Location = new System.Drawing.Point(36, 201);
            this.daily_n.Name = "daily_n";
            this.daily_n.Size = new System.Drawing.Size(100, 20);
            this.daily_n.TabIndex = 55;
            this.daily_n.Text = "6";
            this.daily_n.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // label96
            // 
            this.label96.AutoSize = true;
            this.label96.Location = new System.Drawing.Point(20, 15);
            this.label96.Name = "label96";
            this.label96.Size = new System.Drawing.Size(229, 13);
            this.label96.TabIndex = 54;
            this.label96.Text = "Insert a series of yearly records of the following:";
            // 
            // label93
            // 
            this.label93.AutoSize = true;
            this.label93.Location = new System.Drawing.Point(142, 65);
            this.label93.Name = "label93";
            this.label93.Size = new System.Drawing.Size(53, 13);
            this.label93.TabIndex = 53;
            this.label93.Text = "Daily ET0";
            // 
            // label89
            // 
            this.label89.AutoSize = true;
            this.label89.Location = new System.Drawing.Point(142, 91);
            this.label89.Name = "label89";
            this.label89.Size = new System.Drawing.Size(71, 13);
            this.label89.TabIndex = 52;
            this.label89.Text = "Daily duration";
            // 
            // label40
            // 
            this.label40.AutoSize = true;
            this.label40.Location = new System.Drawing.Point(142, 34);
            this.label40.Name = "label40";
            this.label40.Size = new System.Drawing.Size(40, 13);
            this.label40.TabIndex = 51;
            this.label40.Text = "Daily P";
            // 
            // dailyET0
            // 
            this.dailyET0.Enabled = false;
            this.dailyET0.Location = new System.Drawing.Point(36, 62);
            this.dailyET0.Name = "dailyET0";
            this.dailyET0.Size = new System.Drawing.Size(100, 20);
            this.dailyET0.TabIndex = 50;
            this.dailyET0.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\ET0day_grunow.csv";
            this.dailyET0.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyD
            // 
            this.dailyD.Enabled = false;
            this.dailyD.Location = new System.Drawing.Point(36, 88);
            this.dailyD.Name = "dailyD";
            this.dailyD.Size = new System.Drawing.Size(100, 20);
            this.dailyD.TabIndex = 49;
            this.dailyD.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Dday_grunow.csv";
            this.dailyD.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // dailyP
            // 
            this.dailyP.Enabled = false;
            this.dailyP.Location = new System.Drawing.Point(36, 31);
            this.dailyP.Name = "dailyP";
            this.dailyP.Size = new System.Drawing.Size(100, 20);
            this.dailyP.TabIndex = 48;
            this.dailyP.Text = "D:\\PhD\\projects\\1g_basic LORICA development\\daily water\\Grunow\\Pday_grunow.csv";
            this.dailyP.TextAlign = System.Windows.Forms.HorizontalAlignment.Right;
            // 
            // Mother_form
            // 
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.None;
            this.AutoScroll = true;
            this.AutoSizeMode = System.Windows.Forms.AutoSizeMode.GrowAndShrink;
            this.ClientSize = new System.Drawing.Size(940, 491);
            this.Controls.Add(this.End_button);
            this.Controls.Add(this.start_button);
            this.Controls.Add(this.tabControl1);
            this.Controls.Add(this.statusBar1);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.MaximumSize = new System.Drawing.Size(1200, 700);
            this.Menu = this.mainMenu1;
            this.MinimumSize = new System.Drawing.Size(823, 530);
            this.Name = "Mother_form";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "LORICA - Soilscape Evolution Model ";
            this.Load += new System.EventHandler(this.Form1_Load);
            Landsliding.ResumeLayout(false);
            Landsliding.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox4)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.InfoStatusPanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.TimeStatusPanel)).EndInit();
            ((System.ComponentModel.ISupportInitialize)(this.ScenarioStatusPanel)).EndInit();
            this.groupBox13.ResumeLayout(false);
            this.groupBox13.PerformLayout();
            this.groupBox3.ResumeLayout(false);
            this.groupBox9.ResumeLayout(false);
            this.groupBox9.PerformLayout();
            this.Output.ResumeLayout(false);
            this.groupBox6.ResumeLayout(false);
            this.groupBox12.ResumeLayout(false);
            this.groupBox12.PerformLayout();
            this.groupBox11.ResumeLayout(false);
            this.groupBox11.PerformLayout();
            this.groupBox1.ResumeLayout(false);
            this.groupBox1.PerformLayout();
            this.Run.ResumeLayout(false);
            this.Run.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.uxNumberThreadsUpdown)).EndInit();
            this.groupBox2.ResumeLayout(false);
            this.groupBox2.PerformLayout();
            this.groupBox7.ResumeLayout(false);
            this.groupBox7.PerformLayout();
            this.Input.ResumeLayout(false);
            this.Input.PerformLayout();
            this.groupBox8.ResumeLayout(false);
            this.groupBox8.PerformLayout();
            this.Processes.ResumeLayout(false);
            this.Process_tabs.ResumeLayout(false);
            this.Water.ResumeLayout(false);
            this.Water.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();
            this.Tillage.ResumeLayout(false);
            this.Tillage.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();
            this.Creeper.ResumeLayout(false);
            this.Creeper.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox3)).EndInit();
            this.Solifluction.ResumeLayout(false);
            this.Solifluction.PerformLayout();
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox5)).EndInit();
            this.Rock_weathering.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.pictureBox6)).EndInit();
            this.groupBox10.ResumeLayout(false);
            this.groupBox10.PerformLayout();
            this.Tectonics.ResumeLayout(false);
            this.groupBox14.ResumeLayout(false);
            this.groupBox14.PerformLayout();
            this.groupBox16.ResumeLayout(false);
            this.groupBox16.PerformLayout();
            this.groupBox4.ResumeLayout(false);
            this.groupBox4.PerformLayout();
            this.groupBox15.ResumeLayout(false);
            this.groupBox15.PerformLayout();
            this.treefall.ResumeLayout(false);
            this.treefall.PerformLayout();
            this.tabPage6.ResumeLayout(false);
            this.tabPage6.PerformLayout();
            this.tabControl1.ResumeLayout(false);
            this.tabPage1.ResumeLayout(false);
            this.tabControl2.ResumeLayout(false);
            this.physical.ResumeLayout(false);
            this.physical.PerformLayout();
            this.chemical.ResumeLayout(false);
            this.chemical.PerformLayout();
            this.clay.ResumeLayout(false);
            this.clay.PerformLayout();
            this.bioturbation.ResumeLayout(false);
            this.bioturbation.PerformLayout();
            this.carbon.ResumeLayout(false);
            this.carbon.PerformLayout();
            this.decalcification.ResumeLayout(false);
            this.decalcification.PerformLayout();
            this.tabPage3.ResumeLayout(false);
            this.tabControl3.ResumeLayout(false);
            this.tabPage4.ResumeLayout(false);
            this.tabPage4.PerformLayout();
            this.tabPage5.ResumeLayout(false);
            this.tabPage5.PerformLayout();
            this.tabPage2.ResumeLayout(false);
            this.tabPage2.PerformLayout();
            this.ResumeLayout(false);

        }
        #endregion

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.Run(new Mother_form());
        }   // creates the forms

        LORICA4.Output_timeseries timeseries = new LORICA4.Output_timeseries();
        LORICA4.Output_profile profile = new LORICA4.Output_profile();
        LORICA4.Landuse_determinator landuse_determinator = new LORICA4.Landuse_determinator();
        LORICA4.About_LORICA aboutbox = new LORICA4.About_LORICA();
        public LORICA4.Soil_specifier soildata = new LORICA4.Soil_specifier();

        #region memory, reading and writing utilities

        private void timeseries_output()
        {
            int step;
            string FILENAME = workdir + "\\timeseries.log";
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                //geomprph centred
                if (timeseries.timeseries_cell_waterflow_check.Checked) { sw.Write("cell_waterflow "); }
                if (timeseries.timeseries_cell_altitude_check.Checked) { sw.Write("cell_altitude "); }
                if (timeseries.timeseries_net_ero_check.Checked) { sw.Write("net_erosion "); }
                if (timeseries.timeseries_number_dep_check.Checked) { sw.Write("deposited_cells "); }
                if (timeseries.timeseries_number_erosion_check.Checked) { sw.Write("eroded_cells "); }
                if (timeseries.timeseries_number_waterflow_check.Checked) { sw.Write("wet_cells "); }
                if (timeseries.timeseries_SDR_check.Checked) { sw.Write("SDR "); }
                if (timeseries.timeseries_total_average_alt_check.Checked) { sw.Write("average_alt "); }
                if (timeseries.timeseries_total_dep_check.Checked) { sw.Write("total_dep "); }
                if (timeseries.timeseries_total_ero_check.Checked) { sw.Write("total_ero "); }
                if (timeseries.timeseries_total_evap_check.Checked) { sw.Write("total_evap "); }
                if (timeseries.timeseries_total_infil_check.Checked) { sw.Write("total_infil "); }
                if (timeseries.timeseries_total_outflow_check.Checked) { sw.Write("total_outflow "); }
                if (timeseries.timeseries_total_rain_check.Checked) { sw.Write("total_rain "); }
                if (timeseries.timeseries_outflow_cells_checkbox.Checked) { sw.Write("number_out_cells"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_gravel_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_sand_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_silt_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_clay_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_fineclay_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_yom_kg"); sw.Write(" "); }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write("out_oom_kg"); sw.Write(" "); }
                //soil_centred
                if (timeseries.total_phys_weath_checkbox.Checked) { sw.Write("phys_weath_kg "); }
                if (timeseries.total_chem_weath_checkbox.Checked) { sw.Write("chem_weath_kg "); }
                if (timeseries.total_fine_formed_checkbox.Checked) { sw.Write("fine_clay_formed_kg "); }
                if (timeseries.total_fine_eluviated_checkbox.Checked) { sw.Write("fine_clay_eluviated_kg "); }
                if (timeseries.total_mass_bioturbed_checkbox.Checked) { sw.Write("mass_bioturbed_kg "); }
                if (timeseries.total_OM_input_checkbox.Checked) { sw.Write("OM_input_kg "); }
                if (timeseries.total_average_soilthickness_checkbox.Checked) { sw.Write("average_soilthickness "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("n_soil_thicker "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("n_soil_coarser "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_thickness_m "); }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write("soil_mass_kg "); }
                sw.Write("\r\n");
                for (step = 0; step <= end_time - 1; step++)
                {
                    if (timeseries.timeseries_cell_waterflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[1]]); sw.Write(" "); }
                    if (timeseries.timeseries_cell_altitude_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[2]]); sw.Write(" "); }
                    if (timeseries.timeseries_net_ero_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[3]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_dep_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[4]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_erosion_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[5]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_waterflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[6]]); sw.Write(" "); }
                    if (timeseries.timeseries_SDR_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[7]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_average_alt_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[8]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_dep_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[9]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_ero_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[10]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_evap_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[11]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_infil_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[12]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_outflow_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[13]]); sw.Write(" "); }
                    if (timeseries.timeseries_total_rain_check.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[14]]); sw.Write(" "); }
                    if (timeseries.timeseries_outflow_cells_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[15]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[16]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[17]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[18]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[19]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[20]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[21]]); sw.Write(" "); }
                    if (timeseries.timeseries_sedexport_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[22]]); sw.Write(" "); }
                    //soil_centred
                    if (timeseries.total_phys_weath_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[23]]); sw.Write(" "); }
                    if (timeseries.total_chem_weath_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[24]]); sw.Write(" "); }
                    if (timeseries.total_fine_formed_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[25]]); sw.Write(" "); }
                    if (timeseries.total_fine_eluviated_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[26]]); sw.Write(" "); }
                    if (timeseries.total_mass_bioturbed_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[27]]); sw.Write(" "); }
                    if (timeseries.total_OM_input_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[28]]); sw.Write(" "); }
                    if (timeseries.total_average_soilthickness_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[29]]); sw.Write(" "); }
                    if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[30]]); sw.Write(" "); }
                    if (timeseries.timeseries_coarser_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[31]]); sw.Write(" "); }
                    if (timeseries.timeseries_soil_depth_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[32]]); sw.Write(" "); }
                    if (timeseries.timeseries_soil_mass_checkbox.Checked) { sw.Write(timeseries_matrix[step, timeseries_order[33]]); }
                    sw.Write("\r\n");
                }
            }
        }
        int clearmatrices_test()
        {
            // Reseting values of existing memory instead of Re-allocating (saves memory)
            // Re-allocating, while faster, still keeps the previous memory until Garbage Collection (GC) decides to clear it up

            //Another potentially faster way is to for-loop through each array position and reset to its default value.
            //While it does require so extra coding logic it would be good for larger arrays and can implement Parallel.For()

            if (this.Spitsbergen_case_study.Checked == true) { Array.Clear(original_dtm, 0, original_dtm.Length); }
            Array.Clear(dtm, 0, dtm.Length);
            if (merely_calculating_derivatives == false)
            {
                //Array.Clear(OSL_age, 0, OSL_age.Length);
                Array.Clear(soildepth_m, 0, soildepth_m.Length);
                Array.Clear(dtmchange_m, 0, dtmchange_m.Length);
                Array.Clear(dz_soil, 0, dz_soil.Length);
                // climate grids
                if (check_space_evap.Checked == true) { Array.Clear(evapotranspiration, 0, evapotranspiration.Length); }
                if (check_space_infil.Checked == true) { Array.Clear(infil, 0, infil.Length); }
                if (check_space_rain.Checked == true) { Array.Clear(rain, 0, rain.Length); }

                Array.Clear(veg, 0, veg.Length);
                //Array.Clear(veg_correction_factor, 0, veg.Length);
                // categorical grids
                if (check_space_landuse.Checked == true) { Array.Clear(landuse, 0, landuse.Length); }
            }
            Array.Clear(status_map, 0, status_map.Length);
            //sorting arrays
            Array.Clear(index, 0, index.Length);
            Array.Clear(row_index, 0, row_index.Length);
            Array.Clear(col_index, 0, col_index.Length);
            Array.Clear(rowcol_index, 0, rowcol_index.Length);
            //others
            Array.Clear(depression, 0, depression.Length);
            Array.Clear(dtmfill_A, 0, dtmfill_A.Length);
            if (merely_calculating_derivatives == false)
            {
                if (1 == 1)
                {
                    Array.Clear(texture_kg, 0, texture_kg.Length);   //: mass in kg (per voxel = layer * thickness)
                    Array.Clear(layerthickness_m, 0, layerthickness_m.Length);      // : thickness in m 
                    Array.Clear(young_SOM_kg, 0, young_SOM_kg.Length);   // : OM mass in kg (per voxel = layer * thickness)
                    Array.Clear(old_SOM_kg, 0, old_SOM_kg.Length);
                    Array.Clear(bulkdensity, 0, bulkdensity.Length);           // : bulkdensity in kg/m3 (over the voxel = layer * thickness)
                }
                if (CN_checkbox.Checked)
                {
                    CN_atoms_cm2 = new double[nr, nc, max_soil_layers, n_cosmo];
                    //for (row = 0; row < nr; row++)
                    //{
                    //    for (col = 0; col < nc; col++)
                    //    {
                    //        for (int lay = 0; lay < max_soil_layers; lay++)
                    //        {
                    //            CN_atoms_cm2[row, col, lay, 0] = Convert.ToInt64(8E8);
                    //        }
                    //    }
                    //}
                    // dim[,,,0] = Meteoric 10-Be (dynamics linked to both clay fractions)
                    // dim[,,,1] = In-situ 10-Be (dynamics linked to sand fraction)
                    // dim[,,,2] = In-situ 14-C (dynamics linked to sand fraction)
                    // dim[,,,3] = 137-Cs
                    // Other nuclides can be included at a later stage (e.g., 14-C, 137-Cs, 210-Pb)
                }
                if (OSL_checkbox.Checked)
                {
                    int ngrains = System.Convert.ToInt32(ngrains_textbox.Text);
                    int start_age = 1000000;
                    // OSL_age = new int[nr * nc * max_soil_layers * ngrains, 5];
                    OSL_grainages = new int[nr, nc, max_soil_layers][];
                    OSL_depositionages = new int[nr, nc, max_soil_layers][];
                    OSL_surfacedcount = new int[nr, nc, max_soil_layers][];

                    int count = 0;
                    for (int row = 0; row < nr; row++)
                    {
                        for (int col = 0; col < nc; col++)
                        {
                            for (int lay = 0; lay < max_soil_layers; lay++)
                            {
                                OSL_grainages[row, col, lay] = new int[ngrains];
                                OSL_depositionages[row, col, lay] = new int[ngrains];
                                OSL_surfacedcount[row, col, lay] = new int[ngrains];
                            }
                        }
                    }
                }
                if (Water_ero_checkbox.Checked)
                {
                    //doubles
                    Array.Clear(waterflow_m3, 0, waterflow_m3.Length);
                    if (only_waterflow_checkbox.Checked == false)
                    {
                        Array.Clear(K_fac, 0, K_fac.Length);
                        Array.Clear(P_fac, 0, P_fac.Length);
                        Array.Clear(sediment_in_transport_kg, 0, sediment_in_transport_kg.Length);
                        Array.Clear(young_SOM_in_transport_kg, 0, young_SOM_in_transport_kg.Length);
                        Array.Clear(old_SOM_in_transport_kg, 0, old_SOM_in_transport_kg.Length);
                        Array.Clear(sum_water_erosion, 0, sum_water_erosion.Length);
                        Array.Clear(dz_ero_m, 0, dz_ero_m.Length);
                        Array.Clear(dz_sed_m, 0, dz_sed_m.Length);
                        Array.Clear(lake_sed_m, 0, lake_sed_m.Length);
                        Array.Clear(depressionsum_texture_kg, 0, depressionsum_texture_kg.Length);
                        if (CN_checkbox.Checked) { CN_in_transport = new double[nr, nc, n_cosmo]; }
                        if (OSL_checkbox.Checked) { 
                            OSL_grainages_in_transport = new int[nr, nc][]; 
                            OSL_depositionages_in_transport = new int[nr, nc][]; 
                            OSL_surfacedcount_in_transport = new int[nr, nc][]; 
                        }
                    }
                }

                if (Tillage_checkbox.Checked)
                {
                    Array.Clear(till_result, 0, till_result.Length);
                    Array.Clear(sum_tillage, 0, sum_tillage.Length);
                    Array.Clear(tillfields, 0, tillfields.Length);
                    Array.Clear(dz_till_bd, 0, dz_till_bd.Length);
                }

                if (treefall_checkbox.Checked)
                {
                    Array.Clear(treefall_count, 0, treefall_count.Length);
                    Array.Clear(dz_treefall, 0, dz_treefall.Length);
                }

                if (version_lux_checkbox.Checked)
                {
                    Array.Clear(tpi, 0, tpi.Length);
                    Array.Clear(hornbeam_cover_fraction, 0, hornbeam_cover_fraction.Length);
                    Array.Clear(litter_kg, 0, litter_kg.Length);
                }

                if (Solifluction_checkbox.Checked)
                {
                    Array.Clear(solif, 0, solif.Length);
                    Array.Clear(sum_solifluction, 0, sum_solifluction.Length);
                }
                if (creep_active_checkbox.Checked)
                {
                    Array.Clear(creep, 0, creep.Length);
                    Array.Clear(sum_creep_grid, 0, sum_creep_grid.Length);
                }
                if (Landslide_checkbox.Checked)
                {
                    //doubles
                    Array.Clear(stslope, 0, stslope.Length);
                    Array.Clear(crrain, 0, crrain.Length);
                    Array.Clear(camf, 0, camf.Length);
                    Array.Clear(T_fac, 0, T_fac.Length);
                    Array.Clear(C_fac, 0, C_fac.Length);
                    Array.Clear(Cs_fac, 0, Cs_fac.Length);
                    Array.Clear(bulkd, 0, bulkd.Length);
                    Array.Clear(intfr, 0, intfr.Length);
                    Array.Clear(reserv, 0, reserv.Length);
                    Array.Clear(ero_slid, 0, ero_slid.Length);
                    Array.Clear(cel_dist, 0, cel_dist.Length);
                    Array.Clear(sed_slid, 0, sed_slid.Length);
                    Array.Clear(sed_bud, 0, sed_bud.Length);
                    Array.Clear(dh_slid, 0, dh_slid.Length);
                    Array.Clear(sum_landsliding, 0, sum_landsliding.Length);
                    //integers
                    Array.Clear(slidemap, 0, slidemap.Length);
                    Array.Clear(watsh, 0, watsh.Length);
                }
                if (Biological_weathering_checkbox.Checked)
                {
                    Array.Clear(bedrock_weathering_m, 0, bedrock_weathering_m.Length);
                    Array.Clear(sum_biological_weathering, 0, sum_biological_weathering.Length);
                }
                if (Frost_weathering_checkbox.Checked)
                {
                    Array.Clear(frost_weathering, 0, frost_weathering.Length);
                    Array.Clear(sum_frost_weathering, 0, sum_frost_weathering.Length);
                }
                if (tilting_active_checkbox.Checked)
                {
                    Array.Clear(sum_tilting, 0, sum_tilting.Length);
                }
                if (uplift_active_checkbox.Checked)
                {
                    Array.Clear(sum_uplift, 0, sum_uplift.Length);
                }
                if (decalcification_checkbox.Checked)
                {
                    Array.Clear(CO3_kg, 0, CO3_kg.Length);
                }
                if (blocks_active == 1)
                {
                    Array.Clear(hardlayeropenness_fraction, 0, hardlayeropenness_fraction.Length);
                }

            }
            Array.Clear(aspect, 0, aspect.Length);
            Array.Clear(slopeAnalysis, 0, slopeAnalysis.Length);
            Array.Clear(hillshade, 0, hillshade.Length);
            Array.Clear(Tau, 0, Tau.Length);
            // Debug.WriteLine("memory assigned succesfully");
            return 1;
        }
        int makematrices()
        {
            // Debug.WriteLine("assigning memory");
            // status grids
            if (this.Spitsbergen_case_study.Checked == true) { original_dtm = new double[nr, nc]; }
            dtm = new double[nr, nc];
            if (merely_calculating_derivatives == false)
            {
                soildepth_m = new double[nr, nc];
                dtmchange_m = new double[nr, nc];
                dz_soil = new double[nr, nc];
                // climate grids
                if (check_space_evap.Checked == true) { evapotranspiration = new double[nr, nc]; }
                if (check_space_infil.Checked == true) { infil = new double[nr, nc]; }
                if (check_space_rain.Checked == true) { rain = new double[nr, nc]; }
                veg = new double[nr, nc];
                // categorical grids
                if (check_space_landuse.Checked == true) { landuse = new int[nr, nc]; }
            }
            status_map = new int[nr, nc];
            //sorting arrays
            index = new double[nr * nc];
            row_index = new int[nr * nc];
            col_index = new int[nr * nc];
            rowcol_index = new string[nr * nc];
            //others
            depression = new int[nr, nc];
            dtmfill_A = new double[nr, nc];
            if (merely_calculating_derivatives == false)
            {
                if (1 == 1)
                {
                    texture_kg = new double[nr, nc, max_soil_layers, n_texture_classes];    //: mass in kg (per voxel = layer * thickness)
                    layerthickness_m = new double[nr, nc, max_soil_layers];        // : thickness in m 
                    young_SOM_kg = new double[nr, nc, max_soil_layers];         // : OM mass in kg (per voxel = layer * thickness)
                    old_SOM_kg = new double[nr, nc, max_soil_layers];
                    bulkdensity = new double[nr, nc, max_soil_layers];            // : bulkdensity in kg/m3 (over the voxel = layer * thickness)
                }

                if (CN_checkbox.Checked)
                {
                    CN_atoms_cm2 = new double[nr, nc, max_soil_layers, n_cosmo];

                    // Input parameters
                    met_10Be_input = System.Convert.ToDouble(metBe10_input_textbox.Text);// atoms/cm2/y. MvdM should be determined as function of latitude. 
                    met_10Be_adsorptioncoefficient = Convert.ToDouble(met10Be_dd.Text); // adsorption coefficient of met 10 beadsorption, equivalent to a depth decay parameter
                    met_10Be_clayfraction = Convert.ToDouble(met_10Be_clayfrac.Text);
                    P0_10Be_is_sp = System.Convert.ToDouble(isBe10_sp_input_textbox.Text); // Spallation. atoms / g quartz /y. 4.76; http://dx.doi.org/10.1029/2010GC003084
                    P0_10Be_is_mu = System.Convert.ToDouble(isBe10_mu_input_textbox.Text); // Muon. atoms / g quartz /y

                    P0_14C_is_sp = System.Convert.ToDouble(isC14_sp_input_textbox.Text);// Spallation. atoms / g quartz /y. 15.7; https://doi.org/10.1016/S0016-7037(01)00566-X
                    P0_14C_is_mu = System.Convert.ToDouble(isC14_mu_input_textbox.Text);// Muon. atoms / g quartz /y

                    attenuation_length_sp = System.Convert.ToDouble(attenuationlength_sp_textbox.Text);// kg m-2
                    attenuation_length_mu = System.Convert.ToDouble(attenuationlength_mu_textbox.Text);// kg m-2

                    // Decay parameters
                    decay_Be10 = System.Convert.ToDouble(Be10_decay_textbox.Text);
                    decay_C14 = System.Convert.ToDouble(C14_decay_textbox.Text);
                    
                    // Inherited concentrations
                    met10Be_inherited = System.Convert.ToDouble(metBe10_inherited_textbox.Text);
                    is10Be_inherited = System.Convert.ToDouble(isBe10_inherited_textbox.Text);
                    isC14_inherited = System.Convert.ToDouble(isC14_inherited_textbox.Text);

                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            for (int lay = 0; lay < max_soil_layers; lay++)
                            {
                                CN_atoms_cm2[row, col, lay, 0] = met10Be_inherited * met_10Be_clayfraction;
                                CN_atoms_cm2[row, col, lay, 1] = met10Be_inherited * (1-met_10Be_clayfraction);
                                CN_atoms_cm2[row, col, lay, 2] = is10Be_inherited;
                                CN_atoms_cm2[row, col, lay, 3] = isC14_inherited;
                            }
                        }
                    }
                    // dim[,,,0] = Meteoric 10-Be (dynamics linked to both clay fractions)
                    // dim[,,,1] = Meteoric 10-Be (dynamics linked to silt fraction)
                    // dim[,,,2] = In-situ 10-Be (dynamics linked to sand fraction)
                    // dim[,,,3] = In-situ 14-C (dynamics linked to sand fraction)
                    // dim[,,,4] = ...
                    // Other nuclides can be included at a later stage (e.g., 14-C, 137-Cs, 210-Pb)
                }
                if (OSL_checkbox.Checked)
                {
                    ngrains_kgsand_m2 = Convert.ToInt32(ngrains_textbox.Text);
                    bleaching_depth_m = Convert.ToDouble(bleachingdepth_textbox.Text);
                    start_age = Convert.ToInt32(OSL_inherited_textbox.Text);

                    OSL_grainages = new int[nr, nc, max_soil_layers][];
                    OSL_depositionages = new int[nr, nc, max_soil_layers][];
                    OSL_surfacedcount = new int[nr, nc, max_soil_layers][];

                   
                }

                if (Water_ero_checkbox.Checked)
                {
                    //doubles
                    waterflow_m3 = new double[nr, nc];
                    if (only_waterflow_checkbox.Checked == false)
                    {
                        K_fac = new double[nr, nc];
                        P_fac = new double[nr, nc];
                        sediment_in_transport_kg = new double[nr, nc, n_texture_classes];
                        young_SOM_in_transport_kg = new double[nr, nc];
                        old_SOM_in_transport_kg = new double[nr, nc];
                        sum_water_erosion = new double[nr, nc];
                        dz_ero_m = new double[nr, nc];
                        dz_sed_m = new double[nr, nc];
                        lake_sed_m = new double[nr, nc];
                        depressionsum_texture_kg = new double[n_texture_classes];
                        if (CN_checkbox.Checked) { CN_in_transport = new double[nr, nc, n_cosmo]; }
                        if (OSL_checkbox.Checked) { OSL_grainages_in_transport = new int[nr, nc][]; OSL_depositionages_in_transport = new int[nr, nc][]; OSL_surfacedcount_in_transport = new int[nr, nc][]; }
                    }

                }
                if (Tillage_checkbox.Checked)
                {
                    till_result = new double[nr, nc];
                    sum_tillage = new double[nr, nc];
                    tillfields = new int[nr, nc];
                    dz_till_bd = new double[nr, nc];
                }

                if (treefall_checkbox.Checked)
                {
                    treefall_count = new int[nr, nc];
                    dz_treefall = new double[nr, nc];
                }

                if (version_lux_checkbox.Checked)
                {
                    tpi = new double[nr, nc];
                    hornbeam_cover_fraction = new double[nr, nc];
                    litter_kg = new double[nr, nc, 2];
                }

                if (Solifluction_checkbox.Checked)
                {
                    solif = new double[nr, nc];
                    sum_solifluction = new double[nr, nc];
                }
                if (creep_active_checkbox.Checked)
                {
                    creep = new double[nr, nc];
                    sum_creep_grid = new double[nr, nc];
                }
                if (Landslide_checkbox.Checked)
                {
                    //doubles
                    stslope = new double[nr, nc];
                    crrain = new double[nr, nc];
                    camf = new double[nr, nc];
                    T_fac = new double[nr, nc];
                    C_fac = new double[nr, nc];
                    Cs_fac = new double[nr, nc];
                    bulkd = new double[nr, nc];
                    intfr = new double[nr, nc];
                    reserv = new double[nr, nc];
                    ero_slid = new double[nr, nc];
                    cel_dist = new double[nr, nc];
                    sed_slid = new double[nr, nc];
                    sed_bud = new double[nr, nc];
                    dh_slid = new double[nr, nc];
                    sum_landsliding = new double[nr, nc];
                    //integers
                    slidemap = new int[nr, nc];
                    watsh = new int[nr, nc];
                }
                if (Biological_weathering_checkbox.Checked)
                {
                    bedrock_weathering_m = new double[nr, nc];
                    sum_biological_weathering = new double[nr, nc];
                }
                if (Frost_weathering_checkbox.Checked)
                {
                    frost_weathering = new double[nr, nc];
                    sum_frost_weathering = new double[nr, nc];
                }
                if (tilting_active_checkbox.Checked)
                {
                    sum_tilting = new double[nr, nc];
                }
                if (uplift_active_checkbox.Checked)
                {
                    sum_uplift = new double[nr, nc];
                }
                if (decalcification_checkbox.Checked)
                {
                    CO3_kg = new double[nr, nc, max_soil_layers];
                }
                if (blocks_active == 1)
                {
                    hardlayeropenness_fraction = new float[nr, nc];
                }
            }
            aspect = new double[nr, nc];
            slopeAnalysis = new double[nr, nc];
            hillshade = new double[nr, nc];
            Tau = new double[nr, nc];
            // Debug.WriteLine("memory assigned succesfully");
            return 1;
        }

        void makerecords(string filename)
        {
            string FILE_NAME = filename;
            string input;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            int recordsize = 0;
            try { recordsize = Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }
            if (check_time_rain.Checked) { rainfall_record = new int[recordsize]; }
            if (check_time_evap.Checked) { evap_record = new int[recordsize]; }
            if (check_time_infil.Checked) { infil_record = new int[recordsize]; }
            if (check_time_T.Checked) { temp_record = new int[recordsize]; }
            if (check_time_till_fields.Checked) { till_record = new int[recordsize]; }

            memory_records = true;
        }

        void makedailyrecords(string filename)
        {
            string FILE_NAME = filename;
            string input;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            int recordsize = 0;
            try { recordsize = Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }

            P_all = new int[recordsize];
            ET0_all = new int[recordsize];
            D_all = new int[recordsize];
            Tavg_all = new int[recordsize];
            Tmin_all = new int[recordsize];
            Tmax_all = new int[recordsize];

            memory_records_d = true;
        }

        void dtm_file_test(string name1)
        {
            string FILE_NAME = name1;
            int z, dem_integer_error = 1;
            string[] lineArray2;
            int sp;
            Debug.WriteLine("Opening DEM" + FILE_NAME);          

            int ok = clearmatrices_test(); //reset values of existing memory instead of allocating new memory (saves RAM)
            if (ok == 1)
            { // we have now succesfully made memory reservations for all data layers in the model 
                {
                    int col, row, colcounter;
                    String input;
                    double tttt = 0.00;

                    // load dem again

                    if (!File.Exists(FILE_NAME))
                    {
                        Debug.WriteLine("No such DEM data file..");
                        input_data_error = true;
                        return;
                    }

                    StreamReader sr = File.OpenText(FILE_NAME);

                    //now skip over the headers.
                    for (z = 1; z <= 6; z++)
                    {
                        input = sr.ReadLine();
                    }
                    row = 0;
                    while ((input = sr.ReadLine()) != null)  // so not until nr is reached, but until the file is empty
                    {
                        //Debug.WriteLine("Line " + row);
                        string[] lineArray;
                        lineArray = input.Split(new char[] { ' ' });   // so we split the string that we read (readline) from file into an array of strings that each contain a number
                        col = 0;
                        for (colcounter = 0; colcounter <= (lineArray.Length - 1); colcounter++)  // the length of LineArray should equal nc, and therefore run from 0 to nc-1
                        {

                            //Debug.WriteLine("Col " + col);
                            if (lineArray[colcounter] != "" && col < nc) // but just to make sure, col counts only the non-empty strings in LineArrary (handy for instance when files are double-spaced)
                            {
                                tttt = double.Parse(lineArray[colcounter]);
                                if (Spitsbergen_case_study.Checked == true) { original_dtm[row, col] = tttt; dtm[row, col] = -9999; }
                                else { dtm[row, col] = tttt; }
                                col++;
                                if (double.Parse(lineArray[colcounter]) - Math.Round(double.Parse(lineArray[colcounter])) != 0)
                                {
                                    dem_integer_error = 0;
                                }
                            }
                        }
                        row++;
                    }
                    sr.Close();
                    if (dem_integer_error == 1) { MessageBox.Show("Warning: Digital Elevation Model may only contain integer values\n LORICA can proceed, but may experience problems"); }

                }
            }
        }

        void dtm_file(string name1)
        {

            string FILE_NAME = name1;
            int z, dem_integer_error = 1;
            string[] lineArray2;
            int sp;
            Debug.WriteLine("Opening DEM " + FILE_NAME);
            //MessageBox.Show("Directory " + Directory.GetCurrentDirectory() );

            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such DEM data file..");
                input_data_error = true;
                return;
            }

            try
            {
                //read headers
                StreamReader sr = File.OpenText(FILE_NAME);
                for (z = 1; z <= 6; z++)
                {
                    inputheader[z - 1] = sr.ReadLine();
                    //Debug.WriteLine(inputheader[z - 1]);
                }
                sr.Close();

                // get nc, nr and dx from input headers

                lineArray2 = inputheader[0].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                nc = int.Parse(lineArray2[sp]);

                lineArray2 = inputheader[1].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                nr = int.Parse(lineArray2[sp]);

                lineArray2 = inputheader[2].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                xcoord = double.Parse(lineArray2[sp]);

                lineArray2 = inputheader[3].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                ycoord = double.Parse(lineArray2[sp]);

                lineArray2 = inputheader[4].Split(new char[] { ' ' });
                sp = 1;
                while (lineArray2[sp] == "") sp++;
                dx = double.Parse(lineArray2[sp]);

                Debug.WriteLine("read DEM: nr = " + nr + " nc = " + nc);
            }
            catch (Exception ex)
            {
                Debug.WriteLine("There is a problem with the header of the DEM file");
                input_data_error = true;
                return;

            }
            int ok = makematrices();
            if (ok == 1)
            { // we have now succesfully made memory reservations for all data layers in the model 

            }
            else
            {
                MessageBox.Show("There is not enough memory for LORICA to run with these settings");
            }
            {
                
                int col, row, colcounter;
                String input;
                double tttt = 0.00;

                // load dem again

                if (!File.Exists(FILE_NAME))
                {
                    Debug.WriteLine("No such DEM data file..");
                    input_data_error = true;
                    return;
                }

                StreamReader sr = File.OpenText(FILE_NAME);

                //now skip over the headers.
                for (z = 1; z <= 6; z++)
                {
                    input = sr.ReadLine();
                }
                row = 0;
                while ((input = sr.ReadLine()) != null)  // so not until nr is reached, but until the file is empty
                {

                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });   // so we split the string that we read (readline) from file into an array of strings that each contain a number
                    col = 0;
                    for (colcounter = 0; colcounter <= (lineArray.Length - 1); colcounter++)  // the length of LineArray should equal nc, and therefore run from 0 to nc-1
                    {

                        if (lineArray[colcounter] != "" && col < nc) // but just to make sure, col counts only the non-empty strings in LineArrary (handy for instance when files are double-spaced)
                        {
                            tttt = double.Parse(lineArray[colcounter]);
                            if (Spitsbergen_case_study.Checked == true) { original_dtm[row, col] = tttt; dtm[row, col] = -9999; }
                            else { dtm[row, col] = tttt; }
                            col++;
                            if (double.Parse(lineArray[colcounter]) - Math.Round(double.Parse(lineArray[colcounter])) != 0)
                            {
                                dem_integer_error = 0;
                            }
                        }
                    }
                    row++;

                }
                sr.Close();
                if (dem_integer_error == 1) { MessageBox.Show("Warning: Digital Elevation Model may only contain integer values\n LORICA can proceed, but may experience problems"); }
                
            }
        }

        void read_double(string name2, double[,] map1)
        {
            string FILE_NAME = name2;
            string input;
            double tttt = 0.00;
            int x, y, xcounter;

            StackTrace stackTrace = new StackTrace();
            Debug.WriteLine(stackTrace.GetFrame(1).GetMethod().Name);
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such double data file " + FILE_NAME);
                input_data_error = true;
                return;
            }

            StreamReader sr = File.OpenText(FILE_NAME);

            //read headers
            for (z = 1; z <= 6; z++)
            {
                input = sr.ReadLine();
            }
            y = 0;

            while ((input = sr.ReadLine()) != null)
            {
                string[] lineArray;
                lineArray = input.Split(new char[] { ' ' });
                xcounter = 0;
                for (x = 0; x <= (lineArray.Length - 1); x++)
                {

                    if (lineArray[x] != "" && xcounter < nc)
                    {

                        try
                        {
                            tttt = double.Parse(lineArray[x]);
                        }
                        catch
                        {
                            MessageBox.Show("Incorrect content " + lineArray[x] + " in file " + FILE_NAME);
                            input_data_error = true;
                            return;
                        }
                        map1[y, xcounter] = tttt;
                        xcounter++;
                    }
                }
                y++;

            }
            sr.Close();
        } // end read_double()

        void read_integer(string name2, int[,] map1)
        {
            string FILE_NAME = name2;
            string input;
            int tttt = 0;
            int x, y, xcounter;
            Debug.WriteLine(" Reading " + FILE_NAME + " from " + Directory.GetCurrentDirectory());
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            StreamReader sr = File.OpenText(FILE_NAME);

            //read headers
            for (z = 1; z <= 6; z++)
            {
                input = sr.ReadLine();
                /*if (z == 1)
                {
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });
                    Debug.WriteLine(input + " here " + lineArray[1] + " there " );
                    if (int.Parse(lineArray[1]) != nc)
                    {
                        Debug.WriteLine(filename + " has different cols than the DEM ");
                    }
                }
                if (z == 2)
                {
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ' ' });
                    Debug.WriteLine(lineArray[1]);
                    if (int.Parse(lineArray[1]) != nr)
                    {
                        Debug.WriteLine(filename + " has different rows than the DEM ");
                    }
                } */
            }
            y = 0;
            while ((input = sr.ReadLine()) != null)
            {
                string[] lineArray;
                lineArray = input.Split(new char[] { ' ' });
                xcounter = 0;
                for (x = 0; x <= (lineArray.Length - 1); x++)
                {

                    if (lineArray[x] != "" && xcounter < nc)
                    {
                        try
                        {
                            tttt = int.Parse(lineArray[x]);
                        }
                        catch
                        {
                            MessageBox.Show("Incorrect content " + lineArray[x] + " in file " + FILE_NAME);
                            input_data_error = true;
                            return;
                        }
                        map1[y, xcounter] = tttt;
                        xcounter++;
                    }
                }
                y++;

            }
            sr.Close();
            //Debug.WriteLine("completed reading file" + FILE_NAME);
        } // end read_integer()

        void read_record(string filename, int[] record)
        {
            string FILE_NAME = filename;
            string input;
            int tttt = 0;
            int y;
            if (!File.Exists(FILE_NAME))
            {
                MessageBox.Show("No such data file " + FILE_NAME);
                input_data_error = true;
                return;
            }
            // Debug.WriteLine("reading " + filename + " into record ");
            StreamReader sr = File.OpenText(FILE_NAME);

            //read first line: number of timesteps
            input = sr.ReadLine();
            y = 0;
            int recordsize = 0;
            try { recordsize = System.Convert.ToInt32(input); }
            catch
            {
                MessageBox.Show("Wrong value " + input + " in first line of record " + FILE_NAME);
                input_data_error = true;
                return;
            }

            // Debug.WriteLine("reading " + filename + " into record of size " + record.Length);

            // the record size is read from the first line and not necessarily equal to the number of timesteps. 
            // Runs will start from beginning of record and repeat when necessary
            while ((input = sr.ReadLine()) != null)
            {
                if (y >= recordsize)
                {
                    MessageBox.Show("record " + FILE_NAME + " contains more values than expected. Extras are ignored");
                    break;
                }

                try { tttt = int.Parse(input); }
                catch
                {
                    MessageBox.Show("Incorrect content " + input + " in file " + FILE_NAME);
                    input_data_error = true;
                    return;
                }
                record[y] = tttt;
                //Debug.WriteLine("value " + y + " in record is " + record[y]);
                y++;
            }
            sr.Close();

        }

        void out_double(string name4, double[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");
                for (nn = 2; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\r\n");
                    //MessageBox.Show(inputheader[nn]);
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        sw.Write("{0:F6}", output[row, col]);
                        sw.Write(" ");

                    }
                    sw.Write("\r\n");
                }
                sw.Close();
            }

        }

        void out_float(string name4, float[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");
                for (nn = 2; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\r\n");
                    //MessageBox.Show(inputheader[nn]);
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        sw.Write("{0:F6}", output[row, col]);
                        sw.Write(" ");

                    }
                    sw.Write("\r\n");
                }
                sw.Close();
            }

        }

        void out_blocks(string name4)
        {
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                int blocknr = 0;
                sw.WriteLine("blocknr x y size row col");
                foreach (var Block in Blocklist)
                {
                    sw.WriteLine(blocknr + " " + (Block.X_col * dx + xcoord) + " " + (Block.Y_row * dx + ycoord) + " " + Block.Size_m + " " + Math.Floor(Block.Y_row) + " " + Math.Floor(Block.X_col));
                    blocknr++;
                }
                sw.Close();
            }
            Debug.WriteLine(" wrote block locations and sizes to file " + name4);
        } //end out_double

        void out_mf(string name4, double[,,] output)
        {
            int row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("In n1 n2 n3 n4 n5 n6 n7 n8");
                sw.Write("\r\n");
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        for (int dir = 0; dir < 9; dir++)
                        {
                            sw.Write(OFy_m[row, col, dir]);
                            sw.Write(" ");
                        }
                        sw.Write("\r\n");
                    }
                }

                sw.Write("ncols         " + nc);
                sw.Write("\r\n");
                sw.Write("nrows         " + nr);
                sw.Write("\r\n");

                sw.Close();
            }
        }

        void out_integer(string name4, int[,] output)
        {
            int nn, row, col;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                for (nn = 0; nn <= 5; nn++)
                {
                    sw.Write(inputheader[nn]); sw.Write("\n");
                }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {

                        sw.Write(output[row, col]);
                        sw.Write(" ");
                    }

                    sw.Write("\n");
                }
                sw.Close();
            }
        } //end out_integer

        void out_profile(string name5, double[,] output, bool row_is_fixed, int row_or_col)
        {
            // WVG 20-10-2010 output a profile file for benefit glorious model of LORICA
            int row, col;
            string FILENAME = name5;
            using (StreamWriter sw = new StreamWriter(FILENAME))

                try
                {
                    if (row_is_fixed)
                    {
                        try
                        {
                            for (col = 0; col < nc; col++)// WVG the number of columns is equal to nc
                            {
                                sw.WriteLine(output[row_or_col, col]);
                            }
                        }
                        catch { Debug.WriteLine("out_profile: error "); }
                    }
                    else  // apparently column is fixed
                    {
                        try
                        {
                            for (row = 0; row < nr; row++)// WVG the number of columns is equal to nc
                            {
                                sw.WriteLine(output[row, row_or_col]);
                            }
                        }
                        catch { Debug.WriteLine("out_profile: error "); }
                    }
                    sw.Close();
                }
                catch { Debug.WriteLine("Profile could not be written"); }

        } //WVG end out_profile

        void writesoil(int row, int col)
        {
            int layer;
            double cumthick, midthick;
            string FILENAME = string.Format("{0}\\t{1}_r{2}_c{3}_out_soil.csv", workdir, t + 1, row, col);
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("row, col, t, cumth_m, thick_m, midthick_m, coarse_kg, sand_kg, silt_kg, clay_kg, fine_kg, YOM_kg, OOM_kg, YOM/OOM, f_coarse, f_sand, f_silt, f_clay, f_fineclay");
                sw.Write("\r\n");
                cumthick = 0;
                midthick = 0;
                int t_out = t + 1;
                for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
                {
                    if (layerthickness_m[row, col, layer] > 0)
                    {
                        cumthick += layerthickness_m[row, col, layer];
                        midthick += layerthickness_m[row, col, layer] / 2;
                        double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                        sw.Write(row + "," + col + "," + t_out + "," + cumthick + "," + layerthickness_m[row, col, layer] + "," + midthick + "," + texture_kg[row, col, layer, 0] + "," + texture_kg[row, col, layer, 1] + "," + texture_kg[row, col, layer, 2] + "," + texture_kg[row, col, layer, 3] + "," + texture_kg[row, col, layer, 4] + "," + young_SOM_kg[row, col, layer] + "," + old_SOM_kg[row, col, layer] + "," + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + "," + texture_kg[row, col, layer, 0] / totalweight + "," + texture_kg[row, col, layer, 1] / totalweight + "," + texture_kg[row, col, layer, 2] / totalweight + "," + texture_kg[row, col, layer, 3] / totalweight + "," + texture_kg[row, col, layer, 4] / totalweight);
                        sw.Write("\r\n");
                        midthick += layerthickness_m[row, col, layer] / 2;
                    }

                }
                sw.Close();
            }
        }// end writesoil


        void writeOSLages(string name4)
        {
            int layer;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("row, col, layer, grain_age, deposition_age, count_surfaced");
                sw.Write("\r\n");
                int t_out = t + 1;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            for (int lay = 0; lay < max_soil_layers; lay++)
                            {
                                for (int ind = 0; ind < OSL_grainages[row, col, lay].Length; ind++)
                                {
                                    double laythick = layerthickness_m[row, col, lay];
                                    double laymass = total_layer_mass_kg(row, col, lay);
                                    sw.Write(row + "," + col + "," + lay + "," + OSL_grainages[row, col, lay][ind] + "," + OSL_depositionages[row, col, lay][ind] + "," + OSL_surfacedcount[row, col, lay][ind]);
                                    sw.Write("\r\n");
                                }
                            }
                        }
                    }
                }
                sw.Close();
            }
        }

        void writeallsoils(string name4)
        {
            int layer;
            double cumthick, midthick, z_layer;
            string FILENAME = name4;
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                sw.Write("row,col,t,nlayer,cumth_m,thick_m,midthick_m,z,coarse_kg,sand_kg,silt_kg,clay_kg,fine_kg,YOM_kg,OOM_kg,YOM/OOM,f_coarse,f_sand,f_silt,f_clay,f_fineclay,ftotal_clay,f_OM,BD");
                if (CN_checkbox.Checked) { sw.Write(",Be-10_meteoric_clay,Be-10_meteoric_silt,Be-10_meteoric_total,Be-10_insitu,C-14_insitu"); }
                sw.Write("\r\n");
                int t_out = t + 1;
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            cumthick = 0;
                            midthick = 0;
                            z_layer = dtm[row, col];
                            for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
                            {
                                if (layerthickness_m[row, col, layer] > 0)
                                {
                                    cumthick += layerthickness_m[row, col, layer];
                                    midthick += layerthickness_m[row, col, layer] / 2;
                                    double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    double totalweight_tex = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4];
                                    sw.Write(row + "," + col + "," + t_out + "," + layer + "," + cumthick + "," + layerthickness_m[row, col, layer] + "," + midthick + "," + z_layer + "," + texture_kg[row, col, layer, 0] + "," + texture_kg[row, col, layer, 1] + "," + texture_kg[row, col, layer, 2] + "," + texture_kg[row, col, layer, 3] + "," + texture_kg[row, col, layer, 4] + "," + young_SOM_kg[row, col, layer] + "," + old_SOM_kg[row, col, layer] + "," + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + "," + texture_kg[row, col, layer, 0] / totalweight_tex + "," + texture_kg[row, col, layer, 1] / totalweight_tex + "," + texture_kg[row, col, layer, 2] / totalweight_tex + "," + texture_kg[row, col, layer, 3] / totalweight_tex + "," + texture_kg[row, col, layer, 4] / totalweight_tex + "," + (texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight_tex + "," + (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) / (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer] + totalweight_tex) + "," + bulkdensity[row, col, layer]);

                                    if (CN_checkbox.Checked)
                                    {
                                        sw.Write("," + (CN_atoms_cm2[row, col, layer, 0] + "," + CN_atoms_cm2[row, col, layer, 1]) + "," + (CN_atoms_cm2[row, col, layer, 0]+ CN_atoms_cm2[row, col, layer, 1]) + "," + CN_atoms_cm2[row, col, layer, 2] + "," + CN_atoms_cm2[row, col, layer, 3]);
                                    }

                                    sw.Write("\r\n");
                                    midthick += layerthickness_m[row, col, layer] / 2;
                                    z_layer -= layerthickness_m[row, col, layer];
                                }

                            }

                        }
                    }
                }
                sw.Close();
            }

        }// end writeallsoils

        void write_longitudinal_profile(int startrow, int startcol, string name4)
        {

            // writes a longitudinal steepest-descent profile starting from a given begin r,c 
            double altidiff, non_lake_altidiff, maxaltidiff;
            int row, col, i, j, non_lake_maxi, non_lake_maxj, maxi, maxj, profilesize = 1000, step;
            double[] profile;
            profile = new double[1000];
            row = startrow;
            col = startcol;
            step = 0;
            string FILENAME = name4;

            while (row - 1 >= 0 && row + 1 < nr && col - 1 >= 0 && col + 1 < nc)
            {   // as long as we have not reached the edge
                Debug.WriteLine("profile now at row %d col %d, alt %.4f\n", row, col, dtm[row, col]);
                altidiff = -9999; non_lake_altidiff = 0; maxaltidiff = 0; non_lake_maxi = 0; non_lake_maxj = 0; maxi = 0; maxj = 0;
                for (i = -1; i <= 1; i++)
                {
                    for (j = -1; j <= 1; j++)
                    {
                        altidiff = dtm[row, col] - dtm[row + i, col + j];
                        //Debug.WriteLine(" profile : nb %d %d, diff %.3f\n",row+i,col+j,altidiff);
                        if (altidiff > maxaltidiff)
                        {
                            maxaltidiff = altidiff; maxi = i; maxj = j;
                        }
                        if (altidiff > non_lake_altidiff && depression[row + i, col + j] == 0)
                        {
                            non_lake_altidiff = altidiff; non_lake_maxi = i; non_lake_maxj = j;
                        }
                    }
                }
                Debug.WriteLine("profile : found lowest nb at %d %d, diff %.3f\n", row + maxi, col + maxj, maxaltidiff);
                if (non_lake_altidiff != 0) { row += non_lake_maxi; col += non_lake_maxj; } //avoid depressions if you can and prevent from falling back
                else { row += maxi; col += maxj; }
                if (maxi == 0 && maxj == 0 || maxaltidiff == 0)
                {
                    Debug.WriteLine("warning : no profile-progress due to sink?\n"); // go straight to the outlet of this depression and count the number of cells in between
                                                                                     //break;
                    maxi = drainingoutlet_row[depression[row, col], 0] - row;
                    maxj = drainingoutlet_col[depression[row, col], 0] - col;
                    for (i = 1; i <= (Math.Abs(maxi) + Math.Abs(maxj)); i++)
                    {
                        profile[step] = dtm[row, col] + (i / (Math.Abs(maxi) + Math.Abs(maxj))) * (depressionlevel[depression[row, col]] - dtm[row, col]);
                        Debug.WriteLine("profile %d now %.6f\n", step, profile[step]);
                        step++;
                    }
                    row += maxi;
                    col += maxj;
                }
                else
                {
                    profile[step] = dtm[row, col];
                    step++;
                    if (step > profilesize - 3) { Debug.WriteLine("warning : profilerecord may be too small\n"); break; }
                }
            }

            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                for (i = 0; i < step + 1; i++)
                {
                    Debug.WriteLine(profile[i]);
                    sw.Write("{0:F6}", profile[i]);
                }
                sw.Write("\r\n");
            }
            Debug.WriteLine("profile contains %d values\n", step);
        } // end write_profile() 

        void write_full_output(string filecore, int rows, int cols, int layers, int t)
        {
            int layer, row, col;
            string filename = workdir + "\\" + filecore + t + ".lrc";
            //Debug.WriteLine("attempting to write output " + filename + " at t " + t);
            using (StreamWriter sw = new StreamWriter(filename))
            {
                try
                {
                    sw.WriteLine("Lorica output header");
                    sw.WriteLine("year " + t);
                    sw.WriteLine("years " + end_time + " every " + int.Parse(Box_years_output.Text));
                    sw.WriteLine("rows " + rows + " cellsize " + dx + " yllcoord " + ycoord);
                    sw.WriteLine("cols " + cols + " xllcoord " + xcoord);
                    sw.WriteLine("layers " + layers);
                    sw.WriteLine("properties 10");
                    sw.WriteLine("propnames elevation thickness_m density_kg_m3 coarse_kg sand_kg silt_kg clay_kg fineclay_kg youngom_kg oldom_kg");
                    sw.WriteLine("Lorica output content");
                }
                catch { Debug.WriteLine(" issue with writing the header of the full output file for this timestep"); }
                try
                {
                    for (row = 0; row < rows; row++)
                    {
                        for (col = 0; col < cols; col++)
                        {
                            for (layer = 0; layer < layers; layer++)
                            {
                                sw.Write(dtm[row, col]
                                    + "_" + layerthickness_m[row, col, layer]
                                    + "_" + bulkdensity[row, col, layer]
                                    + "_" + texture_kg[row, col, layer, 0]
                                    + "_" + texture_kg[row, col, layer, 1]
                                    + "_" + texture_kg[row, col, layer, 2]
                                    + "_" + texture_kg[row, col, layer, 3]
                                    + "_" + texture_kg[row, col, layer, 4]
                                    + "_" + young_SOM_kg[row, col, layer]
                                    + "_" + old_SOM_kg[row, col, layer]
                                    + ",");
                            }
                            sw.Write("\n");
                        }
                    }
                }
                catch { Debug.WriteLine(" issue with writing the content of the full output file for this timestep"); }
                sw.Close();
            }
        }

        private void menuItemConfigFileOpen_Click(object sender, System.EventArgs e)
        {
            //opens a runfile
            XmlTextReader xreader;
            int read_error = 0;
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "cfg files (*.xml)|*.xml|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                cfgname = openFileDialog1.FileName;

                xreader = new XmlTextReader(cfgname);

                //Read the file
                if (xreader != null)
                {
                    try
                    {
                        xreader.ReadStartElement("Parms");
                        xreader.ReadStartElement("Processes");
                        xreader.ReadStartElement("Water_erosion");
                        Water_ero_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("water_active"));
                        parameter_m_textbox.Text = xreader.ReadElementString("para_m");
                        parameter_n_textbox.Text = xreader.ReadElementString("para_n");
                        parameter_conv_textbox.Text = xreader.ReadElementString("para_p");
                        parameter_K_textbox.Text = xreader.ReadElementString("para_K");
                        erosion_threshold_textbox.Text = xreader.ReadElementString("para_ero_threshold");
                        rock_protection_constant_textbox.Text = xreader.ReadElementString("para_rock_protection_const");
                        bio_protection_constant_textbox.Text = xreader.ReadElementString("para_bio_protection_const");
                        selectivity_constant_textbox.Text = xreader.ReadElementString("para_selectivity");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading water ero paras"); }

                    try
                    {
                        xreader.ReadStartElement("Tillage");
                        Tillage_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("tillage_active"));
                        parameter_ploughing_depth_textbox.Text = xreader.ReadElementString("para_plough_depth");
                        parameter_tillage_constant_textbox.Text = xreader.ReadElementString("para_tillage_constant");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading tillage paras"); }

                    try
                    {
                        xreader.ReadStartElement("Weathering");
                        Biological_weathering_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("bio_weathering_active"));
                        parameter_P0_textbox.Text = xreader.ReadElementString("para_P0");
                        parameter_k1_textbox.Text = xreader.ReadElementString("para_k1");
                        parameter_k2_textbox.Text = xreader.ReadElementString("para_k2");
                        parameter_Pa_textbox.Text = xreader.ReadElementString("para_Pa");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading weathering paras"); }

                    try
                    {
                        xreader.ReadStartElement("Landsliding");
                        Landslide_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("landsliding_active"));
                        radio_ls_absolute.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("radio_ls_absolute"));
                        radio_ls_fraction.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("radio_ls_fraction"));
                        text_ls_abs_rain_intens.Text = xreader.ReadElementString("para_absolute_rain_intens");
                        text_ls_rel_rain_intens.Text = xreader.ReadElementString("para_relative_rain_intens");
                        textBox_ls_coh.Text = xreader.ReadElementString("para_cohesion");
                        textBox_ls_ifr.Text = xreader.ReadElementString("para_friction");
                        textBox_ls_bd.Text = xreader.ReadElementString("para_density");
                        textBox_ls_trans.Text = xreader.ReadElementString("para_transmissivity");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading landsliding paras"); }

                    try
                    {
                        xreader.ReadStartElement("Creep");
                        creep_active_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("creep_active"));
                        parameter_diffusivity_textbox.Text = xreader.ReadElementString("para_diffusivity");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading creep paras"); }

                    try
                    {
                        xreader.ReadStartElement("Tree_fall");
                        treefall_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("treefall_active"));
                        tf_W.Text = xreader.ReadElementString("tf_width");
                        tf_D.Text = xreader.ReadElementString("tf_depth");
                        tf_growth.Text = xreader.ReadElementString("tf_growth");
                        tf_age.Text = xreader.ReadElementString("tf_age");
                        tf_freq.Text = xreader.ReadElementString("tf_freq");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading tree fall paras"); }

                    try
                    {
                        xreader.ReadStartElement("Blocks");
                        blocks_active_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("blocks_active"));
                        hardlayerthickness_textbox.Text = xreader.ReadElementString("hardlayerthickness");
                        hardlayerelevation_textbox.Text = xreader.ReadElementString("hardlayerelevation");
                        hardlayerdensity_textbox.Text = xreader.ReadElementString("hardlayerdensity");
                        hardlayerweath_textbox.Text = xreader.ReadElementString("hardlayerweath");
                        blockweath_textbox.Text = xreader.ReadElementString("blockweath");
                        blocksize_textbox.Text = xreader.ReadElementString("blockminsize");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading block paras"); }

                    try
                    {
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Soil_forming_processes");
                        xreader.ReadStartElement("Physical_weathering");
                        soil_phys_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("phys_weath_active"));
                        Physical_weath_C1_textbox.Text = xreader.ReadElementString("weath_rate_constant");
                        physical_weath_constant1.Text = xreader.ReadElementString("constant1");
                        physical_weath_constant2.Text = xreader.ReadElementString("constant2");
                        upper_particle_coarse_textbox.Text = xreader.ReadElementString("size_coarse");
                        upper_particle_sand_textbox.Text = xreader.ReadElementString("size_sand");
                        upper_particle_silt_textbox.Text = xreader.ReadElementString("size_silt");
                        upper_particle_clay_textbox.Text = xreader.ReadElementString("size_clay");
                        upper_particle_fine_clay_textbox.Text = xreader.ReadElementString("size_fine");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading soil phys weath paras"); }

                    try
                    {
                        xreader.ReadStartElement("Chemical_weathering");
                        soil_chem_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("chem_weath_active"));
                        chem_weath_rate_constant_textbox.Text = xreader.ReadElementString("weath_rate_constant");
                        chem_weath_depth_constant_textbox.Text = xreader.ReadElementString("constant3");
                        chem_weath_specific_coefficient_textbox.Text = xreader.ReadElementString("constant4");
                        specific_area_coarse_textbox.Text = xreader.ReadElementString("surface_coarse");
                        specific_area_sand_textbox.Text = xreader.ReadElementString("surface_sand");
                        specific_area_silt_textbox.Text = xreader.ReadElementString("surface_silt");
                        specific_area_clay_textbox.Text = xreader.ReadElementString("surface_clay");
                        specific_area_fine_clay_textbox.Text = xreader.ReadElementString("surface_fine_clay");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading soil chemical weath paras"); }

                    try
                    {
                        xreader.ReadStartElement("Clay_dynamics");
                        soil_clay_transloc_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("clay_dynamics_active"));
                        clay_neoform_constant_textbox.Text = xreader.ReadElementString("neoform_rate_constant");
                        clay_neoform_C1_textbox.Text = xreader.ReadElementString("constant5");
                        clay_neoform_C2_textbox.Text = xreader.ReadElementString("constant6");
                        maximum_eluviation_textbox.Text = xreader.ReadElementString("max_eluviation");
                        eluviation_coefficient_textbox.Text = xreader.ReadElementString("eluviation_coefficient");
                        ct_Jagercikova.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("ct_Jagercikova_active"));
                        ct_v0_Jagercikova.Text = xreader.ReadElementString("ct_v0_Jagercikova");
                        ct_dd_Jagercikova.Text = xreader.ReadElementString("ct_dd_Jagercikova");
                        xreader.ReadEndElement();
                    }
                    catch
                    {
                        read_error = 1; Debug.WriteLine("failed reading clay dynamics paras");
                    }

                    try
                    {
                        xreader.ReadStartElement("Bioturbation");
                        soil_bioturb_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("bioturbation_active"));
                        potential_bioturbation_textbox.Text = xreader.ReadElementString("potential_bioturb");
                        bioturbation_depth_decay_textbox.Text = xreader.ReadElementString("bioturb_depth_decay");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading water ero paras"); }

                    try
                    {
                        xreader.ReadStartElement("Carboncycle");
                        soil_carbon_cycle_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("carboncycle_active"));
                        carbon_input_textbox.Text = xreader.ReadElementString("carbon_input");
                        carbon_depth_decay_textbox.Text = xreader.ReadElementString("carbon_depth_decay");
                        carbon_humification_fraction_textbox.Text = xreader.ReadElementString("carbon_hum_fraction");
                        carbon_y_decomp_rate_textbox.Text = xreader.ReadElementString("carbon_y_decomp");
                        carbon_y_depth_decay_textbox.Text = xreader.ReadElementString("carbon_y_depth_decay");
                        carbon_y_twi_decay_textbox.Text = xreader.ReadElementString("carbon_y_twi_decay");
                        carbon_o_decomp_rate_textbox.Text = xreader.ReadElementString("carbon_o_decomp");
                        carbon_o_depth_decay_textbox.Text = xreader.ReadElementString("carbon_o_depth_decay");
                        carbon_o_twi_decay_textbox.Text = xreader.ReadElementString("carbon_o_twi_decay");
                        xreader.ReadEndElement();
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading carbon cycle paras"); }

                    try
                    {
                        xreader.ReadStartElement("Geochronological_tracers");

                        OSL_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("OSL_active"));
                        ngrains_textbox.Text = xreader.ReadElementString("ngrains");
                        bleachingdepth_textbox.Text = xreader.ReadElementString("bleachingdepth");
                        OSL_inherited_textbox.Text = xreader.ReadElementString("inherited_age");
                        CN_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("CN_active"));
                        metBe10_input_textbox.Text = xreader.ReadElementString("metBe10_input_rate");
                        met10Be_dd.Text = xreader.ReadElementString("metBe10_dd");
                        Be10_decay_textbox.Text = xreader.ReadElementString("Be10_decay");
                        met_10Be_clayfrac.Text = xreader.ReadElementString("metBe10_clay");
                        metBe10_inherited_textbox.Text = xreader.ReadElementString("met10Be_inherited");

                        isBe10_sp_input_textbox.Text = xreader.ReadElementString("isBe10_sp_input");
                        isBe10_mu_input_textbox.Text = xreader.ReadElementString("isBe10_mu_input");
                        isBe10_inherited_textbox.Text = xreader.ReadElementString("isBe10_inherited");

                        attenuationlength_sp_textbox.Text = xreader.ReadElementString("attlength_sp");
                        attenuationlength_mu_textbox.Text = xreader.ReadElementString("attlength_mu");

                        isC14_sp_input_textbox.Text = xreader.ReadElementString("isC14_sp_input");
                        isC14_mu_input_textbox.Text = xreader.ReadElementString("isC14_mu_input");
                        C14_decay_textbox.Text = xreader.ReadElementString("C14_decay");
                        isC14_inherited_textbox.Text = xreader.ReadElementString("isC14_inherited");

                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading geochron paras"); }

                    try
                    {
                        xreader.ReadStartElement("Inputs");
                        check_space_DTM.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_DTM"));
                        check_space_soildepth.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_soil"));
                        check_space_landuse.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_landuse"));
                        check_space_till_fields.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_tillfields"));
                        check_space_rain.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_rain"));
                        check_space_infil.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_infil"));
                        check_space_evap.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_space_evap"));
                        check_time_landuse.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_landuse"));
                        check_time_till_fields.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_tillfields"));
                        check_time_rain.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_rain"));
                        check_time_infil.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_infil"));
                        check_time_evap.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_time_evap"));
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading input paras"); }

                    try
                    {
                        daily_water.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("dailywater"));
                        dailyP.Text = xreader.ReadElementString("dailyP");
                        dailyET0.Text = xreader.ReadElementString("dailyET0");
                        dailyD.Text = xreader.ReadElementString("dailyD");
                        dailyT_avg.Text = xreader.ReadElementString("dailyT_avg");
                        dailyT_min.Text = xreader.ReadElementString("dailyT_min");
                        dailyT_max.Text = xreader.ReadElementString("dailyT_max");
                        latitude_deg.Text = xreader.ReadElementString("latitude_deg");
                        latitude_min.Text = xreader.ReadElementString("latitude_min");
                        snowmelt_factor_textbox.Text = xreader.ReadElementString("snowmelt_factor");
                        snow_threshold_textbox.Text = xreader.ReadElementString("snowmelt_threshold");
                        daily_n.Text = xreader.ReadElementString("daily_n_years");
                        check_scaling_daily_weather.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("scaledailyweather"));
                    } //MMxml
                    catch { read_error = 1; Debug.WriteLine("xml7.2"); Debug.WriteLine("failed reading hydrolorica paras"); }

                    try
                    {
                        dtm_input_filename_textbox.Text = xreader.ReadElementString("dtm_input_filename");
                        soildepth_input_filename_textbox.Text = xreader.ReadElementString("soildepth_input_filename");
                        landuse_input_filename_textbox.Text = xreader.ReadElementString("landuse_input_filename");
                        tillfields_input_filename_textbox.Text = xreader.ReadElementString("tillfields_input_filename");
                        rain_input_filename_textbox.Text = xreader.ReadElementString("rain_input_filename");
                        infil_input_filename_textbox.Text = xreader.ReadElementString("infil_input_filename");
                        evap_input_filename_textbox.Text = xreader.ReadElementString("evap_input_filename");
                        soildepth_constant_value_box.Text = xreader.ReadElementString("soildepth_constant_value");
                        landuse_constant_value_box.Text = xreader.ReadElementString("landuse_constant_value");
                        tillfields_constant_textbox.Text = xreader.ReadElementString("tillfields_constant_value");
                        rainfall_constant_value_box.Text = xreader.ReadElementString("rain_constant_value");
                        infil_constant_value_box.Text = xreader.ReadElementString("infil_constant_value");
                        evap_constant_value_box.Text = xreader.ReadElementString("evap_constant_value");
                        checkbox_layer_thickness.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("checkbox_layer_thickness"));
                        textbox_max_soil_layers.Text = xreader.ReadElementString("max_soil_layers");
                        textbox_layer_thickness.Text = xreader.ReadElementString("layer_thickness");
                        fill_sinks_before_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_fill_sinks_before"));
                        fill_sinks_during_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("check_fill_sinks_during"));
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading more input paras"); }

                    try
                    {
                        xreader.ReadStartElement("Run");
                        runs_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("runs_radiobutton"));
                        Number_runs_textbox.Text = xreader.ReadElementString("number_runs");
                        xreader.ReadStartElement("Specialsettings");
                        Spitsbergen_case_study.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Spitsbergen"));
                        version_lux_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Luxembourg"));
                        version_Konza_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("Konza"));
                        version_CarboZALF_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("CarboZALF"));

                        OSL_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("OSL_tracing"));
                        CN_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("CN_tracing"));
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("xm29"); Debug.WriteLine("failed reading run paras"); }

                    try
                    {
                        xreader.ReadStartElement("CalibrationSensitivity");

                        Calibration_button.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("calibration_active_button"));
                        num_cal_paras_textbox.Text = xreader.ReadElementString("calibration_num_paras_string");
                        calibration_ratios_textbox.Text = xreader.ReadElementString("calibration_ratios_string");
                        calibration_levels_textbox.Text = xreader.ReadElementString("calibration_levels");
                        calibration_ratio_reduction_parameter_textbox.Text = xreader.ReadElementString("calibration_ratio_reduction_per_level");
                        obsfile_textbox.Text = xreader.ReadElementString("calibration_observations_file");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 2; Debug.WriteLine("failed reading calib paras"); }

                    try
                    {
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Output");
                        xreader.ReadStartElement("File_Output");
                        xreader.ReadStartElement("Moment_of_Output");
                        Final_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("final_output_checkbox"));
                        Regular_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("regular_output_checkbox"));
                        Box_years_output.Text = xreader.ReadElementString("years_between_outputs");
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Type_of_Output");

                        cumulative_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cumulative"));
                        annual_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("annual"));
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Maps_to_Output");
                        Altitude_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("alti"));
                        Alt_change_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("altichange"));
                        Soildepth_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("soildepth"));
                        all_process_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("all_processes"));
                        water_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("waterflow"));
                        depressions_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("depressions"));
                        diagnostic_output_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("diagnostics"));
                        xreader.ReadEndElement();
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Other_outputs");
                        xreader.ReadStartElement("Timeseries");
                        timeseries.timeseries_total_ero_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_erosion"));
                        timeseries.timeseries_total_dep_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_deposition"));
                        timeseries.timeseries_net_ero_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("net_erosion"));
                        timeseries.timeseries_sedexport_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("sed_export"));
                        timeseries.timeseries_SDR_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("SDR"));
                        timeseries.timeseries_total_average_alt_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_average_alt"));
                        timeseries.timeseries_total_rain_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_rain"));
                        timeseries.timeseries_total_infil_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_infil"));
                        timeseries.timeseries_total_evap_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_evap"));
                        timeseries.timeseries_total_outflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_outflow"));
                        timeseries.timeseries_number_waterflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("wet_cells"));
                        timeseries.timeseries_number_erosion_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("eroded_cells"));
                        timeseries.timeseries_number_dep_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("deposited_cells"));
                        timeseries.timeseries_outflow_cells_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("outflow_cells"));
                        timeseries.timeseries_cell_altitude_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cell_altitude"));
                        timeseries.timeseries_cell_waterflow_check.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("cell_waterflow"));
                        timeseries.timeseries_textbox_waterflow_threshold.Text = xreader.ReadElementString("waterflow_threshold");
                        timeseries.timeseries_textbox_erosion_threshold.Text = xreader.ReadElementString("erosion_threshold");
                        timeseries.timeseries_textbox_deposition_threshold.Text = xreader.ReadElementString("deposition_threshold");
                        timeseries.timeseries_textbox_cell_row.Text = xreader.ReadElementString("cell_row");
                        timeseries.timeseries_textbox_cell_col.Text = xreader.ReadElementString("cell_col");
                        timeseries.total_OM_input_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_OM_input"));
                        timeseries.total_average_soilthickness_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_average_soil_thickness"));
                        timeseries.total_phys_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_phys_weath"));
                        timeseries.total_chem_weath_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_chem_weath"));
                        timeseries.total_fine_formed_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_fine_formed"));
                        timeseries.total_fine_eluviated_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_fine_eluviated"));
                        timeseries.total_mass_bioturbed_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("total_mass_bioturbed"));
                        timeseries.timeseries_soil_depth_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_soil_depth"));
                        timeseries.timeseries_soil_mass_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_soil_mass"));
                        timeseries.timeseries_coarser_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_coarser"));
                        timeseries.timeseries_number_soil_thicker_checkbox.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("timeseries_thicker"));
                        timeseries.timeseries_soil_cell_col.Text = xreader.ReadElementString("soil_cell");
                        timeseries.timeseries_soil_cell_row.Text = xreader.ReadElementString("soil_col");
                        timeseries.timeseries_soil_coarser_fraction_textbox.Text = xreader.ReadElementString("coarser_fraction");
                        timeseries.timeseries_soil_thicker_textbox.Text = xreader.ReadElementString("thicker_threshold");
                        xreader.ReadEndElement();
                        xreader.ReadStartElement("Profiles");
                        profile.radio_pro1_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile1_row"));
                        profile.radio_pro1_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile1_col"));
                        profile.radio_pro2_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile2_row"));
                        profile.radio_pro2_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile2_col"));
                        profile.radio_pro3_row.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile3_row"));
                        profile.radio_pro3_col.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("profile3_col"));
                        profile.p1_row_col_box.Text = xreader.ReadElementString("p1_number");
                        profile.p2_row_col_box.Text = xreader.ReadElementString("p2_number");
                        profile.p3_row_col_box.Text = xreader.ReadElementString("p3_number");
                        profile.check_waterflow_profile1.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p1_waterflow"));
                        profile.check_altitude_profile1.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p1_altitude"));
                        profile.check_waterflow_profile2.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p2_waterflow"));
                        profile.check_altitude_profile2.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p2_altitude"));
                        profile.check_waterflow_profile3.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p3_waterflow"));
                        profile.check_altitude_profile3.Checked = XmlConvert.ToBoolean(xreader.ReadElementString("p3_altitude"));
                        xreader.ReadEndElement();
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading output paras"); }

                    try
                    {
                        xreader.ReadStartElement("Soilfractions");
                        soildata.coarsebox.Text = xreader.ReadElementString("coarsefrac");
                        soildata.sandbox.Text = xreader.ReadElementString("sandfrac");
                        soildata.siltbox.Text = xreader.ReadElementString("siltfrac");
                        soildata.claybox.Text = xreader.ReadElementString("clayfrac");
                        soildata.fineclaybox.Text = xreader.ReadElementString("fclayfrac");
                        xreader.ReadEndElement();
                    }
                    catch { read_error = 1; Debug.WriteLine("failed reading soil frac paras"); }

                    if (read_error == 1) { MessageBox.Show("warning : not all runfile data could be read.\r\n LORICA can continue"); }
                    if (read_error == 2) { MessageBox.Show("Error in new XML lines"); }

                    xreader.Close();

                    this.Text = basetext + " (" + Path.GetFileName(cfgname) + ")";
                    start_button.Enabled = true;
                    tabControl1.Visible = true;

                }
            }
        }

        private void menuItemConfigFileSave_Click(object sender, System.EventArgs e)
        {
            XmlTextWriter xwriter;

            if ((sender == menuItemConfigFileSaveAs) || (cfgname == null))
            {

                SaveFileDialog saveFileDialog1 = new SaveFileDialog();

                saveFileDialog1.InitialDirectory = workdir;
                saveFileDialog1.Filter = "cfg files (*.xml)|*.xml|All files (*.*)|*.*";
                saveFileDialog1.FilterIndex = 1;
                saveFileDialog1.RestoreDirectory = false;

                if (saveFileDialog1.ShowDialog() == DialogResult.OK)
                {
                    cfgname = saveFileDialog1.FileName;
                }
            }
            if (cfgname != null)
            {

                //Create a new XmlTextWriter.
                xwriter = new XmlTextWriter(cfgname, System.Text.Encoding.UTF8);
                //Write the beginning of the document including the 
                //document declaration. Standalone is true. 
                //Use indentation for readability.
                xwriter.Formatting = Formatting.Indented;
                xwriter.Indentation = 4;

                xwriter.WriteStartDocument(true);

                //Write the beginning of the "data" element. This is 
                //the opening tag to our data 
                xwriter.WriteStartElement("Parms");
                xwriter.WriteStartElement("Processes");
                xwriter.WriteStartElement("Water_erosion");
                xwriter.WriteElementString("water_active", XmlConvert.ToString(Water_ero_checkbox.Checked));
                xwriter.WriteElementString("para_m", parameter_m_textbox.Text);
                xwriter.WriteElementString("para_n", parameter_n_textbox.Text);
                xwriter.WriteElementString("para_p", parameter_conv_textbox.Text);
                xwriter.WriteElementString("para_K", parameter_K_textbox.Text);
                xwriter.WriteElementString("para_ero_threshold", erosion_threshold_textbox.Text);
                xwriter.WriteElementString("para_rock_protection_const", rock_protection_constant_textbox.Text);
                xwriter.WriteElementString("para_bio_protection_const", bio_protection_constant_textbox.Text);
                xwriter.WriteElementString("para_selectivity", selectivity_constant_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Tillage");
                xwriter.WriteElementString("tillage_active", XmlConvert.ToString(Tillage_checkbox.Checked));
                xwriter.WriteElementString("para_plough_depth", parameter_ploughing_depth_textbox.Text);
                xwriter.WriteElementString("para_tillage_constant", parameter_tillage_constant_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Weathering");
                xwriter.WriteElementString("bio_weathering_active", XmlConvert.ToString(Biological_weathering_checkbox.Checked));
                xwriter.WriteElementString("para_P0", parameter_P0_textbox.Text);
                xwriter.WriteElementString("para_k1", parameter_k1_textbox.Text);
                xwriter.WriteElementString("para_k2", parameter_k2_textbox.Text);
                xwriter.WriteElementString("para_Pa", parameter_Pa_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Landsliding");
                xwriter.WriteElementString("landsliding_active", XmlConvert.ToString(Landslide_checkbox.Checked));
                xwriter.WriteElementString("radio_ls_absolute", XmlConvert.ToString(radio_ls_absolute.Checked));
                xwriter.WriteElementString("radio_ls_fraction", XmlConvert.ToString(radio_ls_fraction.Checked));
                xwriter.WriteElementString("para_absolute_rain_intens", text_ls_abs_rain_intens.Text);
                xwriter.WriteElementString("para_relative_rain_intens", text_ls_rel_rain_intens.Text);
                xwriter.WriteElementString("para_cohesion", textBox_ls_coh.Text);
                xwriter.WriteElementString("para_friction", textBox_ls_ifr.Text);
                xwriter.WriteElementString("para_density", textBox_ls_bd.Text);
                xwriter.WriteElementString("para_transmissivity", textBox_ls_trans.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Creep");
                xwriter.WriteElementString("creep_active", XmlConvert.ToString(creep_active_checkbox.Checked));
                xwriter.WriteElementString("para_diffusivity", parameter_diffusivity_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Tree_fall");
                xwriter.WriteElementString("treefall_active", XmlConvert.ToString(treefall_checkbox.Checked));
                xwriter.WriteElementString("tf_width", tf_W.Text);
                xwriter.WriteElementString("tf_depth", tf_D.Text);
                xwriter.WriteElementString("tf_growth", tf_growth.Text);
                xwriter.WriteElementString("tf_age", tf_age.Text);
                xwriter.WriteElementString("tf_freq", tf_freq.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Blocks");
                xwriter.WriteElementString("blocks_active", XmlConvert.ToString(treefall_checkbox.Checked));
                xwriter.WriteElementString("hardlayerthickness", hardlayerthickness_textbox.Text);
                xwriter.WriteElementString("hardlayerelevation", hardlayerelevation_textbox.Text);
                xwriter.WriteElementString("hardlayerdensity", hardlayerdensity_textbox.Text);
                xwriter.WriteElementString("hardlayerweath", hardlayerweath_textbox.Text);
                xwriter.WriteElementString("blockweath", blockweath_textbox.Text);
                xwriter.WriteElementString("blockminsize", blocksize_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Soil_forming_processes");
                xwriter.WriteStartElement("Physical_weathering");
                xwriter.WriteElementString("phys_weath_active", XmlConvert.ToString(soil_phys_weath_checkbox.Checked));
                xwriter.WriteElementString("weath_rate_constant", Physical_weath_C1_textbox.Text);
                xwriter.WriteElementString("constant1", physical_weath_constant1.Text);
                xwriter.WriteElementString("constant2", physical_weath_constant2.Text);
                xwriter.WriteElementString("size_coarse", upper_particle_coarse_textbox.Text);
                xwriter.WriteElementString("size_sand", upper_particle_sand_textbox.Text);
                xwriter.WriteElementString("size_silt", upper_particle_silt_textbox.Text);
                xwriter.WriteElementString("size_clay", upper_particle_clay_textbox.Text);
                xwriter.WriteElementString("size_fine", upper_particle_fine_clay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Chemical_weathering");
                xwriter.WriteElementString("chem_weath_active", XmlConvert.ToString(soil_chem_weath_checkbox.Checked));
                xwriter.WriteElementString("weath_rate_constant", chem_weath_rate_constant_textbox.Text);
                xwriter.WriteElementString("constant3", chem_weath_depth_constant_textbox.Text);
                xwriter.WriteElementString("constant4", chem_weath_specific_coefficient_textbox.Text);
                xwriter.WriteElementString("surface_coarse", specific_area_coarse_textbox.Text);
                xwriter.WriteElementString("surface_sand", specific_area_sand_textbox.Text);
                xwriter.WriteElementString("surface_silt", specific_area_silt_textbox.Text);
                xwriter.WriteElementString("surface_clay", specific_area_clay_textbox.Text);
                xwriter.WriteElementString("surface_fine_clay", specific_area_fine_clay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Clay_dynamics");
                xwriter.WriteElementString("clay_dynamics_active", XmlConvert.ToString(soil_clay_transloc_checkbox.Checked));
                xwriter.WriteElementString("neoform_rate_constant", clay_neoform_constant_textbox.Text);
                xwriter.WriteElementString("constant5", clay_neoform_C1_textbox.Text);
                xwriter.WriteElementString("constant6", clay_neoform_C2_textbox.Text);
                xwriter.WriteElementString("max_eluviation", maximum_eluviation_textbox.Text);
                xwriter.WriteElementString("eluviation_coefficient", eluviation_coefficient_textbox.Text);
                xwriter.WriteElementString("ct_Jagercikova_active", XmlConvert.ToString(ct_Jagercikova.Checked));
                xwriter.WriteElementString("ct_v0_Jagercikova", ct_v0_Jagercikova.Text);
                xwriter.WriteElementString("ct_dd_Jagercikova", ct_dd_Jagercikova.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Bioturbation");
                xwriter.WriteElementString("bioturbation_active", XmlConvert.ToString(soil_bioturb_checkbox.Checked));
                xwriter.WriteElementString("potential_bioturb", potential_bioturbation_textbox.Text);
                xwriter.WriteElementString("bioturb_depth_decay", bioturbation_depth_decay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Carboncycle");
                xwriter.WriteElementString("carboncycle_active", XmlConvert.ToString(soil_carbon_cycle_checkbox.Checked));
                xwriter.WriteElementString("carbon_input", carbon_input_textbox.Text);
                xwriter.WriteElementString("carbon_depth_decay", carbon_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_hum_fraction", carbon_humification_fraction_textbox.Text);
                xwriter.WriteElementString("carbon_y_decomp", carbon_y_decomp_rate_textbox.Text);
                xwriter.WriteElementString("carbon_y_depth_decay", carbon_y_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_y_twi_decay", carbon_y_twi_decay_textbox.Text);
                xwriter.WriteElementString("carbon_o_decomp", carbon_o_decomp_rate_textbox.Text);
                xwriter.WriteElementString("carbon_o_depth_decay", carbon_o_depth_decay_textbox.Text);
                xwriter.WriteElementString("carbon_o_twi_decay", carbon_o_twi_decay_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Geochronological_tracers");
                xwriter.WriteElementString("OSL_active", XmlConvert.ToString(OSL_checkbox.Checked));
                xwriter.WriteElementString("ngrains", ngrains_textbox.Text);
                xwriter.WriteElementString("bleachingdepth", bleachingdepth_textbox.Text);
                xwriter.WriteElementString("inherited_age", OSL_inherited_textbox.Text);
                xwriter.WriteElementString("CN_active", XmlConvert.ToString(CN_checkbox.Checked));
                xwriter.WriteElementString("metBe10_input_rate", metBe10_input_textbox.Text);
                xwriter.WriteElementString("metBe10_dd", met10Be_dd.Text);
                xwriter.WriteElementString("Be10_decay", Be10_decay_textbox.Text);
                xwriter.WriteElementString("metBe10_clay", met_10Be_clayfrac.Text);
                xwriter.WriteElementString("met10Be_inherited", metBe10_inherited_textbox.Text);
                xwriter.WriteElementString("isBe10_sp_input", isBe10_sp_input_textbox.Text);
                xwriter.WriteElementString("isBe10_mu_input", isBe10_mu_input_textbox.Text);
                xwriter.WriteElementString("isBe10_inherited", isBe10_inherited_textbox.Text);
                xwriter.WriteElementString("attlength_sp", attenuationlength_sp_textbox.Text);
                xwriter.WriteElementString("attlength_mu", attenuationlength_mu_textbox.Text);
                xwriter.WriteElementString("isC14_sp_input", isC14_sp_input_textbox.Text);
                xwriter.WriteElementString("isC14_mu_input", isC14_mu_input_textbox.Text);
                xwriter.WriteElementString("C14_decay", C14_decay_textbox.Text);
                xwriter.WriteElementString("isC14_inherited", isC14_inherited_textbox.Text);

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Inputs");
                xwriter.WriteElementString("check_space_DTM", XmlConvert.ToString(check_space_DTM.Checked));
                xwriter.WriteElementString("check_space_soil", XmlConvert.ToString(check_space_soildepth.Checked));
                xwriter.WriteElementString("check_space_landuse", XmlConvert.ToString(check_space_landuse.Checked));
                xwriter.WriteElementString("check_space_tillfields", XmlConvert.ToString(check_space_till_fields.Checked));
                xwriter.WriteElementString("check_space_rain", XmlConvert.ToString(check_space_rain.Checked));
                xwriter.WriteElementString("check_space_infil", XmlConvert.ToString(check_space_infil.Checked));
                xwriter.WriteElementString("check_space_evap", XmlConvert.ToString(check_space_evap.Checked));
                xwriter.WriteElementString("check_time_landuse", XmlConvert.ToString(check_time_landuse.Checked));
                xwriter.WriteElementString("check_time_tillfields", XmlConvert.ToString(check_time_till_fields.Checked));
                xwriter.WriteElementString("check_time_rain", XmlConvert.ToString(check_time_rain.Checked));
                xwriter.WriteElementString("check_time_infil", XmlConvert.ToString(check_time_infil.Checked));
                xwriter.WriteElementString("check_time_evap", XmlConvert.ToString(check_time_evap.Checked));

                xwriter.WriteElementString("dailywater", XmlConvert.ToString(daily_water.Checked));
                xwriter.WriteElementString("dailyP", dailyP.Text);
                xwriter.WriteElementString("dailyET0", dailyET0.Text);
                xwriter.WriteElementString("dailyD", dailyD.Text);
                xwriter.WriteElementString("dailyT_avg", dailyT_avg.Text);
                xwriter.WriteElementString("dailyT_min", dailyT_min.Text);
                xwriter.WriteElementString("dailyT_max", dailyT_max.Text);
                xwriter.WriteElementString("latitude_deg", latitude_deg.Text);
                xwriter.WriteElementString("latitude_min", latitude_min.Text);
                xwriter.WriteElementString("snowmelt_factor", snowmelt_factor_textbox.Text);
                xwriter.WriteElementString("snowmelt_threshold", snow_threshold_textbox.Text);
                xwriter.WriteElementString("daily_n_years", daily_n.Text);
                xwriter.WriteElementString("scaledailyweather", XmlConvert.ToString(check_scaling_daily_weather.Checked));

                xwriter.WriteElementString("dtm_input_filename", dtm_input_filename_textbox.Text);
                xwriter.WriteElementString("soildepth_input_filename", soildepth_input_filename_textbox.Text);
                xwriter.WriteElementString("landuse_input_filename", landuse_input_filename_textbox.Text);
                xwriter.WriteElementString("tillfields_input_filename", tillfields_input_filename_textbox.Text);
                xwriter.WriteElementString("rain_input_filename", rain_input_filename_textbox.Text);
                xwriter.WriteElementString("infil_input_filename", infil_input_filename_textbox.Text);
                xwriter.WriteElementString("evap_input_filename", evap_input_filename_textbox.Text);

                xwriter.WriteElementString("soildepth_constant_value", soildepth_constant_value_box.Text);
                xwriter.WriteElementString("landuse_constant_value", landuse_constant_value_box.Text);
                xwriter.WriteElementString("tillfields_constant_value", tillfields_constant_textbox.Text);
                xwriter.WriteElementString("rain_constant_value", rainfall_constant_value_box.Text);
                xwriter.WriteElementString("infil_constant_value", infil_constant_value_box.Text);
                xwriter.WriteElementString("evap_constant_value", evap_constant_value_box.Text);
                xwriter.WriteElementString("checkbox_layer_thickness", XmlConvert.ToString(checkbox_layer_thickness.Checked));
                xwriter.WriteElementString("max_soil_layers", textbox_max_soil_layers.Text);
                xwriter.WriteElementString("layer_thickness", textbox_layer_thickness.Text);
                xwriter.WriteElementString("check_fill_sinks_before", XmlConvert.ToString(fill_sinks_before_checkbox.Checked));
                xwriter.WriteElementString("check_fill_sinks_during", XmlConvert.ToString(fill_sinks_during_checkbox.Checked));

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Run");
                xwriter.WriteElementString("runs_radiobutton", XmlConvert.ToString(runs_checkbox.Checked));
                xwriter.WriteElementString("number_runs", Number_runs_textbox.Text);

                xwriter.WriteStartElement("Specialsettings");
                xwriter.WriteElementString("Spitsbergen", XmlConvert.ToString(Spitsbergen_case_study.Checked));
                xwriter.WriteElementString("Luxembourg", XmlConvert.ToString(version_lux_checkbox.Checked));
                xwriter.WriteElementString("Konza", XmlConvert.ToString(version_Konza_checkbox.Checked));
                xwriter.WriteElementString("CarboZALF", XmlConvert.ToString(version_CarboZALF_checkbox.Checked));
                xwriter.WriteElementString("OSL_tracing", XmlConvert.ToString(OSL_checkbox.Checked));
                xwriter.WriteElementString("CN_tracing", XmlConvert.ToString(CN_checkbox.Checked));
                //xwriter.WriteElementString("other", XmlConvert.ToString(runs_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("CalibrationSensitivity");
                xwriter.WriteElementString("calibration_active_button", XmlConvert.ToString(Calibration_button.Checked));
                xwriter.WriteElementString("calibration_num_paras_string", num_cal_paras_textbox.Text);
                xwriter.WriteElementString("calibration_ratios_string", calibration_ratios_textbox.Text);
                xwriter.WriteElementString("calibration_levels", calibration_levels_textbox.Text);
                xwriter.WriteElementString("calibration_ratio_reduction_per_level", calibration_ratio_reduction_parameter_textbox.Text);
                xwriter.WriteElementString("calibration_observations_file", obsfile_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Output");

                xwriter.WriteStartElement("File_Output");

                xwriter.WriteStartElement("Moment_of_Output");
                xwriter.WriteElementString("final_output_checkbox", XmlConvert.ToString(Final_output_checkbox.Checked));
                xwriter.WriteElementString("regular_output_checkbox", XmlConvert.ToString(Regular_output_checkbox.Checked));
                xwriter.WriteElementString("years_between_outputs", Box_years_output.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Type_of_Output");
                xwriter.WriteElementString("cumulative", XmlConvert.ToString(cumulative_output_checkbox.Checked));
                xwriter.WriteElementString("annual", XmlConvert.ToString(annual_output_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Maps_to_Output");
                xwriter.WriteElementString("alti", XmlConvert.ToString(Altitude_output_checkbox.Checked));
                xwriter.WriteElementString("altichange", XmlConvert.ToString(Alt_change_output_checkbox.Checked));
                xwriter.WriteElementString("soildepth", XmlConvert.ToString(Soildepth_output_checkbox.Checked));
                xwriter.WriteElementString("all_processes", XmlConvert.ToString(all_process_output_checkbox.Checked));
                xwriter.WriteElementString("waterflow", XmlConvert.ToString(water_output_checkbox.Checked));
                xwriter.WriteElementString("depressions", XmlConvert.ToString(depressions_output_checkbox.Checked));
                xwriter.WriteElementString("diagnostics", XmlConvert.ToString(diagnostic_output_checkbox.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Other_outputs");

                xwriter.WriteStartElement("Timeseries");
                xwriter.WriteElementString("total_erosion", XmlConvert.ToString(timeseries.timeseries_total_ero_check.Checked));
                xwriter.WriteElementString("total_deposition", XmlConvert.ToString(timeseries.timeseries_total_dep_check.Checked));
                xwriter.WriteElementString("net_erosion", XmlConvert.ToString(timeseries.timeseries_net_ero_check.Checked));
                xwriter.WriteElementString("sed_export", XmlConvert.ToString(timeseries.timeseries_sedexport_checkbox.Checked));
                xwriter.WriteElementString("SDR", XmlConvert.ToString(timeseries.timeseries_SDR_check.Checked));
                xwriter.WriteElementString("total_average_alt", XmlConvert.ToString(timeseries.timeseries_total_average_alt_check.Checked));
                xwriter.WriteElementString("total_rain", XmlConvert.ToString(timeseries.timeseries_total_rain_check.Checked));
                xwriter.WriteElementString("total_infil", XmlConvert.ToString(timeseries.timeseries_total_infil_check.Checked));
                xwriter.WriteElementString("total_evap", XmlConvert.ToString(timeseries.timeseries_total_evap_check.Checked));
                xwriter.WriteElementString("total_outflow", XmlConvert.ToString(timeseries.timeseries_total_outflow_check.Checked));
                xwriter.WriteElementString("wet_cells", XmlConvert.ToString(timeseries.timeseries_number_waterflow_check.Checked));
                xwriter.WriteElementString("eroded_cells", XmlConvert.ToString(timeseries.timeseries_number_erosion_check.Checked));
                xwriter.WriteElementString("deposited_cells", XmlConvert.ToString(timeseries.timeseries_number_dep_check.Checked));
                xwriter.WriteElementString("outflow_cells", XmlConvert.ToString(timeseries.timeseries_outflow_cells_checkbox.Checked));
                xwriter.WriteElementString("cell_altitude", XmlConvert.ToString(timeseries.timeseries_cell_altitude_check.Checked));
                xwriter.WriteElementString("cell_waterflow", XmlConvert.ToString(timeseries.timeseries_cell_waterflow_check.Checked));
                xwriter.WriteElementString("waterflow_threshold", timeseries.timeseries_textbox_waterflow_threshold.Text);
                xwriter.WriteElementString("erosion_threshold", timeseries.timeseries_textbox_erosion_threshold.Text);
                xwriter.WriteElementString("deposition_threshold", timeseries.timeseries_textbox_deposition_threshold.Text);
                xwriter.WriteElementString("cell_row", timeseries.timeseries_textbox_cell_row.Text);
                xwriter.WriteElementString("cell_col", timeseries.timeseries_textbox_cell_col.Text);
                xwriter.WriteElementString("total_OM_input", XmlConvert.ToString(timeseries.total_OM_input_checkbox.Checked));
                xwriter.WriteElementString("total_average_soil_thickness", XmlConvert.ToString(timeseries.total_average_soilthickness_checkbox.Checked));
                xwriter.WriteElementString("total_phys_weath", XmlConvert.ToString(timeseries.total_phys_weath_checkbox.Checked));
                xwriter.WriteElementString("total_chem_weath", XmlConvert.ToString(timeseries.total_chem_weath_checkbox.Checked));
                xwriter.WriteElementString("total_fine_formed", XmlConvert.ToString(timeseries.total_fine_formed_checkbox.Checked));
                xwriter.WriteElementString("total_fine_eluviated", XmlConvert.ToString(timeseries.total_fine_eluviated_checkbox.Checked));
                xwriter.WriteElementString("total_mass_bioturbed", XmlConvert.ToString(timeseries.total_mass_bioturbed_checkbox.Checked));
                xwriter.WriteElementString("timeseries_soil_depth", XmlConvert.ToString(timeseries.timeseries_soil_depth_checkbox.Checked));
                xwriter.WriteElementString("timeseries_soil_mass", XmlConvert.ToString(timeseries.timeseries_soil_mass_checkbox.Checked));
                xwriter.WriteElementString("timeseries_coarser", XmlConvert.ToString(timeseries.timeseries_coarser_checkbox.Checked));
                xwriter.WriteElementString("timeseries_thicker", XmlConvert.ToString(timeseries.timeseries_number_soil_thicker_checkbox.Checked));
                xwriter.WriteElementString("soil_cell", timeseries.timeseries_soil_cell_col.Text);
                xwriter.WriteElementString("soil_col", timeseries.timeseries_soil_cell_row.Text);
                xwriter.WriteElementString("coarser_fraction", timeseries.timeseries_soil_coarser_fraction_textbox.Text);
                xwriter.WriteElementString("thicker_threshold", timeseries.timeseries_soil_thicker_textbox.Text);
                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Profiles");
                xwriter.WriteElementString("profile1_row", XmlConvert.ToString(profile.radio_pro1_row.Checked));
                xwriter.WriteElementString("profile1_col", XmlConvert.ToString(profile.radio_pro1_col.Checked));
                xwriter.WriteElementString("profile2_row", XmlConvert.ToString(profile.radio_pro2_row.Checked));
                xwriter.WriteElementString("profile2_col", XmlConvert.ToString(profile.radio_pro2_col.Checked));
                xwriter.WriteElementString("profile3_row", XmlConvert.ToString(profile.radio_pro3_row.Checked));
                xwriter.WriteElementString("profile3_col", XmlConvert.ToString(profile.radio_pro3_col.Checked));
                xwriter.WriteElementString("p1_number", profile.p1_row_col_box.Text);
                xwriter.WriteElementString("p2_number", profile.p2_row_col_box.Text);
                xwriter.WriteElementString("p3_number", profile.p3_row_col_box.Text);
                xwriter.WriteElementString("p1_waterflow", XmlConvert.ToString(profile.check_waterflow_profile1.Checked));
                xwriter.WriteElementString("p1_altitude", XmlConvert.ToString(profile.check_altitude_profile1.Checked));
                xwriter.WriteElementString("p2_waterflow", XmlConvert.ToString(profile.check_waterflow_profile2.Checked));
                xwriter.WriteElementString("p2_altitude", XmlConvert.ToString(profile.check_altitude_profile2.Checked));
                xwriter.WriteElementString("p3_waterflow", XmlConvert.ToString(profile.check_waterflow_profile3.Checked));
                xwriter.WriteElementString("p3_altitude", XmlConvert.ToString(profile.check_altitude_profile3.Checked));
                xwriter.WriteEndElement();

                xwriter.WriteEndElement();

                xwriter.WriteStartElement("Soilfractions");
                xwriter.WriteElementString("coarsefrac", soildata.coarsebox.Text);
                xwriter.WriteElementString("sandfrac", soildata.sandbox.Text);
                xwriter.WriteElementString("siltfrac", soildata.siltbox.Text);
                xwriter.WriteElementString("clayfrac", soildata.claybox.Text);
                xwriter.WriteElementString("fclayfrac", soildata.fineclaybox.Text);
                xwriter.WriteEndElement();
                //End the document
                xwriter.WriteEndDocument();

                //Flush the xml document to the underlying stream and
                //close the underlying stream. The data will not be
                //written out to the stream until either the Flush()
                //method is called or the Close() method is called.
                xwriter.Close();

                this.Text = basetext + " (" + Path.GetFileName(cfgname) + ")";
            }
        }

        private void read_soil_elevation_distance_from_output(int time, string dir)
        {
            // read latest output and start calculating from there
            dir = dir + "\\";

            initialise_once();

            filename = dir + "0_" + time + "_out_dtm.asc";
            read_double(filename, dtm);
            Debug.WriteLine("read dtm");

            filename = dir + "0_" + time + "_out_soildepth.asc";
            read_double(filename, soildepth_m);
            Debug.WriteLine("read soildepth");

            filename = dir + "0_" + time + "_out_change.asc";
            read_double(filename, dtmchange_m);
            Debug.WriteLine("read dtm change");

            if (Water_ero_checkbox.Checked)
            {
                filename = dir + "0_" + time + "_out_water_erosion.asc";
                read_double(filename, sum_water_erosion);
                Debug.WriteLine("read water erosion");
            }

            if (Tillage_checkbox.Checked)
            {
                filename = dir + "0_" + time + "_out_tillage.asc";
                read_double(filename, sum_tillage);
                Debug.WriteLine("read sum_tillage");
            }

            if (Creep_Checkbox.Checked)
            {
                filename = dir + "0_" + time + "_out_creep.asc";
                read_double(filename, creep);
                Debug.WriteLine("read creep");
            }

            if (treefall_checkbox.Checked)
            {
                filename = dir + "0_" + time + "_out_dz_treefall.asc";
                read_double(filename, dz_treefall);
                Debug.WriteLine("read dz_treefall");
            }

            filename = dir + "0_" + time + "_out_dz_soil.asc";
            read_double(filename, dz_soil);
            Debug.WriteLine("read sum_dz_soil");

            // SOIL INFORMATION
            // reset old info
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    for (int lay = 0; lay < max_soil_layers; lay++)
                    {
                        texture_kg[row, col, lay, 0] = 0;
                        texture_kg[row, col, lay, 1] = 0;
                        texture_kg[row, col, lay, 2] = 0;
                        texture_kg[row, col, lay, 3] = 0;
                        texture_kg[row, col, lay, 4] = 0;
                        young_SOM_kg[row, col, lay] = 0;
                        old_SOM_kg[row, col, lay] = 0;
                        layerthickness_m[row, col, lay] = 0;
                        bulkdensity[row, col, lay] = 0;

                        if (CN_checkbox.Checked)
                        {
                            for (int cn = 0; cn < n_cosmo; cn++)
                            {
                                CN_atoms_cm2[row, col, lay, cn] = 0;
                            }
                        }
                        if (OSL_checkbox.Checked)
                        {
                            OSL_grainages[row, col, lay] = new int[0];
                            OSL_depositionages[row, col, lay] = new int[0];
                            OSL_surfacedcount[row, col, lay] = new int[0];
                        }
                    }
                }
            }

            using (var reader = new StreamReader(dir + "\\" + run_number + "_" + time + "_out_allsoils.csv"))
            {
                int row, col, lay;
                // discard first line (header)    
                var line = reader.ReadLine();
                var values = line.Split(',');

                while (!reader.EndOfStream)
                {
                    line = reader.ReadLine();
                    values = line.Split(',');

                    row = Convert.ToInt32(values[0]);
                    col = Convert.ToInt32(values[1]);
                    lay = Convert.ToInt32(values[3]);

                    texture_kg[row, col, lay, 0] = Convert.ToDouble(values[8]); //coarse
                    texture_kg[row, col, lay, 1] = Convert.ToDouble(values[9]); // sand
                    texture_kg[row, col, lay, 2] = Convert.ToDouble(values[10]); // silt
                    texture_kg[row, col, lay, 3] = Convert.ToDouble(values[11]); // clay
                    texture_kg[row, col, lay, 4] = Convert.ToDouble(values[12]); // fine clay
                    young_SOM_kg[row, col, lay] = Convert.ToDouble(values[13]); // young SOM
                    old_SOM_kg[row, col, lay] = Convert.ToDouble(values[14]); // old SOM
                    layerthickness_m[row, col, lay] = Convert.ToDouble(values[5]); // thickness
                    bulkdensity[row, col, lay] = Convert.ToDouble(values[23]); // bulk density

                    if (CN_checkbox.Checked)
                    {
                        CN_atoms_cm2[row, col, lay, 0] = Convert.ToDouble(values[24]);
                        CN_atoms_cm2[row, col, lay, 1] = Convert.ToDouble(values[25]);
                        CN_atoms_cm2[row, col, lay, 2] = Convert.ToDouble(values[27]);
                        CN_atoms_cm2[row, col, lay, 3] = Convert.ToDouble(values[28]);
                    }
                }
            }

            // OSL ages
            using (var reader = new StreamReader(dir + "\\" + run_number + "_" + time + "_out_OSL_ages.csv"))
            {
                int row = -1, col = -1, lay = -1, row_ref = -1, col_ref = -1, lay_ref = -1;

                var grainages_temp = new List<int>();
                var depositionages_temp = new List<int>();
                var countsurfaced_temp = new List<int>();

                var line = reader.ReadLine();
                var values = line.Split(',');

                while (!reader.EndOfStream)
                {
                    // discard first line (header)    
                    line = reader.ReadLine();
                    values = line.Split(',');

                    row = Convert.ToInt32(values[0]);
                    col = Convert.ToInt32(values[1]);
                    lay = Convert.ToInt32(values[2]);

                    if(row != row_ref | col != col_ref | lay != lay_ref)
                    { // write stored grain properties to the files, change to new row col and lay in the output, reset the strings
                        if (row_ref >= 0)
                        {
                            OSL_grainages[row_ref, col_ref, lay_ref] = grainages_temp.ToArray();
                            OSL_depositionages[row_ref, col_ref, lay_ref] = depositionages_temp.ToArray();
                            OSL_surfacedcount[row_ref, col_ref, lay_ref] = countsurfaced_temp.ToArray();
                        }

                        grainages_temp = new List<int>();
                        depositionages_temp = new List<int>();
                        countsurfaced_temp = new List<int>();

                        row_ref = row;
                        col_ref = col;
                        lay_ref = lay;
                    }

                    grainages_temp.Add(Convert.ToInt32(values[3]));
                    depositionages_temp.Add(Convert.ToInt32(values[4]));
                    countsurfaced_temp.Add(Convert.ToInt32(values[5]));
                }
                // write the last data into the OSL age arrays, that were not captured in the while loop
                OSL_grainages[row, col, lay] = grainages_temp.ToArray();
                OSL_depositionages[row, col, lay] = depositionages_temp.ToArray();
                OSL_surfacedcount[row, col, lay] = countsurfaced_temp.ToArray();

            }
        }

            #endregion

            #region depression code

            void findsinks()
        {
            /*Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "findtrouble has been entered";
            }, CancellationToken.None, TaskCreationOptions.None, guiThread); */
            int number, twoequals = 0, threeequals = 0, moreequals = 0;
            int[] intoutlet = new int[9];
            int x;
            numsinks = 0;
            int row, col;

            for (row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        dh = 0.0; high = 0; low = 0; equal = 0; status_map[row, col] = 0; number = 0;
                        for (x = 0; x < 9; x++) { intoutlet[x] = 99; }
                        for (i = (-1); i <= 1; i++)
                        {       //make a circle around every cell  ...
                            for (j = (-1); j <= 1; j++)
                            {
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)) && dtm[row + i, col + j] != -9999)
                                { //boundaries of grid
                                    number++;
                                    dh = dtm[row, col] - dtm[row + i, col + j];
                                    if (dh < 0) { high++; intoutlet[number - 1] = -1; }     // add one to the higher-nbour-counter and add 'h' to the outlet-string
                                    if (dh > 0) { low++; intoutlet[number - 1] = 1; }       // add one to the lower-nbour-counter and add 'l' to the outlet-string
                                    if (dh == 0) { equal++; intoutlet[number - 1] = 0; }      // add one to the equal-nbour-counter and add 'e' to the outlet-string
                                                                                              //Debug.WriteLine("cell %d %d, alt=%.2f nb %d %d, alt=%.2f dh %.3f low %d, equal %d, high %d\n",row,col,dtm[row,col],row+i,col+j,dtm[row+i,col+j],dh,low,equal,high); 
                                }  //end if within boundaries
                            }  // end for j
                        } // end for i, we have considered the circle around the cell and counted higher, equal and, therefore, lower neighbours

                        if (low == 0 && intoutlet[7] != 99) { status_map[row, col] = 1; numsinks++; }       // if 0 lower cells cells are present and 8 cells in total, we have a sink
                        if (low == 8) { status_map[row, col] = -1; }       // if 8 lower cells are present, we have a top
                        if (equal == 1) { twoequals++; }        // this case is rare in real DEMs
                        if (equal == 2) { threeequals++; }      // this case is very rare in real DEMs
                        if (equal > 2) { moreequals++; }        // this case is extremely rare in real DEMs
                    } //end for nodata
                    else
                    {
                        status_map[row, col] = 3;
                    }
                }   // end for col
            }  // end for row

            /*
            last but not least we give status_map a 3 for all cells on the edge of the DEM, so we can end formation of depressions there
            */

            for (col = 0; col < nc; col++)
            {
                status_map[0, col] = 3; status_map[nr - 1, col] = 3;
            }
            for (row = 0; row < nr; row++)
            {
                status_map[row, 0] = 3; status_map[row, nc - 1] = 3;
            }

            //reports

            //this.InfoStatusPanel.Text = "found " + numsinks + " true sinks in " + nr * nc + "  cells";
            //Debug.WriteLine("\n\n--sinks overview at t = " + t + "--");

            //if (numsinks / (nr * nc) > 0.0075) { Debug.WriteLine("this DEM contains " + numsinks + " true sinks in " + nr * nc + "  cells\n That's a lot!"); }
            //else { Debug.WriteLine("t" + t + " this DEM contains " + numsinks + " true sinks in " + nr * nc + "  cells"); }
            //Debug.WriteLine(" equals: " + twoequals / 2 + " double, " + threeequals / 3 + " triple and about " + moreequals + " larger\n");

        }

        void searchdepressions()
        {
            int z;
            //this.InfoStatusPanel.Text = "searchdepressions has been entered";
            for (int row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (int col = 0; col < nc; col++)
                {
                    depression[row, col] = 0;     // set depression to zero
                }
            }

            for (z = 0; z < numberofsinks; z++)
            {         // the maximum number of depressions is the number of sinks
                drainingoutlet_row[z, 0] = -1;
                drainingoutlet_col[z, 0] = -1;
                drainingoutlet_row[z, 1] = -1;
                drainingoutlet_col[z, 1] = -1;
                drainingoutlet_row[z, 2] = -1;
                drainingoutlet_col[z, 2] = -1;
                drainingoutlet_row[z, 3] = -1;
                drainingoutlet_col[z, 3] = -1;
                drainingoutlet_row[z, 4] = -1;
                drainingoutlet_col[z, 4] = -1;
                depressionlevel[z] = 0;
                depressionsize[z] = 0;
                depressionvolume_m[z] = 0;
                iloedge[z] = 0;
                jloedge[z] = 0;
                iupedge[z] = 0;
                jupedge[z] = 0;
            }

            totaldepressions = 0; totaldepressionsize = 0; maxsize = 0; totaldepressionvolume = 0; largestdepression = -1;
            depressionnumber = 0;
            for (int row = 0; row < nr; row++)
            {        //visit all cells in the DEM and  ...
                for (int col = 0; col < nc; col++)
                {
                    if (status_map[row, col] == 1 && depression[row, col] == 0)
                    {   // sink  -NODATA cells are never sinks, no need to exclude them explicitly here
                        numberoflowestneighbours = 0;
                        for (lowestneighbourcounter = 0; lowestneighbourcounter < maxlowestnbs; lowestneighbourcounter++)
                        {
                            rowlowestnb[lowestneighbourcounter] = -1;
                            collowestnb[lowestneighbourcounter] = -1;
                        }
                        depressionnumber++;                 // so depressionnumber 0 is not used, neither is depression[r,c] = 0
                        if (depressionnumber == 1153000) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }
                        //Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " is initially " + depressionvolume[depressionnumber]); 
                        totaldepressions++;
                        depressionlevel[depressionnumber] = dtm[row, col];
                        iloedge[depressionnumber] = row - 1;
                        iupedge[depressionnumber] = row + 1;
                        jloedge[depressionnumber] = col - 1;
                        jupedge[depressionnumber] = col + 1;
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" Sink " + depressionnumber + " located: " + row + "," + col + " alt " + dtm[row, col]);
                            Debug.WriteLine(" edges : " + iloedge[depressionnumber] + ", " + iupedge[depressionnumber] + ", " + jloedge[depressionnumber] + ", " + jupedge[depressionnumber]);
                        }
                        depressionsize[depressionnumber] = 1;
                        depression[row, col] = depressionnumber;
                        if (depression[row, col] < 0)
                        {
                            MessageBox.Show("Depression error at row " + row + " col " + col + " dep " + depression[row, col]);
                        }
                        iupradius = 1; jupradius = 1; iloradius = 1; jloradius = 1;
                        depressionready = 0; depressiondrainsout = 0;
                        while (depressionready != 1)
                        {
                            if (depressionnumber == 1153000) { diagnostic_mode = 1; }
                            minaltidiff = -99999999; int already_lower_than_lakelevel = 0;
                            for (i = (-1 * iloradius); i <= iupradius; i++)
                            {       //make a circle around the current cell that is so large that it covers all neighbours of all cells currently in the depression
                                for (j = (-1 * jloradius); j <= jupradius; j++)
                                {
                                    if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // in this case, we DO want to find cells with NODATA, because these are valid end-points of lakes
                                    {
                                        //if (diagnostic_mode == 1) { Debug.WriteLine("now at " + (row + i) + ", " + (col + j)); }
                                        nbismemberofdepression = 0;
                                        for (alpha = (-1); alpha <= 1; alpha++)
                                        {       // check in circle around the current cell if one of its neighbours is member of the depression
                                            for (beta = (-1); beta <= 1; beta++)
                                            {
                                                if (((row + i + alpha) >= 0) && ((row + i + alpha) < nr) && ((col + j + beta) >= 0) && ((col + j + beta) < nc) && !((alpha == 0) && (beta == 0)))
                                                {
                                                    if (depression[row + i + alpha, col + j + beta] == depressionnumber)
                                                    {   //and only if the cell is an actual neighbour of a cell that is member of the depression
                                                        nbismemberofdepression = 1;
                                                    } // end if nb = member of depression
                                                } // end if boundary
                                            }
                                        } // end for first alpha-beta circle to see if any nb = member of depression. It could have been no neighbour of the current depression but still within ilorarius, iupradius etc.
                                        if (nbismemberofdepression == 1 && depression[row + i, col + j] != depressionnumber)
                                        {   // only in case cell row+i, col+j  has a nb that is already member, we are interested in its altitude diff with depressionlevel
                                            altidiff = depressionlevel[depressionnumber] - dtm[row + i, col + j];
                                            if (diagnostic_mode == 1)
                                            {
                                                Debug.WriteLine((row + i) + ", " + (col + j) + " is neighbour of depression , altidifference " + altidiff);
                                            }
                                            if (altidiff == minaltidiff)
                                            {   //if lowest higher nb = equally high as previous lowest higher nb
                                                lowestneighbourcounter++; numberoflowestneighbours++;
                                                if (numberoflowestneighbours == maxlowestnbs) { Debug.WriteLine(" WARNING: the setting for maximum number of lowest neighbours is " + numberoflowestneighbours + " lowest nbs" + maxlowestnbs); }
                                                rowlowestnb[lowestneighbourcounter] = (row + i);
                                                collowestnb[lowestneighbourcounter] = (col + j);
                                                // in this way, we can add all equally high lowest higher neighbours to the current depression (maximum = maxlowestnbs)
                                            } //end if higher neighbour, equal as before
                                            if (altidiff > minaltidiff || dtm[row + i, col + j] < depressionlevel[depressionnumber])  // this INCLUDES nodata cells bordering the lake!!
                                            {   //het hoogteverschil met deze buur telt alleen als minder hoog dan vorige buren OF lager dan meerniveau 
                                                minaltidiff = altidiff;
                                                if (dtm[row + i, col + j] < depressionlevel[depressionnumber] && already_lower_than_lakelevel == 1)
                                                {  // the new lowest neighbour is lower than lakelevel!! 
                                                   // We want to know all lowest nbs that are lower than lakelevel, so we do not zero the rowlowestnb 
                                                   // and colllowestnb arrays
                                                    lowestneighbourcounter++; numberoflowestneighbours++;
                                                    rowlowestnb[lowestneighbourcounter] = (row + i);
                                                    collowestnb[lowestneighbourcounter] = (col + j);
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" found another neighbour that is lower than lakelevel "); }
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" lower neighbour that is lower than lakelevel: " + rowlowestnb[lowestneighbourcounter] + ", " + collowestnb[lowestneighbourcounter] + " , " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]); }
                                                }
                                                else  // the new lowest neighbour is higher than lakelevel or is the first lowest nb that is lower than lakelevel
                                                {
                                                    if (dtm[row + i, col + j] < depressionlevel[depressionnumber]) { already_lower_than_lakelevel = 1; }
                                                    for (lowestneighbourcounter = 0; lowestneighbourcounter < maxlowestnbs; lowestneighbourcounter++)
                                                    {
                                                        rowlowestnb[lowestneighbourcounter] = -1; collowestnb[lowestneighbourcounter] = -1;
                                                    } //end:  for all lowestneighbours that we had before, the rowlowestnb and collowestnb arrays have been zeroed
                                                    lowestneighbourcounter = 0; numberoflowestneighbours = 1;
                                                    rowlowestnb[0] = (row + i); collowestnb[0] = (col + j);
                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" higher neighbour that is lower than previous higher nbs: " + rowlowestnb[0] + ", " + collowestnb[0] + " , " + dtm[rowlowestnb[0], collowestnb[0]]); }
                                                }
                                            } //end if higher neighbour but lower than before
                                        } //end if nbismemberofdepression

                                    } // end if boundary
                                }
                            } // double end for circle with possibly extended radius around the sink, alpha - beta circle . We now know what is/are the lowest higher neighbours

                            if (diagnostic_mode == 1)
                            {
                                for (lowestneighbourcounter = 0; lowestneighbourcounter < numberoflowestneighbours; lowestneighbourcounter++)
                                {
                                    Debug.WriteLine(rowlowestnb[lowestneighbourcounter] + " " + collowestnb[lowestneighbourcounter] + " is one of the " + numberoflowestneighbours + " lowest neighbours of depression " + depressionnumber + ". Its altitude is " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]);
                                }
                            }

                            int outletfound = 0; int numberofoutlets = 0; int outletnumber = 0;

                            for (lowestneighbourcounter = 0; lowestneighbourcounter < numberoflowestneighbours; lowestneighbourcounter++)
                            {
                                if (rowlowestnb[lowestneighbourcounter] >= iupedge[depressionnumber]) { iupedge[depressionnumber] = rowlowestnb[lowestneighbourcounter] + 1; }
                                if (rowlowestnb[lowestneighbourcounter] <= iloedge[depressionnumber]) { iloedge[depressionnumber] = rowlowestnb[lowestneighbourcounter] - 1; }
                                if (collowestnb[lowestneighbourcounter] >= jupedge[depressionnumber]) { jupedge[depressionnumber] = collowestnb[lowestneighbourcounter] + 1; }
                                if (collowestnb[lowestneighbourcounter] <= jloedge[depressionnumber]) { jloedge[depressionnumber] = collowestnb[lowestneighbourcounter] - 1; }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" minaltidiff = " + minaltidiff + "; depression " + depressionnumber + " row " + rowlowestnb[lowestneighbourcounter] + " col " + collowestnb[lowestneighbourcounter] + " alt " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + " is lower than depressionlevel " + depressionlevel[depressionnumber]); }

                                if (minaltidiff <= 0.0)
                                { // if the cell is higher than depressionlevel
                                  // it can either be a cell of another depression

                                    if (diagnostic_mode == 1) { Debug.WriteLine(rowlowestnb[lowestneighbourcounter] + "," + collowestnb[lowestneighbourcounter] + " is member of depression " + depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]]); }
                                    if (depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] != 0 && depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] != depressionnumber)
                                    {  // then we have touched upon a depression that was previously analysed
                                       //status_map[rowlowestnb[lowestneighbourcounter],collowestnb[lowestneighbourcounter]] = 0;
                                        otherdepressionsize = 0;
                                        otherdepression = depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        if (t > 1000000) { diagnostic_mode = 1; }
                                        totaldepressions--;
                                        totaldepressionvolume -= depressionvolume_m[otherdepression];
                                        for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                                        {
                                            drainingoutlet_row[otherdepression, outletcounter] = -1;
                                            drainingoutlet_col[otherdepression, outletcounter] = -1;
                                        }
                                        depressionvolume_m[depressionnumber] += depressionvolume_m[otherdepression];
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " was increased to " + depressionvolume[depressionnumber] + " with " + depressionvolume[otherdepression] + " of depression " + otherdepression); }
                                        depressionvolume_m[depressionnumber] += (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]));  //
                                                                                                                                                                                                                                           //if (diagnostic_mode == 1) { Debug.WriteLine(" added " + depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]) + " to depressionvolume of depression " + depressionnumber + ". Dtm " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + ", depressionlevel " + depressionlevel[depressionnumber]); }
                                        depressionvolume_m[otherdepression] = 0;
                                        depressionlevel[depressionnumber] = dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" first: ilo = " + iloradius + " , iup = " + iupradius + " , jlo = " + jloradius + " , jup = " + jupradius + "  around sink " + row + " " + col); }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" depression " + otherdepression + " : iloedge " + iloedge[otherdepression] + " , iupedge " + iupedge[otherdepression] + " , jloedge " + jloedge[otherdepression] + " , jupedge " + jupedge[otherdepression]); }
                                        if (jloedge[otherdepression] < (col - jloradius)) { jloradius = Math.Abs(jloedge[otherdepression] - col) + 1; jloedge[depressionnumber] = col - jloradius; }     // we enlarge the area around the sink of the current depression that is to be checked
                                        if (iloedge[otherdepression] < (row - iloradius)) { iloradius = Math.Abs(iloedge[otherdepression] - row) + 1; iloedge[depressionnumber] = row - iloradius; }     // it now includes the complete area of the depression that has been touched upon
                                        if (jupedge[otherdepression] > (col + jupradius)) { jupradius = Math.Abs(jupedge[otherdepression] - col) + 1; jupedge[depressionnumber] = col + jupradius; }
                                        if (iupedge[otherdepression] > (row + iupradius)) { iupradius = Math.Abs(iupedge[otherdepression] - row) + 1; iupedge[depressionnumber] = row + iupradius; }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" now: ilo = " + iloradius + " , iup = " + iupradius + " , jlo = " + jloradius + " , jup = " + jupradius + " around sink " + row + "  " + col); }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" begonnen met gebied om sink om cellen uit ander meer om te nummeren"); }
                                        for (alpha = (-1 * iloradius); alpha <= iupradius; alpha++)
                                        {       // move around in this square and change depressionnumber
                                            for (beta = (-1 * jloradius); beta <= jupradius; beta++)
                                            {
                                                if (((row + alpha) >= 0) && ((row + alpha) < nr) &&   // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                    ((col + beta) >= 0) && ((col + beta) < nc) && !((alpha == 0) && (beta == 0)) && dtm[row + alpha, col + beta] != -9999)
                                                {
                                                    if (depression[row + alpha, col + beta] == otherdepression)
                                                    {
                                                        depression[row + alpha, col + beta] = depressionnumber;
                                                        otherdepressionsize++;
                                                        if (diagnostic_mode == 1) { Debug.WriteLine(" moved cell " + (row + alpha) + " , " + (col + beta) + "(" + dtm[row + alpha, col + beta] + ") from depression " + otherdepression + " to depression " + depressionnumber + " "); }
                                                    } // end if cell belonged to other depression
                                                }
                                            }
                                        } // double end for second alpha-beta square : around the sink to change depressionnumber of previously checked depression
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" All " + otherdepressionsize + "  cells of depression " + otherdepression + "  were added to depression " + depressionnumber + "  (prvsly " + depressionsize[depressionnumber] + " ), level now " + depressionlevel[depressionnumber]); }
                                        depressionsize[depressionnumber] += otherdepressionsize;
                                        depressionsize[otherdepression] = 0;
                                        totaldepressionsize -= otherdepressionsize;
                                        if (diagnostic_mode == 1) { Debug.WriteLine("B totaldepressionsize " + totaldepressionsize + " , otherdepressionnsize " + otherdepression + "  = " + otherdepressionsize + "  depressionnumber " + depressionnumber + " "); }

                                        // it is theoretically possible that the outlet that connects the 'depression' and the 'otherdepression' , drains to a third side. In that case, the new, combined depression
                                        // should be declared ready after added 'otherdepression' to 'depression' ...

                                        for (alpha = (-1); alpha <= 1; alpha++)
                                        {
                                            for (beta = -1; beta <= 1; beta++)
                                            {
                                                if (((rowlowestnb[lowestneighbourcounter] + alpha) >= 0) && ((rowlowestnb[lowestneighbourcounter] + alpha) < nr) &&
                                                    ((collowestnb[lowestneighbourcounter] + beta) >= 0) && ((collowestnb[lowestneighbourcounter] + beta) < nc) &&
                                                    !((alpha == 0) && (beta == 0)) && dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != -9999)
                                                {  // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                    if (depression[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != depressionnumber)
                                                    {
                                                        if (dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] < depressionlevel[depressionnumber])
                                                        {
                                                            depressionready = 1;
                                                            drainingoutlet_row[depressionnumber, 0] = rowlowestnb[lowestneighbourcounter];
                                                            drainingoutlet_col[depressionnumber, 0] = collowestnb[lowestneighbourcounter];
                                                            status_map[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] = 2;
                                                            if (diagnostic_mode == 1)
                                                            {
                                                                Debug.WriteLine(" depression " + depressionnumber + " drains to a third side and is ready ");
                                                                //displayonscreen(rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta);
                                                            }
                                                        } // end if lower than outlet = depressionlevel
                                                    }  // end if depression != depression
                                                } // end if boundaries
                                            } // end for beta
                                        } // end for alpha
                                    }  // end if touched another depression with lowest nb

                                    //or it can be any other non-depression cell

                                    else
                                    {      // so we did not touch another depression with our lowest nb , but it was a higher or equally high nb so the depression is not yet ready
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" this lowest neighbour: second option: no depression "); }
                                        depression[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] = depressionnumber;
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" depressionvolume of depression " + depressionnumber + " is " + depressionvolume_m[depressionnumber]); }
                                        depressionvolume_m[depressionnumber] += (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber]));  // add the amount of water added to the surface already part of depression
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" added " + (depressionsize[depressionnumber] * (dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] - depressionlevel[depressionnumber])) + " to depressionvolume of depression " + depressionnumber + ". depressionsize: " + depressionsize[depressionnumber] + ", dtm %6.6f, depressionlevel " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]], depressionlevel[depressionnumber]); }
                                        depressionsize[depressionnumber]++;
                                        depressionlevel[depressionnumber] = dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]];
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" added " + rowlowestnb[lowestneighbourcounter] + ", " + collowestnb[lowestneighbourcounter] + "  with level " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + " to depression " + depressionnumber + " , size now " + depressionsize[depressionnumber] + " "); }
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" lowest neighbour of depression " + depressionnumber + "  is " + rowlowestnb[lowestneighbourcounter] + " , " + collowestnb[lowestneighbourcounter] + " ," + depressionlevel[depressionnumber] + "  "); }
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" depressionlevel for this depression is currently: " + depressionlevel[depressionnumber]); }  // laagste buur is nog niet betrokken bij een ander meer

                                        if (status_map[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] == 3)
                                        { // then this depression drains out of the DEM...
                                            depressionready = 1;
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" depression " + depressionnumber + " drains out of the DEM and is ready "); }
                                            depressiondrainsout = 1;
                                            drainingoutlet_row[depressionnumber, 0] = rowlowestnb[lowestneighbourcounter];
                                            drainingoutlet_col[depressionnumber, 0] = collowestnb[lowestneighbourcounter];
                                        }
                                        else
                                        { // depression does not drain out of DEM
                                            if ((rowlowestnb[lowestneighbourcounter] - row) == iupradius) { iupradius++; }     //in that case we will now change searchradius
                                            if ((row - rowlowestnb[lowestneighbourcounter]) == iloradius) { iloradius++; }
                                            if ((collowestnb[lowestneighbourcounter] - col) == jupradius) { jupradius++; }
                                            if ((col - collowestnb[lowestneighbourcounter]) == jloradius) { jloradius++; }
                                        } // end else
                                    } //end else
                                } // end if cell was higher than depressionlevel

                                else
                                {  // apparently it was lower than depressionlevel
                                   //Debug.WriteLine(" found lower neighbour " + rowlowestnb[lowestneighbourcounter] + "  " + collowestnb[lowestneighbourcounter] + "  alt " + dtm[rowlowestnb[lowestneighbourcounter], collowestnb[lowestneighbourcounter]] + "  for depression " + depressionnumber + "   level " + depressionlevel[depressionnumber] + " "); 
                                    outletfound = 1;
                                    // find for this cell, that should not be part of the depression, the necessarily present depression nb @ depressionlevel and call it a outlet
                                    for (alpha = (-1); alpha <= 1; alpha++)
                                    {
                                        for (beta = -1; beta <= 1; beta++)
                                        {
                                            if (((rowlowestnb[lowestneighbourcounter] + alpha) >= 0) && ((rowlowestnb[lowestneighbourcounter] + alpha) < nr) &&
                                                    ((collowestnb[lowestneighbourcounter] + beta) >= 0) && ((collowestnb[lowestneighbourcounter] + beta) < nc) &&
                                                    !((alpha == 0) && (beta == 0)) && dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] != -9999)
                                            {  // insofar that the circle is within the boundaries, excluding the centre cell itself
                                                if (depression[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] == depressionnumber)
                                                {
                                                    if (dtm[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] == depressionlevel[depressionnumber])
                                                    {
                                                        //Debug.WriteLine(" At lower cell  " + rowlowestnb[lowestneighbourcounter] + " " + collowestnb[lowestneighbourcounter] + ", looking back at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta));
                                                        if (drainingoutlet_col[depressionnumber, outletnumber] != -1) //ArT is outletnumber put to zero before here somewhere?
                                                        {
                                                            // Then we found an earlier outlet (somewhere), and we have to define an extra one here, IF that earlier one was not this one.      
                                                            bool this_is_an_earlier_outlet = false;
                                                            for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                                                            {
                                                                if (rowlowestnb[lowestneighbourcounter] + alpha == drainingoutlet_row[depressionnumber, outletcounter] && collowestnb[lowestneighbourcounter] + beta == drainingoutlet_col[depressionnumber, outletcounter])
                                                                {
                                                                    this_is_an_earlier_outlet = true;
                                                                    //Debug.WriteLine(" A prior outlet definition for depression " + depressionnumber + " exists at " + drainingoutlet_row[depressionnumber, outletcounter] + " " + drainingoutlet_col[depressionnumber, outletcounter] + " (" + (lowestneighbourcounter + 1) + "/" + numberoflowestneighbours + ")");
                                                                }
                                                            }
                                                            if (this_is_an_earlier_outlet == false)
                                                            {
                                                                //Debug.WriteLine(" A new outlet was found for depression " + depressionnumber + " at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta) + " (" + (lowestneighbourcounter + 1) + "/" + numberoflowestneighbours + ")");
                                                                outletnumber++;
                                                                numberofoutlets++;
                                                                if (outletnumber > 4)
                                                                {
                                                                    //displayonscreen(drainingoutlet_row[depressionnumber, 1], drainingoutlet_col[depressionnumber, 1]);
                                                                    if (diagnostic_mode == 1) { Debug.WriteLine(" Warning: LORICA seeks to define more than five outlets for depression " + depressionnumber + ". This request is denied"); }
                                                                    outletnumber--; numberofoutlets--;
                                                                }
                                                                else
                                                                {
                                                                    drainingoutlet_row[depressionnumber, outletnumber] = rowlowestnb[lowestneighbourcounter] + alpha;
                                                                    drainingoutlet_col[depressionnumber, outletnumber] = collowestnb[lowestneighbourcounter] + beta;
                                                                    status_map[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] = 2;
                                                                    //Debug.WriteLine(" made " + (rowlowestnb[lowestneighbourcounter] + alpha) + "  " + (collowestnb[lowestneighbourcounter] + beta) + "  the nr " + outletnumber + " outlet for depression " + depressionnumber + " ");
                                                                }
                                                            }

                                                        }
                                                        else  // then this is the first outlet, and we will define it as such
                                                        {
                                                            //Debug.WriteLine(" First definition of outlet for depression " + depressionnumber + " at " + (rowlowestnb[lowestneighbourcounter] + alpha) + " " + (collowestnb[lowestneighbourcounter] + beta) + " (" + (lowestneighbourcounter+1) + "/" + numberoflowestneighbours + ")");
                                                            if (outletnumber > 4)
                                                            {
                                                                //displayonscreen(drainingoutlet_row[depressionnumber, 1], drainingoutlet_col[depressionnumber, 1]);
                                                                if (diagnostic_mode == 1) { Debug.WriteLine(" Warning: LORICA seeks to define more than five outlets for depression " + depressionnumber + ". This request is denied"); }
                                                                outletnumber--; numberofoutlets--;
                                                            }
                                                            else
                                                            {
                                                                drainingoutlet_row[depressionnumber, outletnumber] = rowlowestnb[lowestneighbourcounter] + alpha;
                                                                drainingoutlet_col[depressionnumber, outletnumber] = collowestnb[lowestneighbourcounter] + beta;
                                                                status_map[rowlowestnb[lowestneighbourcounter] + alpha, collowestnb[lowestneighbourcounter] + beta] = 2;
                                                                //Debug.WriteLine(" made " + (rowlowestnb[lowestneighbourcounter] + alpha) + "  " + (collowestnb[lowestneighbourcounter] + beta) + "  the nr " + outletnumber + " outlet for depression " + depressionnumber + " ");
                                                            }
                                                        }

                                                    } // end if dtm = depressionlevel
                                                } // end if depression = depressionnumber
                                            } // end if bnd
                                        } // end for beta
                                    } // end for alpha
                                } // end else
                            } //end for all lowestneighbours
                              // if outlet(s) defined ==> depressionready
                            if (outletfound == 1) { depressionready = 1; }
                        } // end while depressionready != 1

                        //if (depressionnumber == 180) {diagnostic_mode = 1;}
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" depression " + depressionnumber + "  (" + depressionlevel[depressionnumber] + "  m) is ready and contains " + depressionsize[depressionnumber] + "  cells. Volume = " + depressionvolume_m[depressionnumber] + " ");
                            if (depressiondrainsout == 1) { Debug.WriteLine(" depression " + depressionnumber + "  (" + depressionlevel[depressionnumber] + "  m) drains outside the DEM "); }
                            minimaps(row, col);
                        }
                        totaldepressionsize += depressionsize[depressionnumber];
                        totaldepressionvolume += depressionvolume_m[depressionnumber];
                        if (maxsize < depressionsize[depressionnumber]) { maxsize = depressionsize[depressionnumber]; largestdepression = depressionnumber; }
                        if (maxdepressionnumber < depressionnumber) { maxdepressionnumber = depressionnumber; }
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine(" Defined depression " + depressionnumber + ". Now size " + depressionsize[depressionnumber] + " and volume " + depressionvolume_m[depressionnumber]);
                        }
                    } // end if sink
                      //Debug.WriteLine("now at row " + row + " and col " + col);
                }  // end for  col
            } // end for   row
            /*
            Debug.WriteLine("\n\n--depressions overview--");
            if (totaldepressions != 0)
            {
                Debug.WriteLine("found " + totaldepressions + "  depressions containing " + totaldepressionsize + "  cells, with a volume of " + totaldepressionvolume);
                Debug.WriteLine(" " + totaldepressions + " depressions with a volume of " + totaldepressionvolume);
                //Debug.WriteLine("depression " + largestdepression + "  is largest by area: " + maxsize + " cells " + depressionlevel[largestdepression] + " m " + depressionvolume[largestdepression] + "m3");
                //if (depressionvolume[largestdepression] < 0) { Debug.WriteLine("negative depressionvolume found"); }
            }
            else
            {
                Debug.WriteLine(" no depressions found ");

            } */
            //out_integer("lakes.asc",depression);
        }

        void define_fillheight_new()  //calculates where depressions must be filled how high
        {
            // when completely filling a depression, we need to know - for each constituent cell and even for its neighbours - the altitude we
            // can fill it to. Since the depression must still drain towards the outlet, we add a very small value
            // to membercells so they drain towards the outlet.
            // we cannot simply use distance_to_outlet for each member cell, since depressions can round corners....

            //this.InfoStatusPanel.Text = "def fillheight has been entered";
            //Debug.WriteLine("defining fillheight\n");
            int notyetdone, done, depressiontt;

            once_dtm_fill = 0;

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    dtmfill_A[row, col] = -1;
                } //for
            } //for

            depressiontt = 0;
            for (depressiontt = 1; depressiontt <= maxdepressionnumber; depressiontt++)
            {  // for all possible depressions

                if (depressionsize[depressiontt] > 0)
                {      // if they exist, so have not been intermediate depressions
                    dtmfill_A[drainingoutlet_row[depressiontt, 0], drainingoutlet_col[depressiontt, 0]] = depressionlevel[depressiontt];
                    if (drainingoutlet_row[depressiontt, 1] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 1], drainingoutlet_col[depressiontt, 1]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 2] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 2], drainingoutlet_col[depressiontt, 2]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 3] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 3], drainingoutlet_col[depressiontt, 3]] = depressionlevel[depressiontt]; }
                    if (drainingoutlet_row[depressiontt, 4] != -1) { dtmfill_A[drainingoutlet_row[depressiontt, 4], drainingoutlet_col[depressiontt, 4]] = depressionlevel[depressiontt]; }

                    notyetdone = 1; done = 0;
                    while (notyetdone > 0)
                    {
                        notyetdone = 0;
                        //if (diagnostic_mode == 1) { Debug.WriteLine("depressioncells depression " + depressiontt + " size " + depressionsize[depressiontt] + " " +drainingoutlet_row[depressiontt]+ " " + drainingoutlet_col[depressiontt]); }
                        //diagnostic_mode = 0;
                        for (int row = iloedge[depressiontt]; row <= iupedge[depressiontt]; row++)
                        {
                            for (int col = jloedge[depressiontt]; col <= jupedge[depressiontt]; col++)
                            {
                                if (((row) >= 0) && ((row) < nr) && ((col) >= 0) && ((col) < nc) && dtm[row, col] != -9999)
                                {  //bnd
                                    if (t > 1000000) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }
                                    if (diagnostic_mode == 1) { Debug.WriteLine("dtmfill_A of " + row + " " + col + " = " + dtmfill_A[row, col] + ", checking on behalf of depression " + depressiontt); }
                                    if (dtmfill_A[row, col] == -1 && depression[row, col] == depressiontt)
                                    {  // if this is a cell of the current depression that has not yet got a dtmfill
                                       // and remember that this is the only place where this cell could have gotten that DTMfill
                                        notyetdone++;       // then we are not yet ready
                                        if (diagnostic_mode == 1) { Debug.WriteLine(row + " " + col + ": notyetdone =  " + notyetdone); }
                                        //if (diagnostic_mode == 1) { displayonscreen(row, col); }
                                        for (int i = -1; i <= 1; i++)
                                        {      // go and see if it has a depression-nb that does have a dtmfill and that is lower than the previous possible dep-nb's dtmfill
                                            for (int j = -1; j <= 1; j++)
                                            {
                                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)) && dtm[row + i, col + j] != -9999)
                                                {  //bnd
                                                    if (depression[row + i, col + j] == depressiontt && dtmfill_A[row + i, col + j] > 0.0)
                                                    { // if it IS a depression-nb and DOES have a dtmfill
                                                        if ((i == 0 || j == 0) && (dtmfill_A[row, col] == -1 || (dtmfill_A[row, col] > dtmfill_A[row + i, col + j] + epsilon * dx)))
                                                        {
                                                            dtmfill_A[row, col] = (dtmfill_A[row + i, col + j] + epsilon * dx);
                                                        } // end if
                                                        if ((i != 0 && j != 0) && (dtmfill_A[row, col] == -1 || (dtmfill_A[row, col] > dtmfill_A[row + i, col + j] + epsilon * dx * Math.Sqrt(2))))
                                                        {
                                                            dtmfill_A[row, col] = (dtmfill_A[row + i, col + j] + epsilon * dx * Math.Sqrt(2));
                                                        } // end if
                                                    } // end if
                                                }//end if within boundaries
                                            }//end for circle (first part)
                                        }//end for circle (second part)
                                        if (dtmfill_A[row, col] > 0) { notyetdone--; done++; }
                                        //if (diagnostic_mode == 1) { Debug.WriteLine(" notyetdone =  " + notyetdone + " done = " + done); }
                                    } // end if depression
                                      //if (diagnostic_mode == 1) { Debug.WriteLine("-> " + notyetdone); }
                                } // end if bnd
                            } // end for
                        } // end for
                    } // end while
                } // end if they exist
            } //end for all possible depressions
            //Debug.WriteLine("\n--dtmfill determination finished--");
        }

        void cleardelta(int iloradius, int iupradius, int jloradius, int jupradius, int clear_row, int clear_col)   //clears a delta
        {
            int epsilon, eta;
            if (diagnostic_mode == 1) { Debug.WriteLine(" clearing delta lake " + Math.Abs(depression[clear_row, clear_col]) + " around " + clear_row + " " + clear_col); }
            for (epsilon = -(iloradius + 3); epsilon <= iupradius + 3; epsilon++)
            {
                for (eta = -(jloradius + 3); eta <= jupradius + 3; eta++)
                {
                    if (((clear_row + epsilon) >= 0) && ((clear_row + epsilon) < nr) && ((clear_col + eta) >= 0) && ((clear_col + eta) < nc))
                    { // boundaries
                        if (depression[clear_row + epsilon, clear_col + eta] < 0)
                        {
                            depression[clear_row + epsilon, clear_col + eta] = Math.Abs(depression[clear_row, clear_col]);
                            if (diagnostic_mode == 1)
                            {
                                Debug.WriteLine(" membership of delta has been cancelled for " + (clear_row + epsilon) + " " + (clear_col + eta));
                            }
                        }  // end if depression < 0
                    }   // end if boundary
                }   // end for eta
            } // end for epsilon
              //Debug.WriteLine("cleared delta\n");
        }

        void update_depression(int number)   //updates depressions when the erosion/deposition process has reached them to include cells that have been eroded to below lakelevel
        {
            /*  a.	First estimate of required sediment is fillheight  dtm for all lake cells. Test whether dz_ero_m and dz_sed_m for these cells are zero (they should be).
                b.	Starting from every lake cell, look for cells around it that are not part of the lake and had dtm above lakelevel.
                    	For such a cell, look around it for all lake-neighbours and determine the one that would yield the lowest fillheight. 
                    	Assign that fillheight to the cell, see  if its current altitude (corrected for already calculated ero and sed) is lower than fillheight.
                    	Add the difference to the sediment needed to fill the (now larger) lake.
                    	Add the cell to the lake and update the size and volume  of the lake
                c.	Continue until no more cells around the lake are lower 
                This would potentially clash with lakes that have more than two outlets. The third and later outlets would be 
                seen as lake cells and their lower neighbours on the non-lake-side would be added to the lake, leading to errors. */
            int urow = 0, ucol = 0, size = 0;
            int depressionnumber = number;
            //if (depressionnumber > 1) diagnostic_mode = 1;
            if (diagnostic_mode == 1) { Debug.WriteLine(" now updating depression " + depressionnumber); }
            depressionsum_water_m = 0;
            depressionsum_sediment_m = 0;
            depressionsum_texture_kg[0] = 0; depressionsum_texture_kg[1] = 0; depressionsum_texture_kg[2] = 0; depressionsum_texture_kg[3] = 0; depressionsum_texture_kg[4] = 0; depressionsum_YOM_kg = 0; depressionsum_OOM_kg = 0;
            needed_to_fill_depression_m = 0;

            for (urow = iloedge[depressionnumber]; urow <= iupedge[depressionnumber]; urow++)
            {
                for (ucol = jloedge[depressionnumber]; ucol <= jupedge[depressionnumber]; ucol++)
                {
                    if (((urow) >= 0) && ((urow) < nr) && ((ucol) >= 0) && ((ucol) < nc) && dtm[urow, ucol] != -9999)
                    {  //bnd
                        if (depression[urow, ucol] == depressionnumber)
                        {
                            if (only_waterflow_checkbox.Checked == false)
                            {
                                if (!(dz_ero_m[urow, ucol] == 0 && dz_sed_m[urow, ucol] == 0))
                                {
                                    Debug.WriteLine(" error in depression " + depressionnumber);
                                    // this should not happen: erosion or sedimentation into lake cells is not allowed - only the provision of those cells with sediment in transport.
                                    minimaps(urow, ucol);
                                }
                            }
                            // if they are member of the lake : add the diff between fillheight and dtm to the volume that must be filled, and add the sedintrans to what is available for filling
                            depressionsum_water_m += waterflow_m3[urow, ucol] / dx / dx;
                            if (only_waterflow_checkbox.Checked == false)
                            {
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    depressionsum_texture_kg[size] += sediment_in_transport_kg[urow, ucol, size];
                                }
                                depressionsum_OOM_kg += old_SOM_in_transport_kg[urow, ucol];
                                depressionsum_YOM_kg += young_SOM_in_transport_kg[urow, ucol];
                            }
                            needed_to_fill_depression_m += dtmfill_A[urow, ucol] - dtm[urow, ucol];
                            //if (diagnostic_mode == 1) { Debug.WriteLine(" dep_cell " + row + " " + col + " fillheight " + dtmfill_A[urow, ucol] + " dtm " + dtm[urow, ucol] + " needed now " + needed_to_fill_depression  ); }
                        }
                    }
                }
            }

            //now that we know how much kgs of every material are available for lake filling, we can calculate how much thickness [m3/m2 = m] that means.
            depressionsum_sediment_m = calc_thickness_from_mass(depressionsum_texture_kg, depressionsum_YOM_kg, depressionsum_OOM_kg);

            int updating_lake = 1;
            while (updating_lake == 1)
            {
                // while there are potential cells to be added to the lake
                updating_lake = 0;
                for (urow = iloedge[depressionnumber] - 1; urow <= iupedge[depressionnumber] + 1; urow++)
                {
                    for (ucol = jloedge[depressionnumber] - 1; ucol <= jupedge[depressionnumber] + 1; ucol++)
                    {
                        if (((urow) >= 0) && ((urow) < nr) && ((ucol) >= 0) && ((ucol) < nc) && dtm[urow, ucol] != -9999)
                        {  //bnd
                            if (depression[urow, ucol] != depressionnumber && dtm[urow, ucol] > depressionlevel[depressionnumber]) // the second part of the condition should ensure that no cells on the downstream side of outlets are added. 
                            {
                                double lowest_dtm_fill = 9999;
                                // we have now found a cell that should potentiall added to the lake - however, it should have a lake-neighbour for that to be really true. We look around to check this.
                                for (alpha = -1; alpha <= 1; alpha++)
                                {
                                    for (beta = -1; beta <= 1; beta++)
                                    {
                                        if ((urow + alpha) >= 0 && (urow + alpha) < nr && (ucol + beta) >= 0 && (ucol + beta) < nc && !((alpha) == 0 && (beta) == 0) && dtm[urow + alpha, ucol + beta] != -9999)
                                        {
                                            if ((urow != urow + alpha) && (ucol != ucol + beta)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            if (only_waterflow_checkbox.Checked == false)
                                            {
                                                if (depression[urow + alpha, ucol + beta] == depressionnumber && (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]) < (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x))
                                                // if this cell has a lake neighbour and has a current altitude lower than the fillheight resulting from that neighbour, we store that fillheight until we find the lowest fillheight resulting from any lake-nbs of this cell
                                                {
                                                    if ((dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x) < lowest_dtm_fill)
                                                    {
                                                        lowest_dtm_fill = (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x);

                                                    }
                                                }
                                            }
                                            else
                                            {
                                                if (depression[urow + alpha, ucol + beta] == depressionnumber && (dtm[urow, ucol]) < (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x))
                                                // if this cell has a lake neighbour and has a current altitude lower than the fillheight resulting from that neighbour, we store that fillheight until we find the lowest fillheight resulting from any lake-nbs of this cell
                                                {
                                                    if ((dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x) < lowest_dtm_fill)
                                                    {
                                                        lowest_dtm_fill = (dtmfill_A[urow + alpha, ucol + beta] + epsilon * d_x);

                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                // after checking, if this cell had any lake-nb and was low enough itself, it is added to the lake and the search window is enlarged.
                                if (lowest_dtm_fill < 9999)
                                {
                                    depression[urow, ucol] = depressionnumber;
                                    depressionsize[depressionnumber]++;
                                    dtmfill_A[urow, ucol] = lowest_dtm_fill;
                                    if (only_waterflow_checkbox.Checked == false)
                                    {
                                        needed_to_fill_depression_m += dtmfill_A[urow, ucol] - (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]);
                                        for (size = 0; size < n_texture_classes; size++)
                                        {
                                            sediment_in_transport_kg[urow, ucol, size] = 0;
                                        }
                                    }
                                    else { needed_to_fill_depression_m += dtmfill_A[urow, ucol] - (dtm[urow, ucol]); }
                                    updating_lake = 1;
                                    if (urow == iloedge[depressionnumber] - 1) { iloedge[depressionnumber]--; }
                                    if (urow == iupedge[depressionnumber] + 1) { iupedge[depressionnumber]++; }
                                    if (ucol == jloedge[depressionnumber] - 1) { jloedge[depressionnumber]--; }
                                    if (ucol == jupedge[depressionnumber] + 1) { jupedge[depressionnumber]++; }

                                    // setting sed in trans to 0 is required to avoid double-counting when building delta's later
                                    // no addition to depressionsum_sed or _water is required because flows from this cell have already been considered earlier, and any dz_ero_m or dz_sed_m have been considered, and sed_in_trans has arrived at the lake to be counted
                                    //if (diagnostic_mode == 1) { Debug.WriteLine(" non_dep_cell " + urow + " " + ucol + " fillheight " + dtmfill_A[urow, ucol] + " new dtm " + (dtm[urow, ucol] + dz_ero_m[urow, ucol] + dz_sed_m[urow, ucol]) + " needed now " + needed_to_fill_depression); }
                                }
                            }
                        }
                    }
                }  // end for

            } // end while
            if (diagnostic_mode == 1) { Debug.WriteLine(" Updated depression " + depressionnumber + ". Now size " + depressionsize[depressionnumber] + ", sum_water " + depressionsum_water_m + " sum_sed " + depressionsum_sediment_m + " Needed: " + needed_to_fill_depression_m); }

        }

        void fill_depression(int number, double fraction_sediment_used_for_this_dep)  // completely fills updated depressions (because enough sediment was available)
        {
            int this_depression = number;
            int fillrow = 0, size, fillcol = 0;
            //Debug.WriteLine(" now filling depression " + this_depression);
            sediment_filled_m += needed_to_fill_depression_m;

            for (fillrow = iloedge[this_depression]; fillrow <= iupedge[this_depression]; fillrow++)
            {
                for (fillcol = jloedge[this_depression]; fillcol <= jupedge[this_depression]; fillcol++)
                {
                    if (((fillrow) >= 0) && ((fillrow) < nr) && ((fillcol) >= 0) && ((fillcol) < nc) && dtm[fillrow, fillcol] != -9999)
                    {  //bnd
                        if (depression[fillrow, fillcol] == this_depression)
                        {
                            // add the actual kgs of different textures and OM to the top layer in this location: 

                            double fraction_sediment_used_for_this_cell = (dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol]) / needed_to_fill_depression_m;
                            if (fraction_sediment_used_for_this_cell > 1) { Debug.WriteLine(" dumping too much soil into lake"); }
                            if (fraction_sediment_used_for_this_cell < 0) { Debug.WriteLine(" dumping negative soil into lake"); }
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                texture_kg[fillrow, fillcol, 0, size] += fraction_sediment_used_for_this_dep * fraction_sediment_used_for_this_cell * depressionsum_texture_kg[size];
                            }
                            young_SOM_kg[fillrow, fillcol, 0] += fraction_sediment_used_for_this_dep * fraction_sediment_used_for_this_cell * depressionsum_YOM_kg;
                            old_SOM_kg[fillrow, fillcol, 0] += fraction_sediment_used_for_this_dep * fraction_sediment_used_for_this_cell * depressionsum_OOM_kg;

                            //also update dtm (although it will again be updated soon when we update soils)
                            lake_sed_m[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            dtmchange_m[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            soildepth_m[fillrow, fillcol] += dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol] - dtm[fillrow, fillcol];
                            dtm[fillrow, fillcol] = dtmfill_A[fillrow, fillcol] - dz_ero_m[fillrow, fillcol] - dz_sed_m[fillrow, fillcol];
                            if (dtm[fillrow, fillcol] == -1) { Debug.WriteLine("C cell " + (fillrow) + " " + (fillcol) + " has an altitude of -1 now"); minimaps(fillrow, fillcol); }
                        }
                    }
                }
            }
            int outletcounter = 0;
            while (drainingoutlet_col[this_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (int i = 0; i < outletcounter; i++)
            {
                waterflow_m3[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] += dx * dx * (depressionvolume_m[this_depression]) / outletcounter;
                //we need a rule to determine whether any sediment size stays behind preferentially if we fill a depression. For the moment: no preference
                for (size = 0; size < n_texture_classes; size++)
                {
                    //sediment_in_transport_kg[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] += (depressionsum_sediment_m - needed_to_fill_depression_m) / outletcounter * ;
                    //we need to calculate how much of which fraction there is in transport, and then deposit by weight-ratio (or anything else).                
                }
            }
            //Debug.WriteLine(" Filled depression " + this_depression);
        }

        void leave_depression_alone(int number)  // only updates counters and sentinels
        {
            /*int this_depression = number;
            int leaverow = 0, leavecol = 0;
            //Debug.WriteLine(" leaving depression " + this_depression + " alone");

            for (leaverow = iloedge[this_depression];
            leaverow <= iupedge[this_depression]; leaverow++)
            {
                for (leavecol = jloedge[this_depression]; leavecol <= jupedge[this_depression]; leavecol++)
                {
                    if (((leaverow) >= 0) && ((leaverow) < nr) && ((leavecol) >= 0) && ((leavecol) < nc) && dtm[leaverow, leavecol] != -9999)
                    {  //bnd
                        if (depression[leaverow, leavecol] == this_depression)
                        {
                            considered[leaverow, leavecol] = 1;
                        }
                    }
                }
            }
            int outletcounter = 0;
            while (drainingoutlet_col[this_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (i = 0; i < outletcounter; i++)
            {
                considered[drainingoutlet_row[this_depression, i], drainingoutlet_col[this_depression, i]] = 0;
            }
            //Debug.WriteLine(" Left depression " + this_depression + " alone"); */
        }

        void bottom_depression(int depnumber)
        /* this code is intended as an alternative for delta_depression, to save calculation time and increase model stability
         * instead of building deltas from each of a lake's side cells, we simply take the depressionsum_sediment_kg and put it in the lowest parts of the lake,
         * aiming to raise the lakebottom higher and higher until depressionsum_sed_kg runs  out. 
         * Lake bottom will be raised parallel to fillheight, not lakelevel, to ensure that we will ultimately have a non-flat surface. 
         * the code will 
         * a) calculate the difference between dtm+ero+sed and fillheight for each cell
         * b) sort that list in descending order to get the 'deepest' cell first.
         * c) calculate how many of the available cells can be raised how high with the available sediment
         * d) raise those cells
         */
        //a: calculate difference, populate list
        {
            int active_depression = depnumber;
            for (int startrow = iloedge[active_depression]; startrow <= iupedge[active_depression]; startrow++)
            {
                for (int startcol = jloedge[active_depression]; startcol <= jupedge[active_depression]; startcol++)
                {
                    if (((startrow) >= 0) && ((startrow) < nr) && ((startcol) >= 0) && ((startcol) < nc) && dtm[startrow, startcol] != -9999)
                    {  //bnd
                        if (depression[startrow, startcol] == active_depression)
                        {
                            double sed_thickness_needed_m = dtmfill_A[startrow, startcol] - (dtm[startrow, startcol] + dtm[startrow, startcol] + dtm[startrow, startcol]);
                            L_lakecells.Add(new Lakecell(startrow, startcol, sed_thickness_needed_m, 0));
                        }
                    }
                }
            }
            //b: now sort the list on the difference:
            L_lakecells.OrderBy(x => x.t_sed_needed_m).ToList();
            Console.WriteLine(String.Join(Environment.NewLine, L_lakecells));
            L_lakecells.Reverse();
            //c: walk through the ordered list and use up the depressionsum_sediment_m.
            // We know that there is less than we'd need to fill the entire lake.
            double sum_to_be_filled_m = 0;
            double depth_under_dtmfill_m = L_lakecells.ElementAt(0).t_sed_needed_m;
            for (int i = 0; i < L_lakecells.Count - 1; i++)
            {
                double extra_fill_m = L_lakecells.ElementAt(i).t_sed_needed_m - L_lakecells.ElementAt(i + 1).t_sed_needed_m;
                sum_to_be_filled_m += extra_fill_m * i; //this increases from 0 to beyond sum_to_be_filled. The outlet cell (which is part of the lake),
                                                        //has a t_sed_needed_m === 0, so if we get that far, sum_to_be_filled_m now is equal to the volume of the
                                                        //lake (to dtmfill), which is more than depression_sum_sediment_m
                depth_under_dtmfill_m -= extra_fill_m; // this diminishes from the initially lowest depth of any cell of the lake to 0 (if we made it to the last cell pair)            
                if (sum_to_be_filled_m > depressionsum_sediment_m)
                {
                    depth_under_dtmfill_m += (sum_to_be_filled_m - depressionsum_sediment_m) / i;
                    break;
                }
            }
            //d: we now know how far under dtmfill all lakecells can reach (although some may already be higher, those won't get filled);
            // let's fill then!
            for (int startrow = iloedge[active_depression]; startrow <= iupedge[active_depression]; startrow++)
            {
                for (int startcol = jloedge[active_depression]; startcol <= jupedge[active_depression]; startcol++)
                {
                    if (((startrow) >= 0) && ((startrow) < nr) && ((startcol) >= 0) && ((startcol) < nc) && dtm[startrow, startcol] != -9999)
                    {  //bnd
                        if (depression[startrow, startcol] == active_depression)
                        {
                            if (dtmfill_A[startrow, startcol] - depth_under_dtmfill_m > dtm[startrow, startcol])
                            {
                                dtm[startrow, startcol] = dtmfill_A[startrow, startcol] - depth_under_dtmfill_m;
                                young_SOM_kg[startrow, startcol, 0] = (dtmfill_A[startrow, startcol] - depth_under_dtmfill_m) / depressionsum_sediment_m * depressionsum_YOM_kg;
                                old_SOM_kg[startrow, startcol, 0] = (dtmfill_A[startrow, startcol] - depth_under_dtmfill_m) / depressionsum_sediment_m * depressionsum_OOM_kg;
                                for (int texxie = 0; texxie < 5; texxie++)
                                {
                                    texture_kg[startrow, startcol, 0, texxie] += (dtmfill_A[startrow, startcol] - depth_under_dtmfill_m) / depressionsum_sediment_m * depressionsum_texture_kg[texxie];
                                }
                            }
                        }

                    }

                }
            }
            depressionsum_sediment_m = 0;
            depressionsum_OOM_kg = 0;
            depressionsum_YOM_kg = 0;
            depressionsum_texture_kg[0] = 0; depressionsum_texture_kg[1] = 0; depressionsum_texture_kg[2] = 0; depressionsum_texture_kg[3] = 0; depressionsum_texture_kg[4] = 0;
            L_lakecells.Clear();
        }
        void delta_depression(int number)  // builds deltas in an updated depression (because not enough sed)
        {
            /*When there is not enough sediment to fill the lake, fill the lake from each of its initial side-cells that have a non-zero sediment in transport, excluding outlet cells (their sediment in transport gets moved outside  they will never have to be raised higher than lakelevel which they already have  - they will remain having the lakenumber even when the whole lake would have been filled). 

                c. For each of these cells, while there is sediment in transport /dx left:
                    	Find a potentially lower oblique cell (in the lake, but there are  no others)
                    	Find the first higher oblique cell relative to that cell
                    	Raise the oblique deepest cell to that level
                    	Reduce the remaining amount of sediment in transport with the raised amount
                    	Test whether the cell has now been raised above fillheight, in which case: 
                            it must be lowered to its fillheight, 
                            remaining amount of sed in trans must be increased again
                            lakecell must be removed from the lake (potentially fragmenting the original lake) 
            
            filling happens for the moment with perfectly mixed sediment for the entire lake. 
            The alternative, where different sides of a lake provide differently textured sediment to differently-textured deltas, is a 
            possible development
             */

            double fraction_of_depression_filled = depressionsum_sediment_m / needed_to_fill_depression_m;
            int active_depression = number, size;
            if (diagnostic_mode == 1 && number > 2300000) { Debug.WriteLine(" building deltas in depression " + number + " sed needed " + needed_to_fill_depression_m + " sed available " + depressionsum_sediment_m); }
            //else { diagnostic_mode = 0; }

            //if (number == 30001 && t == 1) { diagnostic_mode = 1; } else { diagnostic_mode = 0; }

            for (startrow = iloedge[active_depression]; startrow <= iupedge[active_depression]; startrow++)
            {
                for (startcol = jloedge[active_depression]; startcol <= jupedge[active_depression]; startcol++)
                {
                    if (((startrow) >= 0) && ((startrow) < nr) && ((startcol) >= 0) && ((startcol) < nc) && dtm[startrow, startcol] != -9999)
                    {  //bnd
                        int sediment_present = 0;
                        for (size = 0; size < n_texture_classes; size++)
                        {
                            if (sediment_in_transport_kg[startrow, startcol, size] > 0)
                            { sediment_present = 1; }
                        }
                        if (depression[startrow, startcol] == active_depression && sediment_present == 1)
                        // so, for all cells in the depression that have a non-zero sediment in transport (and EXCLUDING the outlets) 
                        {
                            if (!(drainingoutlet_row[active_depression, 0] == startrow && drainingoutlet_col[active_depression, 0] == startcol) &&
                                !(drainingoutlet_row[active_depression, 1] == startrow && drainingoutlet_col[active_depression, 1] == startcol) &&
                                !(drainingoutlet_row[active_depression, 2] == startrow && drainingoutlet_col[active_depression, 2] == startcol) &&
                                !(drainingoutlet_row[active_depression, 3] == startrow && drainingoutlet_col[active_depression, 3] == startcol) &&
                                !(drainingoutlet_row[active_depression, 4] == startrow && drainingoutlet_col[active_depression, 4] == startcol))
                            {
                                deltasize = 0;
                                dhobliquemax1 = 0;
                                iloradius3 = 1; iupradius3 = 1; jloradius3 = 1; jupradius3 = 1;
                                iloradius2 = 1; iupradius2 = 1; jloradius2 = 1; jupradius2 = 1;
                                rowlowestobnb = startrow; collowestobnb = startcol;
                                if (diagnostic_mode == 1) { Debug.WriteLine(" building a delta from " + startrow + " " + startcol + ", dtm " + dtm[startrow, startcol]); minimaps(startrow, startcol); }
                                double[] local_s_i_t_kg = new double[5] { 0, 0, 0, 0, 0 };
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    local_s_i_t_kg[size] = sediment_in_transport_kg[startrow, startcol, size];
                                    sediment_in_transport_kg[startrow, startcol, size] = 0;
                                }
                                available_for_delta_m += calc_thickness_from_mass(local_s_i_t_kg, 0, 0);
                                sediment_delta_m += available_for_delta_m;
                                // we will completely use all of this sed in trans now, so let's add it to the overall counter of the volume used in deltas

                                while (available_for_delta_m > 0)
                                {
                                    find_lowest_oblique_neighbour(active_depression);  // to start in the right location with building the delta
                                                                                       // this may be lower in the lake than at the side-cell, at location rowlowestobnb,collowestobnb
                                    depression[rowlowestobnb, collowestobnb] = -active_depression;   // we have found the start of this delta
                                    deltasize = 1;    // therefore we give delta a value of 1
                                    dhobliquemax2 = 99999.99;
                                    II = 0; JJ = 0;
                                    iloradius3 = 1; iupradius3 = 1; jloradius3 = 1; jupradius3 = 1;

                                    while (dhobliquemax2 > 0 && available_for_delta_m > 0)
                                    // starting in the lowest cell, we will now find the lowest higher nb
                                    // we will continue looking for lowest higher nbs as long as we find one and have sediment left
                                    // while doing this, we will raise our delta with us
                                    {
                                        find_lowest_higher_oblique_neighbour(active_depression);

                                        if (dhobliquemax2 < 0)
                                        {   // if we have found a lower neighbour
                                            // leave the current delta and bring the remaining sediment to the lower oblique neighbour
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" lowest oblique neighbour is lower - moving sediment down "); }
                                            cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb);
                                            if (iloradius2 < -(rowlowestobnb + II - startrow)) { iloradius2 = -(rowlowestobnb + II - startrow); }
                                            if (iupradius2 < (rowlowestobnb + II - startrow)) { iupradius2 = (rowlowestobnb + II - startrow); }
                                            if (jloradius2 < -(collowestobnb + JJ - startcol)) { jloradius2 = -(collowestobnb + JJ - startcol); }
                                            if (jupradius2 < (collowestobnb + JJ - startcol)) { jupradius2 = (collowestobnb + JJ - startcol); }
                                            dhobliquemax1 = ((dtm[startrow, startcol] + dz_ero_m[startrow, startcol] + +dz_sed_m[startrow, startcol]) - (dtm[rowlowestobnb + II, collowestobnb + JJ] + dz_ero_m[rowlowestobnb + II, collowestobnb + JJ] + dz_sed_m[rowlowestobnb + II, collowestobnb + JJ]) - (Math.Sqrt((startrow - rowlowestobnb - II) * (startrow - rowlowestobnb - II) + (startcol - collowestobnb - JJ) * (startcol - collowestobnb - JJ)) * dx * tangent_of_delta)) - 0.0000001;
                                        }
                                        if (dhobliquemax2 == 0)
                                        {
                                            // this is not supposed to happen because in this case the search in find_lowest_higher_oblique_nb must go on.
                                            if (diagnostic_mode == 1) { Debug.WriteLine("Warning. Found dhobliquemax = 0 outside of find_lowest_higher_ob_nb"); }
                                        }
                                        if (dhobliquemax2 > 0)
                                        {
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" lowest higher oblique neighbour is higher - raising delta"); }
                                            if (diagnostic_mode == 1) { Debug.WriteLine(" available " + available_for_delta_m + "m and space for " + (deltasize * dhobliquemax2) + " m"); }
                                            if (available_for_delta_m >= deltasize * dhobliquemax2)
                                            {
                                                if (diagnostic_mode == 1) { Debug.WriteLine(" raising delta to higher oblique level "); }
                                                raise_delta_completely(active_depression);
                                            }
                                            else
                                            {
                                                if (diagnostic_mode == 1) { Debug.WriteLine(" raising delta as far as possible given sediment "); }
                                                raise_delta_partly(active_depression);
                                                if (diagnostic_mode == 1) { minimaps(row, col); }
                                                if (obnbchanged == 0) { cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb); }
                                                // if the starting cell was raised above lakelevel, it is no longer member of the lake, and we have taken care of that in raise_delta_partly by changing obnb. 
                                                // this must not be removed, so if obnbchanged != 0, we do not clear the delta.
                                            }

                                        } // end if dhoblmax2 > 0
                                    } // end while dhobliquemax2 > 0
                                } // end while sediment_available
                                cleardelta(iloradius3, iupradius3, jloradius3, jupradius3, rowlowestobnb, collowestobnb);
                            } //end if not outlet 
                        } // end if depressio
                    } // end if boundaries
                } // end for col
            } //end for row 

            // we now divide the total amount of extra water (the amount replaced by sediment in the lake) over the (max 5) outlets.
            int outletcounter = 0;
            while (drainingoutlet_col[active_depression, outletcounter] != -1)
            {
                outletcounter++;
                if (outletcounter == 5) { break; }
            }
            for (i = 0; i < outletcounter; i++)
            {
                waterflow_m3[drainingoutlet_row[active_depression, i], drainingoutlet_col[active_depression, i]] += dx * dx * (depressionsum_sediment_m) / outletcounter;
            }
            //diagnostic_mode = 1;
        }

        void find_lowest_oblique_neighbour(int this_depression) // to determine where to start or continue with current delta 
        {
            if (t > 300000) { diagnostic_mode = 1; }
            if (diagnostic_mode == 1) { Debug.WriteLine(" entered find_lowest_oblique_neighbour"); }
            // finds the lowest oblique neighbour of the current delta
            // affects (changes) global doubles dhobliquemax1 et al
            //int this_depression = Math.Abs(depression[startrow, startcol]);

            int readysearching = 0;
            while (readysearching == 0)
            {
                readysearching = 1;      // we expect to be ready searching, but when not, we will set this to 0
                if (diagnostic_mode == 1) { Debug.WriteLine(" dhobliquemax1 : " + dhobliquemax1); }
                if (diagnostic_mode == 1) { Debug.WriteLine(" ilo " + iloradius2 + ", iup " + iupradius2 + ", jlo " + jloradius2 + ", jup " + jupradius2 + ", row: " + startrow + ", col " + startcol); }
                for (i = -iloradius2; i <= iupradius2; i++)
                {
                    for (j = -jloradius2; j <= jupradius2; j++)
                    {
                        if ((startrow + i >= 0) && (startrow + i < nr) && (startcol + j >= 0) && (startcol + j < nc) && !((i == 0) && (j == 0)) && dtm[startrow + i, startcol + j] != -9999) //&& !((startrow + i == row) && (startcol + j == col))
                        { // boundary check while looking around startrow startcol for the neighbours of the entire current delta
                            if (diagnostic_mode == 1) { Debug.WriteLine(" oblique neighbour now " + (startrow + i) + " " + (startcol + j) + ", depression " + depression[startrow + i, startcol + j] + " dtm " + (dtm[startrow + i, startcol + j] + dz_ero_m[startrow + i, startcol + j] + dz_sed_m[startrow + i, startcol + j])); }
                            if (depression[startrow + i, startcol + j] == this_depression || depression[startrow + i, startcol + j] == -this_depression)
                            {  // if you are a member of this depression
                                dhoblique = (dtm[startrow, startcol] + dz_ero_m[startrow, startcol] + dz_sed_m[startrow, startcol]) - (dtm[startrow + i, startcol + j] + dz_ero_m[startrow + i, startcol + j] + dz_sed_m[startrow + i, startcol + j]) - (Math.Sqrt((i * i) + (j * j)) * dx * tangent_of_delta);
                                if (diagnostic_mode == 1) { Debug.WriteLine(" oblique neighbour now " + (startrow + i) + " " + (startcol + j) + " :" + dhoblique); }
                                //if (diagnostic_mode == 1) { Debug.WriteLine(" dhobliquemax1 : " + dhobliquemax1); }
                                if ((dhoblique > dhobliquemax1))
                                {      // vanwege afkortinsverschillen 0.000000000 etc 1
                                    dhobliquemax1 = dhoblique;
                                    rowlowestobnb = startrow + i;
                                    collowestobnb = startcol + j;
                                    //deltasize = 1;
                                    if (this_depression > 0)
                                    {
                                        if (diagnostic_mode == 1) { Debug.WriteLine(" lowest oblique neighbour now " + rowlowestobnb + " " + collowestobnb + " dhobliquemax1 : " + dhobliquemax1); }
                                    }
                                    lower_nb_exists = 1;
                                    readysearching = 0;
                                    if (i == -1 * iloradius2) { iloradius2++; }
                                    if (i == iupradius2) { iupradius2++; }
                                    if (j == -1 * jloradius2) { jloradius2++; }
                                    if (j == jupradius2) { jupradius2++; }
                                    if (diagnostic_mode == 1) { Debug.WriteLine(" ilo " + iloradius2 + ", iup " + iupradius2 + ", jlo " + jloradius2 + ", ju2 " + jupradius2); }
                                } // end if dhoblique  < dhobliquemax1)
                                if (dhoblique < 0.0000000001 && dhobliquemax1 < 0.0000000001 && dhoblique > -0.0000000001)
                                {   // in this case, we may have filled the present neighbour
                                    // in an earlier stage, but have had to clear the delta because
                                    // a lower obnb was found. We must look beyond this equally-high
                                    // oblique nb to be able to find this lower obnb.....
                                    if (diagnostic_mode == 1) { Debug.WriteLine("found previous delta"); }
                                    if (i == -1 * iloradius2) { iloradius2++; readysearching = 0; }
                                    if (i == iupradius2) { iupradius2++; readysearching = 0; }
                                    if (j == -1 * jloradius2) { jloradius2++; readysearching = 0; }
                                    if (j == jupradius2) { jupradius2++; readysearching = 0; }
                                } // end if dhoblique and dhobliquemax1 are zero
                            } // end if depression = depression
                        } // end if boundaries
                    } // end for j
                } // end if
            } // end while readysearching = 0
            if (diagnostic_mode == 1) { Debug.WriteLine(" ready searching - dhobliquemax1: " + dhobliquemax1 + ", dx: " + dx + ", row " + rowlowestobnb + ", col " + collowestobnb); }
        }

        void find_lowest_higher_oblique_neighbour(int here_depression) // to determine to which level (and cell) the current delta can be raised 
        {
            if (t > 1000000) { diagnostic_mode = 1; }
            if (diagnostic_mode == 1) { Debug.WriteLine(" entered find_lowest_higher_oblique_neighbour"); }
            if (diagnostic_mode == 1) { Debug.WriteLine(" rowlow = " + rowlowestobnb + " collow = " + collowestobnb + " range " + iloradius3 + iupradius3 + jloradius3 + jupradius3); }
            if (diagnostic_mode == 1 && rowlowestobnb == 224) { minimaps(rowlowestobnb, collowestobnb); }
            readysearching = 0;
            while (readysearching == 0)
            {
                dhobliquemax2 = 99999.99;
                for (i = -1 * iloradius3; i <= iupradius3; i++)
                {
                    for (j = -1 * jloradius3; j <= jupradius3; j++)
                    {
                        if (((rowlowestobnb + i) >= 0) && ((rowlowestobnb + i) < nr) && ((collowestobnb + j) >= 0) && ((collowestobnb + j) < nc) && !((i == 0) && (j == 0)))
                        { // boundaries
                            if (depression[rowlowestobnb + i, collowestobnb + j] == here_depression)
                            {
                                dhoblique = -((dtm[rowlowestobnb, collowestobnb]) + dz_ero_m[rowlowestobnb, collowestobnb] + dz_sed_m[rowlowestobnb, collowestobnb]) + (dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) + (Math.Sqrt(Math.Pow((rowlowestobnb + i - startrow), 2) + Math.Pow((collowestobnb + j - startcol), 2)) - Math.Sqrt(Math.Pow((rowlowestobnb - startrow), 2) + Math.Pow((collowestobnb - startcol), 2))) * dx * tangent_of_delta;
                                if (dhoblique != 0 && dhoblique < dhobliquemax2)
                                {
                                    readysearching = 1;
                                    dhobliquemax2 = dhoblique;
                                    II = i; JJ = j;
                                    if (diagnostic_mode == 1 && dhobliquemax2 < 0) { Debug.WriteLine("cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " is a lower obnb (dhoblmax2 = " + dhobliquemax2 + ") from " + rowlowestobnb + collowestobnb); }
                                    // 
                                } // end if
                                if (dhoblique < 0.0000000001 && dhoblique > -0.0000000001)
                                {       //this means we have transferred to a 'new delta' after encountering a negative dhobliquemax2 first,
                                        //then filled this new delta to the point that we are as high as the previous one
                                        // we therefore encounter one or more cells with dhoblique = 0
                                        //we must incorporate these cells into the delta and increase the searchradius
                                    depression[rowlowestobnb + i, collowestobnb + j] = -here_depression;
                                    deltasize++;
                                    readysearching = 0;
                                    if (diagnostic_mode == 1) { Debug.WriteLine("added " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (dhoblique 0.0000) to the delta and will increase searchradius for lowest higher nbour"); }
                                } //end if dhoblmax2 == 0
                            } // end if depression == depression
                        } // end if bndries
                    } // end for j
                } // end for i
                if (readysearching == 0)
                {
                    // If no neighbour within the original radius3 from obnb was member of a lake (which can happen if they were raised to dtm_fill earlier), then 
                    // we will increase the searchradius (there can be another lake cell somewhere, because the lake is not being filled completely).
                    iloradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("ilo is higher"); }
                    iupradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("iup is higher"); }
                    jloradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("jlo is higher"); }
                    jupradius3++; if (diagnostic_mode == 1) { Debug.WriteLine("jup is higher"); }
                    //however, no higher ob nb is necessarily present. The current obnb, and possibly its delta, need not have a lake-neighbour with a higher dhoblique
                    //this is for instance the case when we are currently looking at the last cell in the lake.
                    //In that case, we must fill the current delta as much as possible with the existing sediment. A corresponding dhoblique must be sent back to control.
                    if (rowlowestobnb - iloradius3 <= iloedge[here_depression] && rowlowestobnb + iupradius3 >= iupedge[here_depression] &&
                        collowestobnb - jloradius3 <= jloedge[here_depression] && collowestobnb + jupradius3 >= jupedge[here_depression])
                    {
                        readysearching = 1;
                        dhobliquemax2 = (dtmfill_A[rowlowestobnb, collowestobnb] - (dtm[rowlowestobnb, collowestobnb] + dz_ero_m[rowlowestobnb, collowestobnb] + dz_sed_m[rowlowestobnb, collowestobnb]));
                        if (dhobliquemax2 == 0) { dhobliquemax2 = 1; }//ArT If the dhoblique is zero, because the obnb was the outlet with dtmfill== dtm, then we give an emergency value to dhobliquemax2  
                        if (diagnostic_mode == 1) { Debug.WriteLine(" search for lower ob nb finished - not found - sending dhobliquemax as equal to fillspace of " + dhobliquemax2); }
                    }
                }
            } //end while readysearching == 1
        }

        void raise_delta_completely(int this_depression) // raise delta completely (and then go on raising it to higher obl heights)  
        {
            int size;
            // the amount of sed_in_trans left is enough to raise the entire delta with dhobliquemax1
            if (diagnostic_mode == 1) { Debug.WriteLine(" 2: to be added: " + dhobliquemax2 + ", sed_for_delta: " + available_for_delta_m + "m, deltasize: " + deltasize); }
            if (diagnostic_mode == 1) { Debug.WriteLine(" rowlowestobnb " + rowlowestobnb + " collowestobnb " + collowestobnb + " and " + iloradius3 + iupradius3 + jloradius3 + jupradius3); }
            for (i = -1 * iloradius3; i <= iupradius3; i++)
            {
                for (j = -1 * jloradius3; j <= jupradius3; j++)
                {
                    if (((rowlowestobnb + i) >= 0) && ((rowlowestobnb + i) < nr) && ((collowestobnb + j) >= 0) && ((collowestobnb + j) < nc) && !(rowlowestobnb + i == row && collowestobnb + j == col) && dtm[rowlowestobnb + i, collowestobnb + j] != -9999)
                    { // boundaries, note that i==0 && j==0 is allowed  ;we can raise rowlowestobnb,colloewsobnb when it is part of the delta.
                        if (depression[rowlowestobnb + i, collowestobnb + j] == -this_depression) // i.e. if cell is part of present delta
                        {
                            for (int text_class = 0; text_class < 5; text_class++)
                            {
                                texture_kg[rowlowestobnb + i, collowestobnb + j, 0, text_class] += depressionsum_texture_kg[text_class] * (dhobliquemax2 / depressionsum_sediment_m);
                            }
                            old_SOM_kg[rowlowestobnb + i, collowestobnb + j, 0] += depressionsum_OOM_kg * (dhobliquemax2 / depressionsum_sediment_m);
                            young_SOM_kg[rowlowestobnb + i, collowestobnb + j, 0] += depressionsum_YOM_kg * (dhobliquemax2 / depressionsum_sediment_m);
                            dtm[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            dtmchange_m[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            lake_sed_m[rowlowestobnb + i, collowestobnb + j] += dhobliquemax2;
                            available_for_delta_m -= dhobliquemax2;
                            if (dtm[rowlowestobnb + i, collowestobnb + j] == -1) { Debug.WriteLine("A1 cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                            if (available_for_delta_m < 0) { Debug.WriteLine(" Error: negative sediment for delta " + available_for_delta_m + " m"); minimaps(rowlowestobnb + i, collowestobnb + j); }
                            if (diagnostic_mode == 1) { Debug.WriteLine(" raised " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " with " + dhobliquemax2 + " to " + (dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) + " sed_for_delta now " + available_for_delta_m); }
                            if (diagnostic_mode == 1 && dhobliquemax2 < 0) { Debug.WriteLine(" warning: dhobliquemax2 is less than zero at " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " " + dhobliquemax2); }
                            //if (diagnostic_mode == 1) { MessageBox.Show("warning - extremely high coarse sed_in_trans:" + sediment_in_transport_kg[startrow, startcol,0]); }
                            if ((dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) > dtmfill_A[rowlowestobnb + i, collowestobnb + j])
                            {   // then we have raised this cell too high
                                double take_back_m = (dtm[rowlowestobnb + i, collowestobnb + j] + dz_ero_m[rowlowestobnb + i, collowestobnb + j] + dz_sed_m[rowlowestobnb + i, collowestobnb + j]) - dtmfill_A[rowlowestobnb + i, collowestobnb + j];
                                if (diagnostic_mode == 1) { Debug.WriteLine("1 we change the too-high altitude of " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (depressionlevel " + depressionlevel[this_depression] + ") from " + dtm[rowlowestobnb + i, collowestobnb + j] + " to " + dtmfill_A[rowlowestobnb + i, collowestobnb + j]); }
                                available_for_delta_m += take_back_m;
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    //any sediment in transport that was possibly waiting for consideration later than the current startrow, startcol is taken into this startrow startcol to make a bigger delta here
                                    local_s_i_t_kg[size] += sediment_in_transport_kg[rowlowestobnb + i, collowestobnb + j, size];
                                    sediment_in_transport_kg[rowlowestobnb + i, collowestobnb + j, size] = 0;
                                    texture_kg[rowlowestobnb + i, collowestobnb + j, 0, size] -= depressionsum_texture_kg[size] * (take_back_m / depressionsum_sediment_m);
                                }
                                old_SOM_kg[rowlowestobnb + i, collowestobnb + j, 0] -= depressionsum_OOM_kg * (take_back_m / depressionsum_sediment_m);
                                young_SOM_kg[rowlowestobnb + i, collowestobnb + j, 0] -= depressionsum_YOM_kg * (take_back_m / depressionsum_sediment_m);
                                if (available_for_delta_m < 0) { Debug.WriteLine("5 negative sediment for delta " + available_for_delta_m + " m"); }
                                lake_sed_m[rowlowestobnb + i, collowestobnb + j] -= take_back_m;
                                dtmchange_m[rowlowestobnb + i, collowestobnb + j] -= take_back_m;
                                if (lake_sed_m[rowlowestobnb + i, collowestobnb + j] < -0.0000001) { Debug.WriteLine("1 Warning: negative lake deposition in " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " of " + lake_sed_m[rowlowestobnb + i, collowestobnb + j] + " dtm " + dtm[rowlowestobnb + i, collowestobnb + j] + " fill " + dtmfill_A[rowlowestobnb + i, collowestobnb + j]); minimaps(rowlowestobnb + i, collowestobnb + j); }
                                dtm[rowlowestobnb + i, collowestobnb + j] = dtmfill_A[rowlowestobnb + i, collowestobnb + j] - dz_ero_m[rowlowestobnb + i, collowestobnb + j] - dz_sed_m[rowlowestobnb + i, collowestobnb + j];
                                if (dtm[rowlowestobnb + i, collowestobnb + j] == -1) { Debug.WriteLine("A2 cell " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                                depression[rowlowestobnb + i, collowestobnb + j] = 0;
                                deltasize--;
                                if (diagnostic_mode == 1) { Debug.WriteLine("1: " + (rowlowestobnb + i) + " " + (collowestobnb + j) + " (depressionlevel " + depressionlevel[depression[row, col]] + ") now at " + dtm[rowlowestobnb + i, collowestobnb + j] + " = fill_A " + dtmfill_A[rowlowestobnb + i, collowestobnb + j] + " sed for delta " + available_for_delta_m); }
                                if (diagnostic_mode == 1) { Debug.WriteLine("decreased deltasize with 1 to " + deltasize); }
                            } // end if dtm > depressionlevel
                        }   // end if member of delta
                    }  // end if boundaries
                }  // end for j
            }  // end for i
            if (diagnostic_mode == 1)
            {
                Debug.WriteLine(" raised and now move on to enlarge delta with " + (rowlowestobnb + II) + " " + (collowestobnb + JJ) + " available for delta now " + available_for_delta_m + "m");
                Debug.WriteLine(" by changing " + (rowlowestobnb + II) + "," + (collowestobnb + JJ) + " from " + depression[rowlowestobnb + II, collowestobnb + JJ] + " into " + (-this_depression));
            }
            depression[rowlowestobnb + II, collowestobnb + JJ] = -this_depression;
            deltasize++;
            if (diagnostic_mode == 1) { Debug.WriteLine(" raised deltasize with 1 to " + deltasize + ". " + (rowlowestobnb + II) + " " + (collowestobnb + JJ) + " now negative lakevalue"); }
            //dhobliquemax2 = 0;
            if (II == -iloradius3) { iloradius3++; }
            if (II == iupradius3) { iupradius3++; }
            if (JJ == -jloradius3) { jloradius3++; }
            if (JJ == jupradius3) { jupradius3++; }
        }

        void raise_delta_partly(int this_depression) // raise partly (and then go to new cells on border of lake)  
        {

            int size;
            //Debug.WriteLine( "raising delta partly for dep " + this_depression);
            mem_m = available_for_delta_m / deltasize;
            available_for_delta_m = 0;
            if (diagnostic_mode == 1) { Debug.WriteLine(" 1: to be added: " + mem_m + ", deltasize: " + deltasize); }
            tempx = rowlowestobnb; tempy = collowestobnb;
            obnbchanged = 0;
            for (i = -1 * iloradius3; i <= iupradius3; i++)
            {
                for (j = -1 * jloradius3; j <= jupradius3; j++)
                {
                    if (((tempx + i) >= 0) && ((tempx + i) < nr) && ((tempy + j) >= 0) && ((tempy + j) < nc) && !(tempx + i == row && tempy + j == col) && dtm[tempx + i, tempy + j] != -9999)
                    { // boundaries
                        if (depression[tempx + i, tempy + j] == -this_depression)
                        {
                            for (int text_class = 0; text_class < 5; text_class++)
                            {
                                texture_kg[tempx + i, tempy + j, 0, text_class] += depressionsum_texture_kg[text_class] * (mem_m / depressionsum_sediment_m);
                            }
                            old_SOM_kg[tempx + i, tempy + j, 0] += depressionsum_OOM_kg * (mem_m / depressionsum_sediment_m);
                            young_SOM_kg[tempx + i, tempy + j, 0] += depressionsum_YOM_kg * (mem_m / depressionsum_sediment_m);
                            dtm[tempx + i, tempy + j] += mem_m;
                            dtmchange_m[tempx + i, tempy + j] += mem_m;
                            lake_sed_m[tempx + i, tempy + j] += mem_m;
                            if (dtm[tempx + i, tempy + j] == -1) { Debug.WriteLine("B cell " + (tempx + i) + " " + (tempy + j) + " has an altitude of -1 now"); minimaps((rowlowestobnb + i), (collowestobnb + j)); }
                            if (lake_sed_m[tempx + i, tempy + j] < -0.0000001) { Debug.WriteLine("4 Warning: negative lake deposition in " + (tempx + i) + " " + (tempy + j) + " of " + lake_sed_m[tempx + i, tempy + j]); minimaps(tempx + i, tempy + j); }
                            if (diagnostic_mode == 1) { Debug.WriteLine(" added " + mem_m + " to cell " + (tempx + i) + " " + (tempy + j)); }
                            if ((dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) > dtmfill_A[tempx + i, tempy + j])
                            {
                                double take_back_m = (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) - dtmfill_A[tempx + i, tempy + j];
                                if (diagnostic_mode == 1) { Debug.WriteLine(" cell " + (tempx + i) + " " + (tempy + j) + " raised above filllevel " + dtmfill_A[tempx + i, tempy + j] + ", to " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j])); }
                                available_for_delta_m += take_back_m;
                                for (size = 0; size < n_texture_classes; size++)
                                {
                                    local_s_i_t_kg[size] += sediment_in_transport_kg[tempx + i, tempy + j, size];
                                    sediment_in_transport_kg[tempx + i, tempy + j, size] = 0;   //ART recently changed, should solve a bug (this line did not exist, violation mass balance
                                    texture_kg[tempx + i, tempy + j, 0, size] -= depressionsum_texture_kg[size] * (take_back_m / depressionsum_sediment_m);
                                }
                                old_SOM_kg[tempx + i, tempy + j, 0] -= depressionsum_OOM_kg * (take_back_m / depressionsum_sediment_m);
                                young_SOM_kg[tempx + i, tempy + j, 0] -= depressionsum_YOM_kg * (take_back_m / depressionsum_sediment_m);
                                if (available_for_delta_m < 0) { Debug.WriteLine("9 negative sediment in transport (m) remaining for delta " + available_for_delta_m + "m"); }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" A we change the altitude of " + (tempx + i) + " " + (tempy + j) + " (depressionlevel " + depressionlevel[this_depression] + ") from " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) + " to " + dtmfill_A[tempx + i, tempy + j]); }
                                if (tempx + i == row && tempy + j == col) { Debug.WriteLine("we are changing outlet " + tempx + " " + tempy + " into 0"); }
                                lake_sed_m[tempx + i, tempy + j] -= take_back_m;
                                dtmchange_m[tempx + i, tempy + j] -= take_back_m;
                                if (lake_sed_m[tempx + i, tempy + j] < -0.0000001) { Debug.WriteLine("3 Warning: negative lake deposition in " + (tempx + i) + " " + (tempy + j) + " of " + lake_sed_m[tempx + i, tempy + j] + " alt " + (dtm[tempx + i, tempy + j] + dz_ero_m[tempx + i, tempy + j] + dz_sed_m[tempx + i, tempy + j]) + " fill " + dtmfill_A[tempx + i, tempy + j]); minimaps(tempx + i, tempy + j); }
                                dtm[tempx + i, tempy + j] = (dtmfill_A[tempx + i, tempy + j] - dz_ero_m[tempx + i, tempy + j] - dz_sed_m[tempx + i, tempy + j]); //so that with ero and sed, it equals dtmfill
                                if (dtm[tempx + i, tempy + j] == -1) { Debug.WriteLine("C cell " + (tempx + i) + " " + (tempy + j) + " has an altitude of -1 now"); minimaps(tempx + i, tempy + j); } //
                                if (diagnostic_mode == 1) { Debug.WriteLine(" will change depressionmembership of " + (tempx + i) + " " + (tempy + j) + " from " + depression[tempx + i, tempy + j] + " to 0"); }
                                if (diagnostic_mode == 1) { Debug.WriteLine(" II = " + II + ", JJ = " + JJ); }
                                depression[tempx + i, tempy + j] = 0;
                                if (diagnostic_mode == 1) { Debug.WriteLine(" obnbchanged? - row " + row + " col " + col + " startrow " + startrow + " startcol " + startcol + " rowobnb " + rowlowestobnb + " colobnb " + collowestobnb + " tempx+i " + (tempx + i) + " tempy+j " + (tempy + j)); }
                                obnbchanged = 1;  // if there is at least one cell that has been raised above dtmfill, then that is the lowest oblique neighbour: the cell with rowlowestobnb, collowestobnb. 
                                                  // In that case, we must move to a new rowlowestobnb collowestobnb to build the remainder of the delta from there. There is a remainder because some of the sediment used to raise the original
                                                  // lowest oblique neighbour above dtmfill has been added to available_for_delta again.
                                deltasize--;
                                if (diagnostic_mode == 1) { Debug.WriteLine("decreased deltasize with 1 to " + deltasize); }
                                break;
                            } // end if higher than depressionlevel
                        }  //end if member of delta
                    } // end for boundaries
                } //end for j
            }  // end for i
            if (obnbchanged == 1)
            {
                // this code makes sure that the starting situation for the delta to be built with the remainder of the sediment is correct.
                // this desired situation is: 
                // a) correct amount of sediment (already guaranteed)
                // b) correct cells member of delta (already correct if deltasize > 0, but if deltasize == 0 after removal of the too-high cell, then not correct).
                // c) correct starting cell for delta building (rowlowestobnb and collowestobnb). Not correct because it may be that cell which was just removed from lake and delta. 
                // In case deltasize > 0 and rowlobnb,collobnb is no longer part of the delta, we select any delta-neighbour of the old starting cell.
                // In case deltasize = 0, we select the lowest higher oblique nb for this.
                // Nov 2021: If deltasize = 0, rowlobnb, collownb also is possibly no longer part of the lake. Then what? Then any lake-neighbour of the old starting cell, but we'll need to look harder.

                if (deltasize == 0)
                {
                    if (depression[tempx + II, tempy + JJ] == this_depression)
                    {
                        deltasize++;
                        if (diagnostic_mode == 1) { Debug.WriteLine("increased deltasize with 1 to " + deltasize); }
                        if (diagnostic_mode == 1) { Debug.WriteLine("lowest oblique neighbour now " + rowlowestobnb + " " + collowestobnb + ", will be: " + (tempx + II) + " " + (tempy + JJ)); }
                        rowlowestobnb = tempx + II;
                        collowestobnb = tempy + JJ;
                        if (diagnostic_mode == 1) { Debug.WriteLine(" will change depressionmembership of " + rowlowestobnb + " " + collowestobnb + " from " + depression[rowlowestobnb, collowestobnb] + " to " + (-this_depression)); }
                        depression[rowlowestobnb, collowestobnb] = -this_depression;
                    }
                    else
                    {
                        //we have no delta cells left, but we do have sed_in_trans left. We don't know from where to continue delta-building. We do know from where we started delta building, but that cell may no longer be part of the lake.
                        //we also know that there are at least one lake cells left (because we are in fill_delta_partly here), and that all lake cells are within iupradius3,iloradius3, etc from tempx, tempy
                        if (diagnostic_mode == 1)
                        {
                            Debug.WriteLine("row" + row + "col " + col + " depression " + depression[row, col]);
                            Debug.WriteLine("rowlowestobnb" + rowlowestobnb + "collowestobnb " + collowestobnb + " depression " + depression[rowlowestobnb, collowestobnb]);
                            Debug.WriteLine("tempx" + tempx + "tempy " + tempy + " depression " + depression[tempx, tempy]);
                            Debug.WriteLine("tempx + II" + (tempx + II) + "tempy + JJ " + (tempy + JJ) + " depression " + depression[tempx + II, tempy + JJ]);
                            minimaps(row, col);
                        }
                        bool found_a_delta_starter = false;
                        int tprowlowestobnb = -9999;
                        int tpcollowestobnb = -9999;
                        for (i = -1 * iloradius3; i <= iupradius3; i++)
                        {
                            for (j = -1 * jloradius3; j <= jupradius3; j++)
                            {
                                if (((tempx + i) >= 0) && ((tempx + i) < nr) && ((tempy + j) >= 0) && ((tempy + j) < nc) && !(tempx + i == row && tempy + j == col) && dtm[tempx + i, tempy + j] != -9999)
                                { // boundaries
                                    if (depression[tempx + i, tempy + j] == this_depression)
                                    {
                                        Debug.WriteLine(" found a possible delta-starter in cell" + (tempx + i) + " " + (tempy + j) + " depression " + depression[tempx + i, tempy + j] + " for depression " + this_depression);
                                        found_a_delta_starter = true;
                                        tprowlowestobnb = tempx + i;
                                        tpcollowestobnb = tempy + j;

                                    }
                                }
                            }
                        }
                        if (found_a_delta_starter == true)
                        {
                            depression[tprowlowestobnb, tpcollowestobnb] = -this_depression;
                            rowlowestobnb = tprowlowestobnb;
                            collowestobnb = tpcollowestobnb;
                            deltasize++;
                            if (diagnostic_mode == 1) { Debug.WriteLine("increased deltasize with 1 to " + deltasize); }
                        }
                        else
                        {
                            Debug.WriteLine("did not find an alternative start for this delta  " + deltasize + "in lake " + this_depression);
                            //this means that no lake cells are left, even though there is sediment left. We are wrong about the former or the latter
                            //development needed
                            //in meantime, let's try to simply end this lake and move on
                            depressionsum_sediment_m = 0;
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                local_s_i_t_kg[size] = 0;
                                depressionsum_texture_kg[size] = 0;
                            }
                            depressionsum_OOM_kg = 0;
                            depressionsum_YOM_kg = 0;
                            available_for_delta_m = 0;
                            dhobliquemax2 = 0;
                            Debug.WriteLine("trying to break free and move on"
                                );
                        }

                    }
                }
                if (deltasize > 0 && depression[rowlowestobnb, collowestobnb] != -this_depression)
                {
                    if (depression[rowlowestobnb + 1, collowestobnb + 1] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb + 1, collowestobnb] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; }
                    if (depression[rowlowestobnb + 1, collowestobnb - 1] == -this_depression) { rowlowestobnb = rowlowestobnb + 1; collowestobnb = collowestobnb - 1; }
                    if (depression[rowlowestobnb, collowestobnb + 1] == -this_depression) { collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb, collowestobnb - 1] == -this_depression) { collowestobnb = collowestobnb - 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb + 1] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; collowestobnb = collowestobnb + 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; }
                    if (depression[rowlowestobnb - 1, collowestobnb - 1] == -this_depression) { rowlowestobnb = rowlowestobnb - 1; collowestobnb = collowestobnb - 1; }
                }
                if (deltasize > 0 && depression[rowlowestobnb, collowestobnb] == -this_depression)
                {
                    //no action needed, just reporting
                    if (diagnostic_mode == 1) { Debug.WriteLine(" no action needed, lowestobnb is part of the delta " + rowlowestobnb + " " + collowestobnb + " lake " + depression[rowlowestobnb, collowestobnb]); }
                }
            }
            if (diagnostic_mode == 1) { Debug.WriteLine(" sed_for_delta is now " + available_for_delta_m + " and deltasize = " + deltasize); }
            //diagnostic_mode = 0;
        }

        #endregion

        #region experimental and maintenance code

        void minimaps(int row, int col)
        {
            int lowerrow, upperrow, lowercol, uppercol, disrow, discol;
            lowerrow = row - 4; if (lowerrow < 0) { lowerrow = 0; }
            upperrow = row + 4; if (upperrow > nr - 1) { upperrow = nr - 1; }
            lowercol = col - 4; if (lowercol < 0) { lowercol = 0; }
            uppercol = col + 4; if (uppercol > nc - 1) { uppercol = nc - 1; }
            string mess;

            // dtm
            Debug.Write(" \n"); Debug.Write("      DEM");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                //Qs = {0:F8}", tomsedi * dx * dx
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D8}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F6}", dtm[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D8}", (disrow + 1)); Debug.Write(mess); }
            }
            /*
            //water flow
            Debug.Write(" \n"); Debug.Write("      Q");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                //Qs = {0:F8}", tomsedi * dx * dx
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D8}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F6}", OFy_m[disrow, discol,0]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D8}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("SedI_TRA_kg");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", sediment_in_transport_kg[disrow, discol, 0]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            } */
            /*
            Debug.Write(" \n"); Debug.Write("fillheightA_m    ");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", dtmfill_A[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("dz_ero_m    ");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:F8}", dz_ero_m[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write(" DEPRESSION");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:D10}", depression[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }

            Debug.Write(" \n"); Debug.Write("    status");
            for (discol = lowercol; discol < (uppercol + 1); discol++)
            {
                mess = String.Format("  {0:D10}", discol); Debug.Write(mess);
            }
            Debug.Write(" \n"); mess = String.Format(" {0:D10}", lowerrow); Debug.Write(mess);
            for (disrow = lowerrow; disrow < (upperrow + 1); disrow++)
            {
                for (discol = lowercol; discol < (uppercol + 1); discol++)
                {
                    mess = String.Format("  {0:D10}", status_map[disrow, discol]); Debug.Write(mess);
                }
                Debug.Write(" \n"); if ((disrow + 1) <= upperrow) { mess = String.Format(" {0:D10}", (disrow + 1)); Debug.Write(mess); }
            }
            */

        }

        private void displaysoil(int row, int col)
        {

            int layer; double cumthick = 0; double depth = 0, z_layer = dtm[row, col];
            //  if (t == 0) { Debug.WriteLine("digitally augering and analysing at row " + row + " col " + col); }//header
            Debug.WriteLine("row col t nlayer cumth(m)  thick(m)  depth(m) z(m) coarse(kg) sand(kg)   silt(kg)   clay(kg)   fine(kg)   YOM(kg)    OOM(kg)   YOM/OOM   w%coarse   w%sand   w%silt   w%clay   w%fineclay BD");

            for (layer = 0; layer < max_soil_layers; layer++) // only the top layer
            {
                //if (layerthickness_m[row, col, layer] > 0)
                //{
                cumthick += layerthickness_m[row, col, layer];
                depth -= layerthickness_m[row, col, layer] / 2;
                double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                try { Debug.WriteLine(row + " " + col + " " + t + " " + layer + " " + cumthick + " " + layerthickness_m[row, col, layer] + " " + depth + " " + z_layer + " " + texture_kg[row, col, layer, 0] + " " + texture_kg[row, col, layer, 1] + " " + texture_kg[row, col, layer, 2] + " " + texture_kg[row, col, layer, 3] + " " + texture_kg[row, col, layer, 4] + " " + young_SOM_kg[row, col, layer] + " " + old_SOM_kg[row, col, layer] + " " + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + " " + texture_kg[row, col, layer, 0] / totalweight + " " + texture_kg[row, col, layer, 1] / totalweight + " " + texture_kg[row, col, layer, 2] / totalweight + " " + texture_kg[row, col, layer, 3] / totalweight + " " + texture_kg[row, col, layer, 4] / totalweight + " " + bulkdensity[row, col, layer]); }
                catch { Debug.WriteLine("Cannot write soilprofile"); }
                depth -= layerthickness_m[row, col, layer] / 2;
                z_layer -= layerthickness_m[row, col, layer];
                //}
            }

            /*if (t < end_time )
            {

                for (layer = 0; layer < max_soil_layers; layer++) // all layers
                {
                    if (layerthickness_m[row, col, layer] > 0)
                    {

                        cumthick += layerthickness_m[row, col, layer];
                        double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                        try { Debug.WriteLine(t + " " + cumthick + " " + layerthickness_m[row, col, layer] + " " + texture_kg[row, col, layer, 0] + " " + texture_kg[row, col, layer, 1] + " " + texture_kg[row, col, layer, 2] + " " + texture_kg[row, col, layer, 3] + " " + texture_kg[row, col, layer, 4] + " " + young_SOM_kg[row, col, layer] + " " + old_SOM_kg[row, col, layer] + " " + young_SOM_kg[row, col, layer] / old_SOM_kg[row, col, layer] + " " + (texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight + " " + texture_kg[row, col, layer, 2] / totalweight + " " + texture_kg[row, col, layer, 1] / totalweight); }
                        catch { Debug.WriteLine("Cannot write soilprofile"); }
                    }
                }
            }*/
            //Debug.WriteLine("");
        }

        bool check_negative_weight(int row, int col)
        {
            bool check = false;
            for (int layer1 = 0; layer1 < max_soil_layers; layer1++)
            {
                for (int tex = 0; tex < 5; tex++)
                {
                    if (texture_kg[row, col, layer1, tex] < 0)
                    {
                        check = true;
                    }
                }
            }
            return (check);
        }

        void calculate_terrain_derivatives()
        {
            //takes the DTM and calculates key derivatives and writes these to ASCII files
            try { dtm_file(dtm_input_filename_textbox.Text); }
            catch { Debug.WriteLine("could not read DEM for derivative calculation"); }

            //declare rasters and memory
            double[,] ledges, nedges, hedges, hhcliff, hlcliff, slhcliff, sllcliff, terruggedindex, ledgeheight;
            int[,] ledgenames;
            terruggedindex = new double[nr, nc];
            ledges = new double[nr, nc];
            nedges = new double[nr, nc];
            hedges = new double[nr, nc];
            hhcliff = new double[nr, nc];
            hlcliff = new double[nr, nc];
            slhcliff = new double[nr, nc];
            sllcliff = new double[nr, nc];
            ledgeheight = new double[nr, nc];
            ledgenames = new int[nr, nc];
            int runner = 0;

            //Topographic Ruggedness Index (Riley, S.J., DeGloria, S.D., Elliot, R., 1999. A terrain ruggedness index that quantifies topographic heterogeneity. Intermt. J. Sci. 5, 2327.)
            double sum_squared_difference = 0; int num_nbs = 0;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            sum_squared_difference = 0;
                            num_nbs = 0;
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    if (!(i == 0 && j == 0) && (row + i) >= 0 && (col + j) >= 0 && (row + i) < nr && (col + j) < nc)
                                    {
                                        if (dtm[row + i, col + j] != -9999)
                                        {
                                            sum_squared_difference += Math.Pow((dtm[row, col] - dtm[row + i, col + j]), 2);
                                            num_nbs++;
                                        }
                                    }
                                }
                            }
                            if (num_nbs == 0) { terruggedindex[row, col] = -9999; }
                            else { terruggedindex[row, col] = Math.Sqrt(sum_squared_difference) * (8 / num_nbs); }
                        }
                    }
                }
                out_double("ruggednessindex.asc", terruggedindex);
                Debug.WriteLine("terrain ruggedness index calculation and storage successfull");
            }
            catch { Debug.WriteLine("terrain ruggedness index calculation or storage failed"); }

            // Properties of possible ledges on the hillslope above and below each cell.
            //We need to ingest ledge positions
            try { read_integer("ledgenames.asc", ledgenames); Debug.WriteLine("ledgenames read successfully"); }
            catch { Debug.WriteLine("ledgenames not found"); }

            //then calculate local properties of the landscape around ledges. We expect that ledge positions may be up to 1 cell wrong.
            double maxcliffheight = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    ledges[row, col] = -9999;
                    nedges[row, col] = -9999;
                    hedges[row, col] = -9999;
                    hhcliff[row, col] = -9999;
                    hlcliff[row, col] = -9999;
                    slhcliff[row, col] = -9999;
                    sllcliff[row, col] = -9999;
                    ledgeheight[row, col] = -9999;
                    if (dtm[row, col] != -9999)
                    {
                        ledges[row, col] = 0;
                        nedges[row, col] = 0;
                        hedges[row, col] = 0;
                        hhcliff[row, col] = 0;
                        hlcliff[row, col] = 0;
                        slhcliff[row, col] = 0;
                        sllcliff[row, col] = 0;
                        ledgeheight[row, col] = 0;
                        if (ledgenames[row, col] != -9999)
                        {
                            try
                            {
                                maxcliffheight = 0;
                                for (i = (-1); i <= 1; i++)
                                {
                                    for (j = (-1); j <= 1; j++)
                                    {
                                        if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                        {
                                            if (dtm[row + i, col + j] != -9999)
                                            {
                                                for (ii = (-1); ii <= 1; ii++)
                                                {
                                                    for (jj = (-1); jj <= 1; jj++)
                                                    {
                                                        if (!(i + ii == 0 && j + jj == 0) && row + i + ii >= 0 && col + j + jj >= 0 && row + i + ii < nr && col + j + jj < nc)
                                                        {
                                                            if (dtm[row + i + ii, col + j + jj] != -9999)
                                                            {
                                                                if (Math.Abs(dtm[row + i + ii, col + j + jj] - dtm[row + i, col + j]) > maxcliffheight) { maxcliffheight = Math.Abs(dtm[row + i + ii, col + j + jj] - dtm[row + i, col + j]); }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                ledgeheight[row, col] = maxcliffheight;
                            }
                            catch { }
                        }
                    }
                }
            }
            Debug.WriteLine("ledgeheights determined");

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        if (ledgeheight[row, col] == -9999)
                        {
                            double highestledgeheight = 0;
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                    {
                                        if (ledgeheight[row + i, col + j] > highestledgeheight)
                                        {
                                            highestledgeheight = ledgeheight[row + i, col + j];
                                        }

                                    }
                                }
                            }
                            ledgeheight[row + i, col + j] = highestledgeheight;
                        }
                    }
                }
            }

            //now, we sort the dtm from high to low and walk through it from high to low to assign ledge properties to 
            comb_sort();
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {     // the index is sorted from low to high values, but flow goes from high to low
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];
                    //Debug.WriteLine("now at row " + row + " col " + col + " alt " + dtm[row, col]);
                    if (ledgenames[row, col] != -9999)
                    {
                        //we are on a ledge. Setting and resetting time
                        hhcliff[row, col] = ledgeheight[row, col];
                        slhcliff[row, col] = hhcliff[row, col] / dx;
                        hedges[row, col]++;
                    }
                    else
                    {
                        double tempslhcliff = 0, steepest = 0, steepness, distance, steepdist = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!(i == 0 && j == 0) && (row + i >= 0) && (col + j >= 0) && (row + i < nr) && (col + j < nc))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        if (dtm[row + i, col + j] > dtm[row, col])
                                        {
                                            if (i == 0 || j == 0) { distance = dx; } else { distance = dx * 1.414; }
                                            steepness = (dtm[row + i, col + j] - dtm[row, col]) / distance;
                                            if (steepness > steepest)
                                            {
                                                //we copy the cliffheight from the steepest neighbour cell
                                                steepdist = distance;
                                                steepest = steepness;
                                                hhcliff[row, col] = hhcliff[row + i, col + j]; tempslhcliff = slhcliff[row + i, col + j];
                                                hedges[row, col] = hedges[row + i, col + j];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        //we now have an updated hhcliff, so we can also update slhcliff
                        slhcliff[row, col] = hhcliff[row, col] / (steepdist + hhcliff[row, col] / tempslhcliff);
                    }
                }
            }
            Debug.WriteLine("downslope variables calculated");

            //now, we walk the other way (from low to high in the DTM). 
            for (runner = 0; runner < number_of_data_cells; runner++)
            {
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];
                    if (ledgenames[row, col] != -9999)
                    {
                        //we are on a ledge. Setting and resetting time
                        hlcliff[row, col] = ledgeheight[row, col];
                        sllcliff[row, col] = hlcliff[row, col] / dx;
                        ledges[row, col]++;
                    }
                    else
                    {
                        double tempsllcliff = 0, steepest = 0, steepness = 0, distance = 0, steepdist = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!(i == 0 && j == 0) && row + i >= 0 && col + j >= 0 && row + i < nr && col + j < nc)
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        if (dtm[row + i, col + j] < dtm[row, col])
                                        {
                                            if (i == 0 || j == 0) { distance = dx; } else { distance = dx * 1.414; }
                                            steepness = -(dtm[row + i, col + j] - dtm[row, col]) / distance;
                                            if (steepness > steepest)
                                            {
                                                //we copy the cliffheight from the steepest neighbour cell
                                                steepdist = distance;
                                                steepest = steepness;
                                                hlcliff[row, col] = hlcliff[row + i, col + j]; tempsllcliff = sllcliff[row + i, col + j];
                                                ledges[row, col] = ledges[row + i, col + j];
                                            }
                                        }

                                    }
                                }
                            }
                        }
                        //we now have an updated hhcliff, so we can also update slhcliff
                        sllcliff[row, col] = hlcliff[row, col] / (steepdist + hlcliff[row, col] / tempsllcliff);
                    }
                }
            }
            Debug.WriteLine("upslope variables calculated");

            //finally, add up ledges and hedges to get nedges
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        nedges[row, col] = ledges[row, col] + hedges[row, col];
                    }
                }
            }

            //now write all these rasters to ascii:
            out_double("ledgeheights.asc", ledgeheight);
            out_double("nedges.asc", nedges);
            out_double("hedges.asc", hedges);
            out_double("ledges.asc", ledges);
            out_double("hhcliff.asc", hhcliff);
            out_double("hlcliff.asc", hlcliff);
            out_double("slhcliff.asc", slhcliff);
            out_double("sllcliff.asc", sllcliff);
            Debug.WriteLine("variables exported to ASCII");
        }
        #endregion

        #region initialisation code

        void initialize_once_testing()
        {
            if (daily_water.Checked && input_data_error == false)
            {
                try
                {
                    filename = this.dailyP.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    // Debug.WriteLine("P_all record created successfully");

                    int namelength = filename.Length;
                    string fn = filename.Substring(0, (namelength - 4));
                    filename = fn + "_sc" + P_scen + ".csv";

                    read_record(filename, P_all);
                    // Debug.WriteLine("P_all read successfully");

                    //filename = this.dailyET0.Text;
                    //if (memory_records_d == false) { makedailyrecords(filename); }
                    //read_record(filename, ET0_all);
                    //Debug.WriteLine("ET0_all read successfully");

                    filename = this.dailyD.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, D_all);
                    // Debug.WriteLine("D_all read successfully");

                    filename = this.dailyT_avg.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tavg_all);
                    // Debug.WriteLine("Tavg_all read successfully");

                    filename = this.dailyT_min.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmin_all);
                    // Debug.WriteLine("Tmin_all read successfully");

                    filename = this.dailyT_max.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmax_all);
                    // Debug.WriteLine("Tmax_all read successfully");


                    Array.Clear(Ra_rcm, 0, Ra_rcm.Length); //Ra_rcm = new double[nr, nc, 12];
                    Array.Clear(OFy_m, 0, OFy_m.Length); //OFy_m = new double[nr, nc, 10]; // 0: outflow, 1:8 flow to neighbours, 9: inflow
                    Array.Clear(Iy, 0, Iy.Length); //Iy = new double[nr, nc];
                    Array.Clear(waterfactor, 0, waterfactor.Length); //waterfactor = new double[nr, nc];
                    Array.Clear(pond_y, 0, pond_y.Length); //pond_y = new double[nr, nc];
                    Array.Clear(outflow_y, 0, outflow_y.Length);// outflow_y = new double[nr, nc];
                    Array.Clear(total_outflow_y, 0, total_outflow_y.Length); //total_outflow_y = new double[nr, nc];
                    Array.Clear(water_balance_m, 0, water_balance_m.Length); //water_balance_m = new double[nr, nc, 5]; // 1: rainfall, 2: actual ET, 3: runon, 4: runoff, 5: I    //where else is this reference ???
                    Array.Clear(ETay, 0, ETay.Length); //ETay = new double[nr, nc];
                    Array.Clear(ET0y, 0, ET0y.Length);// ET0y = new double[nr, nc];
                    Array.Clear(veg_correction_factor, 0, veg_correction_factor.Length); //veg_correction_factor = new double[nr, nc];
                    Array.Clear(waterflow_m3, 0, waterflow_m3.Length); //waterflow_m3 = new double[nr, nc];
                    Array.Clear(vegetation_type, 0, vegetation_type.Length); //vegetation_type = new int[nr, nc];

                    for (int row = 0; row < nr; row++)
                    {
                        for (int col = 0; col < nc; col++)
                        {
                            veg_correction_factor[row, col] = 1;
                            vegetation_type[row, col] = 0;
                        }
                    }
                    /*
                    Ks_topsoil_mh = new double[nr, nc];
                    Ks_md = new double[nr, nc, max_soil_layers];
                    stagdepth = new double[nr, nc];
                    */
                    snow_m = 0;
                    snow_start_m = 0;
                    snowfall_m = 0;
                    snowmelt_factor_mTd = Convert.ToDouble(snowmelt_factor_textbox.Text);
                    snow_threshold_C = Convert.ToDouble(snow_threshold_textbox.Text);
                }
                catch { Debug.WriteLine(" problem preparing for hourly water balance "); }
            }
            if (input_data_error == false)
            {
                if (check_space_soildepth.Checked)
                {
                    filename = this.soildepth_input_filename_textbox.Text;
                    read_double(filename, soildepth_m);
                    Debug.WriteLine("read soildepth");
                }
                if (check_space_till_fields.Checked)
                {
                    filename = this.tillfields_input_filename_textbox.Text;
                    read_integer(filename, tillfields);
                    Debug.WriteLine("read tillfields");
                }
                if (check_space_landuse.Checked)
                {
                    filename = this.landuse_input_filename_textbox.Text;
                    read_integer(filename, landuse);
                    Debug.WriteLine("read landuse");
                }
                if (check_space_evap.Checked)
                {
                    filename = this.evap_input_filename_textbox.Text;
                    read_double(filename, evapotranspiration);
                }
                if (check_space_infil.Checked)
                {
                    filename = this.infil_input_filename_textbox.Text;
                    read_double(filename, infil);
                }
                if (check_space_rain.Checked)
                {
                    filename = this.rain_input_filename_textbox.Text;
                    read_double(filename, rain);
                }
                // If required, read timeseries instead.
                if (check_time_landuse.Checked)
                {
                    filename = this.landuse_input_filename_textbox.Text;
                    read_integer(filename, landuse);
                }
                if (check_time_evap.Checked)
                {
                    filename = this.evap_input_filename_textbox.Text;
                    if (memory_records == false) { makerecords(filename); }
                    read_record(filename, evap_record);
                }
                if (check_time_infil.Checked)
                {
                    filename = this.infil_input_filename_textbox.Text;
                    if (memory_records == false) { makerecords(filename); }
                    read_record(filename, infil_record);
                }
                if (check_time_rain.Checked)
                {
                    filename = this.rain_input_filename_textbox.Text;
                    if (memory_records == false) { makerecords(filename); }
                    read_record(filename, rainfall_record);
                }
                if (check_time_T.Checked)
                {
                    filename = this.temp_input_filename_textbox.Text;
                    if (memory_records == false) { makerecords(filename); }
                    read_record(filename, temp_record);
                }
                if (check_time_till_fields.Checked)
                {
                    filename = this.tillfields_input_filename_textbox.Text;
                    if (memory_records == false) { makerecords(filename); }
                    read_record(filename, till_record);
                    Debug.WriteLine("Tillage time parameters read");
                }
            }


            try
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        dz_soil[row, col] = 0;
                        if (Creep_Checkbox.Checked) { sum_creep_grid[row, col] = 0; creep[row, col] = 0; }
                        if (Solifluction_checkbox.Checked) { sum_solifluction[row, col] = 0; }
                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false) { sum_water_erosion[row, col] = 0; total_sed_export = 0; }
                        if (treefall_checkbox.Checked) { dz_treefall[row, col] = 0; treefall_count[row, col] = 0; }
                        if (Biological_weathering_checkbox.Checked) { sum_biological_weathering[row, col] = 0; }
                        if (Frost_weathering_checkbox.Checked) { sum_frost_weathering[row, col] = 0; }
                        if (Tillage_checkbox.Checked) { sum_tillage[row, col] = 0; total_sum_tillage = 0; dz_till_bd[row, col] = 0; }
                        if (Landslide_checkbox.Checked) { sum_landsliding[row, col] = 0; total_sum_tillage = 0; }
                        if (soildepth_m[row, col] < 0.0 && soildepth_m[row, col] != -9999) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                        if (uplift_active_checkbox.Checked) { sum_uplift[row, col] = 0; total_sum_uplift = 0; }
                        if (tilting_active_checkbox.Checked) { sum_tilting[row, col] = 0; total_sum_tilting = 0; }
                        if (check_space_soildepth.Checked != true) { soildepth_m[row, col] = soildepth_value; }
                        if (check_space_till_fields.Checked != true && Tillage_checkbox.Checked)
                        {
                            tillfields[row, col] = 1;

                        }

                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false)
                        {
                            K_fac[row, col] = advection_erodibility; P_fac[row, col] = P_act;
                        } //WVG K_fac matrix initialisation is needed when landuse is disabled

                        if (Water_ero_checkbox.Checked && check_space_landuse.Checked == true)
                        {
                            //currently, this will throw an exception if landuse is actually spatial //development required //ArT
                            if (landuse[row, col] == 1)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 2)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 3)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 4)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 5)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 6)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 7)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 8)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 9)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 10)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Dep_textbox.Text);
                            }
                        }
                    } //for
                } //for

                initialise_soil();
                if (findnegativetexture())
                {
                    Debug.WriteLine("err_ini1");
                    // Debugger.Break(); 
                }

                // displaysoil(0, 0);
                // Debug.WriteLine("Total catchment mass = " + total_catchment_mass());

                //displaysoil(50, 0);
                //writesoil(0, 0);
            } //try
            catch { Debug.WriteLine(" problem assigning starting values to matrices "); }

            if (fill_sinks_before_checkbox.Checked)
            {
                try
                {
                    findsinks();
                    if (numberofsinks > 0)
                    {
                        searchdepressions();
                        //define_fillheight_new();
                        for (int row = 0; row < nr; row++)
                        {
                            for (int col = 0; col < nc; col++)
                            {
                                if (dtm[row, col] < dtmfill_A[row, col] && dtm[row, col] != -9999)
                                {
                                    dtm[row, col] = dtmfill_A[row, col];
                                }
                            }
                        }
                    }
                }
                catch { Debug.WriteLine(" problem with sink definition "); }
            }

            // Timeseries preparation
            try
            {
                number_of_outputs = 0;
                if (timeseries.timeseries_cell_waterflow_check.Checked) { timeseries_order[1] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_cell_altitude_check.Checked) { timeseries_order[2] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_net_ero_check.Checked) { timeseries_order[3] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_dep_check.Checked) { timeseries_order[4] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_erosion_check.Checked) { timeseries_order[5] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_waterflow_check.Checked) { timeseries_order[6] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_SDR_check.Checked) { timeseries_order[7] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_average_alt_check.Checked) { timeseries_order[8] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_dep_check.Checked) { timeseries_order[9] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_ero_check.Checked) { timeseries_order[10] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_evap_check.Checked) { timeseries_order[11] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_infil_check.Checked) { timeseries_order[12] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_outflow_check.Checked) { timeseries_order[13] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_rain_check.Checked) { timeseries_order[14] = number_of_outputs; number_of_outputs++; }

                if (timeseries.timeseries_outflow_cells_checkbox.Checked) { timeseries_order[15] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[16] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[17] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[18] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[19] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[20] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[21] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[22] = number_of_outputs; number_of_outputs++; }

                if (timeseries.total_phys_weath_checkbox.Checked) { timeseries_order[23] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_chem_weath_checkbox.Checked) { timeseries_order[24] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_formed_checkbox.Checked) { timeseries_order[25] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_eluviated_checkbox.Checked) { timeseries_order[26] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_mass_bioturbed_checkbox.Checked) { timeseries_order[27] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_OM_input_checkbox.Checked) { timeseries_order[28] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_average_soilthickness_checkbox.Checked) { timeseries_order[29] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { timeseries_order[30] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_coarser_checkbox.Checked) { timeseries_order[31] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_soil_depth_checkbox.Checked) { timeseries_order[32] = number_of_outputs; number_of_outputs++; }

                if (timeseries.timeseries_soil_mass_checkbox.Checked) { timeseries_order[33] = number_of_outputs; number_of_outputs++; }
                Debug.WriteLine("timeseries preparation was succesful");
            }
            catch { Debug.WriteLine("timeseries preparation was unsuccesful"); }

            //if ((Final_output_checkbox.Checked && t == end_time) || (Regular_output_checkbox.Checked && (t % (int.Parse(Box_years_output.Text)) == 0)))
            //Debug.WriteLine(" successfully ended initialisations  ");
        }
        void initialise_once()        //fills the inputgrids with values
        {

            if (daily_water.Checked && input_data_error == false)
            {
                try
                {
                    filename = this.dailyP.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    // Debug.WriteLine("P_all record created successfully");

                    int namelength = filename.Length;
                    string fn = filename.Substring(0, (namelength - 4));
                    filename = fn + "_sc" + P_scen + ".csv";

                    read_record(filename, P_all);
                    // Debug.WriteLine("P_all read successfully");

                    //filename = this.dailyET0.Text;
                    //if (memory_records_d == false) { makedailyrecords(filename); }
                    //read_record(filename, ET0_all);
                    //Debug.WriteLine("ET0_all read successfully");

                    filename = this.dailyD.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, D_all);
                    // Debug.WriteLine("D_all read successfully");

                    filename = this.dailyT_avg.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tavg_all);
                    // Debug.WriteLine("Tavg_all read successfully");

                    filename = this.dailyT_min.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmin_all);
                    // Debug.WriteLine("Tmin_all read successfully");

                    filename = this.dailyT_max.Text;
                    if (memory_records_d == false) { makedailyrecords(filename); }
                    read_record(filename, Tmax_all);
                    // Debug.WriteLine("Tmax_all read successfully");

                    //// Hargreaves extraterrestrial radiation
                    //// http://www.fao.org/docrep/X0490E/x0490e07.htm#radiation
                    //double dr, delta, ws;
                    //double lat_st = Math.PI/180*(System.Convert.ToDouble(latitude_deg.Text)+ System.Convert.ToDouble(latitude_min.Text) / 60); // latitude in radians

                    //for (double day_ra = 1; day_ra <= 365; day_ra++)
                    //{
                    //    dr = 1 + 0.033 * Math.Cos(2 * Math.PI * (day_ra / 365)); //inverse relative distance Earth-Sun
                    //    delta = 0.409 * Math.Sin(2 * Math.PI * (day_ra / 365) - 1.39); //solar declination [rad].
                    //    ws = Math.Acos(-Math.Tan(lat_st) * Math.Tan(delta)); // sunset hour angle [rad]
                    //    Ra_ann[Convert.ToInt16(day_ra - 1)] = (24 * 60 / Math.PI * 0.082 * dr * (ws * Math.Sin(lat_st) * Math.Sin(delta) + Math.Cos(lat_st) * Math.Cos(delta) * Math.Sin(ws))) * 0.408; // extraterrestrial radiation [mm d-1]
                    //}

                    Ra_rcm = new double[nr, nc, 12];
                    OFy_m = new double[nr, nc, 10]; // 0: outflow, 1:8 flow to neighbours, 9: inflow
                    Iy = new double[nr, nc];
                    waterfactor = new double[nr, nc];
                    pond_y = new double[nr, nc];
                    outflow_y = new double[nr, nc];
                    total_outflow_y = new double[nr, nc];
                    water_balance_m = new double[nr, nc, 5]; // 1: rainfall, 2: actual ET, 3: runon, 4: runoff, 5: I
                    ETay = new double[nr, nc];
                    ET0y = new double[nr, nc];
                    veg_correction_factor = new double[nr, nc];
                    waterflow_m3 = new double[nr, nc];
                    vegetation_type = new int[nr, nc];

                    for (int row = 0; row < nr; row++)
                    {
                        for (int col = 0; col < nc; col++)
                        {
                            veg_correction_factor[row, col] = 1;
                            vegetation_type[row, col] = 0;
                        }
                    }

                    Ks_topsoil_mh = new double[nr, nc];
                    Ks_md = new double[nr, nc, max_soil_layers];
                    stagdepth = new double[nr, nc];
                    snow_m = 0;
                    snow_start_m = 0;
                    snowfall_m = 0;
                    snowmelt_factor_mTd = Convert.ToDouble(snowmelt_factor_textbox.Text);
                    snow_threshold_C = Convert.ToDouble(snow_threshold_textbox.Text);
                    // snowmelt factor now assumed to be 0.004 m per degree per day, as a mean from the following paper: Hock 2003, https://www.sciencedirect.com/science/article/pii/S0022169403002579#BIB50
                    // DEVELOP I didn't take the correct parameter (DDF instead of Fm, see paper). Change to right parameter based on the paper of Gottlieb, 1980. Other developments are varying melt factors, based on month, incoming radiation etc. (See Hock 2003)
                }
                catch { Debug.WriteLine(" problem preparing for hourly water balance "); }
            }

            if (check_space_soildepth.Checked && input_data_error == false)
            {
                filename = this.soildepth_input_filename_textbox.Text;
                read_double(filename, soildepth_m);
                Debug.WriteLine("read soildepth");
            }
            if (check_space_till_fields.Checked && input_data_error == false)
            {
                filename = this.tillfields_input_filename_textbox.Text;
                read_integer(filename, tillfields);
                Debug.WriteLine("read tillfields");
            }
            if (check_space_landuse.Checked && input_data_error == false)
            {
                filename = this.landuse_input_filename_textbox.Text;
                read_integer(filename, landuse);
                Debug.WriteLine("read landuse");
            }
            if (check_space_evap.Checked && input_data_error == false)
            {
                filename = this.evap_input_filename_textbox.Text;
                read_double(filename, evapotranspiration);
            }
            if (check_space_infil.Checked && input_data_error == false)
            {
                filename = this.infil_input_filename_textbox.Text;
                read_double(filename, infil);
            }
            if (check_space_rain.Checked && input_data_error == false)
            {
                filename = this.rain_input_filename_textbox.Text;
                read_double(filename, rain);
            }
            // If required, read timeseries instead.
            if (check_time_landuse.Checked && input_data_error == false)
            {
                filename = this.landuse_input_filename_textbox.Text;
                read_integer(filename, landuse);
            }
            if (check_time_evap.Checked && input_data_error == false)
            {
                filename = this.evap_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, evap_record);
            }
            if (check_time_infil.Checked && input_data_error == false)
            {
                filename = this.infil_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, infil_record);
            }
            if (check_time_rain.Checked && input_data_error == false)
            {
                filename = this.rain_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, rainfall_record);
            }
            if (check_time_T.Checked && input_data_error == false)
            {
                filename = this.temp_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, temp_record);
            }

            if (check_time_till_fields.Checked && input_data_error == false)
            {
                filename = this.tillfields_input_filename_textbox.Text;
                if (memory_records == false) { makerecords(filename); }
                read_record(filename, till_record);
                Debug.WriteLine("Tillage time parameters read");
            }

            try
            {
                // Debug.WriteLine(" assigning starting values for geomorph  ");
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        dz_soil[row, col] = 0;
                        if (Creep_Checkbox.Checked) { sum_creep_grid[row, col] = 0; creep[row, col] = 0; }
                        if (Solifluction_checkbox.Checked) { sum_solifluction[row, col] = 0; }
                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false) { sum_water_erosion[row, col] = 0; total_sed_export = 0; }
                        if (treefall_checkbox.Checked) { dz_treefall[row, col] = 0; treefall_count[row, col] = 0; }
                        if (Biological_weathering_checkbox.Checked) { sum_biological_weathering[row, col] = 0; }
                        if (Frost_weathering_checkbox.Checked) { sum_frost_weathering[row, col] = 0; }
                        if (Tillage_checkbox.Checked) { sum_tillage[row, col] = 0; total_sum_tillage = 0; dz_till_bd[row, col] = 0; }
                        if (Landslide_checkbox.Checked) { sum_landsliding[row, col] = 0; total_sum_tillage = 0; }
                        if (soildepth_m[row, col] < 0.0 && soildepth_m[row, col] != -9999) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                        if (uplift_active_checkbox.Checked) { sum_uplift[row, col] = 0; total_sum_uplift = 0; }
                        if (tilting_active_checkbox.Checked) { sum_tilting[row, col] = 0; total_sum_tilting = 0; }
                        if (check_space_soildepth.Checked != true) { soildepth_m[row, col] = soildepth_value; }
                        if (check_space_till_fields.Checked != true && Tillage_checkbox.Checked)
                        {
                            tillfields[row, col] = 1;

                        }

                        if (Water_ero_checkbox.Checked && only_waterflow_checkbox.Checked == false)
                        {
                            K_fac[row, col] = advection_erodibility; P_fac[row, col] = P_act;
                        } //WVG K_fac matrix initialisation is needed when landuse is disabled

                        if (Water_ero_checkbox.Checked && check_space_landuse.Checked == true)
                        {
                            //currently, this will throw an exception if landuse is actually spatial //development required //ArT
                            if (landuse[row, col] == 1)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU1_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 2)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU2_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 3)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU3_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 4)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU4_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 5)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU5_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 6)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU6_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 7)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU7_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 8)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU8_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 9)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU9_Dep_textbox.Text);
                            }
                            if (landuse[row, col] == 10)
                            {
                                infil[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Inf_textbox.Text);
                                evapotranspiration[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Evap_textbox.Text);
                                K_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Ero_textbox.Text);
                                P_fac[row, col] *= System.Convert.ToDouble(landuse_determinator.LU10_Dep_textbox.Text);
                            }
                        }
                    } //for
                } //for
                  // Debug.WriteLine(" assigned starting values for geomorph  ");
                  // Debug.WriteLine("before initialise soil {0}", texture_kg[0, 0, 0, 2]);

                initialise_soil();
                //Debug.WriteLine("after initialise soil {0}", texture_kg[0, 0, 0, 2]);
                if (findnegativetexture())
                {
                    Debug.WriteLine("err_ini1");
                    // Debugger.Break(); 
                }

                // displaysoil(0, 0);
                // Debug.WriteLine("Total catchment mass = " + total_catchment_mass());

                //displaysoil(50, 0);
                //writesoil(0, 0);
            } //try
            catch { Debug.WriteLine(" problem assigning starting values to matrices "); }

            if (fill_sinks_before_checkbox.Checked)
            {
                try
                {
                    findsinks();
                    if (numberofsinks > 0)
                    {
                        searchdepressions();
                        //define_fillheight_new();
                        for (int row = 0; row < nr; row++)
                        {
                            for (int col = 0; col < nc; col++)
                            {
                                if (dtm[row, col] < dtmfill_A[row, col] && dtm[row, col] != -9999)
                                {
                                    dtm[row, col] = dtmfill_A[row, col];
                                }
                            }
                        }
                    }
                }
                catch { Debug.WriteLine(" problem with sink definition "); }
            }
            // Timeseries preparation
            try
            {
                number_of_outputs = 0;
                if (timeseries.timeseries_cell_waterflow_check.Checked) { timeseries_order[1] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_cell_altitude_check.Checked) { timeseries_order[2] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_net_ero_check.Checked) { timeseries_order[3] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_dep_check.Checked) { timeseries_order[4] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_erosion_check.Checked) { timeseries_order[5] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_waterflow_check.Checked) { timeseries_order[6] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_SDR_check.Checked) { timeseries_order[7] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_average_alt_check.Checked) { timeseries_order[8] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_dep_check.Checked) { timeseries_order[9] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_ero_check.Checked) { timeseries_order[10] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_evap_check.Checked) { timeseries_order[11] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_infil_check.Checked) { timeseries_order[12] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_outflow_check.Checked) { timeseries_order[13] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_total_rain_check.Checked) { timeseries_order[14] = number_of_outputs; number_of_outputs++; }

                if (timeseries.timeseries_outflow_cells_checkbox.Checked) { timeseries_order[15] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[16] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[17] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[18] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[19] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[20] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[21] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_sedexport_checkbox.Checked) { timeseries_order[22] = number_of_outputs; number_of_outputs++; }

                if (timeseries.total_phys_weath_checkbox.Checked) { timeseries_order[23] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_chem_weath_checkbox.Checked) { timeseries_order[24] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_formed_checkbox.Checked) { timeseries_order[25] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_fine_eluviated_checkbox.Checked) { timeseries_order[26] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_mass_bioturbed_checkbox.Checked) { timeseries_order[27] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_OM_input_checkbox.Checked) { timeseries_order[28] = number_of_outputs; number_of_outputs++; }
                if (timeseries.total_average_soilthickness_checkbox.Checked) { timeseries_order[29] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked) { timeseries_order[30] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_coarser_checkbox.Checked) { timeseries_order[31] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_soil_depth_checkbox.Checked) { timeseries_order[32] = number_of_outputs; number_of_outputs++; }
                if (timeseries.timeseries_soil_mass_checkbox.Checked) { timeseries_order[33] = number_of_outputs; number_of_outputs++; }
                Debug.WriteLine("timeseries preparation was really succesful");
            }
            catch { Debug.WriteLine("timeseries preparation was unsuccesful"); }

            //if ((Final_output_checkbox.Checked && t == end_time) || (Regular_output_checkbox.Checked && (t % (int.Parse(Box_years_output.Text)) == 0)))
            //Debug.WriteLine(" successfully ended initialisations  ");
        }

        void initialise_soil_standard()
        {
            double depth_m;
            Debug.WriteLine("initialising soil");
            // At this point, we know the input soildepth at every location (may be zero). 
            // We do not yet know how many layers that corresponds to.
            // If soildepth is not zero, we will calculate the number of layers and assign thicknesses and material to them.
            int soil_layer, texture_class;
            upper_particle_size[0] = Convert.ToDouble(upper_particle_coarse_textbox.Text);
            upper_particle_size[1] = Convert.ToDouble(upper_particle_sand_textbox.Text);
            upper_particle_size[2] = Convert.ToDouble(upper_particle_silt_textbox.Text);
            upper_particle_size[3] = Convert.ToDouble(upper_particle_clay_textbox.Text);
            upper_particle_size[4] = Convert.ToDouble(upper_particle_fine_clay_textbox.Text);
            //calculate bulk density so that we know how much kg of material goes into a layer.  //ART this will go wrong when there are different textures in different locations, but is faster up until that time.
            double coarsefrac = Convert.ToDouble(soildata.coarsebox.Text) / 100;
            double sandfrac = Convert.ToDouble(soildata.sandbox.Text) / 100;
            double siltfrac = Convert.ToDouble(soildata.siltbox.Text) / 100;
            double clayfrac = Convert.ToDouble(soildata.claybox.Text) / 100;
            double fclayfrac = Convert.ToDouble(soildata.fineclaybox.Text) / 100;
            double location_bd;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    depth_m = 0;
                    if (creep_testing.Checked)
                    {
                        coarsefrac = 0;
                        sandfrac = 1;
                        siltfrac = 0;
                        clayfrac = 0;
                        fclayfrac = 0;

                    }

                    if (soildepth_m[row, col] == 0)
                    {

                        for (soil_layer = 0; soil_layer < max_soil_layers; soil_layer++)
                        {
                            for (texture_class = 0; texture_class < n_texture_classes; texture_class++)
                            {
                                texture_kg[row, col, soil_layer, texture_class] = 0;
                            }
                            young_SOM_kg[row, col, soil_layer] = 0;
                            old_SOM_kg[row, col, soil_layer] = 0;
                            bulkdensity[row, col, soil_layer] = 0;
                            layerthickness_m[row, col, soil_layer] = -1;
                        }
                    }
                    else
                    {

                        //now assign thicknesses and material to layer.
                        double available_soildepth = soildepth_m[row, col];
                        soil_layer = 0;

                        while (available_soildepth > 0)
                        {
                            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=10
                            // daarna     min 50    insteek 100  geen max            n=5
                            // If max_soil_layers is smaller than the sum of the perfect layers in each of the three ' packages' , then we simply make the lowest layer very thick.
                            //if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                            /*
                            if (soil_layer < 40 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.05)
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.05;
                                    available_soildepth -= 0.05;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            */
                            if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.05) //
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.05; // 
                                    available_soildepth -= 0.05;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            if (soil_layer > 9 && soil_layer < 20 && soil_layer < max_soil_layers - 1)
                            {
                                if (available_soildepth > 0.15) // was 0.25
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.15; // was 0.15
                                    available_soildepth -= 0.15;
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }
                            if (soil_layer > 19 && soil_layer < max_soil_layers && soil_layer < max_soil_layers - 1) // Rest
                            {
                                if (available_soildepth > 0.5) // was 1
                                {
                                    layerthickness_m[row, col, soil_layer] = 0.5; // was 1
                                    available_soildepth -= 0.5; // was 1
                                }
                                else
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                            }

                            if (soil_layer == max_soil_layers - 1)
                            {
                                layerthickness_m[row, col, soil_layer] = available_soildepth;
                                available_soildepth = 0;
                            }

                            if (layerthickness_m[row, col, soil_layer] != 0)
                            {
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                location_bd = bulk_density_calc(coarsefrac, sandfrac, siltfrac, clayfrac, fclayfrac, 0, 0, depth_m);
                                depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                texture_kg[row, col, soil_layer, 0] = location_bd * layerthickness_m[row, col, soil_layer] * coarsefrac * dx * dx;   //  kg = kg/m3 * m * kg/kg * m * m
                                texture_kg[row, col, soil_layer, 1] = location_bd * layerthickness_m[row, col, soil_layer] * sandfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 2] = location_bd * layerthickness_m[row, col, soil_layer] * siltfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 3] = location_bd * layerthickness_m[row, col, soil_layer] * clayfrac * dx * dx;
                                texture_kg[row, col, soil_layer, 4] = location_bd * layerthickness_m[row, col, soil_layer] * fclayfrac * dx * dx;
                                bulkdensity[row, col, soil_layer] = location_bd;

                                if (decalcification_checkbox.Checked)
                                {
                                    CO3_kg[row, col, soil_layer] = (location_bd * layerthickness_m[row, col, soil_layer] * dx * dx) * Convert.ToDouble(ini_CaCO3_content.Text) * 40.08 / (40.08 + 60.01); // calculate total CO3: total mass * fraction of soil * fraction of CaCO3 molecule
                                }

                            }
                            if (creep_testing.Checked)
                            {
                                sandfrac -= 0.05;
                                clayfrac += 0.05;

                                sandfrac = Math.Max(sandfrac, 0);
                                clayfrac = Math.Min(clayfrac, 1);
                            }

                            soil_layer++;

                        } // end availabke soil depth > 0
                    } // end else 

                } // end col
            } // end row
              // Debug.WriteLine("initialised soil");

        }  //keep this code even when it's unreferenced

        void initialise_soil()
        {
            double depth_m;
            //Debug.WriteLine("initialising soil");
            // At this point, we know the input soildepth at every location (may be zero). 
            // We do not yet know how many layers that corresponds to.
            // If soildepth is not zero, we will calculate the number of layers and assign thicknesses and material to them.
            int soil_layer, texture_class;
            upper_particle_size[0] = Convert.ToDouble(upper_particle_coarse_textbox.Text);
            upper_particle_size[1] = Convert.ToDouble(upper_particle_sand_textbox.Text);
            upper_particle_size[2] = Convert.ToDouble(upper_particle_silt_textbox.Text);
            upper_particle_size[3] = Convert.ToDouble(upper_particle_clay_textbox.Text);
            upper_particle_size[4] = Convert.ToDouble(upper_particle_fine_clay_textbox.Text);
            //calculate bulk density so that we know how much kg of material goes into a layer.  //ART this will go wrong when there are different textures in different locations, but is faster up until that time.
            double coarsefrac = Convert.ToDouble(soildata.coarsebox.Text) / 100;
            double sandfrac = Convert.ToDouble(soildata.sandbox.Text) / 100;
            double siltfrac = Convert.ToDouble(soildata.siltbox.Text) / 100;
            double clayfrac = Convert.ToDouble(soildata.claybox.Text) / 100;
            double fclayfrac = Convert.ToDouble(soildata.fineclaybox.Text) / 100;
            double location_bd;

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    depth_m = 0;
                    if (creep_testing.Checked)
                    {
                        coarsefrac = 0;
                        sandfrac = 1;
                        siltfrac = 0;
                        clayfrac = 0;
                        fclayfrac = 0;

                    }

                    if (soildepth_m[row, col] == 0)
                    {

                        for (soil_layer = 0; soil_layer < max_soil_layers; soil_layer++)
                        {
                            for (texture_class = 0; texture_class < n_texture_classes; texture_class++)
                            {
                                texture_kg[row, col, soil_layer, texture_class] = 0;
                            }
                            young_SOM_kg[row, col, soil_layer] = 0;
                            old_SOM_kg[row, col, soil_layer] = 0;
                            bulkdensity[row, col, soil_layer] = 0;
                            layerthickness_m[row, col, soil_layer] = -1;
                        }
                    }
                    else
                    {
                        //now assign thicknesses and material to layer.
                        double available_soildepth = soildepth_m[row, col];
                        soil_layer = 0;

                        if (checkbox_layer_thickness.Checked) // MvdM if layer thickness is fixed
                        {
                            while (available_soildepth > 0)
                            {
                                if (soil_layer == max_soil_layers - 1)
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }
                                else
                                {
                                    if (available_soildepth > dz_standard)
                                    {
                                        layerthickness_m[row, col, soil_layer] = dz_standard;
                                        available_soildepth -= dz_standard;
                                    }
                                    else
                                    {
                                        layerthickness_m[row, col, soil_layer] = available_soildepth;
                                        available_soildepth = 0;
                                    }
                                }
                                
                                //now limit layerthicknes to hardlayer limitations if needed
                                if (blocks_active == 1)
                                {
                                    if (dtm[row, col] >= hardlayerelevation_m)
                                    {
                                        double currentdepth = (dtm[row, col] - depth_m - layerthickness_m[row, col, soil_layer]);
                                        if (currentdepth < hardlayerelevation_m && currentdepth > (hardlayerelevation_m - hardlayerthickness_m))
                                        {
                                            layerthickness_m[row, col, soil_layer] = (dtm[row, col] - depth_m) - hardlayerelevation_m;
                                            //Debug.WriteLine(" limited layerthickness and soildepth to account for proximity of hardlayer  in " + row + " " + col);
                                            //Debug.WriteLine(" hardlayerelevation_m " + hardlayerelevation_m + ", " + ((dtm[row, col] - depth_m) - hardlayerelevation_m) + " under the top of this layer");
                                            //Debug.WriteLine(" dtm " + dtm[row, col] + " currentdepth " + currentdepth + " available_soildepth " + available_soildepth + " depth_m " + depth_m);
                                            //Debug.WriteLine(" adapted layerthickness is " + layerthickness_m[row, col, soil_layer]);
                                            available_soildepth = 0;

                                            //this ensures that soils stay thinner on top of hardlayers, and don't continue under them.
                                        }
                                    }
                                }
                                if (layerthickness_m[row, col, soil_layer] != 0)
                                {
                                    depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                    location_bd = bulk_density_calc(coarsefrac, sandfrac, siltfrac, clayfrac, fclayfrac, 0, 0, depth_m);
                                    depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                    texture_kg[row, col, soil_layer, 0] = location_bd * layerthickness_m[row, col, soil_layer] * coarsefrac * dx * dx;   //  kg = kg/m3 * m * kg/kg * m * m
                                    texture_kg[row, col, soil_layer, 1] = location_bd * layerthickness_m[row, col, soil_layer] * sandfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 2] = location_bd * layerthickness_m[row, col, soil_layer] * siltfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 3] = location_bd * layerthickness_m[row, col, soil_layer] * clayfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 4] = location_bd * layerthickness_m[row, col, soil_layer] * fclayfrac * dx * dx;
                                    bulkdensity[row, col, soil_layer] = location_bd;

                                    if (decalcification_checkbox.Checked)
                                    {
                                        CO3_kg[row, col, soil_layer] = (location_bd * layerthickness_m[row, col, soil_layer] * dx * dx) * Convert.ToDouble(ini_CaCO3_content.Text) * 40.08 / (40.08 + 60.01); // calculate total CO3: total mass * fraction of soil * fraction of CaCO3 molecule
                                    }
                                }
                                if (creep_testing.Checked)
                                {
                                    //bool change_creep_testing = true;
                                    //if(max_soil_layers>10 & soil_layer<10)
                                    //{
                                    //    change_creep_testing = false;
                                    //}
                                    //if (change_creep_testing) 
                                    //{
                                    //    sandfrac = 0;
                                    //    clayfrac = 1;
                                    //}
                                    sandfrac -= 1.0 / max_soil_layers;
                                    clayfrac += 1.0 / max_soil_layers;
                                    sandfrac = Math.Max(sandfrac, 0);
                                    clayfrac = Math.Min(clayfrac, 1);
                                }
                                soil_layer++;
                            } // end available soil depth > 0
                        } // end if fixed layer thickness
                        else
                        { // start variable layer thickness
                            while (available_soildepth > 0)
                            {
                                // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=10
                                // daarna     min 50    insteek 100  geen max            n=5
                                // If max_soil_layers is smaller than the sum of the perfect layers in each of the three ' packages' , then we simply make the lowest layer very thick.
                                //if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                                /*
                                if (soil_layer < 40 && soil_layer < max_soil_layers - 1)
                                {
                                    if (available_soildepth > 0.05)
                                    {
                                        layerthickness_m[row, col, soil_layer] = 0.05;
                                        available_soildepth -= 0.05;
                                    }
                                    else
                                    {
                                        layerthickness_m[row, col, soil_layer] = available_soildepth;
                                        available_soildepth = 0;
                                    }
                                }
                                */
                                if (soil_layer < 10 && soil_layer < max_soil_layers - 1)
                                {
                                    if (available_soildepth > 0.05) //
                                    {
                                        layerthickness_m[row, col, soil_layer] = 0.05; // 
                                        available_soildepth -= 0.05;
                                    }
                                    else
                                    {
                                        layerthickness_m[row, col, soil_layer] = available_soildepth;
                                        available_soildepth = 0;
                                    }
                                }
                                if (soil_layer > 9 && soil_layer < 20 && soil_layer < max_soil_layers - 1)
                                {
                                    if (available_soildepth > 0.15) // was 0.25
                                    {
                                        layerthickness_m[row, col, soil_layer] = 0.15; // was 0.15
                                        available_soildepth -= 0.15;
                                    }
                                    else
                                    {
                                        layerthickness_m[row, col, soil_layer] = available_soildepth;
                                        available_soildepth = 0;
                                    }
                                }
                                if (soil_layer > 19 && soil_layer < max_soil_layers && soil_layer < max_soil_layers - 1) // Rest
                                {
                                    if (available_soildepth > 0.5) // was 1
                                    {
                                        layerthickness_m[row, col, soil_layer] = 0.5; // was 1
                                        available_soildepth -= 0.5; // was 1
                                    }
                                    else
                                    {
                                        layerthickness_m[row, col, soil_layer] = available_soildepth;
                                        available_soildepth = 0;
                                    }
                                }

                                if (soil_layer == max_soil_layers - 1)
                                {
                                    layerthickness_m[row, col, soil_layer] = available_soildepth;
                                    available_soildepth = 0;
                                }

                                if (layerthickness_m[row, col, soil_layer] != 0)
                                {
                                    depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                    location_bd = bulk_density_calc(coarsefrac, sandfrac, siltfrac, clayfrac, fclayfrac, 0, 0, depth_m);
                                    depth_m += layerthickness_m[row, col, soil_layer] / 2;
                                    texture_kg[row, col, soil_layer, 0] = location_bd * layerthickness_m[row, col, soil_layer] * coarsefrac * dx * dx;   //  kg = kg/m3 * m * kg/kg * m * m
                                    texture_kg[row, col, soil_layer, 1] = location_bd * layerthickness_m[row, col, soil_layer] * sandfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 2] = location_bd * layerthickness_m[row, col, soil_layer] * siltfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 3] = location_bd * layerthickness_m[row, col, soil_layer] * clayfrac * dx * dx;
                                    texture_kg[row, col, soil_layer, 4] = location_bd * layerthickness_m[row, col, soil_layer] * fclayfrac * dx * dx;
                                    bulkdensity[row, col, soil_layer] = location_bd;

                                    if (decalcification_checkbox.Checked)
                                    {
                                        CO3_kg[row, col, soil_layer] = (location_bd * layerthickness_m[row, col, soil_layer] * dx * dx) * Convert.ToDouble(ini_CaCO3_content.Text) * 40.08 / (40.08 + 60.01); // calculate total CO3: total mass * fraction of soil * fraction of CaCO3 molecule
                                    }
                                }
                                if (creep_testing.Checked)
                                {
                                    sandfrac -= 0.05;
                                    clayfrac += 0.05;

                                    sandfrac = Math.Max(sandfrac, 0);
                                    clayfrac = Math.Min(clayfrac, 1);
                                }

                                soil_layer++;

                            } // end availabke soil depth > 0
                        }    // end variable layer thickness              
                    } // end else 
                    soildepth_m[row, col] = total_soil_thickness(row, col);

                } // end col
            } // end row
              //Debug.WriteLine("initialised soil");
            if(OSL_checkbox.Checked)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        for (int lay = 0; lay < max_soil_layers; lay++)
                        {
                            int ngrains_layer = Convert.ToInt32(Math.Round(ngrains_kgsand_m2 * texture_kg[row, col, lay, 1] / (dx * dx))); // grains per kg/m2 of sand
                            OSL_grainages[row, col, lay] = new int[ngrains_layer];
                            OSL_depositionages[row, col, lay] = new int[ngrains_layer];
                            OSL_surfacedcount[row, col, lay] = new int[ngrains_layer];

                            for (int grain = 0; grain < ngrains_layer; grain++)
                            {
                                OSL_grainages[row, col, lay][grain] = start_age;
                                OSL_depositionages[row, col, lay][grain] = start_age;
                            }
                        }
                    }
                }
            }
           
        } // anngepast voor standaard diktes

        void initialise_every_till()
        {
            if (check_time_till_fields.Checked && check_space_till_fields.Checked == false)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        tillfields[row, col] = 1 * till_record[t];
                    }
                }

            }
        }

        void initialise_every()                         //fills the inputgrids with values
        {
            int corrected_t;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    // time runs from 1 to end_time - compensate for that when taking values from records
                    // also compensate for records shorter than end_time
                    if (check_time_rain.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > rainfall_record.Length) { corrected_t -= rainfall_record.Length; }

                        rain_value_m = 0.001 * rainfall_record[corrected_t]; //from mm (in record) to m (LORICA)   // mvdm -1 weggehaald van corrected_t, leidde tot OutOfRange errors
                                                                             // changed rain[row, col] to rain_value_m, due to errors, this is not spatial, but temporal variation
                                                                             //this should be improved for when rainfall is not also spatially variable //ArT
                    }
                    if (check_time_infil.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > infil_record.Length) { corrected_t -= infil_record.Length; }
                        infil_value_m = 0.001 * infil_record[corrected_t];
                    }
                    if (check_time_evap.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > evap_record.Length) { corrected_t -= evap_record.Length; }
                        evap_value_m = 0.001 * evap_record[corrected_t];
                    }

                    if (check_time_T.Checked)
                    {
                        corrected_t = t;
                        while (corrected_t > temp_record.Length) { corrected_t -= temp_record.Length; }

                        rain_value_m = 0.001 * temp_record[corrected_t]; //from mm (in record) to m (LORICA)   // mvdm -1 weggehaald van corrected_t, leidde tot OutOfRange errors
                        temp_value_C = temp_record[corrected_t];
                        // changed rain[row, col] to rain_value_m, due to errors, this is not spatial, but temporal variation
                        //this should be improved for when rainfall is not also spatially variable //ArT
                    }

                    if (annual_output_checkbox.Checked)
                    {
                        dz_soil[row, col] = 0;
                        if (Creep_Checkbox.Checked) { sum_creep_grid[row, col] = 0; creep[row, col] = 0; }
                        if (treefall_checkbox.Checked) { dz_treefall[row, col] = 0; treefall_count[row, col] = 0; }
                        if (Solifluction_checkbox.Checked) { sum_solifluction[row, col] = 0; }
                        if (Water_ero_checkbox.Checked) { sum_water_erosion[row, col] = 0; }
                        if (Biological_weathering_checkbox.Checked) { sum_biological_weathering[row, col] = 0; }
                        if (Frost_weathering_checkbox.Checked) { sum_frost_weathering[row, col] = 0; }
                        if (Tillage_checkbox.Checked) { sum_tillage[row, col] = 0; total_sum_tillage = 0; }
                        if (soildepth_m[row, col] < 0.0) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                    }
                    if (soildepth_m[row, col] < 0.0) { soildepth_error += soildepth_m[row, col]; soildepth_m[row, col] = 0; }
                    if (Water_ero_checkbox.Checked) { waterflow_m3[row, col] = 0.0; }

                } //for
            } //for

            if (fill_sinks_during_checkbox.Checked)
            {
                findsinks();
                if (numberofsinks > 0)
                {
                    searchdepressions();
                    //define_fillheight_new();
                    for (int row = 0; row < nr; row++)
                    {
                        for (int col = 0; col < nc; col++)
                        {
                            if (dtm[row, col] < dtmfill_A[row, col] && dtm[row, col] != -9999)
                            {
                                dtmchange_m[row, col] += dtmfill_A[row, col] - dtm[row, col];
                                dtm[row, col] = dtmfill_A[row, col];
                            }
                        }
                    }
                }
            }
            //Debug.WriteLine("initialised every");
        }

        #endregion

        #region Hydrology code

        int[] P_all, ET0_all, Tavg_all, Tmin_all, Tmax_all, D_all;
        double[] Py = new double[365], ET0_m = new double[12];
        int[] Tavgy = new int[365], Tminy = new int[365], Tmaxy = new int[365], Dy = new int[365];
        // int[] D_all = new int[123], Dy = new int[365];
        double[,,] OFy_m, Ks_md, water_balance_m, Ra_rcm;
        double[,] Iy, ROy, Ks_topsoil_mh, pond_d, pond_y, outflow_y, stagdepth, waterfactor, total_outflow_y, ETay, ET0y;
        int[] month = new int[12] { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
        int[] monthcum = new int[12] { 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };
        int[] midmonthdays = new int[] { 16, 46, 75, 106, 136, 167, 197, 228, 259, 289, 320, 350 };
        double Ks_min_mh, Ks_max_mh, snow_m, snow_start_m, snowfall_m, snowmelt_factor_mTd, snow_threshold_C, Pduringsnowmelt; // snow thickness is now constant in space. develop: spatially varying effects of snowfall. snowmelt factor in m T-1 d-1
                                                                                                                               // snowmelt modeling in Hock, 2003, Eq. 2: https://www.sciencedirect.com/science/article/pii/S0022169403002579#BIB50
                                                                                                                               // read data into P_all  etc
        DateTime ponding_start;

        double local_solar_radiation(double slope_rad, double aspect_rad, int month)
        {
            //Debug.WriteLine("lsr1");
            // SOURCE: Swift 1976: Algorithm for solar radiation on mountain slopes
            // https://doi.org/10.1029/WR012i001p00108
            double lat_rad, L1_Ra, L2_Ra, D1_Ra, D_Ra, E_Ra, R0_Ra, R1_Ra, R4_Ra, T_Ra, T7_Ra, T6_Ra, T3_Ra, T2_Ra, T1_Ra, T0_Ra, acos_in;

            R0_Ra = 1.95 * 0.041868; // Convert from cal/cm2/min to MJ/m2/min
            lat_rad = Math.PI / 180 * (System.Convert.ToDouble(latitude_deg.Text) + System.Convert.ToDouble(latitude_min.Text) / 60); // latitude [rad]
            L1_Ra = Math.Asin(Math.Cos(slope_rad) * Math.Sin(lat_rad) + Math.Sin(slope_rad) * Math.Cos(lat_rad) * Math.Cos(aspect_rad)); // equivalent latitude [rad]
            D1_Ra = Math.Cos(slope_rad) * Math.Cos(lat_rad) - Math.Sin(slope_rad) * Math.Sin(lat_rad) * Math.Cos(aspect_rad);
            if (D1_Ra == 0) { D1_Ra = 1E-10; }
            L2_Ra = Math.Atan(Math.Sin(slope_rad) * Math.Sin(aspect_rad) / D1_Ra);
            if (D1_Ra < 0) { L2_Ra += Math.PI; }

            int day_Ra = midmonthdays[month];

            D_Ra = 0.4 * Math.PI / 180 - 23.3 * Math.PI / 180 * Math.Cos((day_Ra + 10) * Math.PI / 180 * 0.986);
            E_Ra = 1 - 0.0167 * Math.Cos((day_Ra - 3) * Math.PI / 180 * 0.986);
            R1_Ra = 60 * R0_Ra / (E_Ra * E_Ra);

            acos_in = -Math.Tan(L1_Ra) * Math.Tan(D_Ra);
            if (acos_in > 1) { acos_in = 1; }
            T_Ra = Math.Acos(acos_in);
            T7_Ra = T_Ra - L2_Ra;
            T6_Ra = -T_Ra - L2_Ra;

            acos_in = -Math.Tan(lat_rad) * Math.Tan(D_Ra);
            if (acos_in > 1) { acos_in = 1; }
            T_Ra = Math.Acos(acos_in);
            T1_Ra = T_Ra;
            T0_Ra = -T_Ra;
            if (T7_Ra < T1_Ra) { T3_Ra = T7_Ra; } else { T3_Ra = T1_Ra; }
            if (T6_Ra > T0_Ra) { T2_Ra = T6_Ra; } else { T2_Ra = T0_Ra; }

            R4_Ra = R1_Ra * (Math.Sin(D_Ra) * Math.Sin(L1_Ra) * (T3_Ra - T2_Ra) * 12 / Math.PI + Math.Cos(D_Ra) * Math.Cos(L1_Ra) * (Math.Sin(T3_Ra + L2_Ra) - Math.Sin(T2_Ra + L2_Ra)) * 12 / Math.PI);
            //Debug.WriteLine("lsr2");
            if (R4_Ra < 0)
            {
                Debug.WriteLine("err_lsr1");
            }
            return (R4_Ra * 0.408 / 1000); // convert to m/d
        }

        void update_solar_radiation()
        {
            if (t % 100 == 0)
            {
                update_slope_and_aspect(); // updates slopemap slopeAnalysis [rad] and aspect [rad]
            }

            for (int hrow = 0; hrow < nr; hrow++)
            {
                for (int hcol = 0; hcol < nc; hcol++)
                {
                    if (dtm[hrow, hcol] != -9999)
                    {
                        for (int mo = 0; mo < 12; mo++)
                        {
                            //Debug.WriteLine("sr1");
                            // Fill 3D matrix with local monthly ET
                            Ra_rcm[hrow, hcol, mo] = local_solar_radiation(slopeAnalysis[hrow, hcol], aspect[hrow, hcol], mo);
                            //Debug.WriteLine("sr2");
                        }

                    }
                }
            }
        }

        double total_snow_melt, total_water_flow;
        void water_balance()
        {
            // Debug.WriteLine("wb1");
            total_water_flow = 0;
            if (t % 100 == 0)
            {
                update_solar_radiation();
            }
            Pduringsnowmelt = 0;

            total_snow_melt = 0;
            snow_start_m = snow_m;
            snowfall_m = 0;
            create_daily_weather(); // Calculate daily weather variables

            // Create yearly matrices for infiltration and overland flow
            // Debug.WriteLine("wb2");
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    pond_y[row, col] = 0;
                    outflow_y[row, col] = 0;
                    waterfactor[row, col] = 1;
                    total_outflow_y[row, col] = 0;
                    ETay[row, col] = 0;
                    ET0y[row, col] = 0;
                    Iy[row, col] = 0;
                    for (int dir = 0; dir < 10; dir++)
                    {
                        OFy_m[row, col, dir] = 0;
                    }
                }
            }
            comb_sort();

            double P_OF, snowmelt_m = 0;
            // Debug.WriteLine("wb3");
            if (t % 10 == 0) { update_Ks(); }

            // Debug.WriteLine("wb4");
            int daycount = 0;
            for (int mo = 0; mo < 12; mo++)
            {
                // create monthly timeseries
                double[] Pm = new double[month[mo]];
                int[] Dm = new int[month[mo]], Tavgm = new int[month[mo]];
                P_OF = 0;
                Array.Copy(Py, daycount, Pm, 0, month[mo]);
                Array.Copy(Dy, daycount, Dm, 0, month[mo]);
                Array.Copy(Tavgy, daycount, Tavgm, 0, month[mo]);
                ;
                // daily overland flow
                snow_threshold_C = 0;
                for (int day = 0; day < month[mo]; day++)
                {
                    if (Tavgm[day] <= snow_threshold_C) // temperature below 0, all rain falls as snow
                    {
                        if (Pm[day] > 0)
                        {
                            // Debug.WriteLine("snowfall");
                            snowfall_m += Pm[day];
                            snow_m += Pm[day];
                            P_OF += Pm[day];
                        }
                    }
                    else // T above 0, snow can melt and is all added to runoff. 
                    {
                        if (snow_m > 0) // Snow present
                        {
                            Pduringsnowmelt += Pm[day];
                            snowmelt_m = snowmelt_factor_mTd * (Tavgm[day] - snow_threshold_C);
                            if (snowmelt_m > snow_m) { snowmelt_m = snow_m; }
                            snow_m -= snowmelt_m;
                            total_snow_melt += snowmelt_m;
                            // Debug.WriteLine("t {0}, m {1} d {2} snowmelt {3} m", t,mo, day,snowmelt_m);
                            dailyflow(Pm[day], Dm[day], day, mo, snowmelt_m); // all snowmelt (+extra rain) becomes overland flow
                            P_OF += Pm[day];

                        }
                        else // no snow cover, rainfall intensity is used as threshold
                        {
                            if (Pm[day] > (Ks_min_mh * Dm[day]) && Dm[day] != 0) // develop. If rainfall is also spatially variable, this has to be adjusted
                            {
                                // Debug.WriteLine("wb4a");
                                //Debug.WriteLine("Overland flow initiated at date {0}/{1}/{2}", day, mo, t);
                                dailyflow(Pm[day], Dm[day], day, mo, 0);
                                P_OF += Pm[day];
                            }
                        }

                        if (snow_m < 0)
                        {
                            Debug.WriteLine("err_sno1");
                        }
                    }
                }

                //if (Pm.Sum() < P_OF) { MessageBox.Show("Pd > P"); }
                // Monthly water balance
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double ET0m_act = ET0_m[mo] * Ra_rcm[row, col, mo] * veg_correction_factor[row, col];
                            // if (row == 0 & col == 0) { Debug.WriteLine(ET0m_act); }
                            ET0y[row, col] += ET0m_act;
                            double ETam = Pm.Sum() / Math.Pow(1 + Math.Pow(Pm.Sum() / (ET0m_act), 1.5), (1 / 1.5));

                            ETay[row, col] += ETam;

                            Iy[row, col] += (Pm.Sum() - P_OF) - ETam; // overland flow has been dealt with earlier (dailyflow), just as ponding
                            if (double.IsNaN(Iy[row, col]))
                            {
                                Debug.WriteLine("err wb1");
                            }
                        }
                    }
                }
                // Debugger.Break();

                daycount += month[mo];
            } // end months

            // yearly update infiltration

            bool Ineg = false;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (Iy[row, col] < 0)
                    {
                        Ineg = true;
                    }
                }
            }
            if (Ineg)
            {
                ;
            }
            //if (t % 10 == 0) { Debugger.Break(); }
            // Debug.WriteLine("wb6");
        }

        void print_water_balance()
        {
            double P_wb = 0, ETa_wb = 0, I_wb = 0, OutF_wb = 0, snow_wb = 0, snow_left = 0, snow_start = 0, OFy_0 = 0, OFy_9 = 0;
            for (int rowb = 0; rowb < nr; rowb++)
            {
                for (int colb = 0; colb < nc; colb++)
                {
                    if (dtm[rowb, colb] != -9999)
                    {
                        P_wb += Py.Sum();
                        ETa_wb += ETay[rowb, colb];
                        I_wb += Iy[rowb, colb];
                        OutF_wb += total_outflow_y[rowb, colb];
                        snow_wb += snowfall_m;
                        snow_start += snow_start_m;
                        snow_left += snow_m;
                        OFy_0 += OFy_m[row, col, 0];
                        OFy_9 += OFy_m[row, col, 9];
                    }

                }
            }
            double balance = P_wb - ETa_wb - I_wb - OutF_wb;
            Debug.WriteLine("Snow start: {0}, snow end: {1}, P during snow: {2}", snow_start, snow_left, Pduringsnowmelt * nr * nc);
            Debug.WriteLine("Annual water balance");
            Debug.WriteLine("P: {0}, of which snowfall: {1}.  ETa: {2}. I: {3}. Outflow: {4}. Balance: {5}. OFy_0: {6}, OFy_9: {7}", P_wb, snow_wb, ETa_wb, I_wb, OutF_wb, balance, OFy_0, OFy_9);
            if (double.IsNaN(I_wb))
            {
                Debug.WriteLine("err_pwb1");
            }
            if (Math.Abs(balance + snow_start - snow_left) > 0.00000001)
            {
                Debug.WriteLine("err_pwb2");
            }
        }

        void print_spatial_water_balance()
        {
            for (int rowb = 0; rowb < nr; rowb++)
            {
                for (int colb = 0; colb < nc; colb++)
                {
                    Debug.WriteLine("{0} {1} {2} {3} {4} {5} {6} {7} {8} {9} {10} {11} {12}", rowb, colb, t, Py.Sum(), ETay[rowb, colb], OFy_m[rowb, colb, 0] - OFy_m[rowb, colb, 9], Iy[rowb, colb], (Py.Sum() - ETay[rowb, colb] - Iy[rowb, colb]), snow_m, snow_start_m, snowfall_m, total_outflow_y[rowb, colb], Pduringsnowmelt);
                    // snowfall_m is part of Py.Sum(), therefore, this should not be accounted for in the balance. Important terms are P, ETa, I and outflow. They close the balance. 
                }
            }
        }

        void print_P_ET0()
        {
            double ET_out = 0;
            double count = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    ET_out += ET0y[row, col];
                    count += 1;

                }
            }
            Debug.WriteLine("P {0} ET0 {1}", Py.Sum(), ET_out / count);
        }

        void update_potential_ET()
        {
            for (int hrow = 0; hrow < nr; hrow++)
            {
                for (int hcol = 0; hcol < nc; hcol++)
                {

                }
            }
        }

        void update_Ks() // both Ks matrix as Ks for topsoil
        {
            double[] tex_topsoil;
            double depth, fsilt, fclay, fOM, BD_t, slope_rad;
            int lay;
            Ks_min_mh = 1000; Ks_max_mh = 0;
            List<double> BD_topsoil;

            // Debug.WriteLine("uks1");
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    BD_topsoil = new List<double>();
                    depth = 0;
                    tex_topsoil = new double[7];
                    lay = 0;
                    if (total_soil_mass_kg(row, col) > 0)
                    {
                        while (depth <= 0.5 & lay < max_soil_layers)
                        {
                            // if (lay == max_soil_layers) { Debugger.Break(); }
                            if (total_layer_mass_kg(row, col, lay) > 0)
                            {
                                depth += layerthickness_m[row, col, lay] / 2;

                                for (int text = 0; text < 5; text++)
                                {
                                    tex_topsoil[text] += texture_kg[row, col, lay, text];
                                }
                                tex_topsoil[5] += young_SOM_kg[row, col, lay];
                                tex_topsoil[5] += old_SOM_kg[row, col, lay];

                                BD_topsoil.Add(bulk_density_calc(texture_kg[row, col, lay, 0], texture_kg[row, col, lay, 1], texture_kg[row, col, lay, 2], texture_kg[row, col, lay, 3], texture_kg[row, col, lay, 4], old_SOM_kg[row, col, lay], young_SOM_kg[row, col, lay], depth));
                                depth += layerthickness_m[row, col, lay] / 2;

                            }
                            lay += 1;
                        }

                        fsilt = 100 * tex_topsoil[2] / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4]); // only fine fraction
                        fclay = 100 * (tex_topsoil[3] + tex_topsoil[4]) / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4]); // only fine fraction
                        fOM = 100 * tex_topsoil[5] / (tex_topsoil[1] + tex_topsoil[2] + tex_topsoil[3] + tex_topsoil[4] + tex_topsoil[5]); // only fine fraction
                        BD_t = BD_topsoil.Average() / 1000;
                        slope_rad = calc_slope_stdesc(row, col);
                        double slope_test = Math.Cos(slope_rad);

                        // Debug.WriteLine("uks3a");
                        Ks_topsoil_mh[row, col] = (Ks_wosten(fsilt, fclay, fOM, BD_t, 1) / 24) * Math.Cos(slope_rad);
                    }
                    else
                    {
                        Ks_topsoil_mh[row, col] = 0;
                        Debug.WriteLine("Empty soil at row {0}, col {1}, t {2}", row, col, t);
                    }

                    if (double.IsNaN(Ks_topsoil_mh[row, col]))
                    {
                        Debug.WriteLine("err_kst1");
                    }
                    // Debug.WriteLine("uks4");

                    //  Ks_topsoil_mh[row, col] *= veg_lag_factor;
                    // Ks_update
                    if (Ks_min_mh > Ks_topsoil_mh[row, col]) { Ks_min_mh = Ks_topsoil_mh[row, col]; }
                    if (Ks_max_mh < Ks_topsoil_mh[row, col]) { Ks_max_mh = Ks_topsoil_mh[row, col]; }
                    // Debug.WriteLine("uks5");
                }
            }
        }

        void create_daily_weather()
        {
            //Debug.WriteLine("dw.start");
            // 1. Select yearly timeseries and the corrected temperatures

            double P_ann = rain_value_m;
            int T_ann = temp_value_C;

            Random year_w = new Random(t); // t as random seed to get deterministic results
            int n_timeseries = year_w.Next(0, System.Convert.ToInt32(daily_n.Text));
            // n_timeseries = 5;

            //Debug.WriteLine("dw.1c");
            Array.Copy(Tmin_all, 365 * (n_timeseries), Tminy, 0, 365); // read new Tmin timeseries
            Array.Copy(Tmax_all, 365 * (n_timeseries), Tmaxy, 0, 365); // read new Tmin timeseries
            Array.Copy(Tavg_all, 365 * (n_timeseries), Tavgy, 0, 365); // read new Tmin timeseries

            Array.Copy(P_all, 365 * (n_timeseries), Py, 0, 365); // read new P timeseries
            Array.Copy(D_all, 365 * (n_timeseries), Dy, 0, 365); // read new D timeseries
            for (int pi = 0; pi < 365; pi++)
            {
                Py[pi] /= 1000; // convert to meters
                                // if (Py[pi] > 0.036) { Debugger.Break(); }
            }

            // 2. Rescale rainfall and temperature
            //Debug.WriteLine("dw.1a");

            if (check_scaling_daily_weather.Checked) // scaling with yearly values, for global change scenarios
            {
                double Py_sum = Py.Sum();
                for (int pi = 0; pi < Py.Count(); pi++) { Py[pi] = Py[pi] / Py_sum * P_ann; } // Scale with yearly P in meters
                double total_P = Py.Sum();

                int d_T = T_ann - Convert.ToInt32(Tavgy.Average());
                for (int pi = 0; pi < Tavgy.Count(); pi++)
                {
                    Tminy[pi] += d_T;
                    Tmaxy[pi] += d_T;
                    Tavgy[pi] += d_T;
                }
            }

            // 3. Calculate PET according to Hargreaves https://www.repository.utl.pt/bitstream/10400.5/4250/1/REP-J.L.Teixeira-InTech-Hargreaves_and_other_reduced_set_methods_for_calculating_evapotranspiration.pdf
            // Use monthly T values, gives a result very similar to daily values
            // multiplication with extraterrestrial radiation occurs in a later step, when ET0_m is actually necessary (water balance). Here we capture the monthly variation. At the later step, the spatiotemporal differences in solar radiation are captured
            int[] Tminm, Tmaxm, Tavgm;
            int daycount = 0;
            for (int pi = 0; pi < 12; pi++)
            {
                Tminm = new int[month[pi]];
                Tmaxm = new int[month[pi]];
                Tavgm = new int[month[pi]];

                Array.Copy(Tminy, daycount, Tminm, 0, month[pi]);
                Array.Copy(Tmaxy, daycount, Tmaxm, 0, month[pi]);
                Array.Copy(Tavgy, daycount, Tavgm, 0, month[pi]);

                daycount += month[pi];
                //get temperature info
                ET0_m[pi] = 0.0023 * (Tavgm.Average() + 17.78) * Math.Sqrt(Tmaxm.Average() - Tminm.Average()) * month[pi]; // multiply value by number of days in the month, to get the monthly total
                if (ET0_m[pi] < 0) { ET0_m[pi] = 0; }

            }

            //Debug.WriteLine("dw.end"); 
        }

        void dailyflow(double P_total, double D_total, int qday, int qmonth, double snowmelt)
        {
            // Debug.WriteLine("df1");
            /*
            Check:
            -is all water flow reset after first iteration?
            -do dtm and ponding values correspond well?
            -is the water balance closing?
            -do all cells refer to OFd[r,c,0] as flow component? rainfall and overland flow
            -link infiltration to differences in Ks (negative Ks) !!!
             */

            pond_d = new double[nr, nc];
            double[,] currentflow = new double[nr, nc];
            // Debug.WriteLine("df1");
            //every cell, inflow and outflow;
            double powered_slope_sum, OF_tot1 = 0, OF_tot2 = 0, OF_tot3 = 0; ;
            double[,,] OFd = new double[nr, nc, 10];

            //0: total flow
            //1-8: flow to neighbours
            //
            // 1 2 3 
            // 4   5
            // 6 7 8
            //
            //9: temporary flow, for the thresholds

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    pond_d[row, col] = 0;
                    for (int it = 0; it <= 9; it++)
                    {
                        OFd[row, col, it] = 0;
                    } // reset all values
                }
            }

            int runner = 0;
            // Debug.WriteLine("df2");
            double totalwater = 0, totalwater2 = 0;
            // create overland flow in current flow map. This will be reset after flowing out, to consider a new flux of water after saddle overflow, without counting the first flux twice. 
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    // Add rainfall excess to every cell. If negative, it can absorb incoming water from upstream.Overland flow will only be calculated when outflow is larger than zero. 
                    // Infiltration is dealt with at the end of the day. Water can still flow into the cell from higher up
                    //If there is snowmelt, all water (including rainfall), becomes overland flow
                    if (snowmelt > 0)
                    {
                        currentflow[row, col] = P_total + snowmelt;
                        total_water_flow += P_total + snowmelt;
                    }
                    else
                    {
                        currentflow[row, col] = P_total - Ks_topsoil_mh[row, col] * D_total; // infiltration excess becomes overland flow
                        total_water_flow += P_total - Ks_topsoil_mh[row, col] * D_total;
                    }
                    totalwater += currentflow[row, col];
                }
            }

            List<double> dh_list = new List<double>();
            List<string> dh_list_loc = new List<string>();
            // Debug.WriteLine("df3");
            // Debug.WriteLine("df2");
            // route to neighbours
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {
                //Debug.WriteLine("runner start of run: " + runner);
                if (index[runner] != -9999)
                {
                    row = row_index[runner]; col = col_index[runner];

                    // if (row == 186 & col == 499 & t == 5) { minimaps(186, 499); }

                    powered_slope_sum = 0;

                    // dh_list = new List<double>();

                    if (currentflow[row, col] > 0) // if there is currently water flowing out of the cell
                    {
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {  //if the cell has no NODATA

                                        dh = dtm[row, col] - (dtm[row + i, col + j] + pond_d[row + i, col + j]);
                                        //Debug.WriteLine("dh = {0}", dh);
                                        if (dh > 0)
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length

                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            dh_list.Add(dh);
                                            dh_list_loc.Add(Convert.ToString(col) + "." + Convert.ToString(j));
                                            powered_slope_sum = powered_slope_sum + dh;

                                            // no correction for possible sedimentation, like in normal overland flow
                                        }
                                    }
                                }
                            }
                        }
                        // Debug.WriteLine("df3");
                        if (powered_slope_sum > 0) // not in a depression
                        {
                            try
                            {

                                int direction = 0;
                                for (i = (-1); i <= 1; i++)
                                {
                                    for (j = (-1); j <= 1; j++)
                                    {
                                        if (!((i == 0) && (j == 0))) { direction++; }
                                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                        {
                                            if (dtm[row + i, col + j] != -9999)
                                            {  //if the cell has no NODATA

                                                dh = dtm[row, col] - (dtm[row + i, col + j] + pond_d[row + i, col + j]);
                                                if (dh > 0)
                                                {
                                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length

                                                    dh = dh / d_x;
                                                    dh = Math.Pow(dh, conv_fac);
                                                    int t2 = t;
                                                    // if (col == 12) { Debugger.Break(); }
                                                    // flow to ij = dh / powered_slope_sum
                                                    OFd[row, col, direction] += dh / powered_slope_sum * currentflow[row, col]; // update outflow to each cell
                                                    currentflow[row + i, col + j] += dh / powered_slope_sum * currentflow[row, col];// update inflow of receiving cell. Here, a negative currentflow can become less negative or positive. 
                                                    OFd[row + i, col + j, 9] += dh / powered_slope_sum * currentflow[row, col]; // to track total inflow for the water balance

                                                }
                                            }
                                        }

                                    } // end j
                                } // end i
                                OFd[row, col, 0] += currentflow[row, col]; // total outflow
                                currentflow[row, col] = 0; // reset currentflow for possible later new flux after saddle position overflow
                            }
                            catch
                            {
                                MessageBox.Show("Error in water redistribution");
                            }

                        } // end powered_slope_sum > 0

                        else // no outflow, so at the edge of the catchment, or in a sink or depression
                        {
                            bool nodataneighbour = search_nodataneighbour(row, col);

                            if (nodataneighbour == true) // outflow
                            {
                                OFd[row, col, 0] += currentflow[row, col];
                                total_outflow_y[row, col] += currentflow[row, col];
                                currentflow[row, col] = 0;
                            }
                            else // depression
                            {
                                // Debug.WriteLine("df3a");
                                List<double> saddle_OF = new List<double>();
                                saddle_OF = ponding(row, col, currentflow[row, col], qday, qmonth);
                                OFd[row, col, 0] += currentflow[row, col];
                                currentflow[row, col] = 0;
                                // Debug.WriteLine("df3b");
                                // Debug.WriteLine("col =" + col);
                                if (saddle_OF.Count() > 0) // if there is saddle overflow
                                {
                                    int OF_row = Convert.ToInt32(saddle_OF[1]);
                                    int OF_col = Convert.ToInt32(saddle_OF[2]);
                                    currentflow[OF_row, OF_col] += saddle_OF[0];
                                    // Debug.WriteLine("runner old: " + runner + ", " + saddle_OF[0] + " " + saddle_OF[1] + " " + saddle_OF[2]);
                                    string rowcol = OF_row.ToString() + "." + OF_col.ToString();
                                    runner = Array.IndexOf(rowcol_index, rowcol) + 1; // index of selected row and col + 1, because in the next iteration of the for loop, 1 is subtracted from runner
                                                                                      // Debug.WriteLine("runner new: " + runner);
                                } // end of saddle overflow
                            }
                        }

                        // Debug.WriteLine("df4");
                    } // end inflow > 0
                    else
                    {

                        // two options:
                        // currentflow is still negative, indicating that only infiltration occurs. 
                        // currentflow has been reset earlier, so nothing happens
                        // if (snowmelt > 0) { Debugger.Break(); }
                        OFd[row, col, 0] += currentflow[row, col]; //Creates negative flow, because this is used for calculating infiltration. At that stage, this parameters will be set to zero
                        currentflow[row, col] = 0;
                    }

                } // end runner !=-9999
            } // end runner
              // Debug.WriteLine("df4");

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    Iy[row, col] += pond_d[row, col];
                    if (double.IsNaN(Iy[row, col]))
                    {
                        Debug.WriteLine("err_df1");
                    }

                    // Calculate infiltration from rainfall and incoming flow
                    if (snowmelt == 0) // no snowmelt
                    {
                        if (OFd[row, col, 0] > 0) // if runoff occurred out of this cell, infiltration is maximum possible infiltration
                        {
                            Iy[row, col] += Ks_topsoil_mh[row, col] * D_total;
                            if (double.IsNaN(Iy[row, col]))
                            {
                                Debug.WriteLine("err_df2");
                            }

                        }
                        else
                        { // cell not saturated, infiltration is maximum infiltration minus the deficit at row, col, which is recorded in OFd[,,0]
                            Iy[row, col] += Ks_topsoil_mh[row, col] * D_total + OFd[row, col, 0]; //+, because OFd[row, col is negative
                                                                                                  //if (double.IsNaN(Iy[row, col])) { Debugger.Break(); }

                            OFd[row, col, 0] = 0;
                        }
                    }
                    else
                    {
                        // snow melt, no infiltration, because the soil is frozen. The rest leaves the catchment. this water only infiltrates when ponding. For the rest, it influences erosion
                    }

                    // Write daily flow to yearly flow
                    for (int it = 0; it <= 9; it++)
                    {
                        OFy_m[row, col, it] += OFd[row, col, it];
                    }

                    // check if total ponding equals total overland flow
                    pond_y[row, col] += pond_d[row, col];
                }
            }
            // Debug.WriteLine("df6");
        } // end dailyflow

        double Ks_wosten(double silt, double clay, double OM, double BD, int topsoil)
        {
            // Debug.WriteLine("KsW1");
            if (OM < 0.5) { OM = 0.5; } // half percent of OM for soils where it is absent, otherwise the PTFs will crash
            double KsW = Math.Exp(7.755 + 0.03252 * silt + 0.93 * topsoil - 0.967 * BD * BD - 0.000484 * clay * clay - 0.000322 * silt *
                silt + 0.001 / silt - 0.0748 / OM - 0.643 * Math.Log(silt) - 0.01398 * BD * clay - 0.1673 * BD * OM + 0.02986 * topsoil * clay - 0.03305 * topsoil * silt) / 100;
            // Debug.WriteLine("KsW2");
            if (Double.IsNaN(KsW)) { KsW = 0; }
            // Debug.WriteLine("KsW3");
            return (KsW); // m day-1

        }

        List<double> ponding(int row1, int col1, double inflow_m, int pday, int pmonth)
        {
            ponding_start = DateTime.Now;
            pond_d[row1, col1] += inflow_m;
            bool flatwater = false;
            int rowp, colp, rowp1, colp1, pondedcells, ri_of, ci_of;
            double minponding = inflow_m, dz_water;
            List<double> elev_p = new List<double>();
            List<double> output = new List<double>();
            elev_p.Add(dtm[row1, col1]);

            // 1. initiate list of ponded rows and cols
            List<int> pondingrows = new List<int>();
            List<int> pondingcols = new List<int>();
            pondingrows.Add(row1);
            pondingcols.Add(col1);
            List<double> dh_nb;
            // Debug.WriteLine("po1");

            // 2. loop over neighbours of ponded sink, to look for lowest neighbour to share water with
            // start with lowest neighbour of ponded cells, and work the way up
            while (flatwater == false)
            {
                dh_nb = new List<double>(); // store the dhs in a list, because we don't know how big the pond gets and therefore how many neighbours there are

                for (int pondcell = 0; pondcell < pondingrows.Count(); pondcell++)
                {

                    rowp = pondingrows[pondcell];
                    colp = pondingcols[pondcell];
                    // if (minponding > pond_d[row, colp]) {minponding = pond_d[row, colp]; }
                    for (int i = -1; i <= 1; i++)
                    { // find lowest neighbour of all ponded cells.
                        for (int j = -1; j <= 1; j++)
                        {
                            if (((rowp + i) >= 0) && ((rowp + i) < nr) && ((colp + j) >= 0) && ((colp + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                if (dtm[rowp + i, colp + j] != -9999)
                                {
                                    dh = (dtm[rowp, colp] + pond_d[rowp, colp]) - (dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j]);
                                    dh_nb.Add(dh);
                                } // end dtm != -9999
                            } // end if
                        } // end j
                    }  // end i
                }// end rowp colp

                //  Debug.WriteLine("po2");
                double maxdiff = dh_nb.Max();

                // 3. If there is a lower neighbour, share the water with him. Threshold a bit above 0, to avoid rounding errors
                if (maxdiff > 0.000000000001)
                {
                    // Debug.WriteLine("po3a");
                    for (int pondcell = 0; pondcell < pondingrows.Count(); pondcell++)
                    {
                        rowp = pondingrows[pondcell];
                        colp = pondingcols[pondcell];
                        double h_c = dtm[rowp, colp];
                        for (int i = -1; i <= 1; i++)
                        { // 4. relocate lowest neighbour of all ponded cells.
                            for (int j = -1; j <= 1; j++)
                            {
                                if (((rowp + i) >= 0) && ((rowp + i) < nr) && ((colp + j) >= 0) && ((colp + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[rowp + i, colp + j] != -9999)
                                    {
                                        // Debug.WriteLine("po3b");
                                        dh = (dtm[rowp, colp] + pond_d[rowp, colp]) - (dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j]);
                                        if (dh == dh_nb.Max()) // if the selected neighbour is the lowest neighbour
                                        {

                                            pondedcells = pondingrows.Count();
                                            dz_water = pondedcells * dh / (pondedcells + 1); // amount of water added to the lowest (waterless) neighbour

                                            // if change in ponded cells exceeds available water in shallowest ponding cell (e.g. saddle positions), water drop is limited to this depth, preventing negative ponding
                                            double h_n = dtm[rowp + i, colp + j] + pond_d[rowp + i, colp + j];
                                            if (h_n < h_c) // if we cross a saddle position, stop water flow for now

                                            {
                                                double overflow = pond_d[rowp, colp] * pondedcells; // excess water is ponding level at the saddle position, times the amount of ponding cells

                                                for (int i_of = 0; i_of < pondedcells; i_of++)
                                                {
                                                    ri_of = pondingrows[i_of];
                                                    ci_of = pondingcols[i_of];
                                                    pond_d[ri_of, ci_of] -= overflow / pondedcells;
                                                }
                                                output.Add(overflow); // create list for output, consisting of saddle r and c, and amount of overflow
                                                output.Add(rowp);
                                                output.Add(colp);
                                                //OFd[rowp, colp, 0] += overflow; // add overflow to the saddle cell, not the lower neighbour. from the saddle cell it will flow onward
                                                dz_water = 0; flatwater = true;
                                            }

                                            else
                                            {
                                                // Debug.WriteLine("po3c");
                                                for (int pondcell1 = 0; pondcell1 < pondingrows.Count(); pondcell1++)
                                                { // subtract redistributed water from original ponds
                                                    rowp1 = pondingrows[pondcell1];
                                                    colp1 = pondingcols[pondcell1];
                                                    pond_d[rowp1, colp1] -= dz_water / pondedcells;
                                                }
                                                pond_d[rowp + i, colp + j] += dz_water; // add water to the new ponding cell
                                                                                        //  Debug.WriteLine("po3d");
                                                pondingrows.Add(rowp + i);
                                                pondingcols.Add(colp + j);
                                                if (minponding > pond_d[rowp + i, colp + j]) { minponding = pond_d[rowp + i, colp + j]; }
                                                elev_p.Add(dtm[rowp + i, colp + j]);
                                            }

                                            //for(int iii = 0;iii<pondingrows.Count();iii++)
                                            //{
                                            //    Debug.Write(dtm[pondingrows[iii], pondingcols[iii]] + pond_d[pondingrows[iii], pondingcols[iii]]+" ");
                                            //}
                                            //Debug.Write("\n");
                                        }
                                    } // end dtm != -9999
                                } // end if
                            } // end j
                        }  // end i

                    } // end rowp colp
                } // end if dh_nb > 
                else
                { // no lower neighbour, end of ponding
                    flatwater = true;
                }
                // Debug.WriteLine("po3");
            } // end of water redistribution

            bool negativeponding = false;
            for (int r = 0; r < nr; r++)
            {
                for (int c = 0; c < nc; c++)
                {
                    //pond_y[r, c] += pond_d[r, c];
                    if (pond_d[r, c] < -0.00000001) { Debug.WriteLine("negative ponding on row {0} and col {1}. Amount = {2} ", r, c, pond_d[r, c]); }
                }
            }
            // if(negativeponding == true) { out_double(workdir + "\\debug\\" + run_number + "_" + t + "_ "+ pmonth+"_ " + pday + "_out_ponding.asc", pond_d); }
            ponding_t += DateTime.Now - ponding_start;

            return (output);

        }

        bool stagnation(double I_d)
        {
            // DEVELOP MM account for different moisture conditions throughout the year
            bool stag;
            bool stag_total = false;
            int lay;
            double depth;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        stag = false;
                        lay = 0;
                        depth = 0;
                        if (I_d > Ks_md[row, col, lay]) { stag = true; stag_total = true; }
                        while (stag == false)
                        {
                            depth += layerthickness_m[row, col, lay];
                            if (I_d > Ks_md[row, col, lay]) { stag = true; stag_total = true; }
                        }
                        if (stag == true) { stagdepth[row, col] = depth; }
                    }
                }
            }
            return (stag_total);
        }

        void lateral_flow()
        {

            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    for (int i = (-1); i <= 1; i++)
                    {
                        for (int j = (-1); j <= 1; j++)
                        {
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                if (dtm[row + i, col + j] != -9999)
                                {  //if the cell has no NODATA

                                }
                            }
                        }
                    }
                }
            }
        }

        #endregion

        #region Soil development code

        void update_all_layer_thicknesses(int row_update, int col_update)
        {
            for (int layer_update = 0; layer_update < max_soil_layers; layer_update++)
            {
                layerthickness_m[row_update, col_update, layer_update] = thickness_calc(row_update, col_update, layer_update);
                layerthickness_m[row_update, col_update, layer_update] = thickness_calc(row_update, col_update, layer_update);
            }

        }

        void remove_empty_layers(int row2, int col2)
        {
            // mainly after tree fall, there can be empty soil layers at the surface. This module shifts the layers up.
            // displaysoil(row2, col2);
            // Debug.WriteLine("rel1");
            // DEVELOP after shifting cells up the script runs through the lower empty cells, moving them up also. with some booleans, this should be prevented. there is no error now, only longer simulation time.  
            try
            {
                int totalgrains_start = 0;
                if (OSL_checkbox.Checked) { for (int lay = 0; lay < max_soil_layers; lay++) { totalgrains_start += OSL_grainages[row2, col2, lay].Length; } }

                if (diagnostic_mode == 1) { Debug.WriteLine("entered removing empty layers"); }
                int empty_layers = 0;
                bool shift_layers = false;

                int n_shifts = 0;
                double mass_before = total_soil_mass_kg(row2, col2);
                // Debug.WriteLine("rel2");
                for (int lay2 = 0; lay2 < max_soil_layers; lay2++)
                {
                    bool full_layer_shift = false;
                    double layer_mass = total_layer_mass_kg(row2, col2, lay2);
                    if (layer_mass < 0.000000000001) // empty layer
                                                     // mind for empty layers at the bottom
                    {
                        shift_layers = true;
                        // if(n_shifts == 0) { displaysoil(row2, col2); }
                        // n_shifts += 1;

                        empty_layers++;
                        for (int layert = lay2; layert < max_soil_layers - 1; layert++) // for all underlying layers, shift one up (since there is space anyway)
                        {

                            if (total_layer_mass_kg(row2, col2, layert + 1) > 0) { full_layer_shift = true; }
                            // Debug.WriteLine(layert);
                            for (i = 0; i < 5; i++)
                            {
                                texture_kg[row2, col2, layert, i] = texture_kg[row2, col2, layert + 1, i];
                            }
                            old_SOM_kg[row2, col2, layert] = old_SOM_kg[row2, col2, layert + 1];
                            young_SOM_kg[row2, col2, layert] = young_SOM_kg[row2, col2, layert + 1];

                            if (CN_checkbox.Checked)
                            {
                                for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                {
                                    CN_atoms_cm2[row2, col2, layert, cosmo] = CN_atoms_cm2[row2, col2, layert + 1, cosmo];
                                }
                            }

                            if (OSL_checkbox.Checked)
                            {
                                transfer_OSL_grains(row2, col2, layert + 1, row2, col2, layert, 1, 0); // transfer all grains from layert + 1 to layers
                            }

                        }
                        for (i = 0; i < 5; i++)
                        {
                            texture_kg[row2, col2, max_soil_layers - 1, i] = 0;
                        }
                        old_SOM_kg[row2, col2, max_soil_layers - 1] = 0;
                        young_SOM_kg[row2, col2, max_soil_layers - 1] = 0;
                        layerthickness_m[row2, col2, max_soil_layers - 1] = 0;

                        if (CN_checkbox.Checked)
                        {
                            for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                            {
                                CN_atoms_cm2[row2, col2, max_soil_layers - 1, cosmo] = 0;
                            }
                        }

                        if (OSL_checkbox.Checked)
                        {

                            //// OSL matrix
                            //for (int osl_i = 0; osl_i < OSL_age.GetLength(0); osl_i++) // loop over all rows
                            //{
                            //    if (OSL_age[osl_i, 0] == row2 & OSL_age[osl_i, 1] == col2)
                            //    {
                            //        if (OSL_age[osl_i, 2] == lay2) { Debugger.Break(); } // should not happen. This layer has been eroded completely
                            //        if (OSL_age[osl_i, 2] > lay2)
                            //        {
                            //            OSL_age[osl_i, 2] -= 1; // MvdM no need to account here for multiple empty layer removal, because this is included by the repeated loop over layer numbers 
                            //        } // reduce layer number by 1
                            //    }
                            //}
                        }

                        if (full_layer_shift == true) { lay2--; }
                        //Debug.WriteLine("-");
                        //displaysoil(row2, col2);
                    }
                }
                // Debug.WriteLine("rel3");
                if (shift_layers == true)
                {
                    double mass_after = total_soil_mass_kg(row2, col2);
                    if (Math.Round(mass_before - mass_after) > 0.0000001)
                    {
                        Debug.WriteLine("Loss of soil data during removal of empty layers");
                        displaysoil(row2, col2);
                    }

                }

                if (diagnostic_mode == 1) { if (n_shifts > 0) { displaysoil(row2, col2); Debug.WriteLine("n layers shifted: {0} in row {1}, col {2}", n_shifts, row2, col2); } }
                update_all_layer_thicknesses(row2, col2);

                int totalgrains_end = 0;
                if (OSL_checkbox.Checked) { for (int lay = 0; lay < max_soil_layers; lay++) { totalgrains_end += OSL_grainages[row2, col2, lay].Length; } if (totalgrains_end != totalgrains_start) { Debugger.Break(); } }

            } // end try

            catch
            {
                Debug.WriteLine("Error in removing empty layers");
                Debug.WriteLine(" at end of remove_empty_layers: "); displaysoil(row2, col2);

            }
        }

        void soil_update_split_and_combine_layers_standard()
        {
            //where at the end of soil development, splitting and combining of soil layers is performed.

            //per layer: if too thin: combine with one of the two neighbours (the closest one in properties). 
            // too thick: split
            // if total too much - combine the most similar two layers although the product conforms to most restrictive rule about thicknesses
            //maat voor verschil is som (absolute differences in de vijf text classes and two organic matter classes)

            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=8
            // daarna     min 40    insteek 50  geen max            n=4

            //for combining : only when matrix size exceeded, then those two layers that are most equal are combined
            //do not combine two layers that together are too thick for their position in the profile. If needed, make lowest layer thicker. Therefore, approach from above

            //MISSING: HOW DO WE GO FROM MAX TO LESS LAYERS? ART
            //  Debug.WriteLine("suscl1 ");

            //displaysoil(0,0);
            double mass_before = total_catchment_mass();
            total_average_soilthickness_m = 0;
            number_soil_thicker_than = 0;
            number_soil_coarser_than = 0;
            local_soil_depth_m = 0;
            local_soil_mass_kg = 0;

            int layer;
            int numberoflayers = 0;
            double depth_m;  // keep better track of this, currently not OK yet
            try
            {
                //Debug.WriteLine("suscl2");
                //displaysoil(0, 0);
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            update_all_layer_thicknesses(row, col);
                            update_all_layer_thicknesses(row, col);

                            depth_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                ////update the layers' thickness now that textures and organic matter amounts have changed (if there is anything in the layer at all).
                                //if (!(texture_kg[row, col, layer, 0] == 0 && texture_kg[row, col, layer, 1] == 0 && texture_kg[row, col, layer, 2] == 0 && texture_kg[row, col, layer, 3] == 0 && texture_kg[row, col, layer, 4] == 0 && young_SOM_kg[row, col, layer] == 0 && old_SOM_kg[row, col, layer] == 0))
                                //{
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //if (layerthickness_m[row,col,layer] < 0) { Debugger.Break(); } //MMS
                                //find_negative_texture_rcl(row, col, layer); //MMS
                                //}
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                                {
                                    local_soil_mass_kg += texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    if (local_soil_mass_kg < 0)
                                    {
                                        Debug.WriteLine("err_uscl1");
                                    } //MMS
                                }
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && layer == 0 && texture_kg[row, col, layer, 0] / (texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) > System.Convert.ToDouble(timeseries.timeseries_soil_coarser_fraction_textbox.Text))
                                {
                                    number_soil_coarser_than++;
                                }
                            }

                        }
                    }
                }

                //displaysoil(0, 0);
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double old_soil_mass = total_soil_mass_kg(row, col), new_soil_mass;
                            // Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            //Debug.WriteLine("soil before splitting");
                            // if (row == 0 & col == 0) { displaysoil(row, col); }
                            depth_m = 0; numberoflayers = 0;
                            bool boolsplit = false;
                            bool boolcombine = false;
                            for (layer = 0; layer < max_soil_layers - 1; layer++)
                            {
                                if (layerthickness_m[row, col, layer] > 0)
                                {

                                    //Debug.WriteLine("depth is now " + depth + " for lyr " +  layer);
                                    numberoflayers++;

                                    // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                    // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                    // daarna     min 50    insteek 100  geen max            n=4

                                    if (depth_m <= 0.5)
                                    {
                                        if (layer == 0 & layerthickness_m[row, col, layer] < 0.001) // smaller than one mm -> merge with layer below
                                        {
                                            combine_layers(row, col, layer, layer + 1);
                                            update_all_layer_thicknesses(row, col);
                                            boolcombine = true;
                                            if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6)) { Debug.WriteLine("err_uscl2"); }
                                        }

                                        if (layerthickness_m[row, col, layer] < 0.025 && layer != 0)
                                        { //combine layers: select the one most like this one
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6))
                                                {
                                                    Debug.WriteLine("err_uscl3");
                                                }

                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6)) { Debugger.Break(); }

                                            }
                                            // we will now check whether layers have become too thick and if needed cut them in half
                                        }

                                        while (layerthickness_m[row, col, layer] > 0.1)
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 1");
                                            split_layer(row, col, layer, depth_m);
                                            update_all_layer_thicknesses(row, col);
                                            boolsplit = true;
                                            // if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001) { Debugger.Break(); }

                                        }

                                        // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                        // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                        // daarna     min 50    insteek 100  geen max            n=4

                                    }

                                    depth_m += layerthickness_m[row, col, layer]; // MM moved this down one if-function, to be able to split big clumps of earth by tree fall. If I put it at the end, it will give problems with splitting the one-before-last layer

                                    if (depth_m > 0.5 && depth_m <= 2)
                                    {
                                        if (layerthickness_m[row, col, layer] < 0.1 && layer != 0)
                                        { //combine 
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001)
                                                {
                                                    Debug.WriteLine("err_uscl4");
                                                }
                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001) { Debugger.Break(); }

                                            }
                                        }
                                        while (layerthickness_m[row, col, layer] > 0.5)
                                        { //split 
                                          // Debug.WriteLine("splitting after combining 2. layer = {0}, layerthickness = {1}", layer, layerthickness_m[row, col, layer]);
                                            split_layer(row, col, layer, depth_m);
                                            update_all_layer_thicknesses(row, col);
                                            boolsplit = true;
                                            new_soil_mass = total_soil_mass_kg(row, col);
                                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                                            {
                                                Debug.WriteLine("err_uscl5");
                                            }

                                        }
                                    }

                                    if (depth_m > 2)
                                    {
                                        if (layerthickness_m[row, col, layer] < 0.4 && layer != 0)
                                        { //combine 
                                          //displaysoil(row, col);
                                            if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001)
                                                {
                                                    Debug.WriteLine("err_uscl6");
                                                }

                                            }
                                            else
                                            {
                                                combine_layers(row, col, layer - 1, layer);
                                                layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                numberoflayers--;
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                // if (Math.Abs(old_soil_mass - total_soil_mass(row, col)) > 0.00000001) { Debugger.Break(); }

                                            }

                                        }
                                        if (layerthickness_m[row, col, layer] > 0.5)
                                        { //split 
                                          // no splitting, no maximum thickness
                                        }
                                    }

                                    //Debug.WriteLine("depth is now " + depth + " and number of layers is  " + numberoflayers);
                                }
                            }
                            //Debug.WriteLine("suscl1" + row + ", " + col + ", " + t);

                            for (int layupdate = 0; layupdate < max_soil_layers; layupdate++)
                            {
                                layerthickness_m[row, col, layupdate] = thickness_calc(row, col, layupdate);
                            }
                            //Debug.WriteLine("Soil after splitting");
                            //if (row == 0 & col == 0) { displaysoil(row, col); }
                            //Debug.WriteLine("suscl4");
                            //displaysoil(0, 0);

                            new_soil_mass = total_soil_mass_kg(row, col);
                            // if (numberoflayers > max_soil_layers)
                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                            {
                                // this should never happen, because the data of the lowest layers have then been lost.
                                Debug.WriteLine(" Warning - loss of soil data ");
                                //displaysoil(row, col);
                            }
                            if (timeseries.timeseries_number_soil_thicker_checkbox.Checked && System.Convert.ToDouble(timeseries.timeseries_soil_thicker_textbox.Text) < depth_m) { number_soil_thicker_than++; }
                            if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m += depth_m; }
                            if (timeseries.timeseries_soil_depth_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                            {
                                local_soil_depth_m = depth_m;
                            }

                            //Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            // update dtm and soil thickness map //MMS
                            double old_thickness = soildepth_m[row, col];
                            double new_thickness = total_soil_thickness(row, col);
                            dtm[row, col] += new_thickness - old_thickness;
                            soildepth_m[row, col] = new_thickness;
                            dtmchange_m[row, col] += new_thickness - old_thickness;
                            dz_soil[row, col] += new_thickness - old_thickness;
                        }// end dtm!=-9999

                    } // end col
                } // end row

                if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m /= number_of_data_cells; }
            }
            catch { }
            double mass_after = total_catchment_mass();
            // if (Math.Round(mass_before, 3) != Math.Round(mass_after, 3)) { Debugger.Break(); }
        } //always keep this code

        void soil_update_split_and_combine_layers()
        {
            //per layer: if too thin: combine with one of the two neighbours (the closest one in properties). 
            // too thick: split
            // if total too much - combine the most similar two layers although the product conforms to most restrictive rule about thicknesses
            //maat voor verschil is som (absolute differences in de vijf text classes and two organic matter classes)

            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
            // 50-200 cm  min 10    insteek 15    maximum 50 cm      n=8
            // daarna     min 40    insteek 50  geen max            n=4

            //for combining : only when matrix size exceeded, then those two layers that are most equal are combined
            //do not combine two layers that together are too thick for their position in the profile. If needed, make lowest layer thicker. Therefore, approach from above

            //MISSING: HOW DO WE GO FROM MAX TO LESS LAYERS? ART
            // Debug.WriteLine("suscl1 ");
            if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
            {
                Debug.WriteLine("err_uscl7");
            }

            //displaysoil(0,0);
            double mass_before = total_catchment_mass();
            total_average_soilthickness_m = 0;
            number_soil_thicker_than = 0;
            number_soil_coarser_than = 0;
            local_soil_depth_m = 0;
            local_soil_mass_kg = 0;

            int layer;
            int numberoflayers = 0;
            double depth_m;  // keep better track of this, currently not OK yet
            try
            {
                /*
                //displaysoil(0, 0);
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            update_all_layer_thicknesses(row, col);
                            update_all_layer_thicknesses(row, col);
                            // Debug.WriteLine("suscl2");
                            if (NA_in_soil(row, col)) { Debugger.Break(); }

                            depth_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                ////update the layers' thickness now that textures and organic matter amounts have changed (if there is anything in the layer at all).
                                //if (!(texture_kg[row, col, layer, 0] == 0 && texture_kg[row, col, layer, 1] == 0 && texture_kg[row, col, layer, 2] == 0 && texture_kg[row, col, layer, 3] == 0 && texture_kg[row, col, layer, 4] == 0 && young_SOM_kg[row, col, layer] == 0 && old_SOM_kg[row, col, layer] == 0))
                                //{
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //layerthickness_m[row, col, layer] = thickness_calc(row, col, layer);
                                //if (layerthickness_m[row,col,layer] < 0) { Debugger.Break(); } //MMS
                                //find_negative_texture_rcl(row, col, layer); //MMS
                                //}
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                                {
                                    local_soil_mass_kg += texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    if (local_soil_mass_kg < 0) { Debugger.Break(); } //MMS
                                }
                                if (timeseries.timeseries_soil_mass_checkbox.Checked && layer == 0 && texture_kg[row, col, layer, 0] / (texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) > System.Convert.ToDouble(timeseries.timeseries_soil_coarser_fraction_textbox.Text))
                                {
                                    number_soil_coarser_than++;
                                }
                            }

                        }
                    }
                } */

                //displaysoil(0, 0);
                depth_m = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            remove_empty_layers(row, col);
                            remove_empty_layers(row, col);
                            update_all_layer_thicknesses(row, col);
                            double old_soil_mass = total_soil_mass_kg(row, col), new_soil_mass;
                            // Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            // Debug.WriteLine("soil before splitting");
                            // if (row == 0 & col == 0) { displaysoil(row, col); }
                            depth_m = 0; numberoflayers = 0;
                            bool boolsplit = false;
                            bool boolcombine = false;

                            if (checkbox_layer_thickness.Checked) // fixed layer thickness
                            {
                                for (layer = 0; layer < (max_soil_layers - 1); layer++)
                                {
                                    if (total_layer_mass_kg(row, col, layer) > 0)
                                    {
                                        //Debug.WriteLine("depth is now " + depth + " for lyr " +  layer);
                                        // Debug.WriteLine("Start update split combine");
                                        numberoflayers++;
                                        if (layer == 0)
                                        {
                                            if (layerthickness_m[row, col, layer] < 0.001 | total_soil_mass_kg(row, col) < 0.001) // smaller than one mm, lighter than 1 gram -> merge with layer below, to avoid numerical problems when always a fraction leaves the profile (e.g. with creep)
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                // Debug.WriteLine("suscl2");
                                                update_all_layer_thicknesses(row, col);
                                                // Debug.WriteLine("suscl3");
                                                boolcombine = true;
                                                if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6))
                                                {
                                                    Debug.WriteLine("err_uscl9");
                                                }
                                                // Debug.WriteLine("suscl4");
                                            }
                                            while (layerthickness_m[row, col, layer] > dz_standard * (1 + tolerance)) //Higher end, split
                                            { //split 
                                                split_layer(row, col, layer, depth_m);
                                                // Debug.WriteLine("splitting after combining 2");
                                                // Debug.WriteLine("d_layer {0}", layerthickness_m[row, col, layer]);
                                                update_all_layer_thicknesses(row, col);
                                                // Debug.WriteLine("splitting after combining 3");
                                                // Debug.WriteLine("d_layer {0}", layerthickness_m[row, col, layer] );
                                                boolsplit = true;
                                            }
                                        }
                                        if (layer != 0)
                                        {
                                            if (layerthickness_m[row, col, layer] < (dz_standard * (1 - tolerance))) // Lower end, combine
                                            {
                                                if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                                {
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                                    {
                                                        Debug.WriteLine("err_uscl10");
                                                    }
                                                    combine_layers(row, col, layer, layer + 1);
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6))
                                                    {
                                                        Debug.WriteLine("err_uscl11");
                                                    }
                                                }
                                                else
                                                {
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                                    {
                                                        Debug.WriteLine("err_uscl12");
                                                    }
                                                    combine_layers(row, col, layer - 1, layer);
                                                    layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    // if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass(row, col), 6)) { Debugger.Break(); }
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                                    {
                                                        Debug.WriteLine("err_uscl13");
                                                    }

                                                }
                                            }
                                            if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                            {
                                                Debug.WriteLine("err_uscl14");
                                            }
                                            if (NA_in_soil(row, col))
                                            {
                                                Debug.WriteLine("err_uscl15");
                                            }
                                            // MvdM changed the 'while' into an 'if' below, to prevent an infinite loop
                                            if (layerthickness_m[row, col, layer] > dz_standard * (1 + tolerance)) //Higher end, split
                                            { //split 
                                              // Debug.WriteLine("splitting after combining 1");
                                                split_layer(row, col, layer, depth_m);
                                                update_all_layer_thicknesses(row, col);
                                                boolsplit = true;
                                                // if (Math.Abs(old_soil_mass-total_soil_mass(row, col))>0.00000001) { Debugger.Break(); }
                                            }

                                            if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                            {
                                                Debug.WriteLine("err_uscl16");
                                            }

                                            //Debug.WriteLine("depth is now " + depth + " and number of layers is  " + numberoflayers);
                                        }
                                        if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                        {
                                            Debug.WriteLine("err_uscl17");
                                        }
                                    }
                                } // end layer
                            } // end fixed layer thickness
                            else // variable layer thickness
                            {
                                for (layer = 0; layer < max_soil_layers - 1; layer++)
                                {
                                    if (layerthickness_m[row, col, layer] > 0)
                                    {
                                        //Debug.WriteLine("depth is now " + depth + " for lyr " +  layer);
                                        numberoflayers++;

                                        // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                        // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                        // daarna     min 50    insteek 100  geen max            n=4

                                        if (depth_m <= 0.5)
                                        {
                                            if (layer == 0 & layerthickness_m[row, col, layer] < 0.001) // smaller than one mm -> merge with layer below
                                            {
                                                combine_layers(row, col, layer, layer + 1);
                                                update_all_layer_thicknesses(row, col);
                                                boolcombine = true;
                                                if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6)) { Debug.WriteLine("err_uscl2"); }
                                            }

                                            if (layerthickness_m[row, col, layer] < 0.025 && layer != 0)
                                            { //combine layers: select the one most like this one
                                                if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                                {
                                                    combine_layers(row, col, layer, layer + 1);
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6))
                                                    {
                                                        Debug.WriteLine("err_uscl3");
                                                    }

                                                }
                                                else
                                                {
                                                    combine_layers(row, col, layer - 1, layer);
                                                    layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Round(old_soil_mass, 6) != Math.Round(total_soil_mass_kg(row, col), 6)) { Debugger.Break(); }

                                                }
                                                // we will now check whether layers have become too thick and if needed cut them in half
                                            }

                                            while (layerthickness_m[row, col, layer] > 0.1)
                                            { //split 
                                              // Debug.WriteLine("splitting after combining 1");
                                                split_layer(row, col, layer, depth_m);
                                                update_all_layer_thicknesses(row, col);
                                                boolsplit = true;
                                                if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001) { Debugger.Break(); }

                                            }

                                            // 0-50 cm    min 2.5   insteek 5    maximum 10 cm       n=10    bovenste laag geen minimum (sediment HOEFT niet meteen weggemiddeld te worden - pas als nodig)
                                            // 50-250 cm  min 10    insteek 25    maximum 50 cm      n=8
                                            // daarna     min 50    insteek 100  geen max            n=4

                                        }

                                        depth_m += layerthickness_m[row, col, layer]; // MM moved this down one if-function, to be able to split big clumps of earth by tree fall. If I put it at the end, it will give problems with splitting the one-before-last layer

                                        if (depth_m > 0.5 && depth_m <= 2)
                                        {
                                            if (layerthickness_m[row, col, layer] < 0.1 && layer != 0)
                                            { //combine 
                                                if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                                {
                                                    combine_layers(row, col, layer, layer + 1);
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001)
                                                    {
                                                        Debug.WriteLine("err_uscl4");
                                                    }
                                                }
                                                else
                                                {
                                                    combine_layers(row, col, layer - 1, layer);
                                                    layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001) { Debugger.Break(); }

                                                }
                                            }
                                            while (layerthickness_m[row, col, layer] > 0.5)
                                            { //split 
                                              // Debug.WriteLine("splitting after combining 2. layer = {0}, layerthickness = {1}", layer, layerthickness_m[row, col, layer]);
                                                split_layer(row, col, layer, depth_m);
                                                update_all_layer_thicknesses(row, col);
                                                boolsplit = true;
                                                new_soil_mass = total_soil_mass_kg(row, col);
                                                if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                                                {
                                                    Debug.WriteLine("err_uscl5");
                                                }

                                            }
                                        }

                                        if (depth_m > 2)
                                        {
                                            if (layerthickness_m[row, col, layer] < 0.4 && layer != 0)
                                            { //combine 
                                              //displaysoil(row, col);
                                                if (layer_difference(row, col, layer, layer - 1) > layer_difference(row, col, layer, layer + 1))
                                                {
                                                    combine_layers(row, col, layer, layer + 1);
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001)
                                                    {
                                                        Debug.WriteLine("err_uscl6");
                                                    }

                                                }
                                                else
                                                {
                                                    combine_layers(row, col, layer - 1, layer);
                                                    layer--;  //because we combined with the previous one, the current one has been replaced with one that has not yet been considered
                                                    numberoflayers--;
                                                    update_all_layer_thicknesses(row, col);
                                                    boolcombine = true;
                                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00000001) { Debugger.Break(); }
                                                }
                                            }
                                            if (layerthickness_m[row, col, layer] > 0.5)
                                            { //split 
                                              // no splitting, no maximum thickness
                                            }
                                        }
                                        //Debug.WriteLine("depth is now " + depth + " and number of layers is  " + numberoflayers);
                                    }
                                    if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                                    {
                                        Debug.WriteLine("err_uscl17");
                                    }

                                }
                            } // end variable layer thickness
                              //Debug.WriteLine("suscl1" + row + ", " + col + ", " + t);
                            if (NA_in_soil(row, col))
                            {
                                Debug.WriteLine("err_uscl18");
                            }

                            for (int layupdate = 0; layupdate < max_soil_layers; layupdate++)
                            {
                                layerthickness_m[row, col, layupdate] = thickness_calc(row, col, layupdate);
                            }
                            //Debug.WriteLine("Soil after splitting");
                            //if (row == 0 & col == 0) { displaysoil(row, col); }

                            // Debug.WriteLine("suscl4");
                            //displaysoil(0, 0);
                            if (Math.Abs(old_soil_mass - total_soil_mass_kg(row, col)) > 0.00001)
                            {
                                Debug.WriteLine("err_uscl19");
                            }
                            new_soil_mass = total_soil_mass_kg(row, col);
                            // if (numberoflayers > max_soil_layers)
                            if (Math.Abs(old_soil_mass - new_soil_mass) > 0.00000001)
                            {
                                // this should never happen, because the data of the lowest layers have then been lost.
                                // Debug.WriteLine("{0}", t);
                                Debug.WriteLine(" Warning - loss of soil data ");
                                //displaysoil(row, col);
                                Debug.WriteLine("err_uscl20");

                            }
                            if (timeseries.timeseries_number_soil_thicker_checkbox.Checked && System.Convert.ToDouble(timeseries.timeseries_soil_thicker_textbox.Text) < depth_m) { number_soil_thicker_than++; }
                            if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m += depth_m; }
                            if (timeseries.timeseries_soil_depth_checkbox.Checked && System.Convert.ToInt32(timeseries.timeseries_soil_cell_row.Text) == row && System.Convert.ToInt32(timeseries.timeseries_soil_cell_col.Text) == col)
                            {
                                local_soil_depth_m = depth_m;
                            }

                            //Debug.WriteLine("suscl0" + row + ", " + col + ", " + t + " " + total_soil_mass(row, col));
                            // update dtm and soil thickness map //MMS
                            update_all_layer_thicknesses(row, col);
                            double old_thickness = soildepth_m[row, col];
                            double new_thickness = total_soil_thickness(row, col);
                            dtm[row, col] += new_thickness - old_thickness;
                            soildepth_m[row, col] = new_thickness;
                            dtmchange_m[row, col] += new_thickness - old_thickness;
                            dz_soil[row, col] += new_thickness - old_thickness;
                        } // end dtm!=-9999
                    } // end col
                } // end row

                if (timeseries.total_average_soilthickness_checkbox.Checked) { total_average_soilthickness_m /= number_of_data_cells; }
            }
            catch
            {
                Debug.WriteLine("err_uscl21");
            }
            double mass_after = total_catchment_mass();

        } // aangepast voor constante diktes

        private void find_negative_texture()
        {
            for (int rr = 0; rr < nr; rr++)
            {
                for (int cc = 0; cc < nc; cc++)
                {
                    for (int ll = 0; ll < max_soil_layers; ll++)
                    {
                        for (int tt = 0; tt < 5; tt++)
                        {
                            if (texture_kg[rr, cc, ll, tt] < 0)
                            {
                                Debug.WriteLine("err_nt1");
                            }
                        }
                    }
                }
            }
        }

        double layer_difference(int rowwer, int coller, int lay1, int lay2)   //calculates a simple measure of difference between two soil layers based on the sum of relative differences in a set of properties
        {
            double average_property_value = 0, property_difference = 0, sum_property_difference = 0;

            try
            {
                // double average_property_value = 0, property_difference = 0, sum_property_difference = 0;
                for (int i = 0; i < 5; i++)
                {
                    //account for total soil mass
                    average_property_value = (texture_kg[rowwer, coller, lay1, i] + texture_kg[rowwer, coller, lay2, i]) / 2;
                    property_difference = Math.Abs(texture_kg[rowwer, coller, lay1, i] - texture_kg[rowwer, coller, lay2, i]);
                    sum_property_difference += property_difference / average_property_value;
                }
                average_property_value = (old_SOM_kg[rowwer, coller, lay1] + old_SOM_kg[rowwer, coller, lay2]) / 2;
                property_difference = Math.Abs(old_SOM_kg[rowwer, coller, lay1] - old_SOM_kg[rowwer, coller, lay2]);
                sum_property_difference += property_difference / average_property_value;
                average_property_value = (young_SOM_kg[rowwer, coller, lay1] + young_SOM_kg[rowwer, coller, lay2]) / 2;
                property_difference = Math.Abs(young_SOM_kg[rowwer, coller, lay1] - young_SOM_kg[rowwer, coller, lay2]);
                sum_property_difference += property_difference / average_property_value;
                sum_property_difference /= 7;
                return sum_property_difference;
            }
            catch
            {
                MessageBox.Show("error in calculating layer difference");
            }
            return sum_property_difference;
        }

        void combine_layers(int rowwer, int coller, int lay1, int lay2)  // combines two soil layers into the first, recalculates their new thickness and shifts underlying layers up
        {
            double CN_before = 0, CN_after = 0;
            //if (CN_checkbox.Checked) { CN_before = total_CNs(); }
            double mass_before = total_layer_mass_kg(rowwer, coller, lay1) + total_layer_mass_kg(rowwer, coller, lay2);
            try
            {
                int totalgrains_start = 0;
                if (OSL_checkbox.Checked) { for (int lay_OSL = 0; lay_OSL < max_soil_layers; lay_OSL++) { totalgrains_start += OSL_grainages[rowwer, coller, lay_OSL].Length; } }

                double old_soil_mass1 = total_soil_mass_kg(rowwer, coller);
                // Debug.WriteLine("Total soil mass: {0}", old_soil_mass); displaysoil(rowwer, coller); 
                //Debug.WriteLine("cl0");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                for (int i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, lay1, i] += texture_kg[rowwer, coller, lay2, i];
                    texture_kg[rowwer, coller, lay2, i] = 0;// set to zero. otherwise the shifting of the layers doesn't work
                    double new_soil_mass = total_soil_mass_kg(rowwer, coller);

                }

                old_SOM_kg[rowwer, coller, lay1] += old_SOM_kg[rowwer, coller, lay2];
                old_SOM_kg[rowwer, coller, lay2] = 0;

                young_SOM_kg[rowwer, coller, lay1] += young_SOM_kg[rowwer, coller, lay2];
                young_SOM_kg[rowwer, coller, lay2] = 0;

                if (CN_checkbox.Checked)
                {
                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                    {
                        CN_atoms_cm2[rowwer, coller, lay1, cosmo] += CN_atoms_cm2[rowwer, coller, lay2, cosmo];
                        CN_atoms_cm2[rowwer, coller, lay2, cosmo] = 0;
                    }
                }

                if (OSL_checkbox.Checked) { transfer_OSL_grains(rowwer, coller, lay2, rowwer, coller, lay1, 1, 0); } // transfer all grains from lay2 to lay1

                //Debug.WriteLine("cl1");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                layerthickness_m[rowwer, coller, lay1] = thickness_calc(rowwer, coller, lay1); // thickness_calc uses a pdf to calculate bulk density and hence layer thickness

                for (int layert = lay2; layert < max_soil_layers - 1; layert++) // for all underlying layers, shift one up (since there is space anyway)
                {
                    //Debug.WriteLine(layert);
                    for (int i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, layert, i] = texture_kg[rowwer, coller, layert + 1, i];
                    }
                    //Debug.WriteLine("cl1b");
                    old_SOM_kg[rowwer, coller, layert] = old_SOM_kg[rowwer, coller, layert + 1];
                    young_SOM_kg[rowwer, coller, layert] = young_SOM_kg[rowwer, coller, layert + 1];
                    //Debug.WriteLine("cl1c");
                    if (CN_checkbox.Checked)
                    {
                        for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                        {
                            CN_atoms_cm2[rowwer, coller, layert, cosmo] = CN_atoms_cm2[rowwer, coller, layert + 1, cosmo];
                        }
                    }

                    if (OSL_checkbox.Checked)
                    {
                        transfer_OSL_grains(rowwer, coller, layert + 1, rowwer, coller, layert, 1, 0); // transfer all grains from layert + 1 to layert
                    }
                    //Debug.WriteLine("cl1d");
                }
                //Debug.WriteLine("cl2");

                //now set the last layer to sentinel value of -1
                for (int i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, max_soil_layers - 1, i] = 0;
                }
                old_SOM_kg[rowwer, coller, max_soil_layers - 1] = 0;
                young_SOM_kg[rowwer, coller, max_soil_layers - 1] = 0;
                layerthickness_m[rowwer, coller, max_soil_layers - 1] = 0;
                bulkdensity[rowwer, coller, max_soil_layers - 1] = 0;

                if (CN_checkbox.Checked)
                {
                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                    {
                        CN_atoms_cm2[rowwer, coller, max_soil_layers - 1, cosmo] = 0;
                    }
                    //CN_after = total_CNs();
                    //if (((CN_before - CN_after) / (CN_after + 1)) > 1E-6) { Debugger.Break(); }
                }
                //Debug.WriteLine("cl4");

                double new_soil_mass1 = total_soil_mass_kg(rowwer, coller);
                //if (Math.Abs(old_soil_mass1 - new_soil_mass1) > 0.00000001) { displaysoil(rowwer, coller); Debugger.Break(); }
                double mass_after = total_layer_mass_kg(rowwer, coller, lay1);
                if (Math.Abs(mass_before - mass_after) > 0.0001)
                {
                    Debug.WriteLine("err_cl1");
                }

                int totalgrains_end = 0;
                if (OSL_checkbox.Checked) { for (int lay_OSL = 0; lay_OSL < max_soil_layers; lay_OSL++) { totalgrains_end += OSL_grainages[rowwer, coller, lay_OSL].Length; } if (totalgrains_end != totalgrains_start) { Debugger.Break(); } }
            }
            catch
            {
                Debug.WriteLine("Failed at combining layers {0} {1} at row {2}, col {3} at time {4}", lay1, lay2, rowwer, coller, t);
                Debugger.Break();
            }
        }

        double bulk_density_calc(double coarse_mass, double sand_mass, double silt_mass, double clay_mass, double fine_clay_mass, double OMo_mass, double OMy_mass, double depth)
        {
            if (depth == 0) { depth = 0.001; } // reset values of 0 to a thickness of 1 micrometer, to avoid infinite numbers in the calculation of BD
            double bd = 2700, combined_frac, m_finesoil;
            m_finesoil = sand_mass + silt_mass + clay_mass + fine_clay_mass;
            if (m_finesoil > 0)
            {
                combined_frac = sand_mass / m_finesoil + 0.76 * silt_mass / m_finesoil;

                bd = 1000 * (1.35 + 0.00452 * 100 * combined_frac + Math.Pow(44.65 - 100 * combined_frac, 2) * -0.0000614 + 0.06 * Math.Log10(depth));  // in kg/m3

                //now coarse fragment and SOM correction
                bd = (coarse_mass + m_finesoil + OMo_mass + OMy_mass) / ((m_finesoil / bd) + (coarse_mass / 2700) + (OMo_mass + OMy_mass) / 224); // ooit through interface    
            }
            else
            {
                bd = 2700;
            }

            return bd;

        }

        double thickness_calc(int rowwer, int coller, int lay1)
        {
            // Debug.WriteLine("tc1");
            double thickness, soil_mass = 0;

            // calculate current depth of layer, for bulk density calculations, using current thickness. 
            double depth_m = 0;
            for (int lay_temp = 0; lay_temp < lay1; lay_temp++)
            {
                depth_m += layerthickness_m[rowwer, coller, lay_temp];
            }
            depth_m += layerthickness_m[rowwer, coller, lay1] / 2;
            // Debug.WriteLine("tc2");
            int i;
            //first calculate total soil mass to calculate mass percentages for the size fractions
            for (i = 1; i < 5; i++)
            {
                soil_mass += texture_kg[rowwer, coller, lay1, i];
            }
            soil_mass += old_SOM_kg[rowwer, coller, lay1] + young_SOM_kg[rowwer, coller, lay1];
            // Debug.WriteLine("tc3");
            if (soil_mass > 0)
            {
                bulkdensity[rowwer, coller, lay1] = bulk_density_calc(texture_kg[rowwer, coller, lay1, 0], texture_kg[rowwer, coller, lay1, 1], texture_kg[rowwer, coller, lay1, 2], texture_kg[rowwer, coller, lay1, 3], texture_kg[rowwer, coller, lay1, 4], old_SOM_kg[rowwer, coller, lay1], young_SOM_kg[rowwer, coller, lay1], depth_m);
            }
            else
            {
                //either there is no soil at all, or there is only coarse material
                if (texture_kg[rowwer, coller, lay1, 0] > 0)
                {
                    bulkdensity[rowwer, coller, lay1] = 2700;   //kg/m3
                }
                // Debug.WriteLine("tc5");

            }
            // Debug.WriteLine("tc5");
            soil_mass += texture_kg[rowwer, coller, lay1, 0];
            if (soil_mass == 0)
            {
                thickness = 0;
            }
            else
            {
                thickness = (soil_mass) / (dx * dx * bulkdensity[rowwer, coller, lay1]);  // thickness in m per unit area
            }
            // Debug.WriteLine("tc6");
            if (double.IsNaN(thickness)) { thickness = 0.00000000001; }
            return thickness;
        }

        double calc_thickness_from_mass(double[] textures_kg, double yom_kg, double oom_kg)
        {
            //pdf goes here
            double thickness_m = 0, soil_mass_kg = 0;
            double sand_fraction, silt_fraction, bulk_density;
            //first calculate total soil mass to calculate mass percentages for the fine earth fractions (excluding coarse)
            for (int ir = 1; ir < 5; ir++)
            {
                soil_mass_kg += textures_kg[ir];
            }
            soil_mass_kg += oom_kg + yom_kg;
            sand_fraction = textures_kg[1] / soil_mass_kg;
            silt_fraction = textures_kg[2] / soil_mass_kg;

            //calculate bulk density
            bulk_density = bulk_density_calc(textures_kg[0], textures_kg[1], textures_kg[2], textures_kg[3], textures_kg[4], oom_kg, yom_kg, 0.001); // MM depth of 1 micrometer, because a depth of 0 will result in infinite numbers 

            thickness_m = (soil_mass_kg + textures_kg[0]) / (dx * dx * bulk_density);  // thickness in m per unit area

            return thickness_m;
        }

        double total_soil_mass_kg(int rowmass, int colmass)
        {
            double tot_mass = 0;
            for (int lay = 0; lay < max_soil_layers; lay++)
            {
                for (int ii = 0; ii < n_texture_classes; ii++)
                {
                    tot_mass += texture_kg[rowmass, colmass, lay, ii];
                }
                tot_mass += old_SOM_kg[rowmass, colmass, lay];
                tot_mass += young_SOM_kg[rowmass, colmass, lay];
            }
            return (tot_mass);
        }

        double total_layer_mass_kg(int rowmass, int colmass, int laymass)
        {
            double tot_mass = 0;

            for (int ii = 0; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        double total_layer_fine_earth_mass_kg(int rowmass, int colmass, int laymass)
        {
            double tot_mass = 0;

            for (int ii = 1; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        double total_layer_mineral_earth_mass_kg(int rowmass, int colmass, int laymass) //MMS
        {
            double tot_mass = 0;

            for (int ii = 0; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            //tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            //tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        double total_layer_fine_earth_om_mass_kg(int rowmass, int colmass, int laymass) //MMS
        {
            double tot_mass = 0;

            for (int ii = 1; ii < 5; ii++)
            {
                tot_mass += texture_kg[rowmass, colmass, laymass, ii];
            }
            tot_mass += old_SOM_kg[rowmass, colmass, laymass];
            tot_mass += young_SOM_kg[rowmass, colmass, laymass];

            return (tot_mass);
        }

        bool findnegativetexture()
        {
            bool neg = false;

            try
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        for (int lay = 0; lay < max_soil_layers; lay++)
                        {
                            for (int tex = 0; tex < n_texture_classes; tex++)
                            {
                                if (texture_kg[row, col, lay, tex] < 0) { neg = true; }
                            }
                        }
                    }
                }
            }
            catch
            {
                Debug.WriteLine("err_nt2");

            }

            return neg;
        }

        double total_mass_in_transport()
        {
            double tot_mass = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    for (ii = 0; ii < 5; ii++)
                    {
                        tot_mass += sediment_in_transport_kg[rowmass, colmass, ii];
                    }

                    tot_mass += old_SOM_in_transport_kg[rowmass, colmass];
                    tot_mass += young_SOM_in_transport_kg[rowmass, colmass];
                }
            }
            return (tot_mass);
        }

        double mass_in_transport_row_col(int row1, int col1)
        {
            double tot_mass = 0;
            for (ii = 0; ii < 5; ii++)
            {
                tot_mass += sediment_in_transport_kg[row1, col1, ii];
            }

            tot_mass += old_SOM_in_transport_kg[row1, col1];
            tot_mass += young_SOM_in_transport_kg[row1, col1];

            return (tot_mass);
        }

        double total_catchment_mass()
        {
            double tot_mass = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    for (int lay = 0; lay < max_soil_layers; lay++)
                    {
                        for (ii = 0; ii < 5; ii++)
                        {
                            tot_mass += texture_kg[rowmass, colmass, lay, ii];
                        }
                        tot_mass += old_SOM_kg[rowmass, colmass, lay];
                        tot_mass += young_SOM_kg[rowmass, colmass, lay];
                    }
                }
            }

            return (tot_mass);
        }

        double total_catchment_elevation()
        {
            double tot_elev = 0;
            for (int rowmass = 0; rowmass < nr; rowmass++)
            {
                for (int colmass = 0; colmass < nc; colmass++)
                {
                    if (dtm[rowmass, colmass] != -9999)
                    {
                        tot_elev += dtm[rowmass, colmass];
                    }

                }
            }

            return (tot_elev);
        }

        double total_soil_thickness(int rowthick, int colthick)
        {
            double tot_thick = 0;
            for (int lay = 0; lay < max_soil_layers; lay++)
            {
                tot_thick += layerthickness_m[rowthick, colthick, lay];
            }
            return (tot_thick);
        }

        void split_layer(int rowwer, int coller, int lay1, double currentdepth) // splits layers 
        {

            try
            {
                // if(t == 7 & row == 0 & col == 41) { Debugger.Break(); }
                int totalgrains_start = 0;
                int grains_splitlayer = 0;
                int[] grains_before = new int[max_soil_layers];
                int[] grains_after = new int[max_soil_layers];
                if (OSL_checkbox.Checked)
                {
                    for (int lay_OSL = 0; lay_OSL < max_soil_layers; lay_OSL++)
                    {
                        totalgrains_start += OSL_grainages[rowwer, coller, lay_OSL].Length;
                        grains_before[lay_OSL] = OSL_grainages[rowwer, coller, lay_OSL].Length;
                    }
                    grains_splitlayer = OSL_grainages[rowwer, coller, lay1].Length;
                }

                double max_layer_difference, current_difference, maximum_allowed_thickness, old_mass_soil, new_soil_mass;
                old_mass_soil = total_soil_mass_kg(rowwer, coller);
                //splitting will increase the number of layers. If this splits beyond the max number of layers, then combine the two most similar ones 
                int laynum, combininglayer = -1;
                // Debug.WriteLine("sl0");
                if (diagnostic_mode == 1) { Debug.WriteLine("total soil mass = " + total_soil_mass_kg(rowwer, coller)); }
                double mass_lowest_layer = total_layer_mass_kg(rowwer, coller, max_soil_layers - 1);
                if (diagnostic_mode == 1) { Debug.WriteLine("total mass last layer = {0}", mass_lowest_layer); }
                if ((total_layer_mass_kg(rowwer, coller, max_soil_layers - 1) > 0))  // so, if we are using the lowest possible layer already:
                {
                    //this breaks now because the lowest layer can be empty due to its encountering a hard layer
                    //if they are already all in use, then the split will create one too many. We start by looking for the two most similar layers that would not create a too-thick product (do we need to do that last part?)
                    max_layer_difference = 100; //100 is a huge difference
                    for (laynum = 0; laynum < max_soil_layers - 1; laynum++)
                    {
                        current_difference = layer_difference(rowwer, coller, laynum, laynum + 1);
                        maximum_allowed_thickness = 9999;   // 9999 is a sentinel value and means infinitely thick 
                        if (currentdepth < 0.5) { maximum_allowed_thickness = 0.1; }
                        else { if (currentdepth < 2.5) { maximum_allowed_thickness = 0.5; } }

                        if (checkbox_layer_thickness.Checked) // Overwrite max allowed thickness in case of fixed initial layer thicknesses
                        {
                            maximum_allowed_thickness = dz_standard * (1 + tolerance);
                        }
                        if (layerthickness_m[rowwer, coller, laynum] + layerthickness_m[rowwer, coller, laynum + 1] < maximum_allowed_thickness)  //if it potentially is possible to combine them 
                        {
                            if (current_difference <= max_layer_difference)   // the equal to condition means that we prefer to combine layers lower in the profile (if equally different from each other)
                            {
                                max_layer_difference = current_difference;
                                combininglayer = laynum;
                            }
                        }
                    }
                    // Debug.WriteLine("sl1");
                    //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));

                    //combine the two most-similar layers, or the lowest two if nothing else possible
                    if (max_layer_difference == 100) { combininglayer = max_soil_layers - 2; }
                    // Debug.WriteLine("sl1a");
                    if (diagnostic_mode == 1)

                        Debug.WriteLine(rowwer + "," + coller + "," + combininglayer + "," + (combininglayer + 1) + "," + t);

                    try { combine_layers(rowwer, coller, combininglayer, combininglayer + 1); }
                    catch { Debug.WriteLine(" failed to combine layers to prepare for splitting "); }
                    // Debug.WriteLine("sl1b");
                    //make sure to change lay1 if needed (because something overlying has been combined into 1 for instance).
                    if (combininglayer == lay1 || combininglayer == lay1 - 1)
                    {
                        if (diagnostic_mode == 1) { Debug.WriteLine("the layer that needed to be split has now been combined: layer {0} at t {1}", combininglayer, t); }
                        // displaysoil(rowwer, coller);
                        // Debugger.Break();
                    }
                    if (combininglayer < lay1) { lay1++; } // mvdm Should this be changed from ++ to --? because if layers above are combined, the target layer has moved up one spot
                                                           // Debug.WriteLine("sl1c");
                }

                if (Math.Abs(old_mass_soil - total_soil_mass_kg(rowwer, coller)) > 0.000001)
                {
                    Debug.WriteLine("err_spl_1 {0}", total_soil_mass_kg(rowwer, coller));
                    Debugger.Break();
                }
                // Debug.WriteLine("sl2");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));

                // now we can move all layers down below the one we want to split
                for (laynum = max_soil_layers - 1; laynum >= lay1 + 2; laynum--)  // we want to clear layer lay1+1 (so we run through move-receiving layers from below up to lay1+2). 
                //This means that layer laynum+1, into which we want to split, will be evacuated and will give its values to laynum+2;
                {
                    for (int i = 0; i < 5; i++)
                    {
                        texture_kg[rowwer, coller, laynum, i] = texture_kg[rowwer, coller, laynum - 1, i];
                        texture_kg[rowwer, coller, laynum - 1, i] = 0;
                    }
                    // Debug.WriteLine("sl2b, ");
                    old_SOM_kg[rowwer, coller, laynum] = old_SOM_kg[rowwer, coller, laynum - 1]; old_SOM_kg[rowwer, coller, laynum - 1] = 0;
                    young_SOM_kg[rowwer, coller, laynum] = young_SOM_kg[rowwer, coller, laynum - 1]; young_SOM_kg[rowwer, coller, laynum - 1] = 0;

                    if (CN_checkbox.Checked)
                    {
                        for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                        {
                            CN_atoms_cm2[rowwer, coller, laynum, cosmo] = CN_atoms_cm2[rowwer, coller, laynum - 1, cosmo]; CN_atoms_cm2[rowwer, coller, laynum - 1, cosmo] = 0;
                        }
                    }
                    if (OSL_checkbox.Checked)
                    {
                        transfer_OSL_grains(rowwer, coller, laynum - 1, rowwer, coller, laynum, 1, 0); // move all grains from laynum - 1 to laynum
                    }
                }
                if (Math.Abs(old_mass_soil - total_soil_mass_kg(rowwer, coller)) > 0.000001)
                {
                    Debug.WriteLine("err_spl_2 {0}", total_soil_mass_kg(rowwer, coller));
                    // Debugger.Break();
                    // old_mass_soil = total_soil_mass(rowwer, coller);
                }

                // MvdM cleaned up the code below. I removed the if-else statement for even splitting or uneven splitting and use div to split the layers. If even splitting, div = 0.5, if not, div gets recalculated
                double div = 0.5;
                if ((lay1 + 1) == (max_soil_layers - 1)) // if one of the splitting layers is the last layer, //MvdM develop. Changed this to max_soil_layers - 1, to indicate that the deeper layer is the last layer. Therefore, a different divide 
                {
                    div = dz_standard / (layerthickness_m[row, col, lay1]); // aim to have the split layer at standard thickness
                }
                if (div > 1) { div = 1; }
                for (i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, lay1 + 1, i] = texture_kg[rowwer, coller, lay1, i] * (1 - div);
                    texture_kg[rowwer, coller, lay1, i] *= div;
                    if (double.IsNaN(texture_kg[rowwer, coller, lay1, i]))
                    {
                        Debug.WriteLine("err_spl1");
                    }
                    if (double.IsNaN(texture_kg[rowwer, coller, lay1 + 1, i]))
                    {
                        Debug.WriteLine("err_spl2");
                    }
                }
                old_SOM_kg[rowwer, coller, lay1 + 1] += old_SOM_kg[rowwer, coller, lay1] * (1 - div);
                old_SOM_kg[rowwer, coller, lay1] *= div;
                young_SOM_kg[rowwer, coller, lay1 + 1] += young_SOM_kg[rowwer, coller, lay1] * (1 - div);
                young_SOM_kg[rowwer, coller, lay1] *= div;

                if (CN_checkbox.Checked)
                {
                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                    {
                        double transport = CN_atoms_cm2[rowwer, coller, lay1, cosmo] * (1 - div);
                        CN_atoms_cm2[rowwer, coller, lay1 + 1, cosmo] += transport;
                        CN_atoms_cm2[rowwer, coller, lay1, cosmo] -= transport;

                    }
                }
                //Debug.WriteLine(" successfully split layer ");
                // Debug.WriteLine("sl4");
                //Debug.WriteLine("total soil mass = " + total_soil_mass(rowwer, coller));
                if (OSL_checkbox.Checked)
                {
                    // jagged array
                    transfer_OSL_grains(rowwer, coller, lay1, rowwer, coller, lay1 + 1, (1 - div), 0);
                }
                new_soil_mass = total_soil_mass_kg(rowwer, coller);
                if (Math.Abs(old_mass_soil - new_soil_mass) > 0.000001)
                {
                    Debug.WriteLine("err_spl_3 {0}", total_soil_mass_kg(rowwer, coller));
                    Debugger.Break();
                }

                int totalgrains_end = 0;
                int splitlayers_end = 0;
                if (OSL_checkbox.Checked)
                {
                    for (int lay_OSL = 0; lay_OSL < max_soil_layers; lay_OSL++)
                    {
                        totalgrains_end += OSL_grainages[rowwer, coller, lay_OSL].Length;
                        grains_after[lay_OSL] = OSL_grainages[rowwer, coller, lay_OSL].Length;
                    }
                    if (totalgrains_end != totalgrains_start)
                    {
                        Debug.WriteLine("Grains before: {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", grains_before[0], grains_before[1], grains_before[2], grains_before[3], grains_before[4], grains_before[5], grains_before[6], grains_before[7], grains_before[8], grains_before[9]);
                        Debug.WriteLine("Grains after: {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", grains_after[0], grains_after[1], grains_after[2], grains_after[3], grains_after[4], grains_after[5], grains_after[6], grains_after[7], grains_after[8], grains_after[9]);

                        Debugger.Break();
                    }
                    splitlayers_end = OSL_grainages[rowwer, coller, lay1].Length + OSL_grainages[rowwer, coller, lay1 + 1].Length;
                    if (grains_splitlayer != splitlayers_end)
                    {
                        Debug.WriteLine("Grains before: {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", grains_before[0], grains_before[1], grains_before[2], grains_before[3], grains_before[4], grains_before[5], grains_before[6], grains_before[7], grains_before[8], grains_before[9]);
                        Debug.WriteLine("Grains after: {0}, {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, {9}", grains_after[0], grains_after[1], grains_after[2], grains_after[3], grains_after[4], grains_after[5], grains_after[6], grains_after[7], grains_after[8], grains_after[9]);
                        // Debugger.Break();
                        displaysoil(rowwer, coller);
                        // Debugger.Break();
                    }
                }
            }
            catch
            {
                Debug.WriteLine("Failed at splitting layer at row {0}, col {1} at time {2}", row, col, t);
            }

        }

        void split_layer_till(int rowwer, int coller, int lay1, double currentdepth) // splits layers 
        {

            double max_layer_difference, current_difference, maximum_allowed_thickness, frac_ap, frac_soil;
            //splitting will increase the number of layers. If this splits beyond the max number of layers, then combine the two most similar ones 
            int laynum, combininglayer = -1;
            if ((layerthickness_m[rowwer, coller, max_soil_layers - 1] > 0))  // so, if we are using the lowest possible layer already:
            {
                //if they are already all in use, then the split will create one too many. We start by looking for the two most similar layers that would not create a too-thick product (do we need to do that last part?)
                max_layer_difference = 100; //100 is a huge difference
                for (laynum = 0; laynum < max_soil_layers - 1; laynum++)
                {
                    current_difference = layer_difference(rowwer, coller, laynum, laynum + 1);
                    maximum_allowed_thickness = 9999;   // 9999 is a sentinel value and means infinitely thick 
                    if (currentdepth < 0.5) { maximum_allowed_thickness = 0.1; }
                    else { if (currentdepth < 2.5) { maximum_allowed_thickness = 0.5; } }

                    if (layerthickness_m[rowwer, coller, laynum] + layerthickness_m[rowwer, coller, laynum + 1] < maximum_allowed_thickness)  //if it potentially is possible to combine them 
                    {
                        if (current_difference <= max_layer_difference)   // the equal to condition means that we prefer to combine layers lower in the profile (if equally different from each other)
                        {
                            max_layer_difference = current_difference; combininglayer = laynum;
                        }
                    }
                }
                //combine the two most-similar layers, or the lowest two if nothing else possible
                if (max_layer_difference == 100) { combininglayer = max_soil_layers - 2; }
                try { combine_layers(rowwer, coller, combininglayer, combininglayer + 1); }
                catch { Debug.WriteLine(" failed to combine layers to prepare for splitting "); }
                //make sure to change lay1 if needed (because something overlying has been combined into 1 for instance).
                if (combininglayer == lay1 || combininglayer == lay1 - 1) { Debug.WriteLine("the layer that needed to be split has now been combined "); }
                if (combininglayer < lay1) { lay1++; }
            }
            // now we can move all layers down below the one we want to split
            for (laynum = max_soil_layers - 1; laynum <= lay1 + 2; laynum--)  // we want to clear layer lay1+1 (so we run through move-receiving layers from below up to lay1+2). 
                                                                              //This means that layer laynum+1, into which we want to split, will be evacuated and will give its values to laynum+2;
            {
                for (i = 0; i < 5; i++)
                {
                    texture_kg[rowwer, coller, laynum, i] = texture_kg[rowwer, coller, laynum - 1, i];
                }
                old_SOM_kg[rowwer, coller, laynum] = old_SOM_kg[rowwer, coller, laynum - 1];
                young_SOM_kg[rowwer, coller, laynum] = young_SOM_kg[rowwer, coller, laynum - 1];
            }
            //Debug.WriteLine(" moved layers one down to make space for split layer ");
            double inithick = layerthickness_m[rowwer, coller, laynum];
            frac_ap = plough_depth / inithick;
            frac_soil = 1 - frac_ap;
            for (i = 0; i < 5; i++)
            {
                texture_kg[rowwer, coller, lay1 + 1, i] = texture_kg[rowwer, coller, lay1, i] * frac_soil; texture_kg[rowwer, coller, lay1, i] *= frac_ap;
            }
            old_SOM_kg[rowwer, coller, lay1 + 1] = old_SOM_kg[rowwer, coller, lay1] / 2; old_SOM_kg[rowwer, coller, lay1] /= 2;
            young_SOM_kg[rowwer, coller, lay1 + 1] = young_SOM_kg[rowwer, coller, lay1] / 2; young_SOM_kg[rowwer, coller, lay1] /= 2;
            //Debug.WriteLine(" successfully split layer ");
        }

        bool search_nodataneighbour(int row, int col)
        {
            bool ndn = false;
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    if ((((row + i) < 0) | ((row + i) >= nr)) | (((col + j) < 0) | ((col + j) >= nc)))
                    {
                        ndn = true;
                    }
                }
            }
            return (ndn);
        }

        void soil_physical_weathering()  //calculate physical weathering
        {
            double old_mass = total_catchment_mass();
            int cells = nr * nc;
            int layer, tex_class;
            double depth;
            try
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        int tempcol = col;
                        depth = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, tempcol, layer] > 0)
                            {
                                int templayer = layer;
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                                for (tex_class = 0; tex_class <= 2; tex_class++)   //we only physically weather the coarse, sand and silt fractions.
                                {
                                    int tempclass = tex_class;
                                    // calculate the mass involved in physical weathering
                                    weathered_mass_kg = texture_kg[row, tempcol, templayer, tempclass] * physical_weathering_constant * Math.Exp(-Cone * depth) * -Ctwo / Math.Log10(upper_particle_size[tempclass]) * dt;
                                    total_phys_weathered_mass_kg += weathered_mass_kg;
                                    //Debug.WriteLine(" weathered mass is " + weathered_mass + " for class " + tempclass );
                                    // calculate the products involved
                                    if (tex_class == 0)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += 0.975 * weathered_mass_kg;
                                        texture_kg[row, tempcol, templayer, tempclass + 2] += 0.025 * weathered_mass_kg;
                                    }
                                    if (tex_class == 1)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += 0.96 * weathered_mass_kg;
                                        texture_kg[row, tempcol, templayer, tempclass + 2] += 0.04 * weathered_mass_kg;
                                    }
                                    if (tex_class == 2)
                                    {
                                        texture_kg[row, tempcol, templayer, tempclass + 1] += weathered_mass_kg;
                                    }
                                    texture_kg[row, tempcol, templayer, tempclass] -= weathered_mass_kg;
                                }
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                            }
                        }
                    }  //);
                } // end for cells
                  //timeseries
                if (timeseries.timeseries_cell_waterflow_check.Checked)
                {
                    timeseries_matrix[t, timeseries_order[23]] = total_phys_weathered_mass_kg;
                }
            }
            catch { Debug.WriteLine(" Soil physical weathering calculation threw an exception"); }

            double new_mass = total_catchment_mass();
            if (Math.Abs(old_mass - new_mass) > 0.000001)
            {
                Debug.WriteLine("err_spw1");
            }
        }

        void SPITS_soil_physical_weathering()  //calculate sedimentary rock (siltstone, limestone) physical weathering
        {
            // in this variant, coarse material (siltstone, limestone) weathers only into a silt fraction. 
            // Nothing else weathers. 
            // Not all of the coarse material weathers into silt, a certain fraction is lost to dissolution (90%).

            int cells = nr * nc;
            int layer, tex_class;
            double depth;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)

                    //Parallel.For(0, nc-1, col =>                    //we should paralellize over cols. Problem so far seems to be that the nc-1 or layer limit is exceeded
                    {
                        int tempcol = col;
                        //Code here is executed in parallel as much as possible for different soils in different places. 
                        //Main assumption: soils affect each other only through their surface interactions and not e.g. through throughflow
                        depth = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, tempcol, layer] > 0)
                            {
                                int templayer = layer;
                                depth += layerthickness_m[row, tempcol, templayer] / 2;
                                tex_class = 0;
                                int tempclass = tex_class;
                                // calculate the mass involved in physical weathering
                                weathered_mass_kg = texture_kg[row, tempcol, templayer, tempclass] * physical_weathering_constant * Math.Exp(-Cone * depth) * -Ctwo / Math.Log10(upper_particle_size[tempclass]) * dt;
                                //Debug.WriteLine(" weathered mass is " + weathered_mass + " for class " + tempclass );
                                // calculate the products involved
                                texture_kg[row, tempcol, templayer, tempclass + 2] += 0.1 * weathered_mass_kg;
                                texture_kg[row, tempcol, templayer, tempclass] -= weathered_mass_kg;
                            }
                        }
                    }  //);
                }
            }
            catch { Debug.WriteLine(" Soil physical weathering calculation threw an exception"); }

        }

        void SPITS_aeolian_deposition()
        {
            //tricks the deposition process by playing with tillage fields. Tillage shoudl be ON - but with zero par values.
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (tillfields[row, col] == 1)
                        {
                            //deposition in kg/m2/y is 0.063 
                            texture_kg[row, col, 0, 1] += 0.063 * dx * dx;
                        }
                    }
                }

            }
            catch { }
        }

        void soil_chemical_weathering()
        {
            int cells = nr * nc;
            int layer, tex_class;
            double depth, weathered_mass_kg, total_weath_mass, fraction_neoform;
            total_chem_weathered_mass_kg = 0;
            total_fine_neoformed_mass_kg = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    //Main assumption: soils affect each other only through their surface interactions and not e.g. through throughflow
                    depth = 0; total_weath_mass = 0;
                    for (layer = 0; layer < max_soil_layers; layer++)
                    {
                        if (layerthickness_m[row, col, layer] > 0)
                        {
                            depth += layerthickness_m[row, col, layer] / 2;
                            for (tex_class = 1; tex_class <= 4; tex_class++) // only sand, silt, clay and fine clay are chemically weathered
                            {
                                weathered_mass_kg = texture_kg[row, col, layer, tex_class] * chemical_weathering_constant / 10 * Math.Exp(-Cthree * depth) * Cfour * specific_area[tex_class] * dt;

                                if (daily_water.Checked) { weathered_mass_kg *= waterfactor[row, col]; }

                                //Debug.WriteLine(" weath mass for layer " + layer + " class " + tex_class + " is " + weathered_mass_kg + " " + Math.Exp(-Cthree * depth));
                                // note that the chem_weath constant is in kg/m2 mineral surface / y (in contrast to the original value from Salvador Blanes (mol/m2 mineral/s)
                                if (weathered_mass_kg > texture_kg[row, col, layer, tex_class]) { weathered_mass_kg = texture_kg[row, col, layer, tex_class]; }
                                total_chem_weathered_mass_kg += weathered_mass_kg;
                                texture_kg[row, col, layer, tex_class] -= weathered_mass_kg;

                                //the following code accounts for the change in average size of the weathered class, 
                                //and the fact that a fraction of it therefore falls into a finer class as well

                                if (tex_class == 1)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.0000156252 * weathered_mass_kg)
                                    {

                                        texture_kg[row, col, layer, tex_class] -= 0.0000156252 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.0000156252 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                if (tex_class == 2)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.0000640041 * weathered_mass_kg)
                                    {
                                        texture_kg[row, col, layer, tex_class] -= 0.0000640041 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.0000640041 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                if (tex_class == 3)
                                {
                                    if (texture_kg[row, col, layer, tex_class] > 0.000125 * weathered_mass_kg)
                                    {
                                        texture_kg[row, col, layer, tex_class] -= 0.000125 * weathered_mass_kg;
                                        texture_kg[row, col, layer, tex_class + 1] += 0.000125 * weathered_mass_kg;
                                    }
                                    else
                                    {
                                        texture_kg[row, col, layer, tex_class + 1] += texture_kg[row, col, layer, tex_class];
                                        texture_kg[row, col, layer, tex_class] = 0;
                                    }
                                }
                                total_weath_mass += weathered_mass_kg;  //leached amount
                            }

                            // clay neoformation
                            fraction_neoform = neoform_constant * (Math.Exp(-Cfive * depth) - Math.Exp(-Csix * depth));
                            if (fraction_neoform >= 1)
                            {
                                Debug.WriteLine(" Warning: more than 100% of leached mass wants to become fine clay. This may indicate an error. Capping at 100%");
                                fraction_neoform = 1;
                            }
                            if (daily_water.Checked) { fraction_neoform *= waterfactor[row, col]; }
                            texture_kg[row, col, layer, 4] += total_weath_mass * fraction_neoform;
                            total_fine_neoformed_mass_kg += total_weath_mass * fraction_neoform;
                            total_weath_mass -= total_weath_mass * fraction_neoform;
                            depth += layerthickness_m[row, col, layer] / 2;
                        }
                    }
                }
            }  //);
               //timeseries
            if (timeseries.total_chem_weath_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[24]] = total_chem_weathered_mass_kg;
            }
            if (timeseries.total_fine_formed_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[25]] = total_fine_neoformed_mass_kg;
            }

        }
       
        void soil_bioturbation()
        {
            try
            {
                //for bioturbation, we first calculate how much bioturbation (kg) this cell will experience, given its thickness
                //shallower soils do not experience the same amount as deeper soils
                //then we look at individual layers. Thicker layers, and layers closer to the surface, will experience more bioturbation kg
                //then, per layer, we will exchange the required bioturbation kg with the surrounding layers. 
                //Layers that are closer will exchange more than those that are further (regardless of whether they are deeper or closer to the surface)

                //XIA : For the Luxembourg study case, the kind of organic matter will affect the overall amount of bioturbation
                //Namely, 'young' organic matter (edible, from hornbeam) will allow more bioturbation than 'old' organic matter (inedible, from beech)
                //I simply calculate how much of each type the soil has, and then let the ratio between the two co-determine bioturbation.

                double local_bioturbation_kg, layer_bioturbation_kg, interlayer_bioturbation_kg;
                double layer_bio_activity_index, total_bio_activity_index, mass_distance_sum, mass_distance_layer;
                int layer, otherlayer;
                double fine_otherlayer_mass, fine_layer_mass;
                double total_soil_thickness_m;
                double depth, otherdepth, distance;
                total_mass_bioturbed_kg = 0;
                double[,] temp_tex_som_kg = new double[max_soil_layers, 7]; // this will hold temporary changed values of texture until all bioturbation is done
                double[] layer_0 = new double[7], layer_0_after = new double[7];
                double mass_soil_before = 0, mass_soil_after = 0, mass_top_before = 0, mass_top_after = 0;
                // if (findnegativetexture()) { Debugger.Break(); }
                double lux_hornbeam_OM_litter_fraction = 0;
                double total_BT_transport_kgm = 0;
                double total_young_som_kg, total_old_som_kg;

                double CN_before = 0, CN_after = 0;
                //if (CN_checkbox.Checked) { CN_before = total_CNs(); }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {

                        if (dtm[row, col] != -9999 & soildepth_m[row, col] > 0)
                        {
                            remove_empty_layers(row, col);
                            update_all_layer_thicknesses(row, col);
                            total_young_som_kg = 0; total_old_som_kg = 0;

                            mass_soil_before = total_soil_mass_kg(row, col);
                            mass_top_before = total_layer_mass_kg(row, col, 0);
                            total_soil_thickness_m = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                if (layer == 0)
                                {
                                    for (int tex = 0; tex < 5; tex++)
                                    {
                                        layer_0[tex] = texture_kg[row, col, 0, tex];
                                    }
                                    layer_0[5] = young_SOM_kg[row, col, 0];
                                    layer_0[6] = old_SOM_kg[row, col, 0];
                                }

                                //if (layer == 0 & !(layerthickness_m[row, col, layer] > 0)) { Debugger.Break(); }
                                //remove_empty_layers(row, col);
                                //if (layer == 0 & !(layerthickness_m[row, col, layer] > 0)) { Debugger.Break(); }
                                if (total_layer_mass_kg(row, col, layer) > 0)  //this says: if the layer actually exists
                                {
                                    for (int prop = 0; prop < 5; prop++) { temp_tex_som_kg[layer, prop] = texture_kg[row, col, layer, prop]; }
                                    temp_tex_som_kg[layer, 5] = young_SOM_kg[row, col, layer];
                                    temp_tex_som_kg[layer, 6] = old_SOM_kg[row, col, layer];
                                    total_soil_thickness_m += layerthickness_m[row, col, layer];

                                    total_young_som_kg += young_SOM_kg[row, col, layer];
                                    total_old_som_kg += old_SOM_kg[row, col, layer];
                                }
                            }

                            //LUX: in the lux case study, we need to know how much litter is hornbeam, i.e. palatable.
                            if (version_lux_checkbox.Checked)
                            {
                                if (total_young_som_kg + total_old_som_kg > 0)
                                {
                                    lux_hornbeam_OM_litter_fraction = total_young_som_kg / (total_young_som_kg + total_old_som_kg);
                                }
                                else
                                {  // ArT quickfix attempt
                                    lux_hornbeam_OM_litter_fraction = 0.5;
                                }
                            }
                            //select vegetation parameters, same as creep

                            if (daily_water.Checked)
                            {
                                if (aridity_vegetation[row, col] < 1) { potential_bioturbation_kg_m2_y = 4 + 0.3; } // grassland
                                else { potential_bioturbation_kg_m2_y = 4 + 1.3; } // forest
                                                                                   // standard potential creep of 4 kg. 0.3 or 1.3 is added, based on vegetation type. Rates are derived from Wilkinson 2009: Breaking Ground and Gabet
                            }

                            //here we calculate the first quantity: how much bioturbation kg needs to happen in this location
                            local_bioturbation_kg = potential_bioturbation_kg_m2_y * (1 - Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m)) * dx * dx * dt;
                            if (local_bioturbation_kg < 0) // local_bt == 0 happens when soil is absent
                            {
                                Debug.WriteLine(" error in local_bioturbation calculation : zero mass");
                                Debug.WriteLine(" total soil thickness :" + total_soil_thickness_m + " at rc " + row + " " + col);
                                Debug.WriteLine("err_sbt1");

                            }

                            if (version_lux_checkbox.Checked) { local_bioturbation_kg *= lux_hornbeam_OM_litter_fraction; }

                            total_mass_bioturbed_kg += local_bioturbation_kg;

                            //LUX: if Luxembourg version: we assume that only hornbeam litter leads to bioturbation. More of it - more bioturbation.

                            depth = 0;
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {

                                if (total_layer_fine_earth_mass_kg(row, col, layer) > 0)  //this says: if the layer actually exists

                                {
                                    double dd_bt = bioturbation_depth_decay_constant*2; // possible adjustments to second depth decay for bioturbation are possible here


                                    //double total_BT_depth_decay_index = 
                                    //    -1/dd_bt*(Math.Exp(-dd_bt*(z_toplayer - 0)) - Math.Exp(-dd_bt*(z_toplayer - z_toplayer))) +
                                    //    -1/dd_bt*(Math.Exp(-dd_bt*(total_soil_thickness_m - z_bottomlayer)) - Math.Exp(-dd_bt*(z_bottomlayer - z_bottomlayer)));                                    


                                    double check_BT_dd = 0;
                                    //integration over the exponential decay function in JGR 2006 for the entire profile, and for the current layer.
                                    //then calculate the fraction of bioturbation that will happen in this layer, and multiply with total bioturbation in this cell
                                    fine_layer_mass = total_layer_fine_earth_mass_kg(row, col, layer);
                                    layer_bio_activity_index = Math.Exp(-bioturbation_depth_decay_constant * depth) - (Math.Exp(-bioturbation_depth_decay_constant * (depth + layerthickness_m[row, col, layer])));
                                    total_bio_activity_index = 1 - (Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m));
                                    layer_bioturbation_kg = (layer_bio_activity_index / total_bio_activity_index) * local_bioturbation_kg;
                                    mass_distance_sum = 0;

                                    depth += layerthickness_m[row, col, layer] / 2;

                                    double total_BT_depth_decay_index =
                                        -1 / dd_bt * (Math.Exp(-dd_bt * (depth - 0)) - 1) + // upper part of the curve
                                        -1 / dd_bt * (Math.Exp(-dd_bt * (total_soil_thickness_m - depth)) - 1); // lower part of the curve


                                    otherdepth = 0; distance = 0;

                                    if (layerthickness_m[row, col, layer] <= 0) { Debug.WriteLine(" error: layer thickness is 0 at t " + t + " r " + row + " c " + col); }

                                    //now that we know how much bioturbation originates in this layer,
                                    //now look at all other layers and decide which one of them exchanges how much of that good stuff.
                                    //Here we include the source layer as wel, to prevent errors and inconsistencies with different layer thicknesses
                                    var mass_distances = new List<double>();
                                    var depths = new List<double>();
                                    var depthdecays = new List<double>();
                                    var P_fromto_list = new List<double>();
                                    var P_tofrom_list = new List<double>();

                                   
                                    double check_mass_distance = 0;

                                    otherdepth = 0; distance = 0;
                                    double BT_fraction = 0;
                                    double layer_BT_depth_decay_index =0;
                                    for (otherlayer = 0; otherlayer < max_soil_layers; otherlayer++)
                                    {
                                        double z_topotherlayer = otherdepth;
                                        double z_bottomotherlayer = otherdepth + layerthickness_m[row,col, otherlayer];
                                        
                                        if (otherlayer < layer) // above the bioturbated layer
                                        {
                                            layer_BT_depth_decay_index = -1/dd_bt*(Math.Exp(-dd_bt*(depth-z_topotherlayer)) - Math.Exp(-dd_bt * (depth - z_bottomotherlayer)));
                                        }
                                        if (otherlayer == layer) // if layer is the same layer. Can it be excluded here and in the calculations? It should be included in calculating the depth profiles
                                        {
                                            layer_BT_depth_decay_index = -1 / dd_bt * (Math.Exp(-dd_bt * (depth - z_topotherlayer)) - 1) +
                                                -1/dd_bt * (Math.Exp(-dd_bt * (z_bottomotherlayer - depth))-1);
                                        }
                                        if (otherlayer > layer) // below the bioturbated layer
                                        {
                                            layer_BT_depth_decay_index = -1/dd_bt*(Math.Exp(-dd_bt*(z_bottomotherlayer - depth)) - Math.Exp(-dd_bt * (z_topotherlayer - depth)));
                                        }

                                        otherdepth += layerthickness_m[row, col, otherlayer] / 2; // MM moved out of if-function, otherwise distance is not calculated correctly
                                        if (total_layer_fine_earth_mass_kg(row, col, otherlayer) > 0 & layer != otherlayer)  //this says: if the other layer actually exists
                                        {
                                            depthdecays.Add(layer_BT_depth_decay_index/total_BT_depth_decay_index);
                                            depths.Add(otherdepth);
                                            
                                            check_BT_dd += layer_BT_depth_decay_index /total_BT_depth_decay_index;
                                            distance = Math.Abs(otherdepth - depth);
                                            

                                            //here we calculate the amount of material bioturbated between the current layer and the current otherlayer

                                            // interlayer_bioturbation_kg = layer_bioturbation_kg * (mass_distance_layer / mass_distance_sum);
                                            interlayer_bioturbation_kg = layer_bioturbation_kg * (layer_BT_depth_decay_index / total_BT_depth_decay_index);
                                            // check_mass_distance += mass_distance_layer / mass_distance_sum;
                                            // BT_fraction += mass_distance_layer / mass_distance_sum;
                                            
                                            fine_otherlayer_mass = texture_kg[row, col, otherlayer, 1] + texture_kg[row, col, otherlayer, 2] + texture_kg[row, col, otherlayer, 3] + texture_kg[row, col, otherlayer, 4] + young_SOM_kg[row, col, otherlayer] + old_SOM_kg[row, col, otherlayer];
                                            

                                            //weathered_mass_kg may be more than present in the other layer, the current layer, or both - in that case one or both of the layers will become mixtures of the original two layers
                                            double fromlayertomixture_kg = 0, fromotherlayertomixture_kg = 0, totalmixturemass_kg = 0, massfromlayer = 0, massfromotherlayer = 0, dmass_l, dmass_ol, cn_bt_l, cn_bt_ol;
                                            double[] mixture_kg = new double[7];
                                            fromlayertomixture_kg = Math.Min(fine_layer_mass, (interlayer_bioturbation_kg / 2));
                                            fromotherlayertomixture_kg = Math.Min(fine_otherlayer_mass, (interlayer_bioturbation_kg / 2));
                                            // totalmixturemass_kg = fromlayertomixture_kg + fromotherlayertomixture_kg;

                                            if ((fromlayertomixture_kg + fromotherlayertomixture_kg) > 1E-6)  // if there is actual exchange (which is not the case when all fine material is removed)
                                            {
                                                //now add to mixture, and take from donors
                                                double massin_l = 0, massin_ol = 0, prob_layer = 0, prob_otherlayer = 0, d_CN_l, d_CN_ol, cn_pool;
                                                double[,] texture_out_total = new double[n_texture_classes, 4];
                                                // texture
                                                for (int prop = 1; prop < 5; prop++)
                                                {
                                                    //determine how much mass can be exchanged,. Do not take more than is present in the temporary layer to prevent negative textures in the end
                                                    //Should not happen, mass of top layer should stay constant, but happens anyway
                                                    dmass_l = (fromlayertomixture_kg / fine_layer_mass) * texture_kg[row, col, layer, prop];
                                                    dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * texture_kg[row, col, otherlayer, prop];

                                                    if (dmass_l > temp_tex_som_kg[layer, prop]) { dmass_l = temp_tex_som_kg[layer, prop]; }
                                                    if (dmass_ol > temp_tex_som_kg[otherlayer, prop]) { dmass_ol = temp_tex_som_kg[otherlayer, prop]; }

                                                    total_BT_transport_kgm += (dmass_l * distance + dmass_ol * distance);
                                                    //take mass from donors to mix
                                                    mixture_kg[prop] += (dmass_l + dmass_ol);
                                                    massfromlayer += dmass_l;
                                                    massfromotherlayer += dmass_ol;

                                                    temp_tex_som_kg[layer, prop] -= dmass_l;
                                                    temp_tex_som_kg[otherlayer, prop] -= dmass_ol;

                                                    // Fill the matrix of exported and total soil material
                                                    texture_out_total[prop, 0] = dmass_l;
                                                    texture_out_total[prop, 1] = texture_kg[row, col, layer, prop];
                                                    texture_out_total[prop, 2] = dmass_ol;
                                                    texture_out_total[prop, 3] = texture_kg[row, col, otherlayer, prop];

                                                                                               
                                                }
                                                //young OM
                                                dmass_l = (fromlayertomixture_kg / fine_layer_mass) * (young_SOM_kg[row, col, layer]);
                                                dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * (young_SOM_kg[row, col, otherlayer]);

                                                if (dmass_l > temp_tex_som_kg[layer, 5]) { dmass_l = temp_tex_som_kg[layer, 5]; }
                                                if (dmass_ol > temp_tex_som_kg[otherlayer, 5]) { dmass_ol = temp_tex_som_kg[otherlayer, 5]; }

                                                //take mass from donors to mix
                                                mixture_kg[5] += (dmass_l + dmass_ol);
                                                massfromlayer += dmass_l;
                                                massfromotherlayer += dmass_ol;

                                                temp_tex_som_kg[layer, 5] -= dmass_l;
                                                temp_tex_som_kg[otherlayer, 5] -= dmass_ol;

                                                //old OM
                                                // if (layer == 0) { Debugger.Break(); }
                                                dmass_l = (fromlayertomixture_kg / fine_layer_mass) * (old_SOM_kg[row, col, layer]);
                                                dmass_ol = (fromotherlayertomixture_kg / fine_otherlayer_mass) * (old_SOM_kg[row, col, otherlayer]);

                                                if (dmass_l > temp_tex_som_kg[layer, 6]) { dmass_l = temp_tex_som_kg[layer, 6]; }
                                                if (dmass_ol > temp_tex_som_kg[otherlayer, 6]) { dmass_ol = temp_tex_som_kg[otherlayer, 6]; }

                                                //take mass from donors to mix
                                                mixture_kg[6] += (dmass_l + dmass_ol);
                                                massfromlayer += dmass_l;
                                                massfromotherlayer += dmass_ol;

                                                temp_tex_som_kg[layer, 6] -= dmass_l;
                                                temp_tex_som_kg[otherlayer, 6] -= dmass_ol;

                                                //now give from mixture to receivers
                                                totalmixturemass_kg = massfromlayer + massfromotherlayer;

                                                // if (findnegativetexture()) { Debugger.Break(); }

                                                for (int prop = 1; prop < 7; prop++)
                                                {
                                                    temp_tex_som_kg[otherlayer, prop] += mixture_kg[prop] * (massfromotherlayer / totalmixturemass_kg);
                                                    massin_ol += mixture_kg[prop] * (massfromotherlayer / totalmixturemass_kg);
                                                    temp_tex_som_kg[layer, prop] += mixture_kg[prop] * (massfromlayer / totalmixturemass_kg);
                                                    massin_l += mixture_kg[prop] * (massfromlayer / totalmixturemass_kg);

                                                    //mixture_kg[prop] = 0;  // that's not perse needed, but feels clean

                                                }

                                                if (CN_checkbox.Checked)
                                                {
                                                    // MvdM develop: change probabilities for sand and clay fractions. Should be the same as the current code, but will look nicer
                                                    for (int cn = 0; cn < n_cosmo; cn++) // For all CNs. Mixing is independent of grain size, so all fractions get mixed evenly
                                                    {
                                                        d_CN_l = (massfromlayer / fine_layer_mass) * CN_atoms_cm2[row, col, layer, cn];
                                                        d_CN_ol = (massfromotherlayer / fine_otherlayer_mass) * CN_atoms_cm2[row, col, otherlayer, cn];
                                                        cn_pool = d_CN_l + d_CN_ol;

                                                        CN_atoms_cm2[row, col, layer, cn] +=  (- d_CN_l + cn_pool * massfromlayer / totalmixturemass_kg);
                                                        CN_atoms_cm2[row, col, otherlayer, cn] += (- d_CN_ol + cn_pool * massfromotherlayer / totalmixturemass_kg);
                                                        //double test = 
                                                    }

                                                }
                                                if (OSL_checkbox.Checked)
                                                {
                                                    prob_layer = texture_out_total[1,0] / texture_out_total[1, 1]; // sand fraction leaving the layer
                                                    prob_otherlayer = texture_out_total[1, 2] / texture_out_total[1, 3]; // sand fraction leaving the other layer
                                                    transfer_OSL_grains(row, col, layer, row, col, otherlayer, prob_layer, prob_otherlayer);

                                                    P_fromto_list.Add(prob_layer);
                                                    P_tofrom_list.Add(prob_otherlayer);
                                                    if (layer == 0 & otherlayer == (max_soil_layers - 1))
                                                    {
                                                        // Debugger.Break();
                                                    }
                                                }
                                            }

                                            //all sorts of checks - we should never have values under zero, or NotANumber NaN
                                            if (temp_tex_som_kg[otherlayer, 1] < 0)
                                            {
                                                Debug.WriteLine(" texture 1 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " (" + total_layer_mass_kg(row, col, layer) + "kg) " + otherlayer + " (" + total_layer_mass_kg(row, col, otherlayer) + "kg) ");
                                            }
                                            if (temp_tex_som_kg[otherlayer, 2] < 0) { Debug.WriteLine(" texture 2 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 3] < 0) { Debug.WriteLine(" texture 3 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 4] < 0) { Debug.WriteLine(" texture 4 null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 5] < 0) { Debug.WriteLine(" young som null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[otherlayer, 6] < 0) { Debug.WriteLine(" old som null " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }

                                            if (temp_tex_som_kg[layer, 1] < 0) { Debug.WriteLine(" texture 1 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 2] < 0) { Debug.WriteLine(" texture 2 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 3] < 0) { Debug.WriteLine(" texture 3 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 4] < 0) { Debug.WriteLine(" texture 4 null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 5] < 0) { Debug.WriteLine(" young som null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (temp_tex_som_kg[layer, 6] < 0) { Debug.WriteLine(" old som null " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }

                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 1])) { Debug.WriteLine(" texture 1 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }

                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 2])) { Debug.WriteLine(" texture 2 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 3])) { Debug.WriteLine(" texture 3 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 4])) { Debug.WriteLine(" texture 4 NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 5])) { Debug.WriteLine(" young som NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[otherlayer, 6])) { Debug.WriteLine(" old som NaN " + t + " rc " + row + "  " + col + " otherlayers " + layer + " " + otherlayer); }

                                            if (double.IsNaN(temp_tex_som_kg[layer, 1])) { Debug.WriteLine(" texture 1 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 2])) { Debug.WriteLine(" texture 2 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 3])) { Debug.WriteLine(" texture 3 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 4])) { Debug.WriteLine(" texture 4 NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 5])) { Debug.WriteLine(" young som NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                            if (double.IsNaN(temp_tex_som_kg[layer, 6])) { Debug.WriteLine(" old som NaN " + t + " rc " + row + "  " + col + " layer " + layer + " " + otherlayer); }
                                        }
                                        otherdepth += layerthickness_m[row, col, otherlayer] / 2; // MM added, because only half other otherdepth was added in this version
                                    }
                                    //if (Math.Round(check_mass_distance,4) != 1) { Debugger.Break(); }
                                    //if (findnegativetexture()) { Debugger.Break(); }

                                    // if (Math.Round(BT_fraction, 6) != 1) { Debugger.Break(); }
                                    depth += layerthickness_m[row, col, layer] / 2;
                                }
                            } // end for layer
                            total_BT_transport_kgm += 0; 
                            // now we know the new, bioturbated amounts in every layer in this row col, let's store them in the main texture_kg variables
                            for (layer = 0; layer < max_soil_layers; layer++)
                            {
                                // if (layer == 0 & temp_tex_som_kg[0, 2] == 0)
                                // {
                                //     Debug.WriteLine("err_sbt_16a. empty top layer after BT 0: {0}, {1}, {2}, {3}, {4}, {5}, {6}. t {7}, row {8}, col {9}, dlayer {10}", layer_0[0], layer_0[1], layer_0[2], layer_0[3], layer_0[4], layer_0[5], layer_0[6], t, row, col, layerthickness_m[row, col, 0]);
                                // 
                                // }
                                for (int prop = 1; prop < 5; prop++)
                                {
                                    if (temp_tex_som_kg[layer, prop] < 0)
                                    {
                                        Debug.WriteLine("err_sbt17");
                                    }
                                    texture_kg[row, col, layer, prop] = temp_tex_som_kg[layer, prop];
                                    layer_0_after[prop] = temp_tex_som_kg[layer, prop];
                                    temp_tex_som_kg[layer, prop] = 0;
                                }
                                young_SOM_kg[row, col, layer] = temp_tex_som_kg[layer, 5];
                                old_SOM_kg[row, col, layer] = temp_tex_som_kg[layer, 6];
                                layer_0_after[5] = temp_tex_som_kg[layer, 5];
                                layer_0_after[6] = temp_tex_som_kg[layer, 6];
                                temp_tex_som_kg[layer, 5] = 0;
                                temp_tex_som_kg[layer, 6] = 0;
                            } //end for layer
                              // if (findnegativetexture()) { Debugger.Break(); }

                            mass_soil_after = total_soil_mass_kg(row, col);
                            mass_top_after = total_layer_mass_kg(row, col, 0);

                            if (Math.Abs(mass_soil_before - mass_soil_after) > 1E-8 | Math.Abs(mass_top_before - mass_top_after) > 1E-8)
                            {
                                Debug.WriteLine("Mass loss during bioturbation");
                                // Debugger.Break(); 
                            }

                        } // end dtm!=-9999
                    }// for col
                } // end for row
                  // if (findnegativetexture()) { Debugger.Break(); }

                if (timeseries.total_mass_bioturbed_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[27]] = total_mass_bioturbed_kg;
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_sbt20");
                }

            }
            catch { Debug.WriteLine(" Error in bioturbation calculations in timestep {)}", t); }

        } // nieuwe code van Arnaud


        void soil_bioturbation_upward()
        {
            try
            {
                
                double local_bioturbation_kg, layer_bioturbation_kg, interlayer_bioturbation_kg;
                double layer_bio_activity_index, total_bio_activity_index, mass_distance_sum, mass_distance_layer;
                int layer, otherlayer;
                double fine_otherlayer_mass, fine_layer_mass;
                double total_soil_thickness_m;
                double depth, otherdepth, distance;
                total_mass_bioturbed_kg = 0;
                double[,] temp_tex_som_kg = new double[max_soil_layers, 7]; // this will hold temporary changed values of texture until all bioturbation is done
                double[] layer_0 = new double[7], layer_0_after = new double[7];
                double mass_soil_before = 0, mass_soil_after = 0, mass_top_before = 0, mass_top_after = 0;
                // if (findnegativetexture()) { Debugger.Break(); }
                double lux_hornbeam_OM_litter_fraction = 0;
                double total_BT_transport_kgm = 0;
                double total_young_som_kg, total_old_som_kg;

                double CN_before = 0, CN_after = 0;
                //if (CN_checkbox.Checked) { CN_before = total_CNs(); }
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {

                        if (dtm[row, col] != -9999 & soildepth_m[row, col] > 0)
                        {
                            remove_empty_layers(row, col);
                            update_all_layer_thicknesses(row, col);
                            total_young_som_kg = 0; total_old_som_kg = 0;

                            mass_soil_before = total_soil_mass_kg(row, col);
                            mass_top_before = total_layer_mass_kg(row, col, 0);
                            total_soil_thickness_m = total_soil_thickness(row, col);

                            if (daily_water.Checked)
                            {
                                if (aridity_vegetation[row, col] < 1) { potential_bioturbation_kg_m2_y = 4 + 0.3; } // grassland
                                else { potential_bioturbation_kg_m2_y = 4 + 1.3; } // forest
                                                                                   // standard potential creep of 4 kg. 0.3 or 1.3 is added, based on vegetation type. Rates are derived from Wilkinson 2009: Breaking Ground and Gabet
                            }

                            //here we calculate the first quantity: how much bioturbation kg needs to happen in this location
                            local_bioturbation_kg = potential_bioturbation_kg_m2_y * (1 - Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m)) * dx * dx * dt;
                            if (local_bioturbation_kg < 0) // local_bt == 0 happens when soil is absent
                            {
                                Debug.WriteLine(" error in local_bioturbation calculation : zero mass");
                                Debug.WriteLine(" total soil thickness :" + total_soil_thickness_m + " at rc " + row + " " + col);
                                Debug.WriteLine("err_sbt1");

                            }

                            if (version_lux_checkbox.Checked) { local_bioturbation_kg *= lux_hornbeam_OM_litter_fraction; }

                            total_mass_bioturbed_kg += local_bioturbation_kg;

                            //LUX: if Luxembourg version: we assume that only hornbeam litter leads to bioturbation. More of it - more bioturbation.

                            depth = layerthickness_m[row, col, 0]; // start at layer 1
                            for (layer = 1; layer < max_soil_layers; layer++)
                            {

                                if (total_layer_fine_earth_mass_kg(row, col, layer) > 0)  //this says: if the layer actually exists

                                {
                                    double dd_bt = bioturbation_depth_decay_constant; // possible adjustments to second depth decay for bioturbation are possible here


                                    //double total_BT_depth_decay_index = 
                                    //    -1/dd_bt*(Math.Exp(-dd_bt*(z_toplayer - 0)) - Math.Exp(-dd_bt*(z_toplayer - z_toplayer))) +
                                    //    -1/dd_bt*(Math.Exp(-dd_bt*(total_soil_thickness_m - z_bottomlayer)) - Math.Exp(-dd_bt*(z_bottomlayer - z_bottomlayer)));                                    


                                    double check_BT_dd = 0, dmass_l;
                                    //integration over the exponential decay function in JGR 2006 for the entire profile, and for the current layer.
                                    //then calculate the fraction of bioturbation that will happen in this layer, and multiply with total bioturbation in this cell
                                    fine_layer_mass = total_layer_fine_earth_mass_kg(row, col, layer);
                                    layer_bio_activity_index = Math.Exp(-bioturbation_depth_decay_constant * depth) - (Math.Exp(-bioturbation_depth_decay_constant * (depth + layerthickness_m[row, col, layer])));
                                    total_bio_activity_index = 1 - (Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m));
                                    layer_bioturbation_kg = (layer_bio_activity_index / total_bio_activity_index) * local_bioturbation_kg;
                                    mass_distance_sum = 0;

                                    depth += layerthickness_m[row, col, layer];


                                    if (layer_bioturbation_kg > fine_layer_mass) { layer_bioturbation_kg = fine_layer_mass; }
                                    for (int tex = 1; tex < n_texture_classes; tex++)
                                    {
                                        dmass_l = layer_bioturbation_kg / fine_layer_mass * texture_kg[row, col, layer, tex];
                                        if(dmass_l > texture_kg[row, col, layer, tex]) { Debugger.Break(); }
                                        texture_kg[row, col, layer, tex] -= dmass_l;
                                        texture_kg[row, col, 0, tex] += dmass_l; // move to the surface

                                        //if (tex == 1)
                                        //{
                                        //    sandout_l = dmass_l; sandtotal_l = texture_kg[row, col, layer, tex];
                                        //}
                                        //if (tex >= 3)
                                        //{
                                        //    clayout_l += dmass_l; claytotal_l += texture_kg[row, col, layer, prop];
                                        //    clayout_ol += dmass_ol; claytotal_ol += texture_kg[row, col, otherlayer, prop];
                                        //}

                                    }

                                    //young OM
                                    dmass_l = layer_bioturbation_kg / fine_layer_mass * (young_SOM_kg[row, col, layer]);
                                    young_SOM_kg[row, col, layer] -= dmass_l;
                                    young_SOM_kg[row, col, 0] += dmass_l;

                                    //old OM
                                    dmass_l = layer_bioturbation_kg / fine_layer_mass * (old_SOM_kg[row, col, layer]);
                                    old_SOM_kg[row, col, layer] -= dmass_l;
                                    old_SOM_kg[row, col, 0] += dmass_l;

                                    if (CN_checkbox.Checked)
                                    {
                                        // MvdM develop: change probabilities for sand and clay fractions. SHould be the same as the current code, but will look nicer
                                        for (int cn = 0; cn < n_cosmo; cn++) // For all CNs. Mixing is independent of grain size, so all fractions get mixed evenly
                                        {
                                            double d_CN_l = (layer_bioturbation_kg / fine_layer_mass) * CN_atoms_cm2[row, col, layer, cn];
                                            CN_atoms_cm2[row, col, layer, cn] -= d_CN_l;
                                            CN_atoms_cm2[row, col, 0, cn] += d_CN_l;
                                        }

                                    }
                                    if (OSL_checkbox.Checked)
                                    {
                                        double prob_layer = layer_bioturbation_kg / fine_layer_mass;
                                        transfer_OSL_grains(row, col, layer, row, col, 0, prob_layer, 0);

                                    }
                                }
                            } // end for layer
                            total_BT_transport_kgm += 0;
                            // now we know the new, bioturbated amounts in every layer in this row col, let's store them in the main texture_kg variables
                            
                            mass_soil_after = total_soil_mass_kg(row, col);
                            mass_top_after = total_layer_mass_kg(row, col, 0);

                            if (Math.Abs(mass_soil_before - mass_soil_after) > 1E-8)
                            {
                                Debug.WriteLine("Mass loss during bioturbation");
                                // Debugger.Break(); 
                            }

                        } // end dtm!=-9999
                    }// for col
                } // end for row
                  // if (findnegativetexture()) { Debugger.Break(); }

                if (timeseries.total_mass_bioturbed_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[19]] = total_mass_bioturbed_kg;
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_sbt20");
                }

            }
            catch { Debug.WriteLine(" Error in bioturbation calculations in timestep {0}", t); }

        } // only upward movement of particles, like ants bringing up soil material

        void soil_litter_cycle()
        {
            // uses parameters from Carbon Cycle for now
            try
            {
                double litter_input_kg;

                //this line keeps young (hornbeam) OM completely gone from the surface every second year (reflecting that,
                //in reality, part of the year is unprotected). MvdM I added the else to rest the decomposition rate
                // if (t % 2 == 0) { potential_young_decomp_rate = 1; } else { potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text); }

                calculate_TPI(7);
                double a = -0.33;
                double b = 28.33;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        //calculating hornbeam fraction
                        hornbeam_cover_fraction[row, col] = 1 - Math.Exp(a + b * tpi[row, col]) / (1 + Math.Exp(a + b * tpi[row, col]));

                        // Decomposition
                        litter_kg[row, col, 0] *= (1 - .97); // Hornbeam
                        litter_kg[row, col, 1] *= (1 - .45); // Beech

                        // litter_input_kg = potential_OM_input; // MvdM no changes in litter input due to soil thickness. 

                        // All litter to litter layer matrix
                        litter_kg[row, col, 0] += .230 * (hornbeam_cover_fraction[row, col]); // Hornbeam
                        litter_kg[row, col, 1] += .403 * (1 - hornbeam_cover_fraction[row, col]); // Beech

                    }
                }
            }
            catch { Debug.WriteLine(" Crash in litter cycle "); }
        }

        void soil_carbon_cycle()
        {
            try
            {
                double local_OM_input_kg, layer_OM_input_kg;
                double young_decomposition_rate, old_decomposition_rate;
                //Debug.WriteLine("succesfully read parameters for soil carbon");
                double depth;
                double total_soil_thickness;
                double layer_OM_input_index, total_OM_input_index;
                int layer;
                total_OM_input_kg = 0;
                if (version_lux_checkbox.Checked)
                {
                    calculate_TPI(7);
                    double a = -0.33;
                    double b = 28.33;
                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            //calculating hornbeam fraction
                            hornbeam_cover_fraction[row, col] = 1 - Math.Exp(a + b * tpi[row, col]) / (1 + Math.Exp(a + b * tpi[row, col]));
                        }
                    }
                    //this line keeps young (hornbeam) OM completely gone from the surface every second year (reflecting that,
                    //in reality, part of the year is unprotected). MvdM I added the else to rest the decomposition rate
                    if (t % 2 == 0) { potential_young_decomp_rate = 1; } else { potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text); }
                }

                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cc1");
                }
                for (row = 0; row < nr; row++)
                {
                    //Parallel.For(0, nc, i =>                    //we parallelize over cols
                    for (col = 0; col < nc; col++)
                    {
                        if (daily_water.Checked)
                        {
                            if (aridity_vegetation[row, col] < 1) { potential_OM_input = 0.67; } // grassland
                            else { potential_OM_input = 0.62; } // forest
                            if (t > (end_time - 300)) { potential_OM_input = 0.42; } // arable land
                            if (t > (end_time - 100)) { potential_OM_input = 0.42 * 1.004; } // arable land // MM_soil2 4permille higher input. Does that work?
                        }
                        total_soil_thickness = 0;
                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, col, layer] > 0)
                            {
                                total_soil_thickness += layerthickness_m[row, col, layer];
                            }
                        }
                        local_OM_input_kg = potential_OM_input * (1 - Math.Exp(-OM_input_depth_decay_constant * total_soil_thickness)) * dx * dx * dt;
                        total_OM_input_kg += local_OM_input_kg;
                        depth = 0;

                        for (layer = 0; layer < max_soil_layers; layer++)
                        {
                            if (layerthickness_m[row, col, layer] > 0)
                            {
                                // if (layer == 0) { Debugger.Break(); }
                                layer_OM_input_index = -1 / OM_input_depth_decay_constant * (Math.Exp(-OM_input_depth_decay_constant * (depth + layerthickness_m[row, col, layer])) - Math.Exp(-OM_input_depth_decay_constant * depth));
                                total_OM_input_index = -1 / OM_input_depth_decay_constant * (Math.Exp(-OM_input_depth_decay_constant * (total_soil_thickness)) - 1);
                                layer_OM_input_kg = (layer_OM_input_index / total_OM_input_index) * local_OM_input_kg;

                                if (version_lux_checkbox.Checked)
                                {
                                    young_SOM_kg[row, col, layer] += layer_OM_input_kg * (hornbeam_cover_fraction[row, col]);
                                    old_SOM_kg[row, col, layer] += layer_OM_input_kg * (1 - hornbeam_cover_fraction[row, col]);
                                }
                                else
                                {
                                    young_SOM_kg[row, col, layer] += layer_OM_input_kg * (1 - humification_fraction);
                                    old_SOM_kg[row, col, layer] += layer_OM_input_kg * (humification_fraction);
                                }
                                if (double.IsNaN(young_SOM_kg[row, col, layer]))
                                {
                                    Debug.WriteLine("err_cc2");
                                }
                                //decomposition gets lost as CO2 to the air (and soil water)
                                depth += layerthickness_m[row, col, layer] / 2;
                                //young_decomposition_rate = potential_young_decomp_rate * Math.Exp(-young_CTI_decay_constant * dynamic_TWI) * Math.Exp(-young_depth_decay_constant * depth);
                                //old_decomposition_rate = potential_old_decomp_rate * Math.Exp(-old_CTI_decay_constant * dynamic_TWI) * Math.Exp(-old_depth_decay_constant * depth);
                                young_decomposition_rate = potential_young_decomp_rate * 1 * Math.Exp(-young_depth_decay_constant * depth);
                                old_decomposition_rate = potential_old_decomp_rate * 1 * Math.Exp(-old_depth_decay_constant * depth);
                                young_SOM_kg[row, col, layer] *= (1 - young_decomposition_rate);
                                old_SOM_kg[row, col, layer] *= (1 - old_decomposition_rate);
                                //Debug.WriteLine(" cell  " + row + " " + col + " has layer_OM_input of " + layer_OM_input_kg);
                                depth += layerthickness_m[row, col, layer] / 2;
                                if (young_SOM_kg[row, col, layer] < 0 | old_SOM_kg[row, col, layer] < 0)
                                {
                                    Debug.WriteLine("err_cc3");
                                }
                            }

                        }
                    }

                }
                if (timeseries.total_OM_input_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[28]] = total_OM_input_kg;
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cc4");
                }

            }
            catch { Debug.WriteLine(" Crash in soil carbon cycle "); }

        }

        void soil_clay_translocation()
        {
            //possibly a function of local wetness / infiltration, but for now not/.
            double Iavg = 0, Imin = 10000000, Imax = 0;

            if (daily_water.Checked)
            {
                int Icount = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (Imin > Iy[row, col]) { Imin = Iy[row, col]; }
                            if (Imax < Iy[row, col]) { Imax = Iy[row, col]; }
                            Iavg += Iy[row, col];
                            Icount++;
                        }
                    }
                }
                Iavg /= Icount;
            }

            int layer;
            double eluviated_kg, depth, CN_transport;
            total_fine_eluviated_mass_kg = 0;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {

                        depth = 0;
                        for (layer = 0; layer < max_soil_layers - 1; layer++)   // we loop through all layers except the lower one - clay translocation there has no lower recipient
                        {
                            if (layerthickness_m[row, col, layer] > 0 && layerthickness_m[row, col, layer + 1] > 0)  // both source and sink layers have to exist.
                            {
                                if (texture_kg[row, col, layer, 4] > 0)
                                {
                                    depth += layerthickness_m[row, col, layer] / 2;
                                    double totalweight = texture_kg[row, col, layer, 0] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4] + young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer];
                                    //calculate the mass of eluviation
                                    if (CT_depth_decay_checkbox.Checked) { eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 4] / totalweight)) * Math.Exp(-ct_depthdec * depth) * dt * dx * dx; }
                                    else { eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 4] / totalweight)) * dt * dx * dx; }
                                    //
                                    if (daily_water.Checked)
                                    {
                                        eluviated_kg *= waterfactor[row, col];

                                    }

                                    if (eluviated_kg > texture_kg[row, col, layer, 4]) { eluviated_kg = texture_kg[row, col, layer, 4]; }

                                    total_fine_eluviated_mass_kg += eluviated_kg;
                                    texture_kg[row, col, layer, 4] -= eluviated_kg;
                                    texture_kg[row, col, layer + 1, 4] += eluviated_kg;

                                    if (CN_checkbox.Checked) // transport of meteoric Be-10 with clay fraction
                                    {
                                        CN_transport = CN_atoms_cm2[row, col, layer, 0] * (eluviated_kg / (texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]));
                                        CN_atoms_cm2[row, col, layer, 0] -= CN_transport;
                                        if ((layer + 1) < max_soil_layers)
                                        {
                                            if (total_layer_mass_kg(row, col, layer + 1) > 0) // if there is soil material present in the lower layer
                                            {
                                                CN_atoms_cm2[row, col, layer + 1, 0] += CN_transport;
                                            }
                                        }
                                       
                                    }

                                    //improve for lowers - where does the fine clay go?
                                    //count the amount of clay and leached chem exiting catchment
                                    // SOIL possibly improve with coarse clay fraction
                                    depth += layerthickness_m[row, col, layer] / 2;
                                }
                            }
                        }
                    }
                }
                if (timeseries.total_fine_eluviated_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[25]] = total_fine_eluviated_mass_kg;
                }
            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_clay_translocation_Jagercikova()
        {
            double ct_adv0, ct_adv0_all, ct_dd, ct_dd_all;
            ct_adv0_all = Convert.ToDouble(ct_v0_Jagercikova.Text);
            ct_dd_all = Convert.ToDouble(ct_dd_Jagercikova.Text);
            ct_adv0 = ct_adv0_all;
            ct_dd = ct_dd_all;

            try
            {
                // based on the advection-diffusion equation of Jagercikova et al., 2017 https://doi.org/10.1007/s11368-016-1560-9
                // We only added the advection part, because the diffusion represents bioturbation and that is already modeled elsewhere
                double local_I;

                double depth, f_clay, f_oc, d_depth, ct_advi, eluviated_kg, CEC_ct, CCEC_ct, wdclay, CN_transport;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (NA_in_soil(row, col))
                            {
                                Debug.WriteLine("ctj1");
                            }

                            if (daily_water.Checked)
                            {
                                local_I = Math.Max(Iy[row, col], 0);
                                ct_adv0 = ct_adv0_all * (1 - Math.Exp(-local_I / (2.0 * (1.0 / 3)))); // Exponential function to determine v0, based on infiltration. The function approaches a v0 of 1. I of 0.5~v0 of 0.5. the 2 indicates the range of the variogram. 
                                ct_dd = ct_dd_all - (1 - Math.Exp(-local_I / (2.0 * (1.0 / 3)))); // adjust depth decay, by subtracting 
                            }

                            depth = 0;
                            for (int layer = 0; layer < max_soil_layers; layer++) // we loop through all layers. Lowest layer has no recipient, so there we have free drainage of clay
                            {
                                if (layerthickness_m[row, col, layer] > 0)  // source layer has to exist. Adjusted for free drainage, receiving layer doesn't have to be present
                                {

                                    if (texture_kg[row, col, layer, 3] > 0)
                                    {
                                        depth += layerthickness_m[row, col, layer] / 2;

                                        f_clay = texture_kg[row, col, layer, 3] / (texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3]); // fine earth fraction of clay. No fine clay
                                        f_oc = (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer]) / (young_SOM_kg[row, col, layer] + old_SOM_kg[row, col, layer] + texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3]); // fine earth fraction of clay. No fine clay
                                        f_oc /= 1.72; // calculate from SOM to SOC: https://www.researchgate.net/post/How_can_I_convert_percent_soil_organic_matter_into_soil_C

                                        if ((layer + 1) < max_soil_layers)
                                        {
                                            d_depth = (layerthickness_m[row, col, layer] + layerthickness_m[row, col, layer + 1]) / 2; // distance from mid-point to mid-point of source and sink cell
                                        }
                                        else // eluviation from lowest layer
                                        {
                                            d_depth = (layerthickness_m[row, col, layer] + layerthickness_m[row, col, layer - 1]) / 2; // use distance to higher cell as reference
                                        }

                                        // Eluviation limited by association with OM and CEC (equations from Model 2 of Brubaker et al, 1992: estimating the water-dispersible clay content of soils)
                                        // CEC estimated with PTF from Foth and Ellis 1996, as used in Finke 2012
                                        CEC_ct = (32 + 3670 * f_oc + 196 * f_clay) / 10; // cmol+/kg
                                        CCEC_ct = CEC_ct - 300 * f_oc; // carbon corrected CEC
                                        if (f_clay == 0) { f_clay = 0.000001; } // prevent dividing by 0. clay percentage of 1% always has absent dispersible clay
                                        wdclay = (0.369 * (f_clay * 100) - 8.96 * (CCEC_ct / (f_clay * 100)) + 4.48) / 100; // fraction of clay that can be dispersed
                                        if (wdclay < 0) { wdclay = 0; } // prevent negative water-dispersible clay

                                        // if (t == 3000) { Debugger.Break(); }
                                        // advection
                                        ct_advi = ct_adv0 * Math.Exp(-ct_dd * depth);
                                        eluviated_kg = ct_advi / 100 * bulkdensity[row, col, layer] * f_clay * dx * dx;
                                        // eluviated_kg = 1 / d_depth * (ct_advi * f_clay) * 1000 / bulkdensity[row, col, layer];

                                        if (eluviated_kg > (texture_kg[row, col, layer, 3] * wdclay))
                                        {
                                            eluviated_kg = texture_kg[row, col, layer, 3] * wdclay;
                                        }

                                        if (eluviated_kg > texture_kg[row, col, layer, 3]) { eluviated_kg = texture_kg[row, col, layer, 3]; } // correct for too muchy clay eluviating, not necessary anymore due to limitation water-dispersible clay

                                        total_fine_eluviated_mass_kg += eluviated_kg;
                                        texture_kg[row, col, layer, 3] -= eluviated_kg;
                                        if ((layer + 1) < max_soil_layers) // in case there is a lower receiving layer
                                        {
                                            if (total_layer_mass_kg(row, col, layer + 1) > 0) // if there is soil material present in the lower layer
                                            {
                                                texture_kg[row, col, layer + 1, 3] += eluviated_kg;
                                            }
                                        }

                                        if (CN_checkbox.Checked) // transport of meteoric Be-10 (index 0) and Cs-137 (index 3) with clay fraction
                                        {
                                          
                                           CN_transport = CN_atoms_cm2[row, col, layer, 0] * (eluviated_kg / texture_kg[row, col, layer, 3]);
                                            CN_atoms_cm2[row, col, layer, 0] -= CN_transport;
                                            if ((layer + 1) < max_soil_layers)
                                            {
                                                if (total_layer_mass_kg(row, col, layer + 1) > 0) // if there is soil material present in the lower layer
                                                {
                                                    CN_atoms_cm2[row, col, layer + 1, 0] += CN_transport;
                                                }
                                            }
                                        }
                                        depth += layerthickness_m[row, col, layer] / 2;

                                    }

                                    if (NA_in_soil(row, col))
                                    {
                                        Debug.WriteLine("err_ctj2");
                                    }

                                }
                            }
                        }
                    }
                    if (timeseries.total_fine_eluviated_checkbox.Checked)
                    {
                        timeseries_matrix[t, timeseries_order[26]] = total_fine_eluviated_mass_kg;
                    }
                }
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_ctj3");
                }

            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_silt_translocation()
        {
            //in Spitsbergen, it is mostly silt (with attendant clay) that gets translocated in the profile. Clay is not modelled in itself

            int layer;
            double eluviated_kg;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        for (layer = 0; layer < max_soil_layers - 1; layer++)   // we loop through all layers except the lower one - clay translocation there has no lower recipient
                        {
                            if (layerthickness_m[row, col, layer] > 0 && layerthickness_m[row, col, layer + 1] > 0)  // both source and sink layers have to exist.
                            {
                                if (texture_kg[row, col, layer, 2] > 0)
                                {
                                    //calculate the mass of eluviation
                                    eluviated_kg = max_eluviation * (1 - Math.Exp(-Cclay * texture_kg[row, col, layer, 2])) * dt * dx * dx;
                                    texture_kg[row, col, layer, 2] -= eluviated_kg;
                                    if (texture_kg[row, col, layer, 2] < 0) { Debug.WriteLine("error: too much clay eluviation "); }
                                    texture_kg[row, col, layer + 1, 2] += eluviated_kg;
                                    //improve for lowers
                                    //count the amount of clay and leached chem exiting catchment
                                    // SOIL possibly improve with coarse clay fraction
                                }
                            }
                        }
                    }
                }
            }
            catch { Debug.WriteLine(" Problem occurred in translocation calculation"); }
        }

        void soil_decalcification()
        {
            // develop: erosion of carbonates, link to clay fraction? Or transport CO3_kg with the rest of the sediments?

            // Decalcification depends on the amount of percolation, according to Egli and Fitze (2001). The function below is a linear regression between the data in their paper. This function should work as a simple test. more complicated functions, with equilibria and secondary carbonates are possible
            try
            {
                double CO3_loss;
                // Carbonate losses [mol m-2 y-1] = 205.58 * percolation [m] - 12.392
                // Infiltration / percolation is modeled in m, so adjustments have to be made for cell size. In every step? 
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            CO3_loss = (205.58 * Iy[row, col] - 12.392) * (dx * dx) * 60.01; // Corrected the equation for cell size (dx*dx) and molar mass (60.01 g mol-1)
                            if (CO3_loss < 0) { CO3_loss = 0; }

                            int layer = 0;
                            while (CO3_loss > 0)
                            {
                                //Debug.WriteLine("dec1");
                                if (CO3_kg[row, col, layer] > 0)
                                {
                                    //Debug.WriteLine("dec1a");
                                    if (CO3_kg[row, col, layer] >= CO3_loss)
                                    {
                                        //Debug.WriteLine("dec2");
                                        CO3_kg[row, col, layer] -= CO3_loss;
                                        CO3_loss = 0;
                                    }
                                    else
                                    {
                                        //Debug.WriteLine("dec3");
                                        CO3_loss -= CO3_kg[row, col, layer];
                                        CO3_kg[row, col, layer] = 0;
                                        if (layer < (max_soil_layers - 1)) { layer++; }
                                        else { CO3_loss = 0; }// all CO3 is removed from the catchment
                                    }
                                    //Debug.WriteLine("dec4");
                                }
                                else
                                {
                                    //Debug.WriteLine("dec5");
                                    if (layer < (max_soil_layers - 1)) { layer++; }
                                    else { CO3_loss = 0; }// all CO3 is removed from the catchment
                                    ;
                                }
                            }
                            //Debug.WriteLine("layer decalc: {0}", layer);
                        }
                    }
                }
            }
            catch
            {
                MessageBox.Show("error in decalcification");
            }
        }

        void lessivage_calibration(int row, int col, int cal)
        {
            //Debug.Write(Cclay + " " + max_eluviation + " " + ct_depthdec + " ");
            //double[] lp4 = new double[,]{0.09, 0.09,0.09, 0.10, 0.16, 0.16, 0.19, 0.19, 0.19, 0.16, 0.16, 0.16, 0.16, 0.13, 0.13, 0.13, 0.13, 0.13, 0.13, 0.13};

            double[,] lp4 = new double[6, 2] { { .31, .09 }, { .45, .10 }, { .62, .16 }, { .90, .19 }, { 1.35, .16 }, { 2.0, .13 } };
            double depth, err, rmse_ct, me_ct, lp4_clay;
            int lp4_row = 0;
            int layercount = 0;
            rmse_ct = 0;
            me_ct = 0;
            depth = 0;
            Debug.WriteLine(rmse_ct + ", " + me_ct);
            for (int layer = 0; layer < max_soil_layers; layer++)
            {
                if (layerthickness_m[row, col, layer] > 0)
                {
                    depth += layerthickness_m[row, col, layer] / 2;
                    if (depth <= lp4[5, 0])
                    {
                        double totalweight = texture_kg[row, col, layer, 1] + texture_kg[row, col, layer, 2] + texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]; // calibrate on fine soil fraction only
                        while (depth > lp4[lp4_row, 0])
                        {
                            lp4_row++;
                        }
                        lp4_clay = lp4[lp4_row, 1];

                        err = ((texture_kg[row, col, layer, 3] + texture_kg[row, col, layer, 4]) / totalweight) - lp4_clay;
                        rmse_ct += err * err;
                        me_ct += err;
                        layercount += 1;
                    }

                    depth += layerthickness_m[row, col, layer] / 2;
                }

            }
            Debug.WriteLine(layercount);
            rmse_ct = Math.Pow(rmse_ct / layercount, .5);
            me_ct = me_ct / layercount;
            //Debug.Write(rmse_ct + " " + me_ct);
            //Debug.WriteLine("");//start on new line
            lessivage_errors[cal, 0] = Cclay;
            lessivage_errors[cal, 1] = max_eluviation;
            lessivage_errors[cal, 2] = ct_depthdec;
            lessivage_errors[cal, 3] = rmse_ct;
            lessivage_errors[cal, 4] = me_ct;
        }

        #endregion

        #region Geomorphic processes code

        int NA_in_map(double[,] map)
        {
            int NA_count = 0;

            try
            {
                for (int rowNA = 0; rowNA < nr; rowNA++)
                {
                    for (int colNA = 0; colNA < nc; colNA++)
                    {
                        if (Double.IsNaN(map[rowNA, colNA]) | Double.IsInfinity(map[rowNA, colNA]))
                        {
                            NA_count++;
                            Debug.WriteLine("NA at row {0}, col {1}", rowNA, colNA);
                        }
                    }
                }

            }
            catch
            {
                Debug.WriteLine("err_NAmap1");

            }
            return (NA_count);
        }

        bool find_gravel(int row_g, int col_g, int lay_g)
        {
            bool bool_out = false;
            if (texture_kg[row_g, col_g, lay_g, 0] > 0) { bool_out = true; }
            return (bool_out);
        }
        bool NA_in_soil(int rowNA, int colNA)
        {
            bool boolNA = false;
            for (int layNA = 0; layNA < max_soil_layers; layNA++)
            {
                for (int texNA = 0; texNA < 5; texNA++)
                {
                    if (Double.IsNaN(texture_kg[rowNA, colNA, layNA, texNA]) | Double.IsInfinity(texture_kg[rowNA, colNA, layNA, texNA]))
                    {
                        boolNA = true;
                        Debug.WriteLine("NA in row {0}, col {1}, lay {2}, tex {3}", rowNA, colNA, layNA, texNA);
                    }

                }
                if (Double.IsNaN(young_SOM_kg[rowNA, colNA, layNA]) | Double.IsInfinity(young_SOM_kg[rowNA, colNA, layNA]))
                {
                    boolNA = true;
                    Debug.WriteLine("NA in row {0}, col {1}, lay {2}, young OM, val {3}", rowNA, colNA, layNA, young_SOM_kg[rowNA, colNA, layNA]);
                }

                if (Double.IsNaN(old_SOM_kg[rowNA, colNA, layNA]) | Double.IsInfinity(old_SOM_kg[rowNA, colNA, layNA]))
                {
                    boolNA = true;
                    Debug.WriteLine("NA in row {0}, col {1}, lay {2}, old OM, val {3}", rowNA, colNA, layNA, old_SOM_kg[rowNA, colNA, layNA]);
                }
            }

            return (boolNA);
        }

        bool NA_anywhere_in_soil()
        {

            bool boolNA = false;
            try
            {
                for (int rowNA = 0; rowNA < nr; rowNA++)
                {
                    for (int colNA = 0; colNA < nc; colNA++)
                    {
                        if (NA_in_soil(rowNA, colNA) == true) { boolNA = true; }
                    }
                }

            }
            catch
            {
                Debug.WriteLine("err_NAmap1");

            }
            return (boolNA);
        }

        int NA_in_location(double[,] map, int rowNA, int colNA)
        {
            int NA_count = 0;
            try
            {
                if (Double.IsNaN(map[rowNA, colNA]) | Double.IsInfinity(map[rowNA, colNA]))
                {
                    NA_count++;
                    Debug.WriteLine("NA at row {0}, col {1}", rowNA, colNA);
                }
            }
            catch
            {
                Debug.WriteLine("err_nal1");

            }
            return (NA_count);
        }

        void calculate_sediment_dynamics(int row_sd, int col_sd, int i_sd, int j_sd, double waterflow_m3_per_m, double flowfraction, double sum_of_fractions)
        {
            int size;
            double total_sediment_in_transport_kg, organic_in_transport, mass_to_be_eroded, rock_fraction, bio_fraction, vegetation_cover_fraction, selectivity_fraction, potential_transported_amount_kg, organic_selectivity_fraction, frac_eroded, frac_deposited;
            double[] total_mass_eroded, total_mass_deposited_kg;
            total_mass_eroded = new double[7] { 0, 0, 0, 0, 0, 0, 0 };
            total_mass_deposited_kg = new double[7] { 0, 0, 0, 0, 0, 0, 0 };
            transport_capacity_kg = advection_erodibility * (bulkdensity[row_sd, col_sd, 0] * dx * dx) * (Math.Pow(waterflow_m3_per_m, m) * Math.Pow(dh, n)); // in a departure from literature, the erosion threshold is only evaluated if erosion actually occurs
            if (transport_capacity_kg < 0)
            {
                transport_capacity_kg = 0;
                Debug.WriteLine(" Warning: negative transport capacity at" + row_sd + " " + col_sd);
            }  // this should never happen
               // We now compare transport_capacity with the total amount of sediment in transport, to determine whether we will have erosion or deposition or nothing
            total_sediment_in_transport_kg = 0;

            for (size = 0; size < n_texture_classes; size++)
            {
                total_sediment_in_transport_kg += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];                     //all in kg
            }

            // Transport
            if (transport_capacity_kg == total_sediment_in_transport_kg)
            {
                // neither erosion nor deposition, simply transport
                for (size = 0; size < n_texture_classes; size++)
                {
                    sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];  //all in kg 
                }
                old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd];  //all in kg
                young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd];  //all in kg

                if (CN_checkbox.Checked)
                {
                    // add fraction of all CNs to the receiving cell
                    for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                    {
                        CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_in_transport[row_sd, col_sd, i_cn] * flowfraction;
                    }
                }
                if (OSL_checkbox.Checked)
                {
                    transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, 0);
                }
            }

            // Erosion
            if (transport_capacity_kg > total_sediment_in_transport_kg)
            {
                //in case of desired erosion, we first evaluate whether we exceed the erosion threshold
                if ((transport_capacity_kg - total_sediment_in_transport_kg) > erosion_threshold_kg)
                {
                    //first, calculate how much we are going to erode. Not as much as we want to if the soil is protected by rocks or plants
                    rock_fraction = texture_kg[row_sd, col_sd, 0, 0] / (texture_kg[row_sd, col_sd, 0, 0] + texture_kg[row_sd, col_sd, 0, 1] + texture_kg[row_sd, col_sd, 0, 2] + texture_kg[row_sd, col_sd, 0, 3] + texture_kg[row_sd, col_sd, 0, 4]);
                    if (version_lux_checkbox.Checked == false)
                    {
                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                        * Math.Exp(-rock_protection_constant * rock_fraction)
                        * Math.Exp(-bio_protection_constant);
                    }
                    else
                    {  //for Luxemburg version, here we additially protect soil from erosion by its cover of 'bad' organic matter as litter (i.e. in top layer)

                        // MvdM litter fraction is determined by the total amount of litter as fraction of the mineral soil in the top layer. This might be changed, because mineral content is variable and indepent of litter quantity
                        //XIA change this number to 0.25 as well. For creep and no creep
                        double litter_characteristic_protection_mass_kg_m2 = 0.9; // based on the maximum litter content in the model results
                        double litter_characteristic_protection_mass_kg = litter_characteristic_protection_mass_kg_m2 * dx * dx;
                        double litter_protection_fraction = (litter_kg[row_sd, col_sd, 0] + litter_kg[row_sd, col_sd, 1]) / litter_characteristic_protection_mass_kg;
                        // double litter_fraction = (litter_kg[row, col, 0] + litter_kg[row, col, 0]) / (litter_kg[row, col, 0] + litter_kg[row, col, 0] + total_layer_mass(row, col, 0));

                        //double litter_fraction = (old_SOM_kg[row, col, 0] + young_SOM_kg[row, col, 0]) / total_layer_mass(row, col, 0);
                        //LUX Xia you have to set this parameter here in the code. Value between 0-1.
                        // double litter_protection_constant = 0.5;

                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                        * Math.Exp(-rock_protection_constant * rock_fraction)
                        * Math.Exp(-bio_protection_constant)
                        * Math.Exp(-litter_protection_fraction);
                    }
                    if (daily_water.Checked)
                    {
                        if (aridity_vegetation[row, col] >= 1) { vegetation_cover_fraction = 1; }
                        else { vegetation_cover_fraction = aridity_vegetation[row, col]; }
                        mass_to_be_eroded = (transport_capacity_kg - total_sediment_in_transport_kg)
                            * Math.Exp(-rock_protection_constant * rock_fraction)
                            * Math.Exp(-bio_protection_constant
                            * vegetation_cover_fraction);
                    }

                    // second, calculate how the mass to be eroded is taken from the different size fractions: selectivity
                    // if total transport capacity is small, only the finer fractions will be eroded (selectivity with diameter to power 0.5). For larger transport capacities, selectivity decreases (diameter to power 0 = equal between fractions)

                    double constant_b1 = 0.5 * Math.Exp(constant_selective_transcap * transport_capacity_kg);
                    double sum_diameter_power = 0;
                    for (size = 0; size < 5; size++)
                    {
                        sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], constant_b1);
                    }
                    double clayeroded_0_kg = 0, claypresent_0_kg = 0, clayeroded_1_kg = 0, claypresent_1_kg = 0;
                    double silteroded_0_kg = 0, siltpresent_0_kg = 0, silteroded_1_kg = 0, siltpresent_1_kg = 0;
                    double sanderoded_0_kg = 0, sandpresent_0_kg = 0, sanderoded_1_kg = 0, sandpresent_1_kg = 0;
                    for (size = 0; size < 5; size++)
                    {
                        selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], constant_b1)) / sum_diameter_power;    // unit [-]
                        if (texture_kg[row_sd, col_sd, 0, size] >= selectivity_fraction * mass_to_be_eroded)
                        {    // typical situation
                            if (size == 1)
                            {
                                sanderoded_0_kg = selectivity_fraction * mass_to_be_eroded;
                                sandpresent_0_kg = texture_kg[row_sd, col_sd, 0, size];
                            }
                            if (size > 2)
                            {
                                clayeroded_0_kg += selectivity_fraction * mass_to_be_eroded;
                                claypresent_0_kg += texture_kg[row_sd, col_sd, 0, size];
                            }
                            total_mass_eroded[size] += selectivity_fraction * mass_to_be_eroded;
                            texture_kg[row_sd, col_sd, 0, size] -= selectivity_fraction * mass_to_be_eroded;   // unit [kg]
                            sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += selectivity_fraction * mass_to_be_eroded;  // unit [kg
                        }
                        else
                        {    // exceptional. If we want to erode more than present in the layer, we will take it from one layer down.
                             //this is to avoid exceptionally thin rocky layers blocking all erosion
                             //we will then first erode everything from the top layer (layer "0") and then erode from the second layer  (i.e. layer "1").

                            // Layer 0
                            if (size == 1)
                            {
                                sanderoded_0_kg = texture_kg[row_sd, col_sd, 0, size];
                                sandpresent_0_kg = texture_kg[row_sd, col_sd, 0, size];
                            }
                            if (size == 2)
                            {
                                silteroded_0_kg = texture_kg[row_sd, col_sd, 0, size];
                                siltpresent_0_kg = texture_kg[row_sd, col_sd, 0, size];
                            }
                            if (size > 2)
                            {
                                clayeroded_0_kg += texture_kg[row_sd, col_sd, 0, size];
                                claypresent_0_kg += texture_kg[row_sd, col_sd, 0, size];
                            }
                            total_mass_eroded[size] += texture_kg[row_sd, col_sd, 0, size];
                            double left = (selectivity_fraction * mass_to_be_eroded) - texture_kg[row_sd, col_sd, 0, size]; // unit [kg]
                            sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += texture_kg[row_sd, col_sd, 0, size];
                            texture_kg[row_sd, col_sd, 0, size] = 0;

                            // Layer 1
                            if (max_soil_layers > 1)
                            {
                                if (texture_kg[row_sd, col_sd, 1, size] >= left)
                                {   // typical
                                    if (size == 1)
                                    {
                                        sanderoded_1_kg = left;
                                        sandpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    if (size == 2)
                                    {
                                        silteroded_1_kg = left;
                                        siltpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    if (size > 2)
                                    {
                                        clayeroded_1_kg += left;
                                        claypresent_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    total_mass_eroded[size] += left;
                                    sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += left;   // unit [kg]
                                    texture_kg[row_sd, col_sd, 1, size] -= left;  // unit [kg]
                                }
                                else
                                {
                                    total_mass_eroded[size] += texture_kg[row_sd, col_sd, 1, size];
                                    if (size == 1)
                                    {
                                        sanderoded_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                        sandpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    if (size == 2)
                                    {
                                        silteroded_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                        siltpresent_1_kg = texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    if (size > 2)
                                    {
                                        clayeroded_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                        claypresent_1_kg += texture_kg[row_sd, col_sd, 1, size];
                                    }
                                    sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += texture_kg[row_sd, col_sd, 1, size];// unit [kg]
                                    texture_kg[row_sd, col_sd, 1, size] = 0;
                                }
                            }
                        }
                    }

                    //organic matter is eroded as a fraction of total OM. That fraction equals the fraction of clay eroded from the layer
                    //the assumption underlying this is that clay and humus are bound in aggregates
                    //this does not cover: LMW SOM, peat or large woody debris
                    double clayerodedfraction_0 = clayeroded_0_kg / claypresent_0_kg;
                    double clayerodedfraction_1 = clayeroded_1_kg / claypresent_1_kg;
                    double silterodedfraction_0 = silteroded_0_kg / siltpresent_0_kg;
                    double silterodedfraction_1 = silteroded_1_kg / siltpresent_1_kg;
                    double sanderodedfraction_0 = sanderoded_0_kg / sandpresent_0_kg;
                    double sanderodedfraction_1 = sanderoded_1_kg / sandpresent_1_kg;
                    if (Double.IsNaN(clayerodedfraction_0))
                    {
                        clayerodedfraction_0 = 0;
                        //Debug.WriteLine(" this should not have happened - no OM erosion possible");
                    }
                    if (Double.IsNaN(clayerodedfraction_1)) { clayerodedfraction_1 = 0; }
                    if (Double.IsNaN(sanderodedfraction_0)) { sanderodedfraction_0 = 0; }
                    if (Double.IsNaN(sanderodedfraction_1)) { sanderodedfraction_1 = 0; }
                    //if (row == 62 && col == 78) { Debug.WriteLine(clayerodedfraction_0 + "  " + clayerodedfraction_1); displaysoil(row, col); }
                    old_SOM_in_transport_kg[row_sd, col_sd] += old_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + old_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    young_SOM_in_transport_kg[row_sd, col_sd] += young_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + young_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    total_mass_eroded[5] += old_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + old_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    total_mass_eroded[6] += young_SOM_kg[row_sd, col_sd, 0] * clayerodedfraction_0 + young_SOM_kg[row_sd, col_sd, 1] * clayerodedfraction_1;
                    old_SOM_kg[row_sd, col_sd, 0] *= 1 - clayerodedfraction_0;
                    young_SOM_kg[row_sd, col_sd, 0] *= 1 - clayerodedfraction_0;
                    old_SOM_kg[row_sd, col_sd, 1] *= 1 - clayerodedfraction_1;
                    young_SOM_kg[row_sd, col_sd, 1] *= 1 - clayerodedfraction_1;

                    if (OSL_checkbox.Checked)
                    {
                        transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, sanderodedfraction_0, sanderodedfraction_1, 0);
                    }

                    if (CN_checkbox.Checked)
                    {
                        for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                        {
                            frac_eroded = 0;
                            // Erosion layer 0
                            if (i_cn == 0) { frac_eroded = clayerodedfraction_0; }
                            if (i_cn == 1) { frac_eroded = silterodedfraction_0; }
                            if (i_cn == 2 | i_cn == 3) { frac_eroded = sanderodedfraction_0; } 
                            double CN_erosion = CN_atoms_cm2[row_sd, col_sd, 0, i_cn] * frac_eroded;
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_erosion; // add CNs associated with eroded fraction to transport
                            CN_atoms_cm2[row_sd, col_sd, 0, i_cn] -= CN_erosion; // remove from source location

                            // Erosion layer 1
                            if (i_cn == 0 | i_cn == 4) { frac_eroded = clayerodedfraction_1; } else { frac_eroded = sanderodedfraction_1; }
                            CN_erosion = CN_atoms_cm2[row_sd, col_sd, 1, i_cn] * frac_eroded;
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_erosion; // add CNs associated with eroded fraction
                            CN_atoms_cm2[row_sd, col_sd, 1, i_cn] -= CN_erosion; // remove from source location

                            // CNs already in transport
                            CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_in_transport[row_sd, col_sd, i_cn] * flowfraction;
                        }
                    }
                }

                // We still need to transport the sediments that were already in transport:
                for (size = 0; size < n_texture_classes; size++)
                {
                    sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += flowfraction * sediment_in_transport_kg[row_sd, col_sd, size];  //all in kg 
                }
                old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd];  //all in kg
                young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd];  //all in kg

                if (OSL_checkbox.Checked)
                {
                    transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, 0);
                }

                if (CN_checkbox.Checked)
                {
                    for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                    {
                        // CNs already in transport
                        CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_in_transport[row_sd, col_sd, i_cn] * flowfraction;
                    }
                }
            }

            // Deposition
            if (transport_capacity_kg < total_sediment_in_transport_kg)
            {
                //first, calculate how much we are going to keep in transport. This is the way that selectivity works now. 
                double sum_diameter_power = 0, clay_deposited = 0, clay_transported = 0, clay_in_transport = 0, sand_deposited = 0, sand_in_transport = 0;
                for (size = 0; size < 5; size++)
                {
                    sum_diameter_power += 1 / Math.Pow(upper_particle_size[size], 0.5);
                }
                for (size = 0; size < 5; size++)
                {
                    selectivity_fraction = (1 / Math.Pow(upper_particle_size[size], 0.5)) / sum_diameter_power;    // unit [-]
                    potential_transported_amount_kg = selectivity_fraction * transport_capacity_kg;                      // unit [kg]
                    if (potential_transported_amount_kg < sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction)
                    {
                        total_mass_deposited_kg[size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                        texture_kg[row_sd, col_sd, 0, size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;        // unit [kg]
                        sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] = potential_transported_amount_kg;                                    // unit [kg]  
                        if (size == 1)
                        {
                            sand_deposited = sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                            sand_in_transport = sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                        }
                        if (size > 2)
                        {
                            clay_deposited += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction - potential_transported_amount_kg;
                            clay_transported += potential_transported_amount_kg;
                            clay_in_transport += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                        }
                    }
                    else
                    {
                        //do nothing. We keep the sediment in transport, and do not deposit anything. Only transport the sediments to the next cell
                        sediment_in_transport_kg[row_sd + i_sd, col_sd + j_sd, size] += sediment_in_transport_kg[row_sd, col_sd, size] * flowfraction;
                    }
                }
                // now organic matter
                double sand_deposited_fraction = sand_deposited / sand_in_transport; if (Double.IsNaN(sand_deposited_fraction)) { sand_deposited_fraction = 0; }
                double clay_deposited_fraction = clay_deposited / clay_in_transport; ; if (Double.IsNaN(clay_deposited_fraction)) { clay_deposited_fraction = 0; }

                total_mass_deposited_kg[5] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                total_mass_deposited_kg[6] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                young_SOM_kg[row_sd, col_sd, 0] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;
                old_SOM_kg[row_sd, col_sd, 0] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * clay_deposited_fraction;

                young_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * young_SOM_in_transport_kg[row_sd, col_sd] * (1 - clay_deposited_fraction);
                old_SOM_in_transport_kg[row_sd + i_sd, col_sd + j_sd] += flowfraction * old_SOM_in_transport_kg[row_sd, col_sd] * (1 - clay_deposited_fraction);

                // Now geochronology
                if (OSL_checkbox.Checked)
                {
                    transport_ero_sed_OSL_by_WE(row_sd, col_sd, i_sd, j_sd, sum_of_fractions, flowfraction, 0, 0, sand_deposited_fraction); // layer 0
                }

                if (CN_checkbox.Checked)
                {
                    for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                    {
                        // Deposition layer 0
                        if (i_cn == 0 | i_cn == 4) { frac_deposited = clay_deposited_fraction; } else { frac_deposited = sand_deposited_fraction; }

                        double CN_deposition = CN_in_transport[row_sd, col_sd, i_cn] * flowfraction * frac_deposited;
                        CN_atoms_cm2[row_sd, col_sd, 0, i_cn] += CN_deposition; // deposit CNs
                        CN_in_transport[row_sd + i_sd, col_sd + j_sd, i_cn] += CN_in_transport[row_sd, col_sd, i_cn] * flowfraction - CN_deposition; // transport the rest
                    }
                }
            } // end deposition

        }

        void calculate_water_ero_sed_daily()
        {
            if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
            {
                Debug.WriteLine("we1");
            }

            for (sbyte tcls = 0; tcls < 5; tcls++)
            {
                domain_sed_export_kg[tcls] = 0;
            }
            domain_OOM_export_kg = 0;
            domain_YOM_export_kg = 0;

            double mass_before = total_catchment_mass(), mass_after, mass_export = 0;
            //Debug.WriteLine("WE1");
            int size, dir;
            double water_out, flow_between_cells_m3_per_m, total_sediment_in_transport_kg, rock_fraction, total_ero = 0, total_dep = 0, potential_transported_amount_kg, vegetation_cover_fraction, mass_to_be_eroded, selectivity_fraction;

            // 1: set all water and sediment flow to 0
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    {
                        if (only_waterflow_checkbox.Checked == false)
                        {

                            for (size = 0; size < n_texture_classes; size++)
                            {
                                sediment_in_transport_kg[row, col, size] = 0;
                            }
                            old_SOM_in_transport_kg[row, col] = 0;
                            young_SOM_in_transport_kg[row, col] = 0;
                            dz_ero_m[row, col] = 0;
                            dz_sed_m[row, col] = 0;
                            lake_sed_m[row, col] = 0;

                            if (OSL_checkbox.Checked)
                            {
                                OSL_grainages_in_transport[row, col] = new int[] { };
                                OSL_depositionages_in_transport[row, col] = new int[] { };
                                OSL_surfacedcount_in_transport[row, col] = new int[] { };
                            }
                            if (CN_checkbox.Checked)
                            {
                                for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                                {
                                    CN_in_transport[row, col, i_cn] = 0;
                                }

                            }

                        }
                    }
                }  // end for col
            }  //end for row
               //Debug.WriteLine("WE2");

            // 2: Iterate through rows and columns
            int runner = 0;
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {

                if (index[runner] != -9999)
                {
                    //if (row == 40 & col == 31) { displaysoil(40, 31); Debugger.Break(); }

                    row = row_index[runner]; col = col_index[runner];

                    //Debug.WriteLine("WE3");

                    // 3: Determine fraction of water flowing to lower neighbour
                    water_out = 0;
                    for (int dir2 = 1; dir2 < 9; dir2++)
                    {
                        water_out += OFy_m[row, col, dir2];
                        //if (col == 12 && dir2 == 1) { Debugger.Break(); }
                        // if (t == 1) { Debugger.Break(); }
                    }
                    double fracsum = 0;

                    if (water_out > 0)
                    {
                        // Debug.WriteLine("Overland flow in col {0}", col);
                        dir = 0;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (!((i == 0) && (j == 0))) { dir++; }

                                dh = 0; fraction = 0; transport_capacity_kg = 0;

                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        // Debug.WriteLine("row = {0}, col = {1}, dir = {2}, i = {3}, j = {4}",row,col,dir,i,j);
                                        dh = dtm[row, col] - dtm[row + i, col + j];
                                        //Debug.WriteLine("Source: {0}, sink: {1}", dtm[row, col], dtm[row + i, col + j]);
                                        d_x = dx;
                                        //if (col + j == 0) { Debugger.Break(); }

                                        if (dh > 0)
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            dh /= d_x;

                                            fraction = OFy_m[row, col, dir] / water_out;

                                            flow_between_cells_m3_per_m = OFy_m[row, col, dir] * dx * dx / dx; // 

                                            //Debug.WriteLine("WE4");
                                            calculate_sediment_dynamics(row, col, i, j, flow_between_cells_m3_per_m, fraction, fracsum);
                                            fracsum += fraction;
                                        } // end dh > 0
                                    } // end dtm!=-9999
                                }
                            } // end j
                        } // end i
                        if (fracsum < 0.9999 & !search_nodataneighbour(row, col))
                        {
                            Debug.WriteLine("fracsum = " + fracsum);
                            for (int otp = 0; otp < 10; otp++)
                            {
                                Debug.WriteLine("dir {0}, {1}", otp, OFy_m[row, col, otp]);
                            }
                            //minimaps(row, col);
                            Debug.WriteLine("err_we3");

                        }
                    } // outflow water
                    else
                    { // no outflow of water. 
                      // -> Cell located in depression. Deposit all sediments
                      // -> Cell at border of landscape, outflow of all sediments
                      // double mass_temp = total_catchment_mass();
                        bool bool_outflow = false;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                if (i != 0 & j != 0)
                                {
                                    if ((row + i) >= nr | (row + i) <= 0 | (col + j) >= nc | (col + j) <= 0) // Does the cell fall outside of the area?
                                    {
                                        bool_outflow = true;
                                    }
                                    else if (dtm[row + i, col + j] == -9999)
                                    {
                                        bool_outflow = true;
                                    }
                                }
                            }
                        }
                        if (bool_outflow) // if there is outflow, export of sediments. 
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                mass_export += sediment_in_transport_kg[row, col, size];
                            }
                            mass_export += old_SOM_in_transport_kg[row, col];  //all in kg
                            mass_export += young_SOM_in_transport_kg[row, col];  //all in kg
                        }
                        else // if there is no outflow, deposition of sediments in cell. No delta formation (yet) develop MvdM
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                texture_kg[row, col, 0, size] += sediment_in_transport_kg[row, col, size];  //all in kg 
                                total_dep += sediment_in_transport_kg[row, col, size];

                                old_SOM_kg[row, col, 0] += old_SOM_in_transport_kg[row, col];  //all in kg
                                young_SOM_kg[row, col, 0] += young_SOM_in_transport_kg[row, col];  //all in kg

                                // now geochronology
                                if (CN_checkbox.Checked)
                                {
                                    for (int cn_i = 0; cn_i < n_cosmo; cn_i++)
                                    {
                                        CN_atoms_cm2[row, col, 0, cn_i] += CN_in_transport[row, col, cn_i];
                                    }
                                }
                                if (OSL_checkbox.Checked)
                                {
                                    transport_ero_sed_OSL_by_WE(row, col, 0, 0, 0, 1, 0, 0, 1); // Deposit all grains in transport at this location
                                }
                            }
                        }
                    }
                }
                mass_after = total_catchment_mass();
                if (mass_before - (mass_after + mass_export) > 0.001)
                {
                    Debug.WriteLine("err_we4");
                }
                // all cells have now been considered in order of (original) altitude. We must still recalculate their thicknesses and recalculate altitude. While doing that, we should count how much erosion and deposition there has been. 
                double old_total_elevation = total_catchment_elevation();
                volume_eroded_m = 0; sediment_exported_m = 0; volume_deposited_m = 0;
                total_average_altitude_m = 0; total_altitude_m = 0;
                total_rain_m = 0; total_evap_m = 0; total_infil_m = 0; 
                total_rain_m3 = 0; total_evap_m3 = 0; total_infil_m3 = 0; total_outflow_m3 = 0;
                wet_cells = 0; eroded_cells = 0; deposited_cells = 0;
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (only_waterflow_checkbox.Checked == false)
                            {
                                double old_thickness = soildepth_m[row, col];
                                update_all_layer_thicknesses(row, col);
                                double new_thickness = total_soil_thickness(row, col);
                                dtm[row, col] += new_thickness - old_thickness;
                                soildepth_m[row, col] = new_thickness;
                                dtmchange_m[row, col] += new_thickness - old_thickness;
                                sum_water_erosion[row, col] += new_thickness - old_thickness;
                                if ((new_thickness - old_thickness) < 0)
                                { dz_ero_m[row, col] += new_thickness - old_thickness; }
                                else { dz_sed_m[row, col] += new_thickness - old_thickness; }
                                if (-dz_ero_m[row, col] > timeseries.timeseries_erosion_threshold) { eroded_cells++; }
                                if (dz_sed_m[row, col] + lake_sed_m[row, col] > timeseries.timeseries_deposition_threshold) { deposited_cells++; }
                            }
                            // 7: Update timeseries
                            if (check_space_rain.Checked == true) { total_rain_m += rain[row, col]; }
                            total_rain_m += rain_value_m;
                            if (check_space_evap.Checked == true) { total_evap_m += evapotranspiration[row, col]; }
                            total_evap_m += evap_value_m;
                            if (check_space_infil.Checked == true) { total_infil_m += infil[row, col]; }
                            total_infil_m += infil_value_m;
                            if (waterflow_m3[row, col] * dx * dx > timeseries.timeseries_waterflow_threshold) { wet_cells++; }
                        } // end for nodata
                    }   // end for col
                } // end for row

                // out_double(workdir + "\\" + run_number + "_" + t + "_mass_difference.asc", mass_difference_input_output);
                total_rain_m3 = total_rain_m * dx * dx;   // m3
                total_evap_m3 = total_evap_m * dx * dx;   // m3
                total_infil_m3 = total_infil_m * dx * dx;  // m3
                total_outflow_m3 = total_rain_m3 - total_evap_m3 - total_infil_m3;
                //Debug.WriteLine("\n--erosion and deposition overview--");
                //Debug.WriteLine("rain " + total_rain + " evap " + total_evap + " total_infil " + total_infil);
                /*Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = "calc movement has been finished";
                    this.out_sed_statuspanel.Text = string.Format("sed_exp {0:F0} * 1000 m3", total_sed_export * dx * dx / 1000);
                }, CancellationToken.None, TaskCreationOptions.None, guiThread); */

                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_we5");
                }

            }
        }

        void calculate_water_ero_sed()    //where the water starts flowing, eroding and transporting
        {
            //this.InfoStatusPanel.Text = "water erosion calculation";
            dhmax_errors = 0;
            //set all start q values effective precipitation at time t
            nb_ok = 0;  // nb_ok is 1 als er uberhaupt buren zijn, dus 0 als er alleen maar NODATA is
            nb_check = 0; all_grids = 0;
            dz_bal = 0; sediment_exported_m = 0; erocnt = 0; sedcnt = 0;
            sedbal = 0; erobal = 0; maximum_allowed_deposition = -9999.0; dh_tol = 0.00025;
            sedbal2 = 0; erobal2 = 0;
            tel1 = 0; tel2 = 0; tel3 = 0; tel4 = 0;
            depressions_filled = 0; depressions_delta = 0; depressions_alone = 0; sediment_delta_m = 0; sediment_filled_m = 0; depressionvolume_filled_m = 0; crashed = false;
            for (sbyte tcls = 0; tcls < 5; tcls++)
            {
                domain_sed_export_kg[tcls] =  0;
            }
            domain_OOM_export_kg =0;
            domain_YOM_export_kg =0;


            double powered_slope_sum, flow_between_cells_m3_per_m;
            int size;
            for (alpha = 1; alpha <= maxdepressionnumber; alpha++)  // zeroing all waterflow at outlets of depressions
            {
                depressionconsidered[alpha] = 0;
                for (int outletcounter = 0; outletcounter < 5; outletcounter++)
                {
                    if (drainingoutlet_row[alpha, outletcounter] != -1)
                    {
                        waterflow_m3[drainingoutlet_row[alpha, outletcounter], drainingoutlet_col[alpha, outletcounter]] = 0;
                    }
                }
            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before row col loop in water erosed"); }
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    // if(row==50 & col == 99) { Debugger.Break(); }
                    if (dtm[row, col] != -9999)
                    {
                        // First, we apply rainwater to our landscape (in a two step approach - first normal cells and lake outlets)
                        if (depression[row, col] == 0 ||
                            (drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                            (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                            (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                            (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                            (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                        {
                            if (check_space_evap.Checked == true) { evap_value_m = evapotranspiration[row, col]; }
                            if (check_space_rain.Checked == true) { rain_value_m = rain[row, col]; }
                            if (check_space_infil.Checked == true) { infil_value_m = infil[row, col]; }
                            //ArT // development required to account for f(t) situations
                            waterflow_m3[row, col] += (rain_value_m - infil_value_m - evap_value_m) * dx * dx;
                            if (waterflow_m3[row, col] < 0) { waterflow_m3[row, col] = 0; }
                            if (waterflow_m3[row, col] < -0.001) { Debug.WriteLine(" Negative waterflow at " + row + " " + col + ": " + waterflow_m3[row, col] + ". rain " + rain_value_m + " infil " + infil_value_m + " evap " + evap_value_m + " use " + landuse[row, col]); }
                        }
                        else  // and then, second step, for other lake cells
                        { // for other lakecells, we send the rainwater directly (equally distributed) to that lake's outlet(s) (infiltration is not zero in the lake at the moment)
                          //Debug.WriteLine(" B at " + row + " col " + col + " alt " + dtm[row, col] + " dep " + depression[row, col]);
                            int outletcounter = 0; ;
                            while (drainingoutlet_col[depression[row, col], outletcounter] != -1)
                            {
                                outletcounter++;
                                if (outletcounter == 5) { break; }
                            }
                            for (i = 0; i < outletcounter; i++)
                            {

                                if (check_space_evap.Checked == true) { evap_value_m = evapotranspiration[row, col]; }
                                if (check_space_rain.Checked == true) { rain_value_m = rain[row, col]; }
                                if (check_space_infil.Checked == true) { infil_value_m = infil[row, col]; }
                                //ArT // development required to account for f(t) situations
                                //ArT remember to check for negative lake outflow once it happens
                                waterflow_m3[drainingoutlet_row[depression[row, col], i], drainingoutlet_col[depression[row, col], i]] += dx * dx * (rain_value_m - infil_value_m - evap_value_m) / outletcounter;
                            }
                        }
                        if (only_waterflow_checkbox.Checked == false)
                        {
                            for (size = 0; size < n_texture_classes; size++)
                            {
                                sediment_in_transport_kg[row, col, size] = 0;
                            }
                            old_SOM_in_transport_kg[row, col] = 0;
                            young_SOM_in_transport_kg[row, col] = 0;
                            dz_ero_m[row, col] = 0;
                            dz_sed_m[row, col] = 0;
                            lake_sed_m[row, col] = 0;

                            if (OSL_checkbox.Checked)
                            {
                                OSL_grainages_in_transport[row, col] = new int[] { };
                                OSL_depositionages_in_transport[row, col] = new int[] { };
                                OSL_surfacedcount_in_transport[row, col] = new int[] { };
                            }
                            if (CN_checkbox.Checked)
                            {
                                for (int i_cn = 0; i_cn < n_cosmo; i_cn++)
                                {
                                    CN_in_transport[row, col, i_cn] = 0;
                                }
                            }

                        }
                    }
                }  // end for col
            }  //end for row
               //Debug.WriteLine(" prepared water. Ready to route for erosion and deposition");
            all_grids = (nr) * (nc);
            memberdepressionnotconsidered = 0;
            int runner = 0;
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before sorted row col loop in water erosed"); }
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {     // the index is sorted from low to high values, but flow goes from high to low
                if (index[runner] != -9999)
                {

                    int row = row_index[runner]; int col = col_index[runner];
                    // if(row==50 & col == 99) { Debugger.Break(); }
                    //Debug.WriteLine(runner + " " + row + "  " + col + " nr " + nr + " nc " + nc + " nr*nc " + nr * nc + " data cells " + number_of_data_cells);
                    if (t == 1 && row == 24 && col == 81) { diagnostic_mode = 1; }

                    else { diagnostic_mode = 0; }

                    powered_slope_sum = 0; max_allowed_erosion = 0; dz_min = -9999.99;
                    direct = 20; dz_max = -10; dhtemp = -99999.99; maximum_allowed_deposition = -9999.99;
                    if (depression[row, col] < 0) { depression[row, col] = 0; }
                    if ((drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                        (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                        (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                        (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                        (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                    {
                        if (depressionconsidered[depression[row, col]] == 0)
                        {

                            depressionnumber = depression[row, col];
                            depressionconsidered[depressionnumber] = 1;

                            if (diagnostic_mode == 1) { Debug.WriteLine(" now considering dep " + depressionnumber + " index " + runner); }
                            update_depression(depressionnumber);
                            if (depressionsum_sediment_m == 0)
                            {
                                leave_depression_alone(depressionnumber); depressions_alone++;
                            }
                            else
                            {
                                if (depressionsum_sediment_m >= needed_to_fill_depression_m) { fill_depression(depressionnumber, needed_to_fill_depression_m / depressionsum_sediment_m); depressions_filled++; }
                                else { delta_depression(depressionnumber); depressions_delta++; }
                            }
                        }
                        //all cells of this lake have now been considered, except the outlets
                    }
                    if (depression[row, col] < 0) { Debug.WriteLine(" error: negative depression value " + depression[row, col] + " at " + row + " " + col); minimaps(row, col); }
                    // this check indicates a problem with the resetting of cells involved in a delta
                    if (depression[row, col] == 0 ||
                                                (drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col) ||
                                                (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col) ||
                                                (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col) ||
                                                (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col) ||
                                                (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                    { //for all cells outside a depression and for outlets, we use the stream power equations based on a multiple flow (D8) template
                      //if (row == 24 && col == 81) { Debug.WriteLine(" looking around cell " + row + " " + col); minimaps(row, col); }
                        for (sbyte i = (-1); i <= 1; i++)
                        {
                            for (sbyte j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))  //to stay within the grid and avoid the row col cell itself
                                {
                                    // below, we calculate slope_sum for all cells either not in a depression, or being a outlet
                                    // slope_sum is needed to calculate flow in a multiple flow environment until someone thinks of something better
                                    // if (diagnostic_mode == 1) { Debug.WriteLine("checking " + (row + i) + " " + (col + j) + " from cell " + row + " " + col); }
                                    if (depression[row, col] == 0)
                                    {    // if the cell is not in a depression (it could be in a depression as an outlet)
                                        if (dtm[row + i, col + j] != -9999)
                                        {  //if the cell has no NODATA
                                            if (only_waterflow_checkbox.Checked)
                                            {
                                                dh = dtm[row, col] - dtm[row + i, col + j]; // in the case that we are not interested in erosion and deposition, then there is no ero and sed to query                                            }
                                            }
                                            else
                                            {
                                                dh = (dtm[row, col] + dz_ero_m[row, col] + dz_sed_m[row, col]) - (dtm[row + i, col + j] + dz_ero_m[row + i, col + j] + dz_sed_m[row + i, col + j]);    // diff @ this moment 
                                            }
                                            if (dh < 0)  // we are looking at a higher neighbour
                                            {
                                                if (dh > maximum_allowed_deposition) { maximum_allowed_deposition = dh; }   // we keep track of the minimum difference in altitude between this cell and its lowest higher neighbour - we will not raise it more, even if we would like to when the Courant criterion is violated
                                            } // end if dh
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }   // for non-cardinal neighbours, we use the adapted length
                                            if (dh > 0)
                                            {  // i j is a lower neighbour
                                                if (dh > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh - dh_tol); }  // we keep track of the minimum difference in current altitude between this cell and its highest lower neighbour - we will not erode it more, even if we would like to

                                                dh = dh / d_x;
                                                dh = Math.Pow(dh, conv_fac);
                                                powered_slope_sum = powered_slope_sum + dh;
                                            }//end if dh  
                                        }//end if novalues
                                    }  // end if not in depression
                                    if ((drainingoutlet_row[depression[row, col], 0] == row && drainingoutlet_col[depression[row, col], 0] == col)
                                        || (drainingoutlet_row[depression[row, col], 1] == row && drainingoutlet_col[depression[row, col], 1] == col)
                                        || (drainingoutlet_row[depression[row, col], 2] == row && drainingoutlet_col[depression[row, col], 2] == col)
                                        || (drainingoutlet_row[depression[row, col], 3] == row && drainingoutlet_col[depression[row, col], 3] == col)
                                        || (drainingoutlet_row[depression[row, col], 4] == row && drainingoutlet_col[depression[row, col], 4] == col))
                                    {    // this cell is one of the draining outlets and is only allowed to drain to cells not in the lake																											
                                         // if the lake has been filled at this time, then all its (by now non-lake) cells have an altitude > outlet, and will not be considered for that reason
                                        if (depression[row + i, col + j] != depression[row, col])
                                        {
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            dh = dtm[row, col] - dtm[row + i, col + j];
                                            if (dh > 0)
                                            {// i j is a lower neighbour
                                                dh = dh / d_x;                      // dh is now equal to slope
                                                dh = Math.Pow(dh, conv_fac);            // dh is nu de helling tot de macht conv fac
                                                powered_slope_sum = powered_slope_sum + dh;
                                            } // end if lower nb
                                        } //end if nb not within depression
                                    } // end if drainingoutlet
                                }// end if boundaries
                            }//end for j
                        }//end for i, we now know slope sum for this cell. We have included cells that are in a lake in this calculation. //ArT should we replace their altitude with depressionlevel?
                         // (row == 24 && col == 81) { Debug.WriteLine("passed"); }
                        if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = -maximum_allowed_deposition; }
                        if (max_allowed_erosion < 0) { max_allowed_erosion = -dh_tol; } else { max_allowed_erosion = -max_allowed_erosion; }
                        //if (diagnostic_mode == 1) { Debug.WriteLine(" slopesum = " + slope_sum + " maximum deposition " + maximum_allowed_deposition + " maximum erosion " + max_allowed_erosion); }

                        //if slope_sum is zero, then we are in a non-lake cell or a lake outlet that has no nbs in the dtm -> we have reached an outflow point.
                        //no action is  needed, but we do count the number of outlets and the total amount of sed in trans that leaves the catchment from these places
                        if (powered_slope_sum == 0)
                        {
                            number_of_outflow_cells++;
                            for (sbyte tcls = 0; tcls < 5; tcls++)
                            {
                                domain_sed_export_kg[tcls] += sediment_in_transport_kg[row, col, tcls];
                            }
                            domain_OOM_export_kg += old_SOM_in_transport_kg[row,col];
                            domain_YOM_export_kg += young_SOM_in_transport_kg[row, col];
                        }
                        else  //apparently, there is at least 1 lower nb in the DEM. Let's do business with it
                        {

                            // we are now prepared to actually calculate erosion and deposition: we can calculate how much water and sediment is redistributed using slope_sum
                            if (NA_in_soil(row, col) == true) { Debug.WriteLine("NA found before eroding " + row + " " + col); }
                            double sum_frac_OSL = 0;
                            for (sbyte i = (-1); i <= 1; i++)
                            {
                                for (sbyte j = (-1); j <= 1; j++)
                                {
                                    dh = 0; fraction = 0; transport_capacity_kg = 0;
                                    sediment_transported = 0; detachment_rate = 0;
                                    d_x = dx;
                                    if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                    {  //boundaries
                                       //if (row == 24 && col == 81) { Debug.WriteLine("entered" + i + j); }
                                        if (dtm[row + i, col + j] != -9999)
                                        {
                                            if (only_waterflow_checkbox.Checked)
                                            {
                                                dh = dtm[row, col] - dtm[row + i, col + j];
                                            }
                                            else
                                            {
                                                dh = (dtm[row, col] + dz_ero_m[row, col] + dz_sed_m[row, col]) - (dtm[row + i, col + j] + dz_ero_m[row + i, col + j] + dz_sed_m[row + i, col + j]);
                                            }
                                            if (dh > 0)

                                            {
                                                //we have found one of the lower nbs
                                                //if (row == 24 && col == 81) { Debug.WriteLine("this is a lower nb " + i + j + "dh" + dh + " " + waterflow_m3[row, col]); }
                                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                                if ((depression[row, col] != 0 && depression[row + i, col + j] != depression[row, col]) || (depression[row, col] == 0))
                                                {   //if cell == outlet of current lake and nb not member of that lake OR if not a lake member

                                                    // Now, we first calculate the fraction of water and sediment that goes from row, col to row+i to col+j , always using current altitudes
                                                    // Then, we calculate the actual amounts of water and sediment, and with that, using the stream power equation, the transport capacity
                                                    // In future, the Hjülstrom diagram can be used to give texture-dependent erosion thresholds (or selectivity)

                                                    dh /= d_x;  //dh is now slope
                                                    fraction = Math.Pow(dh, conv_fac) / powered_slope_sum;
                                                    if (waterflow_m3[row, col] < 0) { waterflow_m3[row, col] = 0; }    // this can have happened if water enters a drier zone in the landscape
                                                    flow_between_cells_m3_per_m = fraction * waterflow_m3[row, col] / dx;
                                                    if (depression[row + i, col + j] == 0)
                                                    {  // if receiving cell is not in a depression, its waterflow is increased 
                                                        waterflow_m3[row + i, col + j] += flow_between_cells_m3_per_m * dx;
                                                    }
                                                    if (depression[row + i, col + j] != 0)
                                                    {  // if receiving cell is in a depression, its outlets' waterflow is increased 
                                                        currentdepression = Math.Abs(depression[row + i, col + j]); // this Abs stuff should not be necessary and is included for stability!
                                                        int outletcounter = 0;
                                                        while (drainingoutlet_col[currentdepression, outletcounter] != -1)
                                                        {
                                                            outletcounter++;
                                                            if (outletcounter == 5) { break; }
                                                        }
                                                        for (int iter = 0; iter < outletcounter; iter++) // for all outlets of this depression, divide that amount of water over them
                                                        {
                                                            waterflow_m3[drainingoutlet_row[currentdepression, iter], drainingoutlet_col[currentdepression, iter]] += dx * flow_between_cells_m3_per_m / outletcounter;
                                                        }
                                                    }

                                                    if (only_waterflow_checkbox.Checked == false)
                                                    {
                                                        calculate_sediment_dynamics(row, col, i, j, flow_between_cells_m3_per_m, fraction, sum_frac_OSL);

                                                    } // end if else : also erosion and deposition considered
                                                    sum_frac_OSL += fraction;
                                                }

                                                // 4. Indien oververzadigd: depositie. Berekenen van de doorgaande massa van iedere textuurklasse, op basis van 1/d0.5 (zie Excel). 
                                                // 4b. Vergelijken van doorgaande massa met massa aanwezig in transport per textuurfractie. Indien teveel aanwezig, afwerpen. 
                                                // 4c. Organische stof afwerpen propoertioneel met de afzettingsfractie van de beide kleifracties. (Dus als er 30% van de klei in transport blijft, dan ook 30% van de OM).
                                                // Dit leidt bij de kleifractie slechts zelden tot afzetting. 

                                                // Depressies: volledige afzetting van materiaal dat in transport is. 
                                                // Instabiliteit: geen garantie dat dit niet gebeurt. Smearing kan er bij gezet worden. 
                                                // Gravelafzettingen: volgens pdf een rho van 2.7. Afgeronde gravel afzettingen van rivieren kunnen die heel laag hebben. 

                                            } //end`dH > 000
                                        }//end if novalues
                                    }//end if boundaries
                                }//end for j
                            }//end for i
                        }  // end else slope_sum ==0                      
                        if (NA_in_soil(row, col) == true) { Debug.WriteLine("NA found after eroding " + row + " " + col); }
                        //if (row == 24 && col == 81) { Debug.WriteLine("passed"); }
                    } // end if not in a lake or a lake outlet (all other lake cells have been considered before
                } //end if nodata
            }//end for index
             // all cells have now been considered in order of (original) altitude. We must still recalculate their thicknesses and recalculate altitude. While doing that, we should count how much erosion and deposition there has been. 
            volume_eroded_m = 0; sediment_exported_m = 0; volume_deposited_m = 0;
            total_average_altitude_m = 0; total_altitude_m = 0;
            total_rain_m = 0; total_evap_m = 0; total_infil_m = 0; 
            total_rain_m3 = 0; total_evap_m3 = 0; total_infil_m3 = 0; total_outflow_m3 = 0;
            wet_cells = 0; eroded_cells = 0; deposited_cells = 0;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        if (only_waterflow_checkbox.Checked == false)
                        {
                            //erosion and deposition affect only the top two layers of soil. All others: unaffected.
                            //So, we calculate the difference between the original and final thicknesses of these two layers to calculate dz_ero and dz_sed. 
                            //We already knew how much mass was involved in ero and sed, but we need the volumes to update the dtm.

                            for (sbyte i = 0; i < 2 & i<max_soil_layers; i++)
                            {
                                double pastlayer = layerthickness_m[row, col, i];
                                layerthickness_m[row, col, i] = thickness_calc(row, col, i);
                                if (pastlayer < layerthickness_m[row, col, i])  //if there is deposition in volume terms
                                {
                                    dz_sed_m[row, col] += layerthickness_m[row, col, i] - pastlayer;  // leading to positive values for dz_sed_m, which is what we want
                                }
                                else
                                {
                                    dz_ero_m[row, col] += layerthickness_m[row, col, i] - pastlayer;  //leading to negative values for dz_ero_m, which is what we want
                                }
                            }
                            //now dz_ero_m and dz_sed_m hold the changed altitudes. 

                            volume_eroded_m += dz_ero_m[row, col];
                            volume_deposited_m += dz_sed_m[row, col];
                            dtmchange_m[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col];  //attention: LAKE_sed and dz_sed_m are treated differently. 
                            dtm[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col];                           //No need to add lake_sed to dtm in the next line
                            soildepth_m[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col]; // update soil depth
                            sum_water_erosion[row, col] += dz_ero_m[row, col] + dz_sed_m[row, col] + lake_sed_m[row, col];

                            if (-dz_ero_m[row, col] > timeseries.timeseries_erosion_threshold) { eroded_cells++; }
                            if (dz_sed_m[row, col] + lake_sed_m[row, col] > timeseries.timeseries_deposition_threshold) { deposited_cells++; }
                        }
                        if (check_space_rain.Checked == true) { total_rain_m += rain[row, col]; }
                        total_rain_m += rain_value_m;
                        if (check_space_evap.Checked == true) { total_evap_m += evapotranspiration[row, col]; }
                        total_evap_m += evap_value_m;
                        if (check_space_infil.Checked == true) { total_infil_m += infil[row, col]; }
                        total_infil_m += infil_value_m;
                        if (waterflow_m3[row, col] * dx * dx > timeseries.timeseries_waterflow_threshold) { wet_cells++; }
                    } // end for nodata
                }   // end for col
            } // end for row
            total_rain_m3 = total_rain_m * dx * dx;   // m3
            total_evap_m3 = total_evap_m * dx * dx;   // m3
            total_infil_m3 = total_infil_m * dx * dx;  // m3
            total_outflow_m3 = total_rain_m3 - total_evap_m3 - total_infil_m3;
            //Debug.WriteLine("\n--erosion and deposition overview--");
            //Debug.WriteLine("rain " + total_rain + " evap " + total_evap + " total_infil " + total_infil);
            if (only_waterflow_checkbox.Checked == false)
            {

                //Debug.WriteLine(" number of dhmax erosion errors: " + + "\n" ,dhmax_errors); 
                //Debug.WriteLine(" filled " + + " of " + + " depressions, %.3f sediment used for %.3f depressionvolume\n",depressions_filled,totaldepressions,sediment_filled,depressionvolume_filled); 
                //Debug.WriteLine(" sedimented into " + + " of " + + " depressions, %.3f sediment used\n",depressions_delta,totaldepressions,sediment_delta);
                //Debug.WriteLine(" left alone " + + " of " + + " depressions",depressions_alone,totaldepressions); 
                //Debug.WriteLine(" total %6.0f cubic metres of sediment (of max %6.0f) deposited ",(sediment_deposited+sediment_delta+sediment_filled)*dx*dx,(-sediment_produced*dx*dx)); 
                /* Debug.WriteLine(" MASS BASED [kg]:");
                 Debug.WriteLine(" SDR_all " + (total_kg_eroded - total_kg_deposited) / (total_kg_eroded));
                 if (total_mass_eroded[0] != 0) { Debug.WriteLine(" SDR_coarse " + (total_mass_eroded[0] - total_mass_deposited[0]) / (total_mass_eroded[0]) + " ero " + total_mass_eroded[0] + "kg sed " + total_mass_deposited[0] + "kg"); } else { Debug.WriteLine("no coarse transport"); }
                 if (total_mass_eroded[1] != 0) { Debug.WriteLine(" SDR_sand " + (total_mass_eroded[1] - total_mass_deposited[1]) / (total_mass_eroded[1]) + " ero " + total_mass_eroded[1] + "kg sed " + total_mass_deposited[1] + "kg"); } else { Debug.WriteLine("no sand transport"); }
                 if (total_mass_eroded[2] != 0) { Debug.WriteLine(" SDR_silt " + (total_mass_eroded[2] - total_mass_deposited[2]) / (total_mass_eroded[2]) + " ero " + total_mass_eroded[2] + "kg sed " + total_mass_deposited[2] + "kg"); } else { Debug.WriteLine("no silt transport"); }
                 if (total_mass_eroded[3] != 0) { Debug.WriteLine(" SDR_clay " + (total_mass_eroded[3] - total_mass_deposited[3]) / (total_mass_eroded[3]) + " ero " + total_mass_eroded[3] + "kg sed " + total_mass_deposited[3] + "kg"); } else { Debug.WriteLine("no clay transport"); }
                 if (total_mass_eroded[4] != 0) { Debug.WriteLine(" SDR_fine_clay " + (total_mass_eroded[4] - total_mass_deposited[4]) / (total_mass_eroded[4]) + " ero " + total_mass_eroded[4] + "kg sed " + total_mass_deposited[4] + "kg"); } else { Debug.WriteLine("no fine clay transport"); }

                 Debug.WriteLine(" VOLUME BASED [m3]:");
                 Debug.WriteLine(" SDR " + (volume_eroded + volume_deposited + sediment_delta + sediment_filled) / (volume_eroded));
                 //Debug.WriteLine(" as sink : %.3f ",((-sediment_delta-sediment_filled)/sediment_produced)); 
                 //Debug.WriteLine(" as sediment : %.3f ",((-sediment_deposited)/sediment_produced)); 
                 Debug.Write(" ERO " + (volume_eroded * dx * dx) + " \n");
                 Debug.Write(" SED " + (volume_deposited * dx * dx) + " \n");
                 Debug.Write(" DEL " + (sediment_delta * dx * dx) + " \n");
                 Debug.WriteLine(" FIL " + (sediment_filled * dx * dx) + " \n");
                 */
                /*if ((volume_eroded + volume_deposited + sediment_delta + sediment_filled) / volume_eroded != 0)
                {
                    Debug.WriteLine(" ALTITUDE BASED:");
                    Debug.WriteLine(" t = " + t + " number of dhmax erosion errors: " + dhmax_errors);
                    Debug.WriteLine(" on m-basis: filled " + depressions_filled + " of " + totaldepressions + " depressions, " + sediment_filled + " sediment used for " + depressionvolume_filled + " depressionvolume");
                    Debug.WriteLine(" on m-basis: sedimented into " + depressions_delta + " of " + totaldepressions + " depressions, " + sediment_delta + "  sediment used");
                } */
            }
            /*
            Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "calc movement has been finished";
                this.out_sed_statuspanel.Text = string.Format("sed_exp {0:F0} * 1000 m3", total_sed_export * dx * dx / 1000);
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            */
            //save timeseries_outputs
            if (timeseries.timeseries_cell_waterflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[1]] = waterflow_m3[System.Convert.ToInt32(timeseries.timeseries_textbox_cell_row.Text), System.Convert.ToInt32(timeseries.timeseries_textbox_cell_col.Text)];
            }
            if (timeseries.timeseries_cell_altitude_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[2]] = dtm[System.Convert.ToInt32(timeseries.timeseries_textbox_cell_row.Text), System.Convert.ToInt32(timeseries.timeseries_textbox_cell_col.Text)];
            }
            if (timeseries.timeseries_net_ero_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[3]] = volume_eroded_m + volume_deposited_m + sediment_delta_m + sediment_filled_m;
            }
            if (timeseries.timeseries_number_dep_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[4]] = deposited_cells;
            }
            if (timeseries.timeseries_number_erosion_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[5]] = eroded_cells;
            }
            if (timeseries.timeseries_number_waterflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[6]] = wet_cells;
            }
            if (timeseries.timeseries_SDR_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[7]] = (volume_eroded_m + volume_deposited_m + sediment_delta_m + sediment_filled_m) / volume_eroded_m;
            }
            if (timeseries.timeseries_total_average_alt_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[8]] = total_average_altitude_m;
            }
            if (timeseries.timeseries_total_dep_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[9]] = volume_deposited_m + sediment_delta_m + sediment_filled_m;
            }
            if (timeseries.timeseries_total_ero_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[10]] = -volume_eroded_m;
            }
            if (timeseries.timeseries_total_evap_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[11]] = total_evap_m3;
            }
            if (timeseries.timeseries_total_infil_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[12]] = total_infil_m3;
            }
            if (timeseries.timeseries_total_outflow_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[13]] = total_outflow_m3;
            }
            if (timeseries.timeseries_total_rain_check.Checked)
            {
                timeseries_matrix[t, timeseries_order[14]] = total_rain_m3;
            }
            if (timeseries.timeseries_outflow_cells_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[15]] = number_of_outflow_cells;
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[16]] = domain_sed_export_kg[0];
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[17]] = domain_sed_export_kg[1];
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[18]] = domain_sed_export_kg[2];
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[19]] = domain_sed_export_kg[3];
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[20]] = domain_sed_export_kg[4];
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[21]] = domain_YOM_export_kg;
            }
            if (timeseries.timeseries_sedexport_checkbox.Checked)
            {
                timeseries_matrix[t, timeseries_order[22]] = domain_OOM_export_kg;
            }
        }

        void ini_slope()   //Initialise LS parameters   
        {
            // the soil physical / hydrological / slope stability parameters:
            //	 Transmissivity, Bulk Density,              
            //   Combined Cohesion and Internal riction.
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    //currently spatially uniform
                    T_fac[row, col] = System.Convert.ToDouble(textBox_ls_trans.Text);
                    C_fac[row, col] = System.Convert.ToDouble(textBox_ls_coh.Text);
                    bulkd[row, col] = System.Convert.ToDouble(textBox_ls_bd.Text);
                    intfr[row, col] = System.Convert.ToDouble(textBox_ls_ifr.Text);

                    // below, the old parameter values for New Zealand (spatially different) are kept
                    /*if (soilmap[row, col] == -9999)
                    { //
                        soilmap[row, col] = 0;
                    }
                    T_fac[row, col] = 15 * T_act; C_fac[row, col] = 0.2 * C_act; Cs_fac[row, col] = 10; // Defaults  15;0.2;10.0;1.8;0.7
                    bulkd[row, col] = 1.8 * bulkd_act; intfr[row, col] = 0.7 * intfr_act;
                    /*if (soilmap[row,col]==1) {  // Lone Kauri 15;0.43;12.223;1.455;0.688
                        T_fac[row,col]=a_T*T_act; C_fac[row,col]=a_coh*C_act;
                        bulkd[row,col]=a_bd*bulkd_act; intfr[row,col]=a_ifr*intfr_act;
                     }
                    if (soilmap[row,col]==2) {  // Piha       18;0.21;5.976;1.447;0.678
                        T_fac[row,col]=b_T*T_act; C_fac[row,col]=b_coh*C_act;
                        bulkd[row,col]=b_bd*bulkd_act; intfr[row,col]=b_ifr*intfr_act;
                     }
                    if (soilmap[row,col]==3) {  // Nihotupu   11;0.25;13.352;1.436;0.548
                        T_fac[row,col]=c_T*T_act; C_fac[row,col]=c_coh*C_act;
                        bulkd[row,col]=c_bd*bulkd_act; intfr[row,col]=c_ifr*intfr_act;
                     }
                     if (soilmap[row,col]==4) {  //
                        T_fac[row,col]=d_T*T_act; C_fac[row,col]=d_coh*C_act;
                        bulkd[row,col]=d_bd*bulkd_act; intfr[row,col]=d_ifr*intfr_act;
                     }
                     if (soilmap[row,col]==5) {  //
                        T_fac[row,col]=e_T*T_act; C_fac[row,col]=e_coh*C_act;
                        bulkd[row,col]=e_bd*bulkd_act; intfr[row,col]=e_ifr*intfr_act;
                     }   */
                } //for
            } //for
        }

        void calculate_critical_rain()    //Calculates Critical Steady State Rainfall for Landsliding    
        {
            // from steepest local slope, contributing area and stability parameters
            // start calculation number of contributing draining cells by multiple flow algorithm
            /*
            Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "critical rainfall calculation";
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            */
            double beta;
            //set all start q values effective precipitation at time t
            nb_ok = 0; nb_check = 0; all_grids = 0;
            maximum_allowed_deposition = -9999; dh_tol = 0.00025;
            for (int row = 0; row < nr; row++)
            {
                for (int col = 0; col < nc; col++)
                {
                    camf[row, col] = 1;    // contributing area multiple flow matrix = 1
                    stslope[row, col] = 0;
                    crrain[row, col] = 0;
                }
            }

            int runner;
            for (runner = number_of_data_cells - 1; runner >= 0; runner--)
            {           // the index is sorted from low to high values, but flow goes from high to low
                row = row_index[runner]; col = col_index[runner];
                // into loop for surounding grids of certain grid
                // Start first the slope_sum loop for all lower neighbour grids
                powered_slope_sum = 0; max_allowed_erosion = 0; dz_min = -9999.99;
                direct = 20; dz_max = -1; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);

                // Repeat the loop to determine flow if all draining neighbours are known
                // but do this only once
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) &&   // boundaries
                             ((col + j) >= 0) && ((col + j) < nc) &&
                       !((i == 0) && (j == 0)))
                        {
                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                            if (dh < 000000)
                            {// i j is a higher neighbour
                                if (dh > dz_min) { dz_min = dh; }
                                if ((dh < 000000))
                                {// i j is a higher neighbour
                                    if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                                }
                            }
                            if (dh > 000000)
                            {// i j is a lower neighbour
                                if ((dh > 000000))
                                {
                                    if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                                }
                                dh = dh / d_x;
                                if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                dh = Math.Pow(dh, conv_fac);
                                powered_slope_sum = powered_slope_sum + dh;
                            }//end if
                        }//end if
                    }//end for
                }//end for
                if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = -maximum_allowed_deposition; }
                if (max_allowed_erosion == 0.0) { max_allowed_erosion = -dh_tol; } else { max_allowed_erosion = -max_allowed_erosion; }
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        dh = 000000; fraction = 0;
                        frac_dis = 0;
                        d_x = dx;
                        if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                        {
                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                            // Multiple Flow: If there are lower neighbours start evaluating
                            if (dh > 000000)
                            { // multiple flow
                              // fraction of discharge into a neighbour grid
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                Slope = dh / d_x;
                                dh = dh / d_x;
                                dh = Math.Pow(dh, conv_fac);
                                fraction = (dh / powered_slope_sum); // multiple fow
                                frac_dis = (camf[row, col] * fraction);
                                camf[row + i, col + j] += frac_dis;
                            }//end if
                        }//end if boarders
                    }//end for j
                }//end for i
            }   // end for

            // Calculation of steepest descent local slope, 8 cell window
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    direct = 20; dz_max = -1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 000000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                if (dh > 000000)
                                {// i j is a lower neighbour
                                    dh = dh / d_x;
                                    if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                }//end if
                            }//end if
                        }//end for
                    }//end for
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 000000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                if ((i * 3 + 5 + j) == direct)
                                { // steepest descent
                                    stslope[row, col] = Math.Atan(dh / d_x);
                                    // Calculation of CRITICAL RAINFALL value = relative landslide hazard, along steepest descent local slope
                                    beta = (T_fac[row, col] * (Math.Sin(stslope[row, col])) * (dx / (camf[row, col] * dx * dx)) * bulkd[row, col] * (1 - ((Math.Sin(stslope[row, col]) - C_fac[row, col]) / ((Math.Tan(intfr[row, col]) * Math.Cos(stslope[row, col])))))); // 'valid' critical rainfall value
                                    if (Math.Tan(stslope[row, col]) > (Math.Tan(intfr[row, col]) + (C_fac[row, col] / Math.Cos(stslope[row, col])))) { beta = -99; } //unconditionally unstable
                                    if (((bulkd[row, col] * Math.Sin(stslope[row, col])) + ((1 - bulkd[row, col]) * Math.Cos(stslope[row, col]) * Math.Tan(intfr[row, col]))) <= ((bulkd[row, col]) * (C_fac[row, col]))) { beta = 99; } // unconditionally stable
                                    crrain[row, col] = (beta);
                                    //Debug.WriteLine( "critical rain for " + row + " " + col + " " + crrain[row,col] + " T_fac " + T_fac[row, col] + " stslope_sin " + Math.Sin(stslope[row, col]) + " upstream " + camf[row,col] + "\n bulkd " + bulkd[row, col] + " C_fac " + C_fac[row, col] + " intfr " + Math.Tan(intfr[row, col]) + " stslope_cos " + Math.Cos(stslope[row, col]) );
                                }
                            }//end if
                        }//end for
                    }//end for
                } // end for
            } // end for 
            out_double("critrain.asc", crrain);
        }

        void steepdesc(int rowst, int colst)
        {
            int trow;
            int tcol;
            trow = rowst;
            tcol = colst;
            xrow = 0; xcol = 0;
            powered_slope_sum = 0;
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                    if (((trow + i) >= 0) && ((trow + i) < nr) &&   // boundaries
                        ((tcol + j) >= 0) && ((tcol + j) < nc) &&
                        !((i == 0) && (j == 0)))
                    {
                        dh = (dtm[trow, tcol] - dtm[trow + i, tcol + j]);
                        if ((trow != trow + i) && (tcol != tcol + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                        if (dh < 000000)
                        {// i j is a higher neighbour
                            if (dh > dz_min) { dz_min = dh; }
                            if ((dh < 000000))
                            {// i j is a higher neighbour
                                if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                            }
                        }
                        if (dh > 000000)
                        {// i j is a lower neighbour
                            if ((dh > 000000))
                            {
                                if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                            }
                            dh = dh / d_x;
                            if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                            dh = Math.Pow(dh, conv_fac);
                            powered_slope_sum = powered_slope_sum + dh;
                        }//end if
                    }//end if
                }//end for
            }//end for
            if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0; } else { maximum_allowed_deposition = (maximum_allowed_deposition * (-1)); }
            if (max_allowed_erosion == 0) { max_allowed_erosion = dh_tol * -1; } else { max_allowed_erosion = (max_allowed_erosion * (-1)); }
            for (i = (-1); i <= 1; i++)
            {
                for (j = (-1); j <= 1; j++)
                {
                    dh = 000000; fraction = 0;
                    frac_dis = 0;
                    if (((trow + i) >= 0) && ((trow + i) < nr) &&   // boundaries
                           ((tcol + j) >= 0) && ((tcol + j) < nc) &&
                          !((i == 0) && (j == 0)))
                    {
                        dh = (dtm[trow, tcol] - dtm[trow + i, tcol + j]);
                        // Steepest descent only one neighbour
                        if ((i * 3 + 5 + j) == direct)
                        { //steepest descent
                            xrow = trow + i;
                            xcol = tcol + j;
                        }//end if
                    }//end if borders
                }//end for j
            }//end for i
        }

        void calculate_slide()
        {
            try
            {
                Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = "landslide calculation";
                }, CancellationToken.None, TaskCreationOptions.None, guiThread);
                int tell;
                //set all start q values effective precipitation at time t
                nb_ok = 0; nb_check = 0; all_grids = 0.0;
                maximum_allowed_deposition = -9999.0; dh_tol = 0.00025; erotot = 0.0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        slidemap[row, col] -= 1;  // terug opbouwen van 'landslide potential' bij meerdere tijdstappen
                        if (slidemap[row, col] < 0) { slidemap[row, col] = 0; }
                        ero_slid[row, col] = 0.0;
                        sed_slid[row, col] = 0.0;
                        cel_dist[row, col] = 0.0;
                        dh_slid[row, col] = 0.0;
                        sed_bud[row, col] = 0.0;
                    }
                }

                // into while loop for all grids if not all neighbours are processed
                int runner;
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];

                    // into loop for surrounding grids of certain grid
                    // Start first the slope_sum loop for all lower neighbour grids
                    powered_slope_sum = 0.0; max_allowed_erosion = 0.0; dz_min = -9999.99; d_x = dx;
                    direct = 20; dz_max = -1.0; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);
                    // Repeat the loop to determine if all neigbours are processed
                    nb_ok = 1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 0.000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                            }//end if
                        }//end for
                    }//end for
                     // Repeat the loop to determine flow if all draining neighbours are known
                     // but do this only once
                     // First loop to process slide erosion with a slope limit and steepest descent

                    slide_tot = 0.0;
                    dh_tot = 0.0;
                    steepdesc(row, col);
                    dh = (dtm[row, col] - dtm[xrow, xcol]);
                    if ((row != xrow) && (col != xcol)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                    Slope = dh / d_x;
                    if ((Slope > 0.176327) && (slidemap[row, col] < 1))
                    { // FACTOR 1 and not slided yet
                        if (watsh[row, col] == 1)
                        {
                            if ((crrain[row, col] > 0.0) && (crrain[row, col] < 0.02))
                            { // FACTOR 4 RELATIVE RISK FOR 'GOING' SET AT 0.02 m/d !!! = SCENARIO
                                if (ero_slid[row, col] > -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]))
                                { // FACTOR 1 maximal erosion applied if more than one slide
                                    ero_slid[row, col] = -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                    slide_tot += -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                    dh_tot += dh;
                                    //getch();
                                }
                                while (Slope > 0.176327)
                                {   // FACTOR 1
                                    xxrow = xrow; xxcol = xcol;
                                    steepdesc(xrow, xcol);
                                    dh = (dtm[xxrow, xxcol] - dtm[xrow, xcol]);
                                    if ((xxrow != xrow) && (xxcol != xcol)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    Slope = dh / d_x;
                                    if (Slope > 0.176327)
                                    {// FACTOR 1 slide keeps eroding if > 10 degrees steepest descent is encountered
                                        if ((ero_slid[xxrow, xxcol] == 0.0) && (slidemap[row, col] < 1))
                                        { // has not been processed (eroded) earlier
                                            ero_slid[xxrow, xxcol] = -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); //FACTOR 1
                                            slide_tot += -((bulkd[row, col] * 9.81 * Math.Cos(Slope) * (Math.Tan(Slope) - Math.Tan(0.176327))) / Cs_fac[row, col]); // FACTOR 1
                                            dh_tot += dh;
                                        }
                                    }
                                    else { Slope = 0.0; sed_bud[xxrow, xxcol] += (slide_tot * -1.0); dh_slid[xxrow, xxcol] += (dh_tot); erotot += slide_tot; }
                                }//end while
                            }//end if
                        }
                    }

                }       // end for all sorted cells
                        //2 Second while loop to process slide deposition with a 'cell distance' and 'double' multiple flow
                nb_ok = 0; nb_check = 0; all_grids = 0.0; tell = 0;
                maximum_allowed_deposition = -9999.0; dh_tol = 0.00025; sedtot = 0.0; strsed = 0.0; startsed = 0.0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        cel_dist[row, col] = ((0.4 * dh_slid[row, col]) / dx); // FACTOR 2 calculate 'celdistance', empirical fraction of runout set at 0.4 (Lit.)
                        startsed += sed_bud[row, col]; // 'startsed'-counter = only to display initial sediment budget in ero-sed balance in model run
                    }
                }
                //2 into while loop for all grids if not all neighbours are processed
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    //2 into loop for surounding grids of certain grid
                    //2 Start first the slope_sum loop for all lower neighbour grids
                    powered_slope_sum = 0.0; max_allowed_erosion = 0.0; dz_min = -9999.99; d_x = dx;
                    direct = 20; dz_max = -1.0; dhtemp = -99999.99; maximum_allowed_deposition = (-9999.99);
                    nb_ok = 1;
                    for (i = (-1); i <= 1; i++)
                    {
                        for (j = (-1); j <= 1; j++)
                        {
                            dh = 0.000;
                            if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                            {
                                dh = (dtm[row, col] - dtm[row + i, col + j]);
                            }//end if
                        }//end for
                    }//end for
                     //2 Repeat the loop to determine flow if all draining neighbours are known
                     //2 but do this only once
                    if ((sed_bud[row, col] > 0.0) && (cel_dist[row, col] > 0.0))
                    {
                        if (sed_bud[row, col] < 0.00001) tell++;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0.000000; dh1 = 0.000; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) &&   // boundaries
                                     ((col + j) >= 0) && ((col + j) < nc) &&
                            !((i == 0) && (j == 0)))
                                {
                                    dh = (dtm[row, col] - dtm[row + i, col + j]);
                                    if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                    if (dh < 0.000000)
                                    {// i j is a higher neighbour
                                        if (dh > dz_min) { dz_min = dh; }
                                        if ((dh < 0.000000))
                                        {// i j is a higher neighbour
                                            if (dh1 > maximum_allowed_deposition) { maximum_allowed_deposition = (dh1); }
                                        }
                                    }
                                    if (dh > 0.000000)
                                    {// i j is a lower neighbour
                                        if ((dh > 0.000000))
                                        {
                                            if (dh1 > max_allowed_erosion - dh_tol) { max_allowed_erosion = (dh1 - dh_tol); }
                                        }
                                        dh = dh / d_x;
                                        if (dh > dz_max) { dz_max = dh; direct = (i * 3 + 5 + j); }
                                        dh = Math.Pow(dh, conv_fac);
                                        powered_slope_sum = powered_slope_sum + dh;
                                    }//end if
                                }//end if
                            }//end for
                        }//end for
                        if (maximum_allowed_deposition == -9999.99) { maximum_allowed_deposition = 0.0; } else { maximum_allowed_deposition = (maximum_allowed_deposition * (-1.0)); }
                        if (max_allowed_erosion == 0.0) { max_allowed_erosion = dh_tol * -1.0; } else { max_allowed_erosion = (max_allowed_erosion * (-1.0)); }
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0.000000; fraction = 0.0;
                                frac_dis = 0.0; frac_bud = 0.0;
                                d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {
                                    dh = (dtm[row, col] - dtm[row + i, col + j]);
                                    //Multiple Flow: If there are lower neighbours start evaluating
                                    if (dh > 0.000000)
                                    {// && (cel_dist[row,col]>0.0)) { // multiple flow, 'celdistance'
                                     // fraction of discharge into a neighbour grid
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        Slope = dh / d_x;
                                        dh = dh / d_x;
                                        dh = Math.Pow(dh, conv_fac);
                                        fraction = (dh / powered_slope_sum); // multiple fow

                                        if (cel_dist[row, col] <= 1.0)
                                        {
                                            frac_bud = (sed_bud[row, col] * fraction);
                                        }
                                        else
                                        {
                                            frac_bud = ((sed_bud[row, col] / cel_dist[row, col]) * fraction);
                                        }
                                        sed_bud[row + i, col + j] += ((sed_bud[row, col] * fraction) - frac_bud);
                                        sed_slid[row, col] += frac_bud;
                                        sedtot += frac_bud;
                                        if ((cel_dist[row, col] - 1.0) > 0.0)
                                        {
                                            if ((sed_bud[row + i, col + j] > 0.0) && (cel_dist[row + i, col + j] < (cel_dist[row, col] - 1.0)))
                                            {
                                                cel_dist[row + i, col + j] = (cel_dist[row, col] - 1.0);
                                            }
                                            else { cel_dist[row + i, col + j] += 0.0; }
                                        }
                                        else { cel_dist[row + i, col + j] += 0.0; }
                                        if ((camf[row, col] >= 500.0) && (sed_slid[row, col] > 0.0))
                                        { // FACTOR 3
                                            strsed += sed_slid[row, col];
                                        }
                                    }//end if
                                }//end borders
                            }//end for j
                        }//end for i
                    }//2 end if sed_bud
                } //2 end for all cells 2

                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (ero_slid[row, col] < 0.0)
                        {
                            slidemap[row, col] = 4;//potentieel terug opbouwen in # tijdstappen..., sediment kan eventueel al direct terug 'aan' gezet worden, zie hierboven **
                        }
                    }
                }
                Debug.WriteLine("Balance ero: %8.4f sed: %8.4f start:%8.4f strsed:%8.4f", erotot, sedtot, startsed, strsed);
            }
            catch
            {
                Debug.WriteLine("err_sli1");
            }

        } // end calc_slide()   

        private void calculate_tillage()
        {
            double CN_before = 0, CN_after = 0;
            //if (CN_checkbox.Checked) { CN_before = total_CNs(); }

            try
            {
                double mass_before = total_catchment_mass();
                /*Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = "tillage calculation";
                }, CancellationToken.None, TaskCreationOptions.None, guiThread); */
                int row, col, i, j;
                double slope_sum, dz_min, d_x, dz_max, dh, fraction, temptill, tempdep, slope;

                nb_ok = 0; nb_check = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        till_result[row, col] = 0;
                        // if (dtm[row, col] < -9900 && dtm[row, col] != -9999) { Debug.WriteLine(" Cell " + row + " " + col + " has altitude " + dtm[row, col] + " till " + till_result[row, col]); }
                    }
                }

                int runner = 0;
                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    //  Debug.WriteLine("till1");

                    if (tillfields[row, col] == 1)
                    {
                        if (check_negative_weight(row, col) == true) { MessageBox.Show("negative weight in t " + t + ", row " + row + ", col " + col + ", step 1"); }

                        // 1. Mixing of the topsoil. 
                        double mixeddepth = 0, completelayerdepth = 0, newdepth = 0;
                        int completelayers = -1;

                        while (mixeddepth <= plough_depth & completelayers <(max_soil_layers-1))
                        {
                            completelayers++;
                            mixeddepth += layerthickness_m[row, col, completelayers];
                            // OSL_age[row, col, completelayers] = 0;

                        }// this will lead to incorporation of the (partial) layer below tillage horizon in completelayers parameter. So the highest number indicates the partial layer 
                         // Debug.WriteLine("till2");
                        double[] tilled_text = new double[5]; // includes soil 
                        double[] tilled_om = new double[2]; // includes OM
                        double[] alldepths = new double[completelayers + 1]; // contains thicknesses of all layers
                        double[] tilled_mass = new double[completelayers + 1];
                        double[] fraction_mixed = new double[completelayers + 1];
                        double[] tilled_cosmo_nuclides = new double[n_cosmo]; // includes cosmogenic nuclides

                        // take material from layers to mix
                        double mass_soil_before = total_soil_mass_kg(row, col);
                        double fraction_mixed_layer;
                        for (int lay = 0; lay <= completelayers; lay++) // Includes partial layer, will be selective taken up
                        {
                            if ((completelayerdepth + layerthickness_m[row, col, lay]) < plough_depth)
                            {
                                fraction_mixed_layer = 1;
                                fraction_mixed[lay] = 1;
                                alldepths[lay] = layerthickness_m[row, col, lay];
                            }
                            else
                            {
                                fraction_mixed_layer = (plough_depth - completelayerdepth) / layerthickness_m[row, col, lay];
                                fraction_mixed[lay] = fraction_mixed_layer; // fraction of layer that is mixed
                                alldepths[lay] = layerthickness_m[row, col, lay] * fraction_mixed_layer; // part of layer [m] that is considered
                            }
                            completelayerdepth += layerthickness_m[row, col, lay];
                            for (int tex = 0; tex < 5; tex++)
                            {
                                tilled_text[tex] += texture_kg[row, col, lay, tex] * fraction_mixed_layer;
                                tilled_mass[lay] += texture_kg[row, col, lay, tex] * fraction_mixed_layer;
                                texture_kg[row, col, lay, tex] *= (1 - fraction_mixed_layer);

                            }
                            tilled_om[0] += old_SOM_kg[row, col, lay] * fraction_mixed_layer;
                            tilled_om[1] += young_SOM_kg[row, col, lay] * fraction_mixed_layer;
                            tilled_mass[lay] += (old_SOM_kg[row, col, lay] * fraction_mixed_layer + young_SOM_kg[row, col, lay] * fraction_mixed_layer);
                            old_SOM_kg[row, col, lay] *= (1 - fraction_mixed_layer);
                            young_SOM_kg[row, col, lay] *= (1 - fraction_mixed_layer);
                            if (CN_checkbox.Checked)
                            {
                                for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                {
                                    double transport = CN_atoms_cm2[row, col, lay, cosmo] * fraction_mixed_layer;
                                    tilled_cosmo_nuclides[cosmo] += transport;
                                    CN_atoms_cm2[row, col, lay, cosmo] -= transport;
                                }
                            }
                        }
                        // Give material back to layers, based on their given mass to mixture and total mixed mass
                        for (int lay = 0; lay <= completelayers; lay++)
                        {

                            for (int tex = 0; tex < 5; tex++)
                            {
                                texture_kg[row, col, lay, tex] += tilled_text[tex] * tilled_mass[lay] / tilled_mass.Sum();

                            }
                            old_SOM_kg[row, col, lay] += tilled_om[0] * tilled_mass[lay] / tilled_mass.Sum();
                            young_SOM_kg[row, col, lay] += tilled_om[1] * tilled_mass[lay] / tilled_mass.Sum();

                            if (CN_checkbox.Checked)
                            {
                                for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                {
                                    CN_atoms_cm2[row, col, lay, cosmo] += tilled_cosmo_nuclides[cosmo] * tilled_mass[lay] / tilled_mass.Sum();
                                }
                            }

                            layerthickness_m[row, col, lay] = thickness_calc(row, col, lay);
                            layerthickness_m[row, col, lay] = thickness_calc(row, col, lay);
                            newdepth += layerthickness_m[row, col, lay];
                        }
                        // MvdM Develop: link mixing of OSL grains to sand or silt fraction, or is that not necessary in this case of complete mixing?
                        if (OSL_checkbox.Checked) // Mix grains from the top layers
                        {
                            int totalgrains_start = 0;
                            for (int lay = 0; lay < max_soil_layers; lay++) { totalgrains_start += OSL_grainages[row, col, lay].Length; }
                            int[] grains_from_layer = new int[alldepths.Length]; // number of donor grains from each layer
                            var mixedgrains = new List<Int32>();
                            var mixedgrains_da = new List<Int32>(); // for deposition ages
                            var mixedgrains_su = new List<Int32>(); // for surfaced count

                            // add grains from complete and partial layers
                            for (int lay = 0; lay <= completelayers; lay++)
                            {
                                var grains_staying_behind = new List<Int32>();
                                var grains_staying_behind_da = new List<Int32>();
                                var grains_staying_behind_su = new List<Int32>();
                                int P_mixing = Convert.ToInt32(Math.Round(10000 * fraction_mixed[lay]));
                                if(OSL_grainages[row, col, lay].Length>0)
                                {
                                    for (int ind = 0; ind < OSL_grainages[row, col, lay].Length; ind++)
                                    {
                                        if ((randOslLayerMixing.Next(0, 10000) < P_mixing ? 1 : 0) == 1)
                                        {
                                            mixedgrains.Add(OSL_grainages[row, col, lay][ind]);
                                            mixedgrains_da.Add(OSL_depositionages[row, col, lay][ind]);
                                            mixedgrains_su.Add(OSL_surfacedcount[row, col, lay][ind]);
                                            grains_from_layer[lay] += 1;
                                        }
                                        else
                                        {
                                            grains_staying_behind.Add(OSL_grainages[row, col, lay][ind]);
                                            grains_staying_behind_da.Add(OSL_depositionages[row, col, lay][ind]);
                                            grains_staying_behind_su.Add(OSL_surfacedcount[row, col, lay][ind]);
                                        }
                                    }
                                }
                                OSL_grainages[row, col, lay] = grains_staying_behind.ToArray(); // Preserve the grains that stay behind
                                OSL_depositionages[row, col, lay] = grains_staying_behind_da.ToArray(); // 
                                OSL_surfacedcount[row, col, lay] = grains_staying_behind_su.ToArray(); // 
                            }

                            // Shuffle the array
                            // make indices based on list lengths
                            int[] indices = new int[mixedgrains.ToArray().Length];
                            for (int ii = 0; ii < indices.Length; ii++) { indices[ii] = ii; }
                            indices = indices.OrderBy(x => randOslLayerMixing.Next()).ToArray();
                            int[] indices_da = new int[indices.Length];
                            int[] indices_su = new int[indices.Length];
                            for (int ii = 0; ii < indices.Length; ii++) { indices_da[ii] = indices[ii]; indices_su[ii] = indices[ii]; }

                            int[] ages_array = mixedgrains.ToArray();
                            Array.Sort(indices, ages_array);
                            mixedgrains = ages_array.ToList();

                            ages_array = mixedgrains_da.ToArray();
                            Array.Sort(indices_da, ages_array);
                            mixedgrains_da = ages_array.ToList();

                            ages_array = mixedgrains_su.ToArray();
                            Array.Sort(indices_su, ages_array);
                            mixedgrains_su = ages_array.ToList();

                            // add back random grains from grain pool
                            int count = 0;
                            for (int lay = 0; lay <= completelayers; lay++)// add grains to complete layers
                            {
                                var newgrains = new List<Int32>();
                                newgrains = mixedgrains.GetRange(count, grains_from_layer[lay]);
                                newgrains.AddRange(OSL_grainages[row, col, lay]);
                                OSL_grainages[row, col, lay] = newgrains.ToArray();
                                newgrains = mixedgrains_da.GetRange(count, grains_from_layer[lay]);
                                newgrains.AddRange(OSL_depositionages[row, col, lay]);
                                OSL_depositionages[row, col, lay] = newgrains.ToArray();

                                newgrains = mixedgrains_su.GetRange(count, grains_from_layer[lay]);
                                newgrains.AddRange(OSL_surfacedcount[row, col, lay]);
                                OSL_surfacedcount[row, col, lay] = newgrains.ToArray();
                                count += grains_from_layer[lay];
                            }
                            int totalgrains_end = 0;
                            for (int lay = 0; lay < max_soil_layers; lay++) { totalgrains_end += OSL_grainages[row, col, lay].Length; }
                            if (totalgrains_start != totalgrains_end) { Debugger.Break(); }
                        }

                        double mass_soil_after = total_soil_mass_kg(row, col);
                        if (Math.Abs(mass_soil_before - mass_soil_after) > 0.0001)
                        {
                            Debug.WriteLine("err_ti2");
                        }
                        // Debug.WriteLine("till5");
                        // 2. Calculate redistribution of material
                        // 2.a First calculate slope_sum for multiple flow, and remember how much lower the !currently! lowest lower neighbour is
                        slope_sum = 0; d_x = dx; dhtemp = -99999.99; nb_ok = 1; dz_max = 0; dz_min = -9999;
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {    // boundaries
                                    if (dtm[row + i, col + j] != -9999)
                                    {
                                        dh = (dtm[row, col] + till_result[row, col] - dtm[row + i, col + j] + till_result[row + i, col + j]);
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        if (dh > 0)
                                        {           // i j is a lower neighbour
                                            if (dh > dz_max) { dz_max = dh; }
                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            slope_sum = slope_sum + dh;
                                        }//end if
                                    }//end if novalues
                                }// end if boundaries
                            }//end for
                        }//end for

                        // 2.b knowing slope_sum, we can now calculate which fraction of the tilled amount goes where, and how much that is. 
                        // knowing the lowest lower neighbour of row,col lets us limit the tillage-erosion to avoid row,col becoming lower 
                        // than its lowest lower neighbour (avoiding sinks).
                        // we are also going to limit the tilled amount to avoid row+i, col+j becoming higher than its own lowest higher nb.
                        // that avoids sinks as well.
                        // Debug.WriteLine("till6");
                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 0; fraction = 0.0;
                                frac_dis = 0.0;
                                d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                                {
                                    if ((dtm)[row + i, col + j] != (-9999))
                                    {
                                        dh = (dtm[row, col] + till_result[row, col] - dtm[row + i, col + j] + till_result[row + i, col + j]);
                                        if (dh > 0.000000) // i j is a lower neighbour to which we would like to till a certain amount.
                                        {
                                            // Calculate fraction of discharge into this cell
                                            if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                            slope = dh / d_x;
                                            dh = dh / d_x;
                                            dh = Math.Pow(dh, conv_fac);
                                            fraction = (dh / slope_sum);
                                            // Tillage erosion calculation
                                            temptill = fraction * (tilc * slope * plough_depth) * dt;    // temptill is what we would like to till from r,c to r+i,c+j
                                                                                                         // Tillage erosion correction through calculating maximum tillage: tempdep
                                            tempdep = soildepth_m[row, col];
                                            //if there is more soil than the difference between the donor cell and its lowest lower nb, limit tillage to that difference.
                                            if (tempdep > dz_max) { tempdep = dz_max; }
                                            //if there is not enough space in the receiver cell because its currently lowest higher neighbour is not high enough, 
                                            //then limit tillage to that amount. First, calculate the current altitude difference with the lowest higher neighbour of r+i,c+j 
                                            dz_min = 9999;
                                            for (alpha = (-1); alpha <= 1; alpha++)
                                            {
                                                for (beta = (-1); beta <= 1; beta++)
                                                {
                                                    if (((row + i + alpha) >= 0) && ((row + i + alpha) < nr) && ((col + j + beta) >= 0) && ((col + j + beta) < nc) && !((alpha == 0) && (beta == 0))) // boundaries
                                                    {
                                                        if (dtm[row + i + alpha, col + j + beta] != -9999)
                                                        {
                                                            if (dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] > (dtm[row + i, col + j] + till_result[row + i, col + j]))
                                                            { // we are looking at a higher neighbour of the receiver cell
                                                                if (dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] - dtm[row + i, col + j] + till_result[row + i, col + j] < dz_min)
                                                                {
                                                                    dz_min = dtm[row + i + alpha, col + j + beta] + till_result[row + i + alpha, col + j + beta] - dtm[row + i, col + j] + till_result[row + i, col + j];
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            // knowing the maximum tillage that the receiver cell can receive without blocking its own higher nbs, we limit the maximum tillage to that amount
                                            if (tempdep > dz_min) { tempdep = dz_min; }
                                            if (dz_min == 9999) { tempdep = 0.0; }     // if the receiver cell does not have higher nbs, we cannot till at all.
                                            if (tempdep < 0.0) tempdep = 0.0;
                                            if (tempdep > epsilon) { tempdep -= epsilon; }  // finally, always till just a bit less than the max allowed to prevent flat areas
                                            if (temptill > tempdep) { temptill = tempdep; } // if we want to till more than the maximum possible, we only till the maximum possible.
                                                                                            // update the corresponding grids 

                                            till_result[row, col] -= temptill;
                                            till_result[row + i, col + j] += temptill;
                                            //soildepth_m[row, col] -= temptill;
                                            //soildepth_m[row + i, col + j] += temptill;
                                            //if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                            //if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }

                                            if (check_negative_weight(row, col) == true) { MessageBox.Show("negative weight in t " + t + ", row " + row + ", col " + col + ", step 2"); }

                                            //double dz_till_m = temptill;
                                            // Debug.WriteLine("till7");

                                            // 2.c update soil properties which are tilled
                                            // top layers are mixed, so it doesn't matter where eroded material comes from.
                                            // problems can arise when eroded depth is larger than plough depth. 
                                            // DEVELOP MvdM: development needed for layers with varying bulk density, in the case this occurs in an Ap horizon
                                            double mass_partial_layer, frac_eroded, total_mass_start, total_mass_end;

                                            //total_mass_start = total_soil_mass(row, col);
                                            int layero = 0;
                                            double temptill0 = temptill;

                                            while (temptill >= layerthickness_m[row, col, layero] | layero >= max_soil_layers) // hele laag wordt verwijderd, al het materiaal naar de volgende cel
                                            {
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    texture_kg[row + i, col + j, 0, tex] += texture_kg[row, col, layero, tex];
                                                    texture_kg[row, col, layero, tex] = 0;
                                                }

                                                young_SOM_kg[row + i, col + j, 0] += young_SOM_kg[row, col, layero];
                                                young_SOM_kg[row, col, layero] = 0;
                                                old_SOM_kg[row + i, col + j, 0] += old_SOM_kg[row, col, layero];
                                                old_SOM_kg[row, col, layero] = 0;

                                                temptill -= layerthickness_m[row, col, layero];

                                                if (CN_checkbox.Checked) // complete transfer of cosmogenic nuclides
                                                {
                                                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                                    {
                                                        CN_atoms_cm2[row + i, col + j, layero, cosmo] += CN_atoms_cm2[row, col, layero, cosmo];
                                                        CN_atoms_cm2[row, col, layero, cosmo] = 0;
                                                    }
                                                }

                                                if (OSL_checkbox.Checked)
                                                {
                                                    transfer_OSL_grains(row, col, layero, row + i, col + j, 0, 1, 0, true); // transfer all grains
                                                }

                                                // layerthickness_m[row, col, layero] = 0;
                                                layero++;
                                            }
                                            // Debug.WriteLine("till8");

                                            // transport eroded fraction
                                            frac_eroded = temptill / layerthickness_m[row, col, layero];
                                            // mass fraction eroded
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                texture_kg[row + i, col + j, 0, tex] += texture_kg[row, col, layero, tex] * frac_eroded;
                                                texture_kg[row, col, layero, tex] -= texture_kg[row, col, layero, tex] * frac_eroded;
                                            }
                                            young_SOM_kg[row + i, col + j, 0] += young_SOM_kg[row, col, layero] * frac_eroded;
                                            young_SOM_kg[row, col, layero] -= young_SOM_kg[row, col, layero] * frac_eroded;
                                            old_SOM_kg[row + i, col + j, 0] += old_SOM_kg[row, col, layero] * frac_eroded;
                                            old_SOM_kg[row, col, layero] -= old_SOM_kg[row, col, layero] * frac_eroded;

                                            if (CN_checkbox.Checked) // every texture is transported with the same fraction, so there is no need to couple the nuclide stocks to different texture fractions
                                            {
                                                for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                                {
                                                    CN_atoms_cm2[row + i, col + j, layero, cosmo] += CN_atoms_cm2[row, col, layero, cosmo] * frac_eroded;
                                                    CN_atoms_cm2[row, col, layero, cosmo] -= CN_atoms_cm2[row, col, layero, cosmo] * frac_eroded;
                                                }
                                            }

                                            if (OSL_checkbox.Checked)
                                            {
                                                transfer_OSL_grains(row, col, layero, row + i, col + j, 0, frac_eroded, 0, true);
                                            }

                                            layerthickness_m[row, col, layero] = thickness_calc(row, col, layero);
                                            layerthickness_m[row + i, col + j, 0] = thickness_calc(row, col, layero);

                                            //if necessary, i.e. an entire layer removed, shift cells up
                                            if (layero > 0)
                                            {
                                                try { remove_empty_layers(row, col); update_all_layer_thicknesses(row, col); }
                                                catch { Debug.WriteLine("Error in removing empty layers after tillage"); }
                                            }
                                        }//end if
                                    }//end if novalues
                                }//end if borders
                            }//end for j
                        }//end for i
                    } //end if tillfields
                }   // end  for 
                    // Debug.WriteLine("till9");
                    // 3. Update elevation changes
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double old_soil_thickness = soildepth_m[row, col];
                            update_all_layer_thicknesses(row, col);
                            double new_soil_thickness = total_soil_thickness(row, col);

                            dtm[row, col] += new_soil_thickness - old_soil_thickness;
                            dtmchange_m[row, col] += new_soil_thickness - old_soil_thickness;
                            sum_tillage[row, col] += new_soil_thickness - old_soil_thickness;
                            soildepth_m[row, col] = new_soil_thickness;
                            if (till_result[row, col] > 0) { total_sum_tillage += new_soil_thickness - old_soil_thickness; }
                        }
                    }
                }

                // Debug.WriteLine("\n--tillage overview--");
                // Debug.WriteLine(" tilled a total of " + total_sum_tillage * dx * dx / 1000 + " * 1000 m3");
                double mass_after = total_catchment_mass();
                if (Math.Abs(mass_before - mass_after) > 0.0001)
                {
                    Debug.WriteLine("err_ti3");
                }

                //if (CN_checkbox.Checked) { CN_after = total_CNs(); 
                //    if (CN_after > 0 & ((CN_before - CN_after)/(CN_after+1)) > 1E-6) { Debugger.Break(); } } // MvdM check for loss of atoms. There is some loss due to rounding, so I built in the check that loss shouldn't be greater than 1E-6. Added +1 to the divider, to prevent dividing by zero in the first time step when there are no CNs added yet

            }
            catch
            {
                Debug.WriteLine("err_ti4");
            }
        }
        void display_grain_distribution(int row2, int col2)
        {
            Debug.Write("Grains row " + row2 + ", col " + col2 + ", t" + t + ": ");
            for (int lay2 = 0; lay2 < max_soil_layers; lay2++)
            {
                Debug.Write(OSL_grainages[row2, col2, lay2].Length + ", ");
            }
            Debug.Write("\r\n");
        }

        private void calculate_creep()
        {
            //Debug.WriteLine("start of creep with diffusivity at " + potential_creep_kg_m2_y);
            try
            {
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cr1");
                    Debugger.Break();
                }
                Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = "creep calculation";
                }, CancellationToken.None, TaskCreationOptions.None, guiThread); 
                int row, col,
                            i, j,
                            nb_ok,
                            NA_dem;
                double
                            dhmin, dhe_tol, dhs_tol,
                            slope_sum, dhmax, dz_min, d_x, dz_max, dh1, dh,
                            fraction,
                            temp, tempcreep_kg, tempdep,
                            slope,
                            local_creep_kg = 0;

                nb_ok = 0; nb_check = 0; all_grids = 0;
                dhmin = -9999; dhe_tol = 0.00000; dhs_tol = 0.00000;

                //NA_dem = NA_in_DEM();
                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }

                int runner = 0;

                for (runner = number_of_data_cells - 1; runner >= 0; runner--)
                {           // the index is sorted from low to high values, but flow goes from high to low
                    row = row_index[runner]; col = col_index[runner];
                    if (dtm[row, col] != -9999)
                    {
                        //Debug.WriteLine("cr1");
                        // into loop for surrounding grids of certain grid
                        // Start first the slope_sum loop for all lower neighbour grids
                        slope_sum = 0; dhmax = 0; dz_min = -9999.99; d_x = dx;
                        dz_max = -1; dhtemp = -99999.99; dhmin = (-9999.99);
                        // if(row == 31 && col == 12) { Debug.WriteLine("creep1"); displaysoil(row, col); }
                        if (thickness_calc(row, col, 0) < 0)
                        {
                            displaysoil(row, col); Debug.WriteLine("err_cr2");
                        }

                        for (i = (-1); i <= 1; i++)
                        {
                            for (j = (-1); j <= 1; j++)
                            {
                                dh = 000000; dh1 = 000; dhtemp = -99999.99; d_x = dx;
                                if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0)))
                                {    // boundaries
                                    if ((dtm)[row + i, col + j] != (-9999))
                                    {
                                        dh = ((dtm)[row, col] - (dtm)[row + i, col + j]);
                                        if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                        if (dh < 000000)
                                        {           // i j is a higher neighbour
                                            if (dh > dz_min) { dz_min = dh; }
                                            if (dh1 > dhmin + dhs_tol) { dhmin = (dh1 + dhs_tol); }
                                        }
                                        if (dh > 000000)
                                        {           // i j is a lower neighbour
                                            if (dh > dhmax - dhe_tol) { dhmax = (dh - dhe_tol); }
                                            dh = dh / d_x;
                                            if (dh > dz_max) { dz_max = dh; }
                                            dh = Math.Pow(dh, conv_fac);
                                            slope_sum = slope_sum + dh;
                                        }//end if
                                    }//end if novalues
                                }// end if boundaries
                            }//end for j
                        }//end for i
                         //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                        if (thickness_calc(row, col, 0) < 0)
                        {
                            displaysoil(row, col); Debug.WriteLine("err_cr3");
                        }
                        if (dhmax < 0)
                        {
                            Debug.WriteLine("err_cr4");
                        }
                        //Debug.WriteLine("cr2"); 

                        // calculate potential creep in kg
                        double maxslope = Math.Atan(dz_max); // max slope in radians

                        if (daily_water.Checked)
                        {
                            if (aridity_vegetation[row, col] < 1) { potential_creep_kg_m2_y = 4 + 0.3; } // grassland
                            else { potential_creep_kg_m2_y = 4 + 1.3; } // forest
                                                                   // standard potential creep of 4 kg. 0.3 or 1.3 is added, based on vegetation type. Rates are derived from Wilkinson 2009: breaking ground and Gabet
                        }

                        // local_creep_kg = potential_creep_kg * Math.Sin(maxslope) * Math.Cos(maxslope) * dx * dx * dt; //Equation from gabet et al., 2003 https://doi.org/10.1146/annurev.earth.31.100901.141314 

                        double total_soil_thickness_m = 0;
                        for (int layer = 0; layer < max_soil_layers; layer++)
                        {
                            total_soil_thickness_m += layerthickness_m[row, col, layer];
                        }
                        local_creep_kg = potential_creep_kg_m2_y * (1 - Math.Exp(-bioturbation_depth_decay_constant * total_soil_thickness_m)) * dx * dx * dt;
                        //Debug.WriteLine("cr3");

                        if (local_creep_kg > 0)
                        {

                            if (dhmin == -9999.99) { dhmin = 0; } else { dhmin = -dhmin; }
                            if (dhmax <= 0.0) { dhmax = 0.0; } else { dhmax = -dhmax; }
                            for (i = (-1); i <= 1; i++)
                            {
                                for (j = (-1); j <= 1; j++)
                                {
                                    dh = 0.000000; fraction = 0.0;
                                    frac_dis = 0.0;
                                    d_x = dx;
                                    //if (col == 1 | col == (nc - 1))
                                    //{ Debugger.Break(); }
                                    if (((row + i) >= 0) && ((row + i) < nr) && ((col + j) >= 0) && ((col + j) < nc) && !((i == 0) && (j == 0))) // boundaries
                                    {
                                        //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                        if (thickness_calc(row, col, 0) < 0)
                                        {
                                            displaysoil(row, col); Debug.WriteLine("err_cr5");
                                        }

                                        if ((dtm)[row + i, col + j] != (-9999.0))
                                        {
                                            dh = (dtm[row, col] - dtm[row + i, col + j]);
                                            temp = dtm[row + i, col + j];
                                            // if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                            // Multiple Flow: If there are lower neighbours start evaluating
                                            if (dh > 0.000000)
                                            {
                                                // if (row == 31 && col == 12) { Debug.WriteLine("creep3"); displaysoil(row, col); }
                                                //Debug.WriteLine("Cr1, dtm = {0}", dtm[row, col]);
                                                // fraction of discharge into a neighbour grid
                                                if ((row != row + i) && (col != col + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                                slope = dh / d_x;
                                                dh = dh / d_x;
                                                dh = Math.Pow(dh, conv_fac);
                                                fraction = (dh / slope_sum);
                                                tempcreep_kg = fraction * local_creep_kg * slope * 100; //MM develop. Original function was fraction*slope*diffusivity. Do I need to add slope in calculations?

                                                //// oldsoildepths
                                                double dsoil_source = total_soil_thickness(row, col);
                                                double dsoil_sink = total_soil_thickness(row + i, col + j);
                                                //displaysoil(row + i, col + j);
                                                double oldmass = total_soil_mass_kg(row, col) + total_soil_mass_kg(row + i, col + j);

                                                double oldmass_source = total_soil_mass_kg(row, col);
                                                double oldmass_sink = total_soil_mass_kg(row + i, col + j);

                                                calc_creep_layers(row, col, i, j, tempcreep_kg);

                                                // update soil depths                                               
                                                update_all_layer_thicknesses(row, col);
                                                update_all_layer_thicknesses(row + i, col + j);

                                                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                                if (thickness_calc(row, col, 0) < 0)
                                                {
                                                    displaysoil(row, col);
                                                    Debug.WriteLine("err_cr6");

                                                    Debug.WriteLine(thickness_calc(row, col, 0));
                                                    ;
                                                }

                                                double dsoil_source_new = total_soil_thickness(row, col);
                                                double dsoil_sink_new = total_soil_thickness(row + i, col + j);

                                                //displaysoil(row + i, col + j);

                                                double dz_source = dsoil_source_new - dsoil_source; // change in soil depth
                                                double dz_sink = dsoil_sink_new - dsoil_sink; // change in soil depth
                                                                                              //at this stage, we should connect to any blocks that are in the source and sink cells,
                                                                                              //and add dz_source and sink to their accum creep counters
                                                                                              //first, see if there are any blocks in here
                                                if (blocks_active == 1)
                                                {
                                                    // need to precalculate total block surface area per cell in a function (not from here) 
                                                    // to allow correction for more blocks having more stopping power and higher buildup behind them
                                                    foreach (var Block in Blocklist)
                                                    {
                                                        int blrow = Convert.ToInt32(Math.Floor(Block.Y_row));
                                                        int blcol = Convert.ToInt32(Math.Floor(Block.X_col));
                                                        if (row == blrow && col == blcol)
                                                        {
                                                            //then we have blocks that are giving in this direction, so should subtract from accum_creep
                                                            //i, j will tell us where this creep went to, so which of our 8 values we shoudl subrtact from
                                                            switch (10 * j + i)
                                                            {
                                                                case -1:  //To N
                                                                    Block.Accumulated_creep_m_0 += Convert.ToSingle(dz_source); break;
                                                                case 9: // To NE
                                                                    Block.Accumulated_creep_m_1 += Convert.ToSingle(dz_source); break;
                                                                case 10: //To E
                                                                    Block.Accumulated_creep_m_2 += Convert.ToSingle(dz_source); break;
                                                                case 11: //To SE
                                                                    Block.Accumulated_creep_m_3 += Convert.ToSingle(dz_source); break;
                                                                case 1: //To S
                                                                    Block.Accumulated_creep_m_4 += Convert.ToSingle(dz_source); break;
                                                                case -9: //To SW
                                                                    Block.Accumulated_creep_m_5 += Convert.ToSingle(dz_source); break;
                                                                case -10: //To W
                                                                    Block.Accumulated_creep_m_6 += Convert.ToSingle(dz_source); break;
                                                                case -11: //To NW
                                                                    Block.Accumulated_creep_m_7 += Convert.ToSingle(dz_source); break;
                                                                default:
                                                                    break;
                                                            }
                                                        }
                                                        if ((row + i) == blrow && (col + j) == blcol)
                                                        {
                                                            //then we have blocks that are receiving FROM this direction, so should add to accum_creep
                                                            //note the changed SWITCH VALUES
                                                            switch (10 * j + i)
                                                            {
                                                                case -1:  //From N, To S, etc
                                                                    Block.Accumulated_creep_m_4 += Convert.ToSingle(dz_sink); break;
                                                                case 9: // From NE
                                                                    Block.Accumulated_creep_m_5 += Convert.ToSingle(dz_sink); break;
                                                                case 10: //From E
                                                                    Block.Accumulated_creep_m_6 += Convert.ToSingle(dz_sink); break;
                                                                case 11: //From SE
                                                                    Block.Accumulated_creep_m_7 += Convert.ToSingle(dz_sink); break;
                                                                case 1: //From S
                                                                    Block.Accumulated_creep_m_0 += Convert.ToSingle(dz_sink); break;
                                                                case -9: //From SW
                                                                    Block.Accumulated_creep_m_1 += Convert.ToSingle(dz_sink); break;
                                                                case -10: //From W
                                                                    Block.Accumulated_creep_m_2 += Convert.ToSingle(dz_sink); break;
                                                                case -11: //From NW
                                                                    Block.Accumulated_creep_m_3 += Convert.ToSingle(dz_sink); break;
                                                                default:
                                                                    break;
                                                            }
                                                        }
                                                    }
                                                }

                                                double newmass = total_soil_mass_kg(row, col) + total_soil_mass_kg(row + i, col + j);
                                                creep[row, col] += dz_source;
                                                creep[row + i, col + j] += dz_sink;

                                                soildepth_m[row, col] += dz_source;
                                                soildepth_m[row + i, col + j] += dz_sink;
                                                // if (soildepth_m[row, col] > 5) { Debugger.Break(); }
                                                if (soildepth_m[row, col] < 0) { soildepth_m[row, col] = 0; }
                                                if (soildepth_m[row + i, col + j] < 0) { soildepth_m[row + i, col + j] = 0; }

                                                dtm[row, col] += dz_source;
                                                dtm[row + i, col + j] += dz_sink;

                                                dtmchange_m[row, col] += dz_source; //MMS
                                                dtmchange_m[row + i, col + j] += dz_sink; //MMS

                                                //Debug.WriteLine("Cr5, dtm = {0}", dtm[row, col]);
                                                //displaysoil(row, col);

                                                if (Math.Abs(oldmass - newmass) > 0.00001)
                                                {
                                                    Debug.WriteLine("err_cr7");

                                                } //MM Qua hoogte lijkt het hieronder nog mis te gaan. De gewichtscheck hierboven gaat wel goed. 
                                                  // Op DTM zijn de verschillen niet te zien, op creep[,] wel
                                                if (Math.Abs(dz_source + dz_sink) > 0.01 & t > 1)
                                                {
                                                    // Can occur with a thick lower soil layer, due to small changes in depth->bulk density->thickness. Can be 4 cm for a total soil thickness of 100  m.
                                                    Debug.WriteLine("Creep: Thickness erosion and deposition are not approximately equal");
                                                    //displaysoil(row, col); 
                                                    //displaysoil(row + i, col + j); 
                                                    // Debugger.Break();
                                                }
                                                //if (NA_dem != NA_in_DEM()) { Debugger.Break(); }
                                                if (thickness_calc(row, col, 0) < 0)
                                                {
                                                    displaysoil(row, col); Debug.WriteLine("err_cr8");
                                                }

                                                // if (row == 31 && col == 12) { Debug.WriteLine("creep7"); displaysoil(row, col); }

                                            }//end if
                                        }//end if novalues
                                    }//end if borders
                                }//end for j
                            }//end for i
                        } // end potential_creep_kg>0
                    }       // end for sorted 
                } // end runner
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_cr9");
                }

            }
            catch
            {
                Debug.WriteLine("err_cr10");

            }
            //Debug.WriteLine("end of creep");
        }

        private void calc_creep_layers(int row1, int col1, int iiii, int jjjj, double mass_export_soil_kg)
        {
            // tempcreep_kg in kg
            try
            {
                //Debug.WriteLine("Cr3.1, dtm = {0}", dtm[row1, col1]);
                //displaysoil(row1, col1);
                int layerreceiver = 0;
                double creep_depth_decay_constant = Convert.ToDouble(bioturbation_depth_decay_textbox.Text);

                double frac_overlap_lay, upperdepthdonor = 0, lowerdepthdonor = 0, upperdepthreceiver = 0, lowerdepthreceiver = 0, dsoil = 0, upp_z_lay = 0, int_curve_total, int_curve_lay, mass_export_lay_kg;
                bool C_done = false, lastlayer = false;

                dsoil = total_soil_thickness(row1, col1);

                //expanding soil thickness to if blocks are active to account of openness of (possibly) underlying hardlayer:
                if (blocks_active == 1)
                {
                    //this condition may be too strict or too lax 
                    if ((dtm[row1, col1] - dsoil) <= (hardlayerelevation_m + 0.001) && (dtm[row1, col1] - dsoil) > hardlayerelevation_m - 0.001)
                    {
                        //Debug.WriteLine(" r " + row1 + " c " + col1 + "  increasing total creeping soildepth from " + dsoil + " to " + (dtm[row1, col1] - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1]))));
                        dsoil = Math.Max(dsoil, (dtm[row1, col1] - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1]))));
                        //Debug.WriteLine(" soildepth now " + dsoil );
                    }
                }

                int_curve_total = 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * 0) - 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * dsoil); // integral over depth decay function, from depth 0 to total soil depth
                upperdepthdonor = 0; //  dtm[row1, col1]; using 0 leads to a continuous landscapes, instead of a step-wise pattern
                upperdepthreceiver = 0; // dtm[row1 + iiii, col1 + jjjj];
                lowerdepthreceiver = upperdepthreceiver - layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];

                for (int lay = 0; lay < max_soil_layers; lay++) // loop over receiving layers
                {

                    double laythick_m = layerthickness_m[row1, col1, lay];
                    if (laythick_m > 0)
                    {
                        if (blocks_active == 1)
                        {
                            if ((dtm[row1, col1] - (upp_z_lay + laythick_m)) <= (hardlayerelevation_m + 0.001) && (dtm[row1, col1] - (upp_z_lay + laythick_m)) > hardlayerelevation_m - 0.001)
                            {
                                //even though we change layer thickness here, we are not adapting how much mass is in it. 
                                //also for layers that currently end slightly IN hardlayer (for reasons unknown), and openness really small, we may actually end up reducing their thickness
                                //and if those layers are already very thin, we may end up with negative layerthicknes..
                                if (((dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1])) - laythick_m) < -0.001)
                                {
                                    Debug.WriteLine(" last layer thick_m " + laythick_m + " will be adding " + ((dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1])) - laythick_m));
                                }
                                laythick_m = (dtm[row1, col1] - upp_z_lay) - (hardlayerelevation_m - (hardlayerthickness_m * hardlayeropenness_fraction[row1, col1]));
                                //Debug.WriteLine("adapted thickness of last layer to " + laythick_m );
                                if (laythick_m < 0)
                                {
                                    Debug.WriteLine(" yikes " + laythick_m + " laythick - less than zero ");
                                    Debug.WriteLine("adapted thickness of last layer to " + laythick_m);
                                    laythick_m = 0;
                                }
                            }
                        }
                        int_curve_lay = 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * upp_z_lay) - 1 / (-creep_depth_decay_constant) * Math.Exp(-creep_depth_decay_constant * (upp_z_lay + laythick_m));//integral over depth decay function, from top of layer to bottom of layer
                        upp_z_lay += laythick_m;
                        lowerdepthdonor = upperdepthdonor - laythick_m; // elevation range donor layer  
                        mass_export_lay_kg = mass_export_soil_kg * (int_curve_lay / int_curve_total); // mass to be removed from layer in kg 

                        if (mass_export_lay_kg < 0)
                        {
                            Debug.Write(" YIKES" + mass_export_lay_kg + " will be exported ");
                            mass_export_lay_kg = 0;
                        }
                        string exchangetype = "N"; //this is the sentinel value, meaning "None of the options below"
                        frac_overlap_lay = 0; // this fraction will be used to correct for partally overlapping layers 

                        //five options: 
                        //              A donor layer is located completely above receiving layer, exchange with air above receiving layer 0,
                        //              B donor layer partially sticks above upper receiving layer, exchange with air above receiving layer 0,
                        // option A and B will not be used, as we consider the transitio between cells as a continuous curve, i.e. not step-wise pattern
                        // -----------------------------------------------------------
                        //              C (partial) overlap with receiving layer higher than donor layer, 
                        //              D receiving layer fully overlapped by (thicker) donor layer,
                        //              E (partial) overlap with receiving layer lower than donor layer,
                        //              F donor layer fully overlapped by (thicker) receiving layer,
                        //              (G exact overlap (which is like B or E, therefore not explicitly modeled)

                        // Options A and B are about donor layers above the surface of the receiving cell.
                        // Options C-F are about subsurface overlaps of layers, working from higher to lower receiving layers.
                        // This enables update of the receiving layer, when the overlap no longer exists
                        // Exchange of mass is done immediately. After this loop layer thicknesses and DTM are updated for the next calculation

                        // OPTION A: donor layer lies completely above receiving layer
                        // Not possible with the curret setup, where upper depth of donor and receiver both are zero, as is the case in continuous landscapes
                        if (lowerdepthdonor >= upperdepthreceiver && layerreceiver == 0)
                        {
                            exchangetype = "A";
                            frac_overlap_lay = 1;
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);
                            // if(row1==0&&col1==0){ Debug.WriteLine("A, layer " +lay+": " + frac_dz_lay * frac_overlap_lay); }
                            // no need to update receiving layer number
                        }

                        // OPTION B. donor layer partly rises above surface source layer. exchange with air above receiving layer 0
                        // Not possible with the curret setup, where upper depth of donor and receiver both are zero, as is the case in continuous landscapes

                        if (upperdepthdonor > upperdepthreceiver && lowerdepthdonor < upperdepthreceiver && layerreceiver == 0)
                        {
                            exchangetype = "B";
                            frac_overlap_lay = (upperdepthdonor - upperdepthreceiver) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);
                            // no need to update receiving layer number, because we only look at air exchange. subsurface exchange will be treated later
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("B, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }

                        // OPTION C: (partial or complete) overlap with receiving layer located (partially) higher than donor layer
                        if (upperdepthdonor <= upperdepthreceiver && lowerdepthdonor <= lowerdepthreceiver && upperdepthdonor > lowerdepthreceiver)
                        {
                            exchangetype = "C";
                            frac_overlap_lay = (upperdepthdonor - lowerdepthreceiver) / layerthickness_m[row1, col1, lay];
                            if (frac_overlap_lay > 1 && frac_overlap_lay < 1.00001) {
                                //for some reason, the calculation results sometimes in frac_overlap_lay values that are extremely near 1, but just a bit higher
                                frac_overlap_lay = 1;
                            }
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);

                            C_done = true;

                            if (lowerdepthdonor <= lowerdepthreceiver && layerreceiver < (max_soil_layers - 1)) // update receiving layer to a lower one. only occurs when lowerdepthdonor == lowerdepthreceiver
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("C, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }

                        // OPTION D: receiving layer completely overlapped by (thicker) donor layer
                        while (upperdepthdonor > upperdepthreceiver && lowerdepthdonor < lowerdepthreceiver && lastlayer == false) // while loop, this can occur several times, when the donor layer completely overlaps receiving layers
                        {
                            exchangetype = "D";
                            frac_overlap_lay = (upperdepthreceiver - lowerdepthreceiver) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);
                            // update receiving layer. the next layer can also be overlapped completely by donor layer
                            if (layerreceiver < (max_soil_layers - 1))
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            else
                            {
                                lastlayer = true;
                            }
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("D, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }

                        }
                        //OPTION E: overlap with receiving layer lower than donor layer  (take care that this does not evaluate to TRUE when C is also TRUE)
                        if (upperdepthdonor >= upperdepthreceiver && lowerdepthdonor >= lowerdepthreceiver && lowerdepthdonor < upperdepthreceiver && C_done == false)
                        {
                            exchangetype = "E";
                            frac_overlap_lay = (upperdepthreceiver - lowerdepthdonor) / layerthickness_m[row1, col1, lay];
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);

                            if (lowerdepthdonor <= lowerdepthreceiver && layerreceiver < (max_soil_layers - 1)) // update receiving layer to a lower one
                            {
                                layerreceiver += 1;
                                upperdepthreceiver = lowerdepthreceiver;
                                lowerdepthreceiver -= layerthickness_m[row1 + iiii, col1 + jjjj, layerreceiver];
                            }
                            //if (row1 == 0 && col1 == 0)
                            //{
                            //    Debug.WriteLine("E, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay);
                            //    Debug.WriteLine("Dupper = {0}, Dlower = {1}, Rupper = {2}, Rlower = {3}", upperdepthdonor, lowerdepthdonor, upperdepthreceiver, lowerdepthreceiver);
                            //}
                        }

                        //OPTION F, donor layer completely overlapped by (thicker) receiver layer
                        if (upperdepthdonor < upperdepthreceiver && lowerdepthdonor > lowerdepthreceiver)
                        {
                            exchangetype = "F";
                            frac_overlap_lay = 1;
                            creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, layerreceiver, mass_export_lay_kg, frac_overlap_lay, exchangetype);
                            // no update of receiving layer required
                            // if (row1 == 0 && col1 == 0) { Debug.WriteLine("F, layer " + lay + ": " + frac_dz_lay * frac_overlap_lay); }
                        }

                        //OPTION G, receiver soil might be absent. Material moves to upper layer of receiving layer, if elevation allows
                        if (total_soil_thickness(row1 + iiii, col1 + jjjj) == 0) // if receiving cell is bare rock 
                        {
                            exchangetype = "G";
                            bool partial_overlap = true;
                            if ((dtm[row1, col1] + upperdepthdonor) < dtm[row1 + iiii, col1 + jjjj]) { frac_overlap_lay = 0; partial_overlap = false; } // donor layer lies completely below surface of receiving cell
                            if ((dtm[row1, col1] + lowerdepthdonor) > dtm[row1 + iiii, col1 + jjjj]) { frac_overlap_lay = 1; partial_overlap = false; } // donor layer lies completely above surface of receiving cell

                            if (partial_overlap == true)
                            {
                                frac_overlap_lay = ((dtm[row1, col1] + upperdepthdonor) - dtm[row1 + iiii, col1 + jjjj]) / (upperdepthdonor - lowerdepthdonor);
                            } // donor layer lies partially above surface of receiving cell
                            if (frac_overlap_lay > 1) { frac_overlap_lay = 1; } // fraction can be a bit higher due to rounding errors

                            if (Double.IsInfinity(frac_overlap_lay) | Double.IsNaN(frac_overlap_lay) | frac_overlap_lay > 1)
                            {
                                Debug.WriteLine("err_cr11");
                            } // something went wrong in calculating overlapping fraction. Either divided by zero, a non-real answer or a fraction larger than 1

                            if (frac_overlap_lay > 0) // If the donor layer is (partially) above the bare bedrock of the receiving cell, everything can move to next cell:
                            {
                                frac_overlap_lay = 1;
                                creep_transport(row1, col1, lay, row1 + iiii, col1 + jjjj, 0, mass_export_lay_kg, frac_overlap_lay,exchangetype);
                            }
                        }

                        upperdepthdonor = lowerdepthdonor;
                        C_done = false;
                    } // end layerthickness > 0
                } // end layers
            } // end of try
            catch
            {
                Debug.WriteLine("Error in time {0}, row {1}, col{2}, receiving row {4}, col {5}", t, row1, col1, row1 + iiii, col1 + jjjj);
                Debug.WriteLine("err_cr12");

            }
        } // end calc_creep_layers

        private void creep_transport(int fromrow, int fromcol, int fromlay, int torow, int tocol, int tolay, double mass_export, double fraction_overlap, string exchangetype)
        {
            double CN_before = 0, CN_after = 0;
            //if (CN_checkbox.Checked) { CN_before = total_CNs(); }

            try
            {
                //Debug.WriteLine("Cr3.1.1, dtm = {0}", dtm[fromrow, fromcol]);
                //displaysoil(fromrow, fromcol);

                // double fraction_transport = fraction_dz * fraction_overlap;
                double fraction_transport = mass_export / total_layer_mass_kg(fromrow, fromcol, fromlay); // fraction of mass to be exported
                if (fraction_transport > 1) { fraction_transport = 1; Debug.WriteLine("type " + exchangetype + " err_cr13a - tried to transport more material via creep than present in donor layer");  }
                if (fraction_transport < 0)
                {
                    fraction_transport = 0; Debug.WriteLine("type " + exchangetype + " err_cr13b - tried to transport negative amount of material - transporting none now");
                }
                if (fraction_overlap > 1)
                {
                    Debug.WriteLine("fraction overlap = " + fraction_overlap.ToString("F40"));
                    fraction_overlap = 1; 
                    Debug.WriteLine("type " + exchangetype + " err_cr13c - tried to transport more material via creep than present in donor layer");
                }

                for (int tex = 0; tex < 5; tex++)
                {
                    texture_kg[torow, tocol, tolay, tex] += texture_kg[fromrow, fromcol, fromlay, tex] * fraction_transport;
                    texture_kg[fromrow, fromcol, fromlay, tex] -= texture_kg[fromrow, fromcol, fromlay, tex] * fraction_transport;
                }
                young_SOM_kg[torow, tocol, tolay] += young_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                young_SOM_kg[fromrow, fromcol, fromlay] -= young_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                old_SOM_kg[torow, tocol, tolay] += old_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;
                old_SOM_kg[fromrow, fromcol, fromlay] -= old_SOM_kg[fromrow, fromcol, fromlay] * fraction_transport;

                if (CN_checkbox.Checked) // every texture class moves with the same fraction, so there is no need to separate CN transport baswed on different texture classes. 
                {
                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                    {
                        CN_atoms_cm2[torow, tocol, tolay, cosmo] += CN_atoms_cm2[fromrow, fromcol, fromlay, cosmo] * fraction_transport;
                        CN_atoms_cm2[fromrow, fromcol, fromlay, cosmo] -= CN_atoms_cm2[fromrow, fromcol, fromlay, cosmo] * fraction_transport;
                    }
                }

                if (OSL_checkbox.Checked)
                {
                    transfer_OSL_grains(fromrow, fromcol, fromlay, torow, tocol, tolay, fraction_transport);
                }

                //Debug.WriteLine("Cr3.1.2, dtm = {0}", dtm[fromrow, fromcol]);
                //displaysoil(fromrow, fromcol);
                //if (CN_checkbox.Checked) { 
                //    CN_after = total_CNs(); 
                //    if (((CN_before - CN_after) / (CN_after+1)) > 1E-6) { Debugger.Break(); } }

            }
            catch
            {
                Debug.WriteLine("crashed during creep transport calculations");
                Debug.WriteLine("type " + exchangetype + " err_cr14");

            }

        }

        private void calculate_tree_fall()
        {
            double tf_mass_before = total_catchment_mass();
            double CN_before = 0, CN_after = 0;
            //if (CN_checkbox.Checked) { CN_before = total_CNs(); }

            try
            {
                Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = "tree fall calculation";
                }, CancellationToken.None, TaskCreationOptions.None, guiThread);
                bool fallen = false;
                int i_tf = 0, j_tf = 0;
                // double mass_before_tf = total_catchment_mass();
                double exported_mass_tf = 0, old_soil_depth_m = 0, tree_fall_frac_sum, tf_frac_dx;

                double[] tree_fall_mass, tree_fall_om;
                double[,] tree_fall_frac;
                Random rand = new Random(t); // t as a random seed
                Random falldirection = new Random(t);
                Random age_of_trees = new Random(t);
                int P_fall = Convert.ToInt32(Math.Round((1 / tf_frequency) / (dx * dx)));
                // int P_fall = Convert.ToInt32(Math.Round(1730 / dx / dx)); // 1/P_fall is the chance of tree fall, per m2, that's why we correct for cell size 
                // Debug.WriteLine("elevation of row 57 and col 40 at t {0} is {1}", t, dtm[57, 40]);
                int rowsource = 0, colsource = 0, rowsink = 0, colsink = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999 & aridity_vegetation[row, col] > 1) // if cell exists, and if there is no grass growing
                        {
                            int chance = rand.Next(0, P_fall);
                            // Debug.WriteLine("tf2");
                            //if (row == 31 & col == 31 & t == 226) { displaysoil(31, 31); Debugger.Break(); }
                            if (chance == 1) // if a tree falls
                            {
                                rowsource = row;
                                colsource = col;
                                fallen = true;
                                treefall_count[row, col] += 1;
                                // if (row == 0 & col == 5) { Debug.WriteLine("tf on t {0}", t); }
                                int falldir = falldirection.Next(1, 9); // for now a random fall direction. This can be changed as a function of e.g. slope, aspect and dominant wind direction
                                                                        // It appears that these factors don't have a dominant effect:https://doi.org/10.3159/10-RA-011.1 
                                                                        // trees can now fall in 8 directions, to all neighbouring cells. Depending on the distance to these cells, sediments will be redistributed.
                                                                        // neighbours:
                                                                        // 1  2  3
                                                                        // 4  X  5
                                                                        // 6  7  8
                                                                        // DEVELOP change surface roughness as function of tree fall, to promote more infiltration?
                                                                        //determine row direction i_tf
                                if (falldir < 4) { i_tf = -1; }
                                else if (falldir < 6) { i_tf = 0; }
                                else if (falldir < 9) { i_tf = 1; }
                                else { MessageBox.Show("error in tree fall. Fall direction Y not known"); }
                                // Debug.WriteLine("tf3");

                                // determine col direction j_tf
                                if (falldir == 1 | falldir == 4 | falldir == 6) { j_tf = -1; }
                                else if (falldir == 2 | falldir == 7) { j_tf = 0; }
                                else if (falldir == 3 | falldir == 5 | falldir == 8) { j_tf = 1; }
                                else { MessageBox.Show("error in tree fall. Fall direction X not known"); }

                                d_x = dx; if (falldir == 1 | falldir == 3 | falldir == 6 | falldir == 8) { d_x = dx * Math.Sqrt(2); } // determine lateral fall distance

                                if ((row + i_tf) >= 0 & (row + i_tf) < nr & (col + j_tf) >= 0 & (col + j_tf) < nc)
                                {
                                    if (dtm[row + i_tf, col + j_tf] != -9999)
                                    {
                                        dh = (dtm[row, col] - dtm[row + i_tf, col + j_tf]) / d_x; // if receiving cell is in catchment, calculate slope
                                    }
                                    else
                                    {
                                        dh = 0;
                                    }
                                }
                                else
                                {
                                    dh = 0; // receiving cell outside catchment, so we assume a slope of 0 percent in order to do the calculations below
                                }

                                double dh_deg = Math.Atan(dh);

                                // growth of tree root system. A spherical growth model is assumed. 
                                // Maximum root system width W_m = 4 m in a circle. This will later be converted to a square surface with the same area
                                // Maximum root system depth D_m = 0.7 m. // From paper Finke on tree fall
                                // These depths are reached after 150 years (typical life span)
                                if (thickness_calc(row, col, 0) < 0)
                                {
                                    Debug.WriteLine("err_tf1");
                                }
                                double W_m, D_m;
                                int tree_age = age_of_trees.Next(0, age_a_max); // selects age between 0 and maximum age of tree, for growth model
                                if (tree_age <= growth_a_max)
                                {
                                    W_m = W_m_max * (3 / 2 * tree_age / growth_a_max - 0.5 * Math.Pow((tree_age / growth_a_max), 3));
                                    D_m = D_m_max * (3 / 2 * tree_age / growth_a_max - 0.5 * Math.Pow((tree_age / growth_a_max), 3));
                                }
                                else
                                {
                                    W_m = W_m_max;
                                    D_m = D_m_max;
                                } // growth formula of trees, giving variable root sizes

                                // Convert spherical surface area to square surface area, to facilitate calculations
                                W_m = Math.Sqrt(Math.PI * Math.Pow(W_m / 2, 2));
                                // Debug.WriteLine("tf4");

                                // Calculation of transported mass over distance
                                int n_affected_cells = 1; // number of affected cells (in a square, so n_cells * n_cells
                                while (W_m > n_affected_cells * dx)
                                {
                                    n_affected_cells += 2;
                                }
                                tree_fall_mass = new double[5];
                                tree_fall_om = new double[2];
                                double[] tree_fall_CN = new double[n_cosmo];

                                tree_fall_frac = new double[n_affected_cells, n_affected_cells]; // keep track of fractions that are removed from all cells, so that those fractions can be redistributed in teh same pattern one or a few cells outward. 
                                tree_fall_frac_sum = 0;

                                // Debug.WriteLine("N affected cells = {0}", n_affected_cells);

                                // minimaps(row, col); // Base situation

                                for (int ii = (n_affected_cells - 1) / -2; ii <= (n_affected_cells - 1) / 2; ii++)
                                {
                                    for (int jj = (n_affected_cells - 1) / -2; jj <= (n_affected_cells - 1) / 2; jj++)
                                    {
                                        // Debug.WriteLine("tf10");

                                        if (Math.Abs(ii) == (n_affected_cells - 1) / 2 | Math.Abs(jj) == (n_affected_cells - 1) / 2) // cell on the side
                                        {
                                            if (Math.Abs(ii) == (n_affected_cells - 1) / 2 & Math.Abs(jj) == (n_affected_cells - 1) / 2) // all corner cells. Fraction eroded = overlap^2 / dx^2
                                            {
                                                tf_frac_dx = Math.Pow(dx - ((n_affected_cells * dx - W_m) / 2), 2) / Math.Pow(dx, 2);
                                            }
                                            else // all other border cells: fraction = overlap * dx / dx^2
                                            {
                                                tf_frac_dx = ((dx - ((n_affected_cells * dx - W_m) / 2)) * dx) / Math.Pow(dx, 2);
                                            }
                                        }
                                        else
                                        {
                                            tf_frac_dx = 1;
                                        }
                                        if (tf_frac_dx > 1) { MessageBox.Show("df_frac_dx > 1"); }
                                        tree_fall_frac[(n_affected_cells - 1) / 2 + ii, (n_affected_cells - 1) / 2 + jj] = tf_frac_dx;
                                        tree_fall_frac_sum += tf_frac_dx;

                                        if (((row + ii) >= 0) && ((row + ii) < nr) && ((col + jj) >= 0) && ((col + jj) < nc) && dtm[row + ii, col + jj] != -9999)
                                        {
                                            // Debug.WriteLine("tf10b");

                                            old_soil_depth_m = soildepth_m[row + ii, col + jj];
                                            // if (soildepth_m[row + ii, col + jj] < 50) { Debug.WriteLine("tf1 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[row + ii, col + jj], t, row + ii, col + jj); Debugger.Break(); }

                                            // Debug.WriteLine("tf5");

                                            double depth = 0, tf_frac_dz;
                                            int lay = 0;
                                            while (depth < D_m & lay < max_soil_layers)
                                            {
                                                // fraction of lowest layer which is incorporated
                                                if (depth + layerthickness_m[row + ii, col + jj, lay] <= D_m) { tf_frac_dz = 1; } // fraction of layer taken up by roots, in z direction
                                                else { tf_frac_dz = (D_m - depth) / layerthickness_m[row + ii, col + jj, lay]; }

                                                if (tf_frac_dz > 1) { MessageBox.Show("df_frac_dz > 1"); }

                                                // uptake of sediments
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    tree_fall_mass[tex] += texture_kg[row + ii, col + jj, lay, tex] * tf_frac_dz * tf_frac_dx;
                                                    texture_kg[row + ii, col + jj, lay, tex] -= texture_kg[row + ii, col + jj, lay, tex] * tf_frac_dz * tf_frac_dx;
                                                }
                                                tree_fall_om[0] += old_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                old_SOM_kg[row + ii, col + jj, lay] -= old_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                tree_fall_om[1] += young_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;
                                                young_SOM_kg[row + ii, col + jj, lay] -= young_SOM_kg[row + ii, col + jj, lay] * tf_frac_dz * tf_frac_dx;

                                                if (CN_checkbox.Checked)
                                                {
                                                    for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                                    {
                                                        double transport = CN_atoms_cm2[row + ii, col + jj, lay, cosmo] * tf_frac_dz * tf_frac_dx;
                                                        tree_fall_CN[cosmo] += transport;
                                                        CN_atoms_cm2[row + ii, col + jj, lay, cosmo] -= transport;
                                                    }
                                                }

                                                if (OSL_checkbox.Checked)
                                                {
                                                    // MvdM develop
                                                }
                                                // Debug.WriteLine("tf10c");

                                                // if (thickness_calc(row, col, 0) < 0) { Debugger.Break(); }

                                                // verder
                                                // check if all fractions are calculated correctly
                                                // what if W_m == dx, than the fraction is 0; correct by doing 1-fraction? is the eroded fraction still calculate correctly?
                                                // calculations of fraction have to be corrected
                                                // redistribution to a next cell, with the right distance etc 
                                                // solve mass loss tree fall
                                                // dtm output has a lot of -9999 instead of no data, check that in R

                                                // update depth and reference layer
                                                depth += layerthickness_m[row + ii, col + jj, lay];
                                                lay += 1;
                                            } // end while depth  < Dm
                                              //Debug.WriteLine("Total soil mass: {0}", total_soil_mass(row + ii, col + jj));
                                              //displaysoil(row + ii, col + jj);
                                            remove_empty_layers(row + ii, col + jj);
                                            //Debug.WriteLine("Total soil mass: {0}", total_soil_mass(row + ii, col + jj));
                                            //displaysoil(row + ii, col + jj);

                                            // Debug.WriteLine("tf11");
                                            update_all_layer_thicknesses(row + ii, col + jj);
                                            update_all_layer_thicknesses(row + ii, col + jj); // meij twice, because bulk density depends on depth. This way, the thickness of the empty layers is set to 0 in the first calculation, and used for bulk density in the second calculation

                                            // Elevation change by erosion (removal of material). 
                                            soildepth_m[row + ii, col + jj] = total_soil_thickness(row + ii, col + jj);
                                            //if (soildepth_m[row + ii, col + jj] < 50) { Debug.WriteLine("tf2 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[row + ii, col + jj], t, row + ii, col + jj); Debugger.Break(); }
                                            if (thickness_calc(row, col, 0) < 0)
                                            {
                                                Debug.WriteLine("err_tf2");
                                            }
                                            // Debug.WriteLine("tf12");

                                            if (old_soil_depth_m - soildepth_m[row + ii, col + jj] > 1)
                                            {
                                                Debug.WriteLine("err_tf3");
                                            }

                                            dtm[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            dz_treefall[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            dtmchange_m[row + ii, col + jj] += soildepth_m[row + ii, col + jj] - old_soil_depth_m;
                                            // Debug.WriteLine("erosion by tree fall = {0}", soildepth_m[row + ii, col + jj] - old_soil_depth_m);
                                            // Debug.WriteLine("tf13");

                                        } // end ii or jj in the area
                                    } // end jj
                                } // end ii
                                  //if (n_affected_cells > 1) { Debugger.Break(); }
                                  // minimaps(row, col); // After erosion

                                // Redistribution of material, deposition
                                // Debug.WriteLine("tf14");
                                double falldist;
                                double dh_rad = dh_deg * (Math.PI / 180);
                                if (dh < 0) // negative slope, tree falls upslope
                                {
                                    falldist = W_m / 2 * (Math.Cos(dh_rad) - Math.Sin(dh_rad)) - D_m / 2 * (Math.Cos(dh_rad) + Math.Sin(dh_rad));
                                }
                                else // positive or zero slope, tree falls downslope
                                {
                                    falldist = W_m / 2 * (Math.Cos(dh_rad) + Math.Sin(dh_rad)) + D_m / 2 * (Math.Sin(dh_rad) - Math.Cos(dh_rad));
                                }

                                // falldist is the distance where the centerpoint of the soil-root mass ends up. The distribution of the material follows the same pattern as the uptake, only shifted a few cells. The whole clump is moved a few steps

                                // Debug.WriteLine("tf15");
                                int ndist_cells = 0;
                                while (falldist > (ndist_cells + 0.5) * dx)
                                {
                                    ndist_cells += 1;
                                }
                                rowsink = row + ndist_cells * i_tf;
                                colsink = col + ndist_cells * j_tf;
                                for (int ii = (n_affected_cells - 1) / -2; ii <= (n_affected_cells - 1) / 2; ii++)
                                {
                                    for (int jj = (n_affected_cells - 1) / -2; jj <= (n_affected_cells - 1) / 2; jj++)
                                    {
                                        // Debug.WriteLine("tf16");

                                        tf_frac_dx = tree_fall_frac[(n_affected_cells - 1) / 2 + ii, (n_affected_cells - 1) / 2 + jj] / tree_fall_frac_sum;
                                        if (((rowsink + ii) >= 0) && ((rowsink + ii) < nr) && ((colsink + jj) >= 0) && ((colsink + jj) < nc) && dtm[rowsink + ii, colsink + jj] != -9999)
                                        {
                                            // Debug.WriteLine("tf17");

                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                texture_kg[rowsink + ii, colsink + jj, 0, tex] += tree_fall_mass[tex] * tf_frac_dx;
                                            }
                                            old_SOM_kg[rowsink + ii, colsink + jj, 0] += tree_fall_om[0] * tf_frac_dx;
                                            old_SOM_kg[rowsink + ii, colsink + jj, 0] += tree_fall_om[1] * tf_frac_dx;

                                            if (CN_checkbox.Checked)
                                            {
                                                for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                                                {
                                                    CN_atoms_cm2[rowsink + ii, colsink + jj, 0, cosmo] += tree_fall_CN[cosmo] * tf_frac_dx;
                                                }
                                            }

                                            if (OSL_checkbox.Checked)
                                            {

                                            }

                                            // elevation change by deposition
                                            old_soil_depth_m = soildepth_m[rowsink + ii, colsink + jj];
                                            double ds_1 = soildepth_m[rowsink + ii, colsink + jj];
                                            update_all_layer_thicknesses(rowsink + ii, colsink + jj);
                                            double ds_2 = soildepth_m[rowsink + ii, colsink + jj];
                                            update_all_layer_thicknesses(rowsink + ii, colsink + jj); // update twice, to approach real BD value, which is depth dependent
                                            double ds_3 = soildepth_m[rowsink + ii, colsink + jj];
                                            //if (soildepth_m[rowsink + ii, colsink + jj] < 50)
                                            //{
                                            //    Debug.WriteLine("tf3 d = {0}, at t {1}, r {2}, c {3}", soildepth_m[rowsink + ii, colsink + jj], t, rowsink + ii, colsink + jj);
                                            //    Debugger.Break();
                                            //}

                                            soildepth_m[rowsink + ii, colsink + jj] = total_soil_thickness(rowsink + ii, colsink + jj);
                                            dtm[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            dz_treefall[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            dtmchange_m[rowsink + ii, colsink + jj] += soildepth_m[rowsink + ii, colsink + jj] - old_soil_depth_m;
                                            //Debug.WriteLine("deposition by tree fall = {0}", soildepth_m[row + ndist_cells * i, col + ndist_cells * j] - old_soil_depth_m);

                                        } // end_time if dtm[,] = -9999
                                        else
                                        {
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                exported_mass_tf += tree_fall_mass[tex] * tf_frac_dx;
                                            }
                                            exported_mass_tf += tree_fall_om[0] * tf_frac_dx;
                                            exported_mass_tf += tree_fall_om[1] * tf_frac_dx;
                                        }
                                    } // end jj
                                } // end ii
                                  // minimaps(row, col); // After deposition

                            } // end chance ==1 (tree is falling)
                        } // end dtm != -9999
                    } // end col
                } // end row
                  // double mass_after_tf = total_catchment_mass() + exported_mass_tf;
                  //if (mass_before_tf != mass_after_tf) { MessageBox.Show("Tree fall mass not equal. difference = "+ (mass_before_tf - mass_after_tf)); }
                if (fallen == true)
                {
                    // Debug.WriteLine("sink cell 1");
                    //displaysoil(rowsink, colsink);

                    //if (t == 4)
                    //{
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsource,colsource));
                    //    displaysoil(rowsource, colsource);
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsink,colsink));
                    //    displaysoil(rowsink,colsink);
                    //}
                    // Debug.WriteLine("tf1a");
                    for (int r_tf = 0; r_tf < nr; r_tf++)
                    {
                        for (int c_tf = 0; c_tf < nc; c_tf++)
                        {
                            remove_empty_layers(r_tf, c_tf);
                            remove_empty_layers(r_tf, c_tf);
                            if (total_soil_mass_kg(r_tf, c_tf) <= 0) { Debugger.Break(); }
                            update_all_layer_thicknesses(r_tf, c_tf);
                        }
                    }
                    soil_update_split_and_combine_layers();
                    // Debug.WriteLine("tf1b");

                    //if (t == 4)
                    //{
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsource, colsource));
                    //    displaysoil(rowsource, colsource);
                    //    Debug.WriteLine("Total soil mass: {0}", total_soil_mass(rowsink, colsink));
                    //    displaysoil(rowsink, colsink);
                    //    Debugger.Break();
                    //}
                    if (NA_in_map(dtm) > 0)
                    {
                        Debug.WriteLine("err_tf5");
                    }
                    if (NA_in_map(soildepth_m) > 0)
                    {
                        Debug.WriteLine("err_tf6");
                    }

                }
                double tf_mass_after = total_catchment_mass() + exported_mass_tf;
                //if (CN_checkbox.Checked) { CN_after = total_CNs(); if (((CN_before - CN_after) / (CN_after+1)) > 1E-6) { Debugger.Break(); } }
                //if (Math.Abs(tf_mass_before - tf_mass_after)>0.001) { Debugger.Break(); }
            }
            catch
            {
                Debug.WriteLine("err_tf7");

            }

        }

        private void calculate_bedrock_weathering()
        {
            // as function of infiltration?
            //Debug.WriteLine("Entered bedrock weathering");												
            double Iavg = 0, Imin = 10000000, Imax = 0;
            if (daily_water.Checked)
            {
                int Icount = 0;
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (Imin > Iy[row, col]) { Imin = Iy[row, col]; }
                            if (Imax < Iy[row, col]) { Imax = Iy[row, col]; }
                            Iavg += Iy[row, col];
                            Icount++;
                        }
                    }
                }
                Iavg /= Icount;
            }
            int soil_layer, lowest_soil_layer;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        double weatheringdepth = 0;
                        //Debug.WriteLine(" bedrock weathering at r " + row + " c " + col);
                        //if the first occurrence of bedrock is the hardlayer, then no weathering should occur.
                        //if more weathering is calculated than needed to get to the hardlayer, then it should be thus limited. 

                        weatheringdepth = soildepth_m[row, col];

                        // humped
                        if (rockweath_method.SelectedIndex == 0)
                        {
                            bedrock_weathering_m[row, col] = P0 * (Math.Exp(-k1 * weatheringdepth) - Math.Exp(-k2 * weatheringdepth)) + Pa;

                        }
                        if (rockweath_method.SelectedIndex == 1)
                        {
                            // exponential (Heimsath, Chappell et al., 2000)
                            bedrock_weathering_m[row, col] = P0 * (Math.Exp(-k1 * weatheringdepth));
                        }

                        if (rockweath_method.SelectedIndex == 2)
                        {
                            if (daily_water.Checked)
                            {
                                bedrock_weathering_m[row, col] = P0 * -k1 * (Iy[row, col] - Imin) / (Imax - Imin);
                            }
                        }
                        //we now know how deep we would weather into normal bedrock
                        if (blocks_active == 1)
                        {
                            double newlowestelevsoil = dtm[row, col] - soildepth_m[row, col] - bedrock_weathering_m[row, col];
                            double oldlowestelevsoil = dtm[row, col] - soildepth_m[row, col];
                            if (newlowestelevsoil < hardlayerelevation_m && oldlowestelevsoil >= hardlayerelevation_m)
                            {
                                //we limit bedrock weathering to the part of the bedrock above hardlayer:
                                bedrock_weathering_m[row, col] = (dtm[row, col] - soildepth_m[row, col]) - hardlayerelevation_m;
                                Debug.WriteLine(" limited bedrock weathering to stop at hardlayer r " + row + " c " + col + " dtm " + dtm[row, col]);
                                //and apply the rest of the weathering to increasing openness of the hardlayer:
                                hardlayeropenness_fraction[row, col] += Convert.ToSingle((hardlayerelevation_m - newlowestelevsoil) * hardlayer_weath_contrast);
                                Debug.WriteLine(" increased openness of hardlayer to " + hardlayeropenness_fraction[row, col]);
                                if (hardlayeropenness_fraction[row, col] > 0.5) { hardlayeropenness_fraction[row, col] = 0.5f; }
                            }
                        }

                        soildepth_m[row, col] += bedrock_weathering_m[row, col]; // this will really be updated at the end of this timestep, but this is a good approximation for the moment

                        //we also add this amount of coarse material to the lowest layer of our soil
                        soil_layer = 0; lowest_soil_layer = 0;
                        while (layerthickness_m[row, col, soil_layer] > 0 & soil_layer < max_soil_layers) // MvdM added second conditional for when all layers are already filled
                        {
                            lowest_soil_layer = soil_layer;
                            soil_layer++;
                            //Debug.WriteLine(" lowest soil layer now " + soil_layer);
                            if (lowest_soil_layer == max_soil_layers - 1) { break; }
                        }
                        texture_kg[row, col, lowest_soil_layer, 0] += bedrock_weathering_m[row, col] * 2700 * dx * dx;   // to go from m (=m3/m2) to kg, we multiply by m2 and by kg/m3
                    }

                }
            }

        }

        private void calculate_tilting()
        {
            Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "tilting calculation";
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            //this.InfoStatusPanel.Text = "tilting calculation";								  
            int row, col;

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (tilt_location == 0) { dtm[row, col] += tilt_intensity * (col / nc); }
                    if (tilt_location == 1) { dtm[row, col] += tilt_intensity * (row / nr); }
                    if (tilt_location == 2) { dtm[row, col] += tilt_intensity * ((nc - col) / nc); }
                    if (tilt_location == 3) { dtm[row, col] += tilt_intensity * ((nr - row) / nr); }
                }
            }
        }

        private void calculate_uplift()
        {
            Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "uplift calculation";
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            //this.InfoStatusPanel.Text = "uplift calculation";	  
            int row, col;

            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (lift_location == 0 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 1 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 2 && row > lift_location) { dtm[row, col] += lift_intensity; }
                    if (lift_location == 3 && row > lift_location) { dtm[row, col] += lift_intensity; }
                }
            }
        }

        #endregion

        #region Hardlayer and block code

        void hardlayer_breaking()
        {
            //layers break off blocks when dz across the layer is larger than layer thickness
            //by a certain margin > 1 (I imagine)
            //Debug.WriteLine(" started breaking hard layer");
            //Debug.WriteLine(" Current number of blocks is " + Blocklist.Count);
            Random location_gen = new Random(t); // t as random seed to get deterministic results
            for (int hrd_lyr = 0; hrd_lyr < nhardlayers; hrd_lyr++)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            if (hardlayer_near_surface(row, col) == true)
                            {
                                //Debug.WriteLine(" hard layer is near surface for " + row + " " + col + " dtm " + dtm[row,col] + " layer " + hardlayerelevation_m);
                                int n_to_s = 5;  //impossible values
                                int e_to_w = 5;
                                //Debug.WriteLine("hardlayerthick " + hardlayerthickness_m + "max_dz_across_layer" + max_dz_across_hardlayer_m(row, col, out n_to_s, out e_to_w));
                                if (max_dz_across_hardlayer_m(row, col, out n_to_s, out e_to_w) > hardlayerthickness_m * 1.25)
                                {
                                    //Debug.WriteLine(" hardlayer breaking at row " + row + " " + col );
                                    dtm[row, col] -= hardlayerthickness_m;
                                    if (n_to_s == 5 | e_to_w == 5) { Debug.WriteLine("invalid direction returned from max_dz_across layer at r" + row + " c " + col); }
                                    //break off blocks and drop  them in direction of max_dz
                                    //floor ensures that blocks are not filling that cell up entirely  
                                    int ndropblocks = Convert.ToInt32(Math.Floor((dx * dx) * (1 - hardlayeropenness_fraction[row, col]) / hardlayerthickness_m));
                                    //Debug.WriteLine(" adding " + ndropblocks + " with size " + hardlayerthickness_m);
                                    for (int blck = 0; blck < ndropblocks; blck++)
                                    {
                                        //Debug.Write(" adding block ");
                                        Blocklist.Add(new Block(Convert.ToSingle(row - n_to_s + location_gen.NextDouble()), Convert.ToSingle(col + e_to_w + location_gen.NextDouble()), hardlayerthickness_m, 0, 0, 0, 0, 0, 0, 0, 0));
                                    }
                                    blocksproduced += ndropblocks;
                                }
                            }
                        }
                    }
                }
            }
            //Debug.WriteLine(" New number of blocks is " + Blocklist.Count);
        }

        bool hardlayer_near_surface(int rowt, int colt)
        {
            if (dtm[rowt, colt] <= (hardlayerelevation_m + 0.1) && dtm[rowt, colt] > (hardlayerelevation_m - 0.001))
            { return true; }
            else { return false; }
        }

        float max_dz_across_hardlayer_m(int nowrow, int nowcol, out int n_to_s, out int e_to_w)
        {
            //Debug.WriteLine(" calculating max dz across hardlayer for " + nowrow + " " + nowcol);
            float max_dz_m = 0;
            n_to_s = 5;
            e_to_w = 5;
            //development possible to account for presence of blocks in downslope cells
            //Debug.WriteLineIf(nowrow == 0 && nowcol == 88,"x");
            //Debug.WriteLineIf(nowrow == 0 && nowcol == 88,  "dtm" + dtm[nowrow, nowcol]);
            if (nowrow > 0 && nowcol > 0) { if (dtm[nowrow - 1, nowcol - 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol - 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol - 1]); n_to_s = 1; e_to_w = -1; } } }
            if (nowrow > 0) { if (dtm[nowrow - 1, nowcol] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol]); n_to_s = 1; e_to_w = 0; } } }
            if (nowrow > 0 && (nowcol + 1) < nc) { if (dtm[nowrow - 1, nowcol + 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol + 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow - 1, nowcol + 1]); n_to_s = 1; e_to_w = 1; } } }
            if (nowcol > 0) { if (dtm[nowrow, nowcol - 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow, nowcol - 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow, nowcol - 1]); n_to_s = 0; e_to_w = -1; } } }
            if ((nowcol + 1) < nc) { if (dtm[nowrow, nowcol + 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow, nowcol + 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow, nowcol + 1]); n_to_s = 0; e_to_w = 1; } } }
            if ((nowrow + 1) < nr && nowcol > 0) { if (dtm[nowrow + 1, nowcol - 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol - 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol - 1]); n_to_s = -1; e_to_w = -1; } } }
            if ((nowrow + 1) < nr) { if (dtm[nowrow + 1, nowcol] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol]); n_to_s = -1; e_to_w = 0; } } }
            if ((nowrow + 1) < nr && (nowcol + 1) < nc) { if (dtm[nowrow + 1, nowcol + 1] != -9999) { if ((dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol + 1]) > max_dz_m) { max_dz_m = Convert.ToSingle(dtm[nowrow, nowcol] - dtm[nowrow + 1, nowcol + 1]); n_to_s = -1; e_to_w = 1; } } }
            return max_dz_m;
        }

        void block_weathering()
        {
            //blocks are cubic and weather smaller as a function of surface area (size squared)
            if (diagnostic_mode == 1) { Debug.WriteLine(" starting block weathering"); }
            Random location_gen = new Random(t); // t as random seed to get deterministic results
            if (Blocklist.Count > 0)
            {
                int index = 0;
                while (index < Blocklist.Count)
                {
                    //Debug.WriteLine(Blocklist[0].Size_m);
                    //Debug.WriteLine(" Block " + index + " will be weathered. Now size is " + Blocklist[index].Size_m + " total blocks " + Blocklist.Count);
                    //Blocklist[index].Size_m *= blockweatheringratio * Convert.ToSingle(location_gen.NextDouble()+0.5);
                    Blocklist[index].Size_m *= blockweatheringratio;
                    //Debug.WriteLine(" Block " + index + " was weathered. Now size is " + Blocklist[index].Size_m + " total blocks " + Blocklist.Count);
                    if (Blocklist[index].Size_m < blocksizethreshold_m)
                    {
                        texture_kg[Convert.ToInt32(Math.Floor(Blocklist[index].Y_row)), Convert.ToInt32(Math.Floor(Blocklist[index].X_col)), 0, 0] += Math.Pow(Blocklist[index].Size_m, 3) * hardlayerdensity_kg_m3;
                        Blocklist.RemoveAt(index);
                        //this will also update Blocklist.Count, so we don't count too far. 

                    }
                    index++;
                }
            }
            else
            {
                Debug.WriteLine(" currently no blocks to weather ");
            }

        }

        void block_movement()
        {
            //blocks either roll or creep along
            // function of size, but not shape for now
            //accum_creep_alt (8 directions) += creep_alt_timestep
            //creep_alt_timestep (8 directions) = creep volume / (cell surface area - cell block area)
            //two options      :
            //EITHER
            //block rolls if slope in cell + (net_accum_creep_alt in any direction/size block) > 1 (45 degrees)
            //if block rolls, it rolls in first direction where the condition is met
            //by exactly one block size
            //accum creep alt in that direction is reset, others are kept

            //OR
            //block moves with creeping soil (which should always be less ?))
            //distance in any direction is volume of creep from that direction/cell size/soildepth in cell
            //average all distances and average their direction
            //pythagoras
            //does not reset accum_creep_alt

            // this way of thinking means that all blocks will roll, some more than others. Not nice
            // Also, many blocks in a cell or few blocks in a cell makes no difference.
            // In reality, it probably should because more blocks, less space, more bunching up of regolith, more roll
            // That can later be solved by taking dz_source or dz_sink DIV (1-blockcover) in creep calculations.
            if (diagnostic_mode == 1) { Debug.WriteLine(" starting block movement"); }
            Random location_gen = new Random(t);
            //Debug.WriteLine(" starting block movement");
            List<Block> removelist = new List<Block>();
            if (Blocklist.Count > 0)
            {
                //Debug.WriteLine(" blockcount now " + Blocklist.Count);
                foreach (var Block in Blocklist)
                {
                    int row = Convert.ToInt32(Math.Floor(Block.Y_row));
                    int col = Convert.ToInt32(Math.Floor(Block.X_col));
                    //Debug.WriteLine(" block in cell " + row + " " + col);
                    if (row == 0 || row == (nr - 1) || col == 0 || col == (nc - 1))
                    {
                        removelist.Add(Block);
                        //Debug.WriteLine(" added to remove list ");
                    }
                    else if (dtm[row, col] != -9999)
                    {
                        // we calculate for four possible directions whether the block should roll:
                        bool block_has_rolled = false;
                        //from north to south
                        double averageslope = (dtm[row - 1, col] - dtm[row + 1, col]) / (2 * dx); // averaged over two cells
                        double additionalslope = (Block.Accumulated_creep_m_0 - Block.Accumulated_creep_m_4) / Block.Size_m;
                        double totalslope = averageslope + additionalslope;
                        if (totalslope > 1)
                        {
                            //Debug.WriteLine(" block rolling. dtm1 " + dtm[row - 1, col] + " dtm2 " + dtm[row + 1, col] + " avslope " + averageslope + " addslope " + additionalslope + " totslope " + totalslope + "rownow " + Block.Y_row + " sizenow " + Block.Size_m);
                            Block.Y_row -= Block.Size_m;
                            block_has_rolled = true;
                            Block.Accumulated_creep_m_0 = 0;
                            Block.Accumulated_creep_m_4 = 0;
                            topoconttoroll += Math.Abs(averageslope);
                            creepconttoroll += Math.Abs(additionalslope);
                            //Debug.WriteLine(" block rolled n to s");
                            if (Math.Floor(Block.Y_row) == nr) { Blocklist.Remove(Block); }
                        } // rolls to south
                        if (totalslope < -1)
                        {
                            //Debug.WriteLine(" block rolling. dtm1 " + dtm[row - 1, col] + " dtm2 " + dtm[row + 1, col] + " avslope " + averageslope + " addslope " + additionalslope + " totslope " + totalslope + "rownow " + Block.Y_row + " sizenow " + Block.Size_m);
                            Block.Y_row += Block.Size_m;
                            block_has_rolled = true;
                            Block.Accumulated_creep_m_0 = 0;
                            Block.Accumulated_creep_m_4 = 0;
                            topoconttoroll += Math.Abs(averageslope);
                            creepconttoroll += Math.Abs(additionalslope);
                            //Debug.WriteLine(" block rolled s to n, lowered row");
                            if (Math.Floor(Block.Y_row) == -1) { Blocklist.Remove(Block); }
                        } // rolls to north

                        if (block_has_rolled == false)
                        {
                            //from NE to SW (note different slope calculation)
                            averageslope = (dtm[row - 1, col + 1] - dtm[row + 1, col - 1]) / (2 * dx * Math.Sqrt(2)); // averaged over two cells, diagonally
                            additionalslope = (Block.Accumulated_creep_m_1 - Block.Accumulated_creep_m_5) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {   //higher on the NE, rolls to the SW
                                block_has_rolled = true;
                                Block.Y_row -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_1 = 0;
                                Block.Accumulated_creep_m_5 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == nr | Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                block_has_rolled = true;
                                Block.Y_row += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_1 = 0;
                                Block.Accumulated_creep_m_5 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == -1 | Math.Floor(Block.X_col) == nc) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //from E to W
                            averageslope = (dtm[row, col + 1] - dtm[row, col - 1]) / (2 * dx); // averaged over two cells 
                            additionalslope = (Block.Accumulated_creep_m_2 - Block.Accumulated_creep_m_6) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {
                                Block.X_col += Block.Size_m;
                                block_has_rolled = true;
                                Block.Accumulated_creep_m_2 = 0;
                                Block.Accumulated_creep_m_6 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                Block.X_col -= Block.Size_m;
                                block_has_rolled = true;
                                Block.Accumulated_creep_m_2 = 0;
                                Block.Accumulated_creep_m_6 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.X_col) == nr) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //from SE to NW (note different slope calculation)
                            averageslope = (dtm[row + 1, col + 1] - dtm[row - 1, col - 1]) / (2 * dx * Math.Sqrt(2)); // averaged over two cells, diagonally
                            additionalslope = (Block.Accumulated_creep_m_3 - Block.Accumulated_creep_m_7) / Block.Size_m;
                            totalslope = averageslope + additionalslope;
                            if (totalslope > 1)
                            {
                                block_has_rolled = true;
                                Block.Y_row += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col += Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_3 = 0;
                                Block.Accumulated_creep_m_7 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == -1 | Math.Floor(Block.X_col) == -1) { Blocklist.Remove(Block); }
                            }
                            if (totalslope < -1)
                            {
                                block_has_rolled = true;
                                Block.Y_row -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.X_col -= Convert.ToSingle(1.4142135 * Block.Size_m);
                                Block.Accumulated_creep_m_3 = 0;
                                Block.Accumulated_creep_m_7 = 0;
                                //Debug.WriteLine(" block rolled");
                                topoconttoroll += Math.Abs(averageslope);
                                creepconttoroll += Math.Abs(additionalslope);
                                if (Math.Floor(Block.Y_row) == nr | Math.Floor(Block.X_col) == nr) { Blocklist.Remove(Block); }
                            }
                        }
                        if (block_has_rolled == false)
                        {
                            //find steepest lower nb, calculate creep to it, calculate distance from kg -> m3 -> 
                        }
                        if (block_has_rolled == true) { blocksrolled++; }
                    }
                }
            }
            else
            {
                //Debug.WriteLine(" currently no blocks to move ");
            }
            Blocklist.RemoveAll(x => removelist.Contains(x));
            //Debug.WriteLine(" removed " + removelist.Count + " blocks from list, leaving blockcount now " + Blocklist.Count);
        }

        #endregion

        #region Vegetation code

        double[,] aridity_vegetation;

        void determine_vegetation_type()
        {
            aridity_vegetation = new double[nr, nc];
            double outflow = 0, aridity, outflowcells = 0;

            for (int vrow = 0; vrow < nr; vrow++)
            {
                for (int vcol = 0; vcol < nc; vcol++)
                {

                    if (dtm[vrow, vcol] != -9999)
                    {
                        // adjusted Budyko
                        // aridity (water stress) = P/PET. If PET>P, water stress, aridity < 1.
                        // P is replaced by (I+ETa), Incoming water that infiltrates in the cell is captured in I

                        outflow = OFy_m[vrow, vcol, 0] - OFy_m[vrow, vcol, 9];
                        // aridity = (Iy[vrow, vcol] + ETay[vrow, vcol] - outflow) / ET0y[vrow, vcol];
                        aridity = (Iy[vrow, vcol] + ETay[vrow, vcol]) / ET0y[vrow, vcol];

                        // First, we had (I+ET)*(P/(P+O) / PET. But I think the scaling is not necessary. 
                        if (aridity < 0)
                        {
                            Debug.WriteLine("err_vg1");
                        }
                        aridity_vegetation[vrow, vcol] = aridity;

                        if (aridity < 1)
                        {
                            vegetation_type[vrow, vcol] += 1; // arid / grass
                        }
                        else
                        {
                            vegetation_type[vrow, vcol] += 1000; // humid / forest
                        }
                    }
                }
            }
        }

        void change_vegetation_parameters()
        {
            // vegetation coefficients for ET
            for (int vrow = 0; vrow < nr; vrow++)
            {
                for (int vcol = 0; vcol < nc; vcol++)
                {
                    if (dtm[vrow, vcol] != -9999)
                    {
                        if (aridity_vegetation[vrow, vcol] < 1) { veg_correction_factor[vrow, vcol] = .75; } // all year long, according to FAO report 56
                        else { veg_correction_factor[vrow, vcol] = .85; } // I took the mid-season coefficient (95) of most deciduous crops and decreased it to 85 to account for less vegetation in other times of the year
                        if (t >= (end_time - 300)) { veg_correction_factor[vrow, vcol] = .45; }  // if there is agriculture
                    }
                }
            }
        }

        void calculate_TPI(int windowsize)
        {
            try
            {
                //Debug.WriteLine("Started calculating TPI");
                // check if window size is an uneven number, so the window has a center cell
                if (windowsize % 2 == 0) { MessageBox.Show("window size for TPI calculations should be an uneven number"); }

                int windowrange = (windowsize - 1) / 2;
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            double tpisum = 0;
                            double tpicount = 0;

                            // calculate moving window average
                            for (int rr = windowrange * -1; rr <= windowrange; rr++)
                            {
                                for (int cc = windowrange * -1; cc <= windowrange; cc++)
                                {
                                    if (row + rr >= 0 & row + rr < nr & col + cc >= 0 & col + cc < nc) // if cell exists in the DEM, 
                                    {
                                        if (dtm[row + rr, col + cc] != -9999 & (rr != 0 | cc != 0)) // if cell contains a value and cell isn't the target cell, it's considered in the TPI
                                        {
                                            tpisum += dtm[row + rr, col + cc];
                                            tpicount += 1;
                                        }
                                    }
                                }
                            }
                            tpi[row, col] = dtm[row, col] - (tpisum / tpicount);
                        }

                    }
                }
                //Debug.WriteLine("Finished calculating TPI");
            }
            catch
            {
                Debug.WriteLine("Error in calculating TPI");
            }
        }

        #endregion

        #region Geochronology code
        Random randOslLayerMixing = new Random(123);

        void transfer_material_between_layers(int row1, int col1, int lay1, int row2, int col2, int lay2, double fraction_transport)
        {
            double transport_betw_layers;
            int transport_betw_layers_int;
            if (fraction_transport > 0)
            {
                for (int tex = 0; tex < n_texture_classes; tex++)
                {
                    transport_betw_layers = texture_kg[row1, col1, lay1, tex] * fraction_transport;
                    texture_kg[row1, col1, lay1, tex] -= transport_betw_layers;
                    texture_kg[row2, col2, lay2, tex] += transport_betw_layers;
                }
                transport_betw_layers = young_SOM_kg[row1, col1, lay1] * fraction_transport;
                young_SOM_kg[row1, col1, lay1] -= transport_betw_layers;
                young_SOM_kg[row2, col2, lay2] += transport_betw_layers;

                transport_betw_layers = old_SOM_kg[row1, col1, lay1] * fraction_transport;
                old_SOM_kg[row1, col1, lay1] -= transport_betw_layers;
                old_SOM_kg[row2, col2, lay2] += transport_betw_layers;

                if (CN_checkbox.Checked)
                {
                    for (int cn = 0; cn < n_cosmo; cn++)
                    {
                        transport_betw_layers = CN_atoms_cm2[row1, col1, lay1, cn] * fraction_transport;
                        CN_atoms_cm2[row1, col1, lay1, cn] -= transport_betw_layers;
                        CN_atoms_cm2[row2, col2, lay2, cn] += transport_betw_layers;
                    }
                }
            }
            
            if (OSL_checkbox.Checked)
            {
                transfer_OSL_grains(row1, col1, lay1, row2, col2, lay2, fraction_transport, 0);
            }
            update_all_layer_thicknesses(row1, col1);
            update_all_layer_thicknesses(row2, col2);
        }
        void update_and_bleach_OSL_ages()
        {
            int P_bleaching_int;
            double sep_fraction = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    
                    update_all_layer_thicknesses(row, col);
                    if (total_soil_thickness(row, col) > 0) // if there is any soil left
                    {
                        //Debug.WriteLine("uboa1");
                        double depth = 0;
                        double bleached_depth_m = bleaching_depth_m;

                        // split or merge top layer, so that it gets the thickness of the bleaching depth. this is to avoid deep-reaching of bleached grains, when the layer is thicker
                        if (layerthickness_m[row, col, 0] > bleaching_depth_m) // give part to the layer below
                        {
                            sep_fraction = (layerthickness_m[row, col, 0] - bleaching_depth_m) / layerthickness_m[row, col, 0];
                            transfer_material_between_layers(row, col, 0, row, col, 1, sep_fraction);
                        }
                        if (layerthickness_m[row, col, 0] < bleaching_depth_m & layerthickness_m[row, col, 1] > 0) // get part of the layer below, if it exists
                        {
                            sep_fraction = (bleaching_depth_m - layerthickness_m[row, col, 0]) / layerthickness_m[row, col, 1];
                            transfer_material_between_layers(row, col, 1, row, col, 0, sep_fraction);
                        }

                        update_all_layer_thicknesses(row, col);

                        for (int layer = 0; layer < max_soil_layers; layer++)
                        {
                            //Debug.WriteLine("uboa2");
                            double laythick = layerthickness_m[row, col, layer];
                            double P_bleaching = 0;
                            if (laythick > 0 & bleached_depth_m > 0) { P_bleaching = bleached_depth_m / laythick; } // determine part of layer that is within bleaching range
                            if (P_bleaching > 1)
                            {
                                P_bleaching = 1;
                            } // set to 1 if bleaching range is larger than layer thickness
                            P_bleaching_int = Convert.ToInt32(Math.Round(100000000 * P_bleaching));
                            //Debug.WriteLine("uboa3");
                            if (OSL_grainages[row, col, layer].Length > 0)
                            {
                                for (int ind = 0; ind < OSL_grainages[row, col, layer].Length; ind++)
                                {
                                    // add a year to all grains
                                    OSL_grainages[row, col, layer][ind] += 1;
                                    OSL_depositionages[row, col, layer][ind] += 1;

                                    //Debug.WriteLine("uboa4");
                                    if (bleached_depth_m > 0)
                                    {
                                        // Chance of bleaching                          
                                        if ((randOslLayerMixing.Next(0, 100000000) < P_bleaching_int ? 1 : 0) == 1) // if grain is exposed to daylight
                                        {
                                            OSL_grainages[row, col, layer][ind] = 0; // bleach grain
                                            OSL_surfacedcount[row, col, layer][ind] += 1; // add 1 to the number of times the grain has surfaced and has been bleached

                                        }
                                    }
                                    //Debug.WriteLine("uboa5");
                                }
                            }
                            bleached_depth_m -= laythick; // subtract layer thickness from bleached depth
                            depth = depth + layerthickness_m[row, col, layer];
                            //Debug.WriteLine("uboa6");
                        }
                    }
                }
            }
        }

        void transfer_OSL_grains(int fromrow, int fromcol, int fromlay, int torow, int tocol, int tolay, double P_fromto, double P_tofrom = 0, bool bleaching_by_transport = false)
        {
            // if (tocol == 41 & tolay == 0) { Debugger.Break(); }
            OSL_JA_start = DateTime.Now;
            int[] ages_from = OSL_grainages[fromrow, fromcol, fromlay];
            int[] ages_to = OSL_grainages[torow, tocol, tolay];
            int[] ages_from_da = OSL_depositionages[fromrow, fromcol, fromlay];
            int[] ages_to_da = OSL_depositionages[torow, tocol, tolay];
            int[] ages_from_su = OSL_surfacedcount[fromrow, fromcol, fromlay];
            int[] ages_to_su = OSL_surfacedcount[torow, tocol, tolay];

            int P_transfer;
            var ages_from_transfer = new List<Int32>();
            var ages_from_keep = new List<Int32>();
            var ages_to_transfer = new List<Int32>();
            var ages_to_keep = new List<Int32>();

            var ages_from_transfer_da = new List<Int32>();
            var ages_from_keep_da = new List<Int32>();
            var ages_to_transfer_da = new List<Int32>();
            var ages_to_keep_da = new List<Int32>();

            var ages_from_transfer_su = new List<Int32>();
            var ages_from_keep_su = new List<Int32>();
            var ages_to_transfer_su = new List<Int32>();
            var ages_to_keep_su = new List<Int32>();

            int ages_before = ages_from.Sum() + ages_to.Sum();

            if (P_fromto < 0.000000001) { P_fromto = 0; }
            if (P_tofrom < 0.000000001) { P_tofrom = 0; }

            // calculate probability of moving
            P_transfer = 0;
            if (P_fromto > 0)
            {
                P_transfer = Convert.ToInt32(Math.Round(1000000000 * P_fromto)); // With a large number (1E9), there is a chance that even the smallest transports are modelled.

                for (int osl_i = 0; osl_i < ages_from.Length; osl_i++) // check for every possibly outgoing grain if it moves
                {
                    int chance_next = randOslLayerMixing.Next(0, 1000000000);
                    if ((chance_next < P_transfer ? 1 : 0) == 1) // if grain gets transported
                    {
                        ages_from_transfer.Add(ages_from[osl_i]);
                        ages_from_transfer_su.Add(ages_from_su[osl_i]);
                        if (bleaching_by_transport == true & (fromrow != torow | fromcol != tocol)) // if the grain is transported laterally and possibly bleached, reset the deposition age
                        {
                            ages_from_transfer_da.Add(0);
                        }
                        else // do not reset the deposition age
                        {
                            ages_from_transfer_da.Add(ages_from_da[osl_i]);
                        }
                    }
                    else
                    {
                        ages_from_keep.Add(ages_from[osl_i]);
                        ages_from_keep_da.Add(ages_from_da[osl_i]);
                        ages_from_keep_su.Add(ages_from_su[osl_i]);
                    }
                }
            }
            else
            {
                ages_from_keep.AddRange(ages_from); // if there is no transport, all grains remain
                ages_from_keep_da.AddRange(ages_from_da);
                ages_from_keep_su.AddRange(ages_from_su);
            }

            if (P_tofrom > 0)
            {
                P_transfer = Convert.ToInt32(Math.Round(1 / P_tofrom));
                for (int osl_i = 0; osl_i < ages_to.Length; osl_i++) // check for every possibly outgoing grain if it moves
                {
  
                    if ((randOslLayerMixing.Next(0, P_transfer) < 1 ? 1 : 0) == 1) // if grain gets transported
                    {
                        ages_to_transfer.Add(ages_to[osl_i]);
                        ages_to_transfer_su.Add(ages_to_su[osl_i]);

                        if (bleaching_by_transport == true & (fromrow != torow | fromcol != tocol)) // if the grain is transported laterally and possibly bleached, reset the deposition age
                        {
                            ages_to_transfer_da.Add(0);
                        }
                        else // do not reset the deposition age
                        {
                            ages_to_transfer_da.Add(ages_to_da[osl_i]);
                        }
                    }
                    else
                    {
                        ages_to_keep.Add(ages_to[osl_i]);
                        ages_to_keep_da.Add(ages_to_da[osl_i]);
                        ages_to_keep_su.Add(ages_to_su[osl_i]);
                    }
                }
            }
            else
            {
                ages_to_keep.AddRange(ages_to); // if there is no transport, all grains remain
                ages_to_keep_da.AddRange(ages_to_da); // if there is no transport, all grains remain
                ages_to_keep_su.AddRange(ages_to_su); // if there is no transport, all grains remain
            }

            ages_from_keep.AddRange(ages_to_transfer);
            OSL_grainages[fromrow, fromcol, fromlay] = ages_from_keep.ToArray();
            ages_from_keep_da.AddRange(ages_to_transfer_da);
            OSL_depositionages[fromrow, fromcol, fromlay] = ages_from_keep_da.ToArray();
            ages_from_keep_su.AddRange(ages_to_transfer_su);
            OSL_surfacedcount[fromrow, fromcol, fromlay] = ages_from_keep_su.ToArray();

            ages_to_keep.AddRange(ages_from_transfer);
            OSL_grainages[torow, tocol, tolay] = ages_to_keep.ToArray();
            ages_to_keep_da.AddRange(ages_from_transfer_da);
            OSL_depositionages[torow, tocol, tolay] = ages_to_keep_da.ToArray();
            ages_to_keep_su.AddRange(ages_from_transfer_su);
            OSL_surfacedcount[torow, tocol, tolay] = ages_to_keep_su.ToArray();

            int ages_after = OSL_grainages[fromrow, fromcol, fromlay].Sum() + OSL_grainages[torow, tocol, tolay].Sum();
            if (ages_before != ages_after) { Debugger.Break(); }

            OSL_JA_t += DateTime.Now - OSL_JA_start;
        }

        void update_cosmogenic_nuclides()
        {
            double local_met10Be_uptake, layer_met10Be_index, total_met10Be_index, total_soil_thickness_m, depth, cum_BD_kg_cm2, sandmass_g, layer_input_atoms_sp, layer_input_atoms_mu;
            ;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        // Meteoric Beryllium-10
                        total_soil_thickness_m = total_soil_thickness(row, col);

                        local_met10Be_uptake = met_10Be_input * (1 - Math.Exp(-met_10Be_adsorptioncoefficient * total_soil_thickness_m)) * dt; // # atoms cm-2
                        total_met10Be_index = 1 - (Math.Exp(-met_10Be_adsorptioncoefficient * total_soil_thickness_m));

                        depth = 0;
                        cum_BD_kg_cm2 = 0;

                        for(int lay = 0; lay<max_soil_layers;lay++)
                        {
                            // Meteoric 10-Be
                            // Uptake
                            layer_met10Be_index = Math.Exp(-met_10Be_adsorptioncoefficient * depth) - (Math.Exp(-met_10Be_adsorptioncoefficient * (depth + layerthickness_m[row, col, lay])));
                            CN_atoms_cm2[row, col, lay, 0] += layer_met10Be_index/total_met10Be_index * local_met10Be_uptake * met_10Be_clayfraction;
                            CN_atoms_cm2[row, col, lay, 1] += layer_met10Be_index / total_met10Be_index * local_met10Be_uptake * (1 - met_10Be_clayfraction);
                            depth += layerthickness_m[row, col, lay];
                            // decay
                            CN_atoms_cm2[row, col, lay, 0] *= (1 - decay_Be10);
                            CN_atoms_cm2[row, col, lay, 1] *= (1 - decay_Be10);

                            // In-situ cosmogenic nuclides
                            // Assumed that all sand is quartz in the model
                            sandmass_g = texture_kg[row, col, lay, 1] * 1000;

                            // In-situ Be-10
                            layer_input_atoms_sp = P0_10Be_is_sp * sandmass_g / (dx * 100 * dx * 100) * dt; // # atoms cm-2
                            layer_input_atoms_mu = P0_10Be_is_mu * sandmass_g / (dx * 100 * dx * 100) * dt; // # atoms cm-2
                            CN_atoms_cm2[row, col, lay, 2] += layer_input_atoms_sp * Math.Exp(-cum_BD_kg_cm2 / attenuation_length_sp); // Spallation production
                            CN_atoms_cm2[row, col, lay, 2] += layer_input_atoms_mu * Math.Exp(-cum_BD_kg_cm2 / attenuation_length_mu); // Muonic production
                            CN_atoms_cm2[row, col, lay, 2] *= (1 - decay_Be10); // Decay

                            // In-situ C-14
                            layer_input_atoms_sp = P0_14C_is_sp * sandmass_g / (dx * 100 * dx * 100) * dt; // # atoms cm-2
                            layer_input_atoms_mu = P0_14C_is_mu * sandmass_g / (dx * 100 * dx * 100) * dt; // # atoms cm-2
                            CN_atoms_cm2[row, col, lay, 3] += layer_input_atoms_sp * Math.Exp(-cum_BD_kg_cm2 / attenuation_length_sp); // Spallation production
                            CN_atoms_cm2[row, col, lay, 3] += layer_input_atoms_mu * Math.Exp(-cum_BD_kg_cm2 / attenuation_length_mu); // Muonic production
                            CN_atoms_cm2[row, col, lay, 3] *= (1 - decay_C14); // Decay

                            // Update cumulative bulk density
                            cum_BD_kg_cm2 += bulkdensity[row, col, lay] * layerthickness_m[row, col, lay];
                        }
                    }
                }
            }
            catch
            {
                Debug.WriteLine("Error in updating cosmogenic nuclides");
            }

        }

        void transport_ero_sed_OSL_by_WE(int row_OSL, int col_OSL, int i_OSL, int j_OSL, double sum_fractions, double new_fraction, double P_ero_0, double P_ero_1, double P_sed)
        {
            var grains_to_next_cell = new List<Int32>();
            var grains_to_next_cell_da = new List<Int32>();
            var grains_to_next_cell_su = new List<Int32>();
            var grains_at_source_location = new List<Int32>();
            var grains_at_source_location_da = new List<Int32>();
            var grains_at_source_location_su = new List<Int32>();
            int P_transfer;
            int[] ages_array;
            double P_ero;

            if (sum_fractions == 0) // If it is the first time this cell is considered, shuffle the present grains to prevent earlier eroded grains to be deposited the first
            {
                int[] indices = new int[OSL_grainages_in_transport[row_OSL, col_OSL].Length]; // create array of indices
                if (indices.Length > 0)
                {
                    for (int ii = 0; ii < indices.Length; ii++) { indices[ii] = ii; } // fill them with numbers
                    indices = indices.OrderBy(x => randOslLayerMixing.Next()).ToArray(); // shuffle the array
                    int[] indices_da = new int[indices.Length]; // create new indice arrays for the other age properties
                    int[] indices_su = new int[indices.Length];
                    for (int ii = 0; ii < indices.Length; ii++) { indices_da[ii] = indices[ii]; indices_su[ii] = indices[ii]; } // copy the indices array

                    ages_array = OSL_grainages_in_transport[row_OSL, col_OSL];
                    Array.Sort(indices, ages_array);
                    OSL_grainages_in_transport[row_OSL, col_OSL] = ages_array;

                    ages_array = OSL_depositionages_in_transport[row_OSL, col_OSL];
                    Array.Sort(indices_da, ages_array);
                    OSL_depositionages_in_transport[row_OSL, col_OSL] = ages_array;

                    ages_array = OSL_surfacedcount_in_transport[row_OSL, col_OSL];
                    Array.Sort(indices_su, ages_array);
                    OSL_surfacedcount_in_transport[row_OSL, col_OSL] = ages_array;
                }
            }

            // select grains that go in the direction of row+i and col+j, based on the fractions of water flow
            int[] grains_considered = OSL_grainages_in_transport[row_OSL, col_OSL];
            int ind_start = Convert.ToInt32(Math.Round(sum_fractions * grains_considered.Length));
            int ind_end = Convert.ToInt32(Math.Round((sum_fractions + new_fraction) * grains_considered.Length));
            int ind_count = ind_end - ind_start;
            if (ind_start < 0 | ind_end > grains_considered.Length | ind_count < 0) { Debugger.Break(); }

            // Select grains that are in transport to next cell
            grains_to_next_cell.AddRange(OSL_grainages_in_transport[row_OSL, col_OSL].Skip(ind_start).Take(ind_count));
            grains_to_next_cell_da.AddRange(OSL_depositionages_in_transport[row_OSL, col_OSL].Skip(ind_start).Take(ind_count));
            grains_to_next_cell_su.AddRange(OSL_surfacedcount_in_transport[row_OSL, col_OSL].Skip(ind_start).Take(ind_count));

            // Erosion/uptake of grains
            double[] P_ero_both_layers = new double[] { P_ero_0, P_ero_1 };
            for (int lay_OSL = 0; lay_OSL < 2; lay_OSL++)
            {
                P_ero = P_ero_both_layers[lay_OSL];

                if (P_ero > 0)
                {
                    // Select grains that are at the source location, in the eroding layer
                    grains_at_source_location.AddRange(OSL_grainages[row_OSL, col_OSL, lay_OSL]);
                    grains_at_source_location_da.AddRange(OSL_depositionages[row_OSL, col_OSL, lay_OSL]);
                    grains_at_source_location_su.AddRange(OSL_surfacedcount[row_OSL, col_OSL, lay_OSL]);

                    // Loop over the grains, to see if they erode
                    P_transfer = Convert.ToInt32(Math.Round(10000 * P_ero));
                    var indices_to_be_removed = new List<Int32>();
                    for (int osl_i = 0; osl_i < grains_at_source_location.Count; osl_i++)
                    {
                        if ((randOslLayerMixing.Next(0, 10000) < P_transfer ? 1 : 0) == 1) // if grain gets eroded
                        {
                            // add to the transfer grains
                            grains_to_next_cell.Add(grains_at_source_location[osl_i]);
                            grains_to_next_cell_da.Add(grains_at_source_location_da[osl_i]);
                            grains_to_next_cell_su.Add(grains_at_source_location_su[osl_i]);
                            indices_to_be_removed.Add(osl_i);
                        }
                    }
                    // Go through indices to be removed in descending order, to remove grains from source location
                    for (int osl_i = (indices_to_be_removed.Count - 1); osl_i >= 0; osl_i--) // 
                    {
                        grains_at_source_location.RemoveAt(indices_to_be_removed[osl_i]);
                        grains_at_source_location_da.RemoveAt(indices_to_be_removed[osl_i]);
                        grains_at_source_location_su.RemoveAt(indices_to_be_removed[osl_i]);
                    }
                    // Reassign the grains that already were at the source location, minus the eroded grains
                    OSL_grainages[row_OSL, col_OSL, 0] = grains_at_source_location.ToArray();
                    OSL_depositionages[row_OSL, col_OSL, 0] = grains_at_source_location_da.ToArray();
                    OSL_surfacedcount[row_OSL, col_OSL, 0] = grains_at_source_location_su.ToArray();
                }
            }

            // Deposition of grains
            if (P_sed > 0)
            {
                // Select grains that are in the surface layer at the source location
                grains_at_source_location.AddRange(OSL_grainages[row_OSL, col_OSL, 0]);
                grains_at_source_location_da.AddRange(OSL_depositionages[row_OSL, col_OSL, 0]);
                grains_at_source_location_su.AddRange(OSL_surfacedcount[row_OSL, col_OSL, 0]);

                P_transfer = Convert.ToInt32(Math.Round(10000 * P_sed));
                var indices_to_be_removed = new List<Int32>();
                for (int osl_i = 0; osl_i < grains_to_next_cell.Count; osl_i++)
                {
                    if ((randOslLayerMixing.Next(0, 10000) < P_transfer ? 1 : 0) == 1) // if grain gets deposited
                    {
                        grains_at_source_location.Add(grains_to_next_cell[osl_i]);
                        grains_at_source_location_da.Add(0); // Add zero instead of age, because deposition age is reset after deposition
                        grains_at_source_location_su.Add(grains_to_next_cell_su[osl_i]);
                        indices_to_be_removed.Add(osl_i);
                    }
                }
                // Loop through indices to be removed in descending order, to remove grains from transport
                for (int osl_i = (indices_to_be_removed.Count - 1); osl_i >= 0; osl_i--) // Does this work?
                {
                    grains_to_next_cell.RemoveAt(indices_to_be_removed[osl_i]);
                    grains_to_next_cell_da.RemoveAt(indices_to_be_removed[osl_i]);
                    grains_to_next_cell_su.RemoveAt(indices_to_be_removed[osl_i]);
                }
                // Add the grains that already were at the  source location, with possible deposited grains, to the source location
                OSL_grainages[row_OSL, col_OSL, 0] = grains_at_source_location.ToArray();
                OSL_depositionages[row_OSL, col_OSL, 0] = grains_at_source_location_da.ToArray();
                OSL_surfacedcount[row_OSL, col_OSL, 0] = grains_at_source_location_su.ToArray();
            }

            // Transfer remaining grains
            // The grains at the source location have already been updated, either through erosion or deposition, or they haven't been affected
            // Now we have to transfer the grains that are still in transport to the next cell. Keep in mind that there might be already grains in transport present, which should be added
            grains_to_next_cell.AddRange(OSL_grainages_in_transport[row_OSL + i_OSL, col_OSL + j_OSL]);
            OSL_grainages_in_transport[row_OSL + i_OSL, col_OSL + j_OSL] = grains_to_next_cell.ToArray();
            grains_to_next_cell_da.AddRange(OSL_depositionages_in_transport[row_OSL + i_OSL, col_OSL + j_OSL]);
            OSL_depositionages_in_transport[row_OSL + i_OSL, col_OSL + j_OSL] = grains_to_next_cell_da.ToArray();
            grains_to_next_cell_su.AddRange(OSL_surfacedcount_in_transport[row_OSL + i_OSL, col_OSL + j_OSL]);
            OSL_surfacedcount_in_transport[row_OSL + i_OSL, col_OSL + j_OSL] = grains_to_next_cell_su.ToArray();
        }

        double total_CNs()
        {
            double total_CN = 0;
            for (int cn_row = 0; cn_row < nr; cn_row++)
            {
                for (int cn_col = 0; cn_col < nc; cn_col++)
                {
                    for (int cn_lay = 0; cn_lay < max_soil_layers; cn_lay++)
                    {
                        for (int cosmo = 0; cosmo < n_cosmo; cosmo++)
                        {
                            total_CN += CN_atoms_cm2[cn_row, cn_col, cn_lay, cosmo];
                        }
                    }
                }
            }
            return (total_CN);
        }

        #endregion

        #region mapping and drawing code

        double calc_slope_stdesc(int row_s, int col_s)
        {
            double slope_desc = 0, slope_temp = 0;
            if (dtm[row_s, col_s] != -9999)
            {
                for (i = (-1); i <= 1; i++)
                {
                    for (j = (-1); j <= 1; j++)
                    {
                        if (((row_s + i) >= 0) && ((row_s + i) < nr) && ((col_s + j) >= 0) && ((col_s + j) < nc) && !((i == 0) && (j == 0)))  //to stay within the grid and avoid the row col cell itself
                        {
                            if (dtm[row_s + i, col_s + j] != -9999) // if neighbour exists
                            {
                                if ((row_s != row_s + i) && (col_s != col_s + j)) { d_x = dx * Math.Sqrt(2); } else { d_x = dx; }
                                slope_temp = (dtm[row_s, col_s] - dtm[row_s + i, col_s + j]) / d_x;
                                if (slope_desc < slope_temp) { slope_desc = slope_temp; }
                            }
                        }
                    }
                }
            }

            slope_desc = Math.Atan(slope_desc); // slope in radians
            return (slope_desc);
        }

        void update_slope_and_aspect()
        {
            double slopemax, slope, slopetot;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        slopemax = 0;
                        slope = 0;
                        slopetot = 0;

                        // Do slope analysis and Aspect Calculation first
                        if ((row - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row - 1, col] && dtm[row - 1, col] != -9999) // North 0
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 0 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((row - 1) >= 0 & (col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row - 1, col + 1] && dtm[row - 1, col + 1] != -9999) // Northeast 45
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col + 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 45 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row, col + 1] && dtm[row, col + 1] != -9999) // East 90
                            {
                                slope = (dtm[row, col] - dtm[row, col + 1]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 90 * (3.141592654 / 180);
                                }
                            }
                        }
                        if ((row + 1) < nr & (col + 1) < nc)
                        {
                            if (dtm[row, col] > dtm[row + 1, col + 1] && dtm[row + 1, col + 1] != -9999) // SouthEast 135
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col + 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 135 * (3.141592654 / 180);
                                }

                            }
                        }

                        if ((row + 1) < nr)
                        {
                            if (dtm[row, col] > dtm[row + 1, col] && dtm[row + 1, col] != -9999) // South 180
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 180 * (3.141592654 / 180);
                                }
                            }
                        }
                        if ((row + 1) < nr & (col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row + 1, col - 1] && dtm[row + 1, col - 1] != -9999) // SouthWest 225
                            {
                                slope = (dtm[row, col] - dtm[row + 1, col - 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 225 * (3.141592654 / 180);
                                }
                            }
                        }

                        if ((col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row, col - 1] && dtm[row, col - 1] != -9999) // West 270
                            {
                                slope = (dtm[row, col] - dtm[row, col - 1]) / dx;
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 270;
                                }
                            }
                        }

                        if ((row - 1) >= 0 & (col - 1) >= 0)
                        {
                            if (dtm[row, col] > dtm[row - 1, col - 1] && dtm[row - 1, col - 1] != -9999) // Northwest 315
                            {
                                slope = (dtm[row, col] - dtm[row - 1, col - 1]) / (dx * Math.Sqrt(2));
                                if (slope > slopemax)
                                {
                                    slopemax = slope;
                                    slopetot++;
                                    aspect[row, col] = 315 * (3.141592654 / 180);
                                }
                            }
                        }

                        if (slope > 0) slopeAnalysis[row, col] = slopemax;// Tom's: (slope/slopetot); ?
                        else { slopeAnalysis[row, col] = 0; }

                        // Convert slope to radians
                        slopeAnalysis[row, col] = System.Math.Atan(slopeAnalysis[row, col]);

                        //// test
                        //slopeAnalysis[row, col] = 0 * Math.PI / 180;
                        //aspect[row, col] = 0 * Math.PI / 180;

                    }
                }
            }
        }

        #endregion

        #region interface behaviour code

        private void End_button_Click(object sender, EventArgs e)
        {
            this.Close();
        }

        private void Menu_aboutbox_Click(object sender, EventArgs e)
        {
            aboutbox.Visible = true;
        }

        private void timeseries_button_Click(object sender, EventArgs e)
        {
            timeseries.Visible = true;
        }

        private void profiles_button_Click(object sender, EventArgs e)
        {
            profile.Visible = true;
        }

        private void landuse_determinator_button_Click(object sender, EventArgs e)
        {
            landuse_determinator.Visible = true;
        }

        private void Water_ero_checkbox_CheckedChanged(object sender, EventArgs e)
        {
            if (Water_ero_checkbox.Checked == false)
            {
                only_waterflow_checkbox.Enabled = false;
                only_waterflow_checkbox.Checked = false;
            }
            if (Water_ero_checkbox.Checked == true) { only_waterflow_checkbox.Enabled = true; }
        }

        private void Form1_Load(object sender, System.EventArgs e)
        {
            //JMW <20040929 -start>
            this.Text = basetext;
            //DoingGraphics = false;
            //JMW <20040929 - end>

        }

        private void check_cnst_soildepth_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_soildepth.Checked == true) // time can never be true,  because the model calculates soildepth
            {
                soildepth_constant_value_box.Enabled = false;
                soildepth_input_filename_textbox.Enabled = true;
            }
            else
            {
                soildepth_constant_value_box.Enabled = true;
                soildepth_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_landuse_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_landuse.Checked == true)
            {
                landuse_constant_value_box.Enabled = false;
                landuse_input_filename_textbox.Enabled = true;
                check_time_landuse.Checked = false;
            }
            if (check_space_landuse.Checked == false && check_time_landuse.Checked == false)
            {
                landuse_constant_value_box.Enabled = true;
                landuse_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_till_fields_CheckedChanged(object sender, EventArgs e)
        {

            if (check_space_till_fields.Checked == true)
            {
                tillfields_constant_textbox.Enabled = false;
                tillfields_input_filename_textbox.Enabled = true;
                check_time_till_fields.Checked = false;
            }
            if (check_space_till_fields.Checked == false && check_time_till_fields.Checked == false)
            {
                tillfields_constant_textbox.Enabled = true;
                tillfields_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_rain_CheckedChanged_1(object sender, EventArgs e)
        {
            if (check_space_rain.Checked == true)
            {
                rainfall_constant_value_box.Enabled = false;
                rain_input_filename_textbox.Enabled = true;
                check_time_rain.Checked = false;
            }
            if (check_space_rain.Checked == false && check_time_rain.Checked == false)
            {
                rainfall_constant_value_box.Enabled = true;
                rain_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_infil_CheckedChanged(object sender, EventArgs e)
        {
            if (check_space_infil.Checked == true)
            {
                infil_constant_value_box.Enabled = false;
                infil_input_filename_textbox.Enabled = true;
                check_time_infil.Checked = false;
            }
            if (check_space_infil.Checked == false && check_time_infil.Checked == false)
            {
                infil_constant_value_box.Enabled = true;
                infil_input_filename_textbox.Enabled = false;
            }
        }

        private void check_cnst_evap_CheckedChanged(object sender, EventArgs e)
        {
            if (check_space_evap.Checked == true)
            {
                evap_constant_value_box.Enabled = false;
                evap_input_filename_textbox.Enabled = true;
                check_time_evap.Checked = false;
            }
            if (check_space_evap.Checked == false && check_time_evap.Checked == false)
            {
                evap_constant_value_box.Enabled = true;
                evap_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_landuse_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_landuse.Checked == true)
            {
                landuse_constant_value_box.Enabled = false;
                landuse_input_filename_textbox.Enabled = true;
                check_space_landuse.Checked = false;
            }
            if (check_space_landuse.Checked == false && check_time_landuse.Checked == false)
            {
                landuse_constant_value_box.Enabled = true;
                landuse_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_tillage_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_till_fields.Checked == true) // time can only be true when space is also true
            {

                tillfields_constant_textbox.Enabled = false;
                tillfields_input_filename_textbox.Enabled = true;
                check_space_till_fields.Checked = false;
            }
            if (check_space_till_fields.Checked == false && check_time_till_fields.Checked == false)
            {
                tillfields_constant_textbox.Enabled = true;
                tillfields_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_rain_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_rain.Checked == true)
            {
                rainfall_constant_value_box.Enabled = false;
                rain_input_filename_textbox.Enabled = true;
                check_space_rain.Checked = false;
            }
            if (check_space_rain.Checked == false && check_time_rain.Checked == false)
            {
                rainfall_constant_value_box.Enabled = true;
                rain_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_infil_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_infil.Checked == true)
            {
                infil_constant_value_box.Enabled = false;
                infil_input_filename_textbox.Enabled = true;
                check_space_infil.Checked = false;
            }
            if (check_space_infil.Checked == false && check_time_infil.Checked == false)
            {
                infil_constant_value_box.Enabled = true;
                infil_input_filename_textbox.Enabled = false;
            }
        }

        private void check_time_evap_CheckedChanged(object sender, EventArgs e)
        {
            if (check_time_evap.Checked == true)
            {
                evap_constant_value_box.Enabled = false;
                evap_input_filename_textbox.Enabled = true;
                check_space_evap.Checked = false;
            }
            if (check_space_evap.Checked == false && check_time_evap.Checked == false)
            {
                evap_constant_value_box.Enabled = true;
                evap_input_filename_textbox.Enabled = false;
            }
        }

        private void button8_Click(object sender, EventArgs e)
        {

            //MessageBox.Show()

            /*"Input filenames are not available when both f(row,col) and f(t) are unchecked. In that case, only single values are input
LORICA will use filename in the following way:

1. When f(row,col) is checked but f(t) is not checked, filename is the ascii grid that will be read.
Example: filename = use.asc ; LORICA will read use.asc

2. When f(row,col) and f(t) are checked, filename is the prefix for 
a series of ascii grid files with the timestep following the prefix. 
Example: filename = use.asc ; LORICA will read use1.asc, use2.asc, use3.asc etc

3. When f(row,col) is not checked, but f(t) is checked, filename is the text file containing 
(spatially uniform) timeseries. The number of values in this file should at least equal 
the number of timesteps in the run. LORICA will start using the first value.
Example: rainfall.asc can look like:
0.67
0.54
0.87
0.70
" */
        }

        private void dtm_input_filename_textbox_Click(object sender, EventArgs e)
        {

            OpenFileDialog openFileDialog1 = new OpenFileDialog();
            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dtm_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void soildepth_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                soildepth_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void landuse_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                landuse_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void tillfields_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                tillfields_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void rain_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                rain_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void infil_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.Filter = "Ascii grids (*.asc)|*.asc|All files (*.*)|*.*";
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                infil_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void evap_input_filename_textbox_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                evap_input_filename_textbox.Text = openFileDialog1.FileName;
            }
        }

        private void dailyP_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyP.Text = openFileDialog1.FileName;
            }
        }

        private void dailyET0_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyET0.Text = openFileDialog1.FileName;
            }
        }

        private void dailyD_TextChanged(object sender, EventArgs e)
        {
            OpenFileDialog openFileDialog1 = new OpenFileDialog();

            openFileDialog1.InitialDirectory = workdir;
            openFileDialog1.FilterIndex = 1;
            openFileDialog1.RestoreDirectory = false;

            if (openFileDialog1.ShowDialog() == DialogResult.OK)
            {
                dailyD.Text = openFileDialog1.FileName;
            }
        }

        private void soil_specify_button_Click(object sender, EventArgs e)
        {
            soildata.Visible = true;
        }

        #endregion

        #region calibration code

        private void calib_calculate_maxruns(int calibparacount)
        {
            //this code calculates the total number of runs needed when calibrating
            string calibration_ratio_string = calibration_ratios_textbox.Text;
            string[] ratiowords = calibration_ratio_string.Split(';');
            int ratio;
            for (ratio = 0; ratio < ratiowords.Length; ratio++)
                for (int par = 0; par < calibparacount; par++)
                {
                    try
                    {
                        calib_ratios[par, ratio] = Convert.ToDouble(ratiowords[ratio]);
                    }
                    catch { input_data_error = true; MessageBox.Show("Calibration ratio input error"); }
                }
            try { calib_levels = Convert.ToInt32(calibration_levels_textbox.Text); }
            catch { input_data_error = true; MessageBox.Show("Calibration iterations must be an integer"); }
            maxruns = calib_levels * Convert.ToInt32(Math.Pow(ratiowords.Length, calibparacount));
            Debug.WriteLine(" the number of runs for calibration will be " + maxruns);
        }

        private void calib_shift_and_zoom(int para_number, double zoom_factor, double orig_par_value)
        {
            //this code iinds out whether the best parameter value was on the edge or inside the range explored. Then shifts and zooms out or in , depending
            try
            {
                Debug.WriteLine(" para number " + para_number);
                Debug.WriteLine(" best parameter value " + best_parameters[para_number]);
                Debug.WriteLine(" original parameter value " + orig_par_value);
                double mid_ratio = 0;
                if (calib_ratios.GetLength(1) % 2 == 0) { mid_ratio = (calib_ratios[para_number, Convert.ToInt32(calib_ratios.GetLength(1) / 2) - 1] + calib_ratios[para_number, Convert.ToInt32((calib_ratios.GetLength(1) / 2))]) / 2; }
                else { mid_ratio = calib_ratios[para_number, Convert.ToInt32(calib_ratios.GetLength(1) / 2 - 0.5)]; }
                Debug.WriteLine("mid ratio is " + mid_ratio);
                Double best_ratio = best_parameters[para_number] / orig_par_value;
                Debug.WriteLine("best ratio is " + best_ratio);
                if (best_parameters[para_number] == calib_ratios[para_number, 0] * orig_par_value | best_parameters[para_number] == calib_ratios[para_number, calib_ratios.GetLength(1) - 1] * orig_par_value)
                {
                    //the best parameter ratio (and thus value) was on the edge of the range. We must shift our range sideways (we keep the same ratio between upper and lower ratio - are you still with me?)
                    Debug.WriteLine(" currentpara value was on edge of range");

                    for (int ratio = 0; ratio < calib_ratios.GetLength(1); ratio++)
                    {
                        Debug.WriteLine(" setting ratio " + calib_ratios[para_number, ratio] + " to " + calib_ratios[para_number, ratio] * (best_ratio / mid_ratio));
                        calib_ratios[para_number, ratio] = calib_ratios[para_number, ratio] * (best_ratio / mid_ratio);
                    }
                }
                else
                {
                    //the best parameter ratio (and thus value) NOT on the edge of the range. We must shift to the best observed value and then zoom IN
                    Debug.WriteLine(" currentpara value was NOT on edge of range");
                    for (int ratio = 0; ratio < calib_ratios.GetLength(1); ratio++)
                    {
                        Debug.Write(" setting ratio " + calib_ratios[para_number, ratio] + " to " );
                        calib_ratios[para_number, ratio] = best_ratio + (((calib_ratios[para_number, ratio]/mid_ratio)*best_ratio)-best_ratio)/ zoom_factor;
                        Debug.WriteLine(calib_ratios[para_number, ratio]);
                    }
                }
            }
            catch { Debug.WriteLine(" problem adapting parameters and ratios "); }
        }

        private void calib_prepare_report()
        {
            //this code prepares a calibration report
            //it opens and writes headers for a text file on disk
            string FILENAME = workdir + "\\calibration.log";
            using (StreamWriter sw = new StreamWriter(FILENAME))
            {
                try
                {
                    sw.Write("run error");
                    //USER INPUT NEEDED IN FOLLOWING LINE: ENTER THE CALIBRATION PARAMETER NAMES 
                    //THEY WILL BE HEADERS IN THE CALIBRATION REPORT
                    if (version_lux_checkbox.Checked)
                    {
                        sw.WriteLine(" erodibility_K");
                    }
                    if (version_Konza_checkbox.Checked)
                    {
                        sw.WriteLine(" erodibility_K potential_creep_kg P0 k1 k2 Pa");
                    }
                    if (version_CarboZALF_checkbox.Checked)
                    {
                        sw.WriteLine(" tillage_C");
                    }

                }
                catch { Debug.WriteLine(" issue with writing the header of the calibration log file"); }
            }
            Debug.WriteLine(" calib tst - calib_prepare_rep - added first line to file" + FILENAME);
        }

        private void calib_update_report(double objective_fnct_result)
        {
            //this code updates a calibration report
            //it writes parameters and objective function outcomes to disk
            string FILENAME = workdir + "\\calibration.log";
            using (StreamWriter sw = File.AppendText(FILENAME))
            {
                try
                {
                    //USER INPUT NEEDED IN FOLLOWING LINE: ENTER THE CALIBRATION PARAMETERS 

                    if (version_lux_checkbox.Checked)
                    {
                        sw.WriteLine(run_number + " " + objective_fnct_result + " " + advection_erodibility);
                    }
                    if (version_Konza_checkbox.Checked)
                    {
                        sw.WriteLine(run_number + " " + objective_fnct_result + " " + advection_erodibility + " " + potential_creep_kg_m2_y + " " + P0 + " " + k1 + " " + k2 + " " + Pa);
                    }
                    if(version_CarboZALF_checkbox.Checked)
                    {
                        sw.WriteLine(run_number + " " + objective_fnct_result + " " + tilc);
                    }

                }
                catch { Debug.WriteLine(" issue with writing a line in the calibration log file"); }
            }
            Debug.WriteLine(" calib tst - calib_update_rep - added line to file " + FILENAME);
        }

        private void calib_finish_report()
        {
            //this code closes a calibration report
            //it writes the parameters for the best run to disk
            //CALIB_USER : Change the number of parameters referenced (now two)
            Debug.WriteLine(" writing final line and closed file");
            try
            {
                string FILENAME = workdir + "\\calibration.log";
                using (StreamWriter sw = File.AppendText(FILENAME))
                {
                    if (version_lux_checkbox.Checked)
                    {
                        //sw.WriteLine(best_run + " " + best_error + " " + best_parameters[0] + " " + best_parameters[1]);
                        sw.WriteLine(best_run + " " + best_error + " " + best_parameters[0]);
                    }
                    if (version_Konza_checkbox.Checked)
                    {
                        sw.WriteLine(best_run + " " + best_error + " " + best_parameters[0] + " " + best_parameters[1] + " " + best_parameters[2] + " " + best_parameters[3] + " " + best_parameters[4]);
                    }
                    if(version_CarboZALF_checkbox.Checked)
                    {
                        sw.WriteLine(best_run + " " + best_error + " " + best_parameters[0]);
                    }

                    Debug.WriteLine(" best run was " + best_run + " with error " + best_error + "m3");
                }
                Debug.WriteLine(" calib tst - calib_finish_rep - wrote final line and closed file");
            }
            catch
            {
                Debug.WriteLine(" calib tst - calib_finish_rep - FAILED to write file");
            }
        }

        private double calib_objective_function_Lux()
        {
            //this code calculates the value of the objective function during calibration and is user-specified. 
            //calibration looks to minimize the value of the objective function by varying parameter values
            //CALIB_USER
            //example for Luxembourg: we want to simulate the correct amount of erosion, over the entire slope
            //Xia, number needs to be adapted
            double simulated_ero_m3 = 0;
            double simulated_ero_kg_m2_y = 0;
            double known_ero_kg_m2_y = 0.0313;
            double total_bulk_density = 0;
            double average_bulk_density_kg_m3 = 0;
            int objective_function_cells = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    if (dtm[row, col] != -9999)
                    {
                        simulated_ero_m3 -= sum_water_erosion[row, col] * dx * dx;
                        total_bulk_density += bulkdensity[row, col, 0];
                        objective_function_cells++;
                    }
                }
            }
            average_bulk_density_kg_m3 = total_bulk_density / objective_function_cells;
            //temporary hard fix to test if bulkdensities of 0 are throwing off our calculations 
            average_bulk_density_kg_m3 = 1560;
            simulated_ero_kg_m2_y = (average_bulk_density_kg_m3 * simulated_ero_m3) / (objective_function_cells * dx * dx) / end_time;
            ;
            Debug.WriteLine(" calib tst - calib_objective_function - error is " + Math.Abs(known_ero_kg_m2_y - simulated_ero_kg_m2_y) + "kg per m2 per year");
            return Math.Abs(known_ero_kg_m2_y - simulated_ero_kg_m2_y);

        }

        public static double[,] KernelDensityEstimation(double[] data, double sigma, int nsteps)
        {
            // from: https://gist.github.com/ksandric/e91860143f1dd378645c01d518ddf013 

            // probability density function (PDF) signal analysis
            // Works like ksdensity in mathlab. 
            // KDE performs kernel density estimation (KDE)on one - dimensional data
            // http://en.wikipedia.org/wiki/Kernel_density_estimation

            // Input:	-data: input data, one-dimensional
            //          -sigma: bandwidth(sometimes called "h")
            //          -nsteps: optional number of abscis points.If nsteps is an
            //          array, the abscis points will be taken directly from it. (default 100)
            // Output:	-x: equispaced abscis points
            //          -y: estimates of p(x)

            // This function is part of the Kernel Methods Toolbox(KMBOX) for MATLAB. 
            // http://sourceforge.net/p/kmbox
            // Converted to C# code by ksandric

            double[,] result = new double[nsteps, 2];
            double[] x = new double[nsteps], y = new double[nsteps];

            double MAX = Double.MinValue, MIN = Double.MaxValue;
            int N = data.Length; // number of data points

            // Find MIN MAX values in data
            for (int i = 0; i < N; i++)
            {
                if (MAX < data[i])
                {
                    MAX = data[i];
                }
                if (MIN > data[i])
                {
                    MIN = data[i];
                }
            }

            // Like MATLAB linspace(MIN, MAX, nsteps);
            x[0] = MIN;
            for (int i = 1; i < nsteps; i++)
            {
                x[i] = x[i - 1] + ((MAX - MIN) / nsteps);
            }

            // kernel density estimation
            double c = 1.0 / (Math.Sqrt(2 * Math.PI * sigma * sigma));
            for (int i = 0; i < N; i++)
            {
                for (int j = 0; j < nsteps; j++)
                {
                    y[j] = y[j] + 1.0 / N * c * Math.Exp(-(data[i] - x[j]) * (data[i] - x[j]) / (2 * sigma * sigma));
                }
            }

            // compilation of the X,Y to result. Good for creating plot(x, y)
            for (int i = 0; i < nsteps; i++)
            {
                result[i, 0] = x[i];
                result[i, 1] = y[i];
            }
            return result;
        }

        private double calib_function_CarboZALF_OSL(int row_cal, int col_cal, double sample_depth_from_fAh, double age_ref)
        {
            double depth_z, refdepth, penalty, dummy_penalty;
            int lay_cal;

            refdepth = dtm[row_cal, col_cal] - dtmchange_m[row_cal, col_cal] + sample_depth_from_fAh;
            depth_z = dtm[row_cal, col_cal];
            lay_cal = -1;
            dummy_penalty = end_time / (end_time - age_ref + 1); // Penalty for samples where colluvium is simulated too thin
                                                                 // Calculate penalty based on measured age relative to simulation time.
                                                                 // The older, the higher the penalty. Penalties are generally higher than the ones calculated below.
                                                                 // Penalty never below 1, made sure by adding 1 to the reference age
            
            // Select the layer that corresponds to the measured sample depth. 
            if (refdepth > depth_z)
            { // if measured sample is not present in the simulated colluvium, simulated colluvium too thin
                penalty = dummy_penalty;
            }
            else
            {
                lay_cal = 0;
                while (!(refdepth < depth_z & (refdepth >= (z - layerthickness_m[row_cal, col_cal, lay_cal]))))
                {
                    lay_cal++;
                    depth_z -= layerthickness_m[row_cal, col_cal, lay_cal];
                }
                // calculate age penalty
                try
                {
                    int[] ages_cal = OSL_grainages[row_cal, col_cal, lay_cal];
                    ages_cal = ages_cal.Where(e => e < start_age).ToArray(); // remove old grains from the selection, Focus on the younger grains. younger age is never larger thans tart_age, so it's a good reference point
                    double[] ages_cal_d = ages_cal.Select(x => (double)x).ToArray();

                    if (ages_cal_d.Length > 1)
                    {
                        double[,] density = KernelDensityEstimation(ages_cal_d, 1, Convert.ToInt32(Math.Round(ages_cal_d.Max() / 10)));

                        double[] density_prob = new double[density.GetLength(0)];
                        double[] density_value = new double[density.GetLength(0)]; ;
                        
                        for (int it = 0; it < density.GetLength(0); it++)
                        {
                            density_value[it] = density[it, 0];
                            density_prob[it] = density[it, 1];
                        }
                        int[] indices_prob = new int[density_value.Length];
                        for (int ii = 0; ii < density_value.Length; ii++) { indices_prob[ii] = ii; }
                        Array.Sort(density_prob, indices_prob);

                        double ages_mode = density_value[indices_prob[indices_prob.Length - 1]];

                        penalty = Math.Abs(ages_mode - age_ref) / age_ref;
                    }
                    else
                    {
                        if(ages_cal_d.Length == 1)
                        { // only one rejuvenated grain. Use that age as reference
                            penalty = Math.Abs(ages_cal_d[0] - age_ref) / age_ref;
                        }
                        else
                        {
                            // no grains present for this sample. This means the sample is too close to the surface (layer = 0), or there are no young grains (poor bleaching, non-eroded layer). So penalty is based on measured age
                            penalty = dummy_penalty;
                        }
                    }
                }
                catch
                {
                    Debug.WriteLine("Error in calculating age densities");
                    penalty = dummy_penalty;
                }

            }
            return (penalty);
        }
        private double calib_objective_function_CarboZALF()
        {
            //this code calculates the value of the objective function during calibration and is user-specified. 
            //calibration looks to minimize the value of the objective function by varying parameter values
            //CALIB_USER
            //example for Luxembourg: we want to simulate the correct amount of erosion, over the entire slope
            //Xia, number needs to be adapted
            bool calib_erodep = false;
            bool calib_OSL = true;
            bool calib_CN = false;
            bool calib_stabages = false;
            if (CarboZALF_calib_stabilizationages_checkbox.Checked) { calib_stabages = true; }
            double sim_ero_m = 0, obs_ero_m, sim_depo_m = 0, obs_depo_m, error_CZ = 0;
            int obj_fun_cells_ero = 0, obj_fun_cells_depo = 0;

            if (calib_erodep)
            {
                // calibration values derived from Van der Meij et al., 2017, approach 2c
                obs_ero_m = -0.30; // average for all eroding positions
                obs_depo_m = 0.51; // average  colluvium thickness
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999 & dtmchange_m[row, col] < 0)
                        {
                            sim_ero_m += dtmchange_m[row, col];
                            obj_fun_cells_ero++;
                        }
                        if (dtm[row, col] != -9999 & dtmchange_m[row, col] > 0)
                        {
                            sim_depo_m += dtmchange_m[row, col];
                            obj_fun_cells_depo++;
                        }
                    }
                }
                sim_ero_m /= obj_fun_cells_ero; // average elevation change in eroding locations
                sim_depo_m /= obj_fun_cells_depo; // average elevation change in deposition locations
                error_CZ = Math.Abs(((obs_ero_m - sim_ero_m) + (obs_depo_m - sim_depo_m)) / 2); // average error of erosion and deposition
            }
            if (calib_OSL)
            {
                double cum_age_error = 0;

                // Calculate reference depths from the former soil surface, not from the top of the colluvium, to prevent colluvial samples ending up in the former soil.
                // The selected methoid can result in measured sample located above the simulated colluvium. These will get a large penalty in the calibration 
                // This approach is better suited for deposition rates, because colluvium builds up from the bottom to the top

                if( calib_stabages) // calibration with mode of stabilization ages
                {
                    // calibration old colluvium ( > 300 a)
                    // Location P2
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.025, 3700); // NCL7317038
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.125, 3301); // NCL7317039
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.225, 2227); // NCL7317040

                    // Location P3
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.055, 1898); // NCL7317069
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.155, 1731); // NCL7317145
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.255, 1048); // NCL7317146

                    // calibration young colluvium (<= 300 a)
                    // Location P2
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.325, 120); // NCL7317041
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.425, 27); // NCL7317042
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.605, 18); // NCL7317068

                    // Location P3
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.355, 44); // NCL7317147
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.455, 40); // NCL7317070

                    // Location BP5
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.075, 159); // NCL7317062
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.175, 135); // NCL7317063
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.275, 99); // NCL7317064
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.375, 87); // NCL7317065
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.475, 73); // NCL7317066
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.575, 37); // NCL7317067

                    // Location BP6
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.045, 160); // NCL7317152
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.175, 136); // NCL7317153
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.305, 121); // NCL7317154
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.425, 103); // NCL7317155
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.545, 92); // NCL7317156

                    // Location BP8
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.045, 258); // NCL7317142
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.145, 227); // NCL7317148
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.245, 197); // NCL7317143
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.345, 139); // NCL7317149
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.445, 117); // NCL7317150
                }
                else // calibration with mode of measured ages
                {
                    // calibration old colluvium ( > 300 a)
                    // Location P2
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.025, 3832); // NCL7317038
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.125, 3606); // NCL7317039
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.225, 3895); // NCL7317040

                    // Location P3
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.055, 3265); // NCL7317069
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.155, 2650); // NCL7317145
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.255, 1425); // NCL7317146

                    // calibration young colluvium (<= 300 a)
                    // Location P2
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.325, 2170); // NCL7317041
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.425, 66); // NCL7317042
                    cum_age_error += calib_function_CarboZALF_OSL(14, 17, 0.605, 46); // NCL7317068

                    // Location P3
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.355, 41); // NCL7317147
                    cum_age_error += calib_function_CarboZALF_OSL(27, 17, 0.455, 44); // NCL7317070

                    // Location BP5
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.075, 170); // NCL7317062
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.175, 127); // NCL7317063
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.275, 87); // NCL7317064
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.375, 89); // NCL7317065
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.475, 75); // NCL7317066
                    cum_age_error += calib_function_CarboZALF_OSL(14, 23, 0.575, 58); // NCL7317067

                    // Location BP6
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.045, 201); // NCL7317152
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.175, 137); // NCL7317153
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.305, 136); // NCL7317154
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.425, 107); // NCL7317155
                    cum_age_error += calib_function_CarboZALF_OSL(17, 20, 0.545, 76); // NCL7317156

                    // Location BP8
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.045, 458); // NCL7317142
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.145, 282); // NCL7317148
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.245, 232); // NCL7317143
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.345, 146); // NCL7317149
                    cum_age_error += calib_function_CarboZALF_OSL(18, 22, 0.445, 126); // NCL7317150                   
                }
                error_CZ = cum_age_error;
            }
            Debug.WriteLine(" calib tst - calib_objective_function - error is " + error_CZ + " a in total");
            return Math.Abs(error_CZ);
        }


        private double domain_sum(string properties)
        {
            //Debug.WriteLine(properties);
            string[] lineArray = properties.Split(new char[] { ',' });
            int lyr; int x;
            double sum = 0;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {
                    for (lyr = 0; lyr < max_soil_layers; lyr++)
                    {
                        if (layerthickness_m[row, col, lyr] > 0)
                        {
                            for (x = 0; x < (lineArray.Length); x++)
                            {
                                if (lineArray[x] == "0") sum += texture_kg[row, col, lyr, 0];
                                if (lineArray[x] == "1") sum += texture_kg[row, col, lyr, 1];
                                if (lineArray[x] == "2") sum += texture_kg[row, col, lyr, 2];
                                if (lineArray[x] == "3") sum += texture_kg[row, col, lyr, 3];
                                if (lineArray[x] == "4") sum += texture_kg[row, col, lyr, 4];
                                if (lineArray[x] == "5") sum += young_SOM_kg[row, col, lyr];
                                if (lineArray[x] == "6") sum += old_SOM_kg[row, col, lyr];
                            }
                        }
                    }
                }
            }
            return sum;
        }

        private double calib_objective_function_Konza()
        {
            observations = new double[100, 100];         //may be used for other sets of observations as well
            string input;
            double tttt = 0.00;
            int x, y, xcounter;
            string localfile = "localcalresults.txt";
            string globalfile = "globalcalresults.txt";
            //string obsfile = "obst0b.txt";
            string obsfile = obsfile_textbox.Text;
            if (!File.Exists(obsfile))
            {
                MessageBox.Show("No such file: " + obsfile);
                return (-1);
            }
            StreamReader sr = File.OpenText(obsfile);
            //read header line (and do nothing with it)
            try
            {
                input = sr.ReadLine();
                //read the rest
                y = 0;
                while ((input = sr.ReadLine()) != null)
                {
                    //Debug.WriteLine(input);
                    string[] lineArray;
                    lineArray = input.Split(new char[] { ',' });
                    xcounter = 0;
                    for (x = 0; x < (lineArray.Length); x++)
                    {
                        //Debug.WriteLine(lineArray[x]);
                        if (lineArray[x] != "")
                        {
                            try
                            {
                                tttt = double.Parse(lineArray[x]);
                            }
                            catch
                            {
                                MessageBox.Show("Incorrect content " + lineArray[x] + " in file " + obsfile);
                                input_data_error = true;
                                return (-1);
                            }
                            //Debug.WriteLine("obs " + y + " " + xcounter + " = " + tttt);
                            observations[y, xcounter] = tttt;
                            xcounter++;
                        }
                    }
                    y++;

                }
                //Array.Resize(observations)
                sr.Close();
                //we now have the observations stored, and the output file prepared
            }
            catch { Debug.WriteLine(" failed to read all observations from file " + obsfile); input_data_error = true; }


            //this function evaluates model performance after every model run
            //we have observations[,] at our disposal, which contains values at all observed locations 

            Debug.WriteLine(" starting to evaluate performance using " + localfile);
            localfile = workdir + "\\" + localfile;
            globalfile = workdir + "\\" + globalfile;
            bool location_errors_requested = false;
            if (location_errors_requested)
            {
                if (!File.Exists(localfile))
                {
                    MessageBox.Show("No such observation file: " + localfile);
                    return (-1);
                }
            }
            /* if (!File.Exists(globalfile))
            {
                MessageBox.Show("No such observation file: " + globalfile);
                return (-1);
            } */
            //run, soildepth_e, SOMfract_e, coarsefract_e, clayfract_e, siltfract_e, sandfract_e, average_e
            int obsnumber = 0; int row = 0; int col = 0;
            double localdepth_error, SOM_error, coarse_error, clay_error, silt_error, sand_error;
            double totaldepth_error = 0;
            double SOM_error_depthproduct, coarse_error_depthproduct, sand_error_depthproduct, silt_error_depthproduct, clay_error_depthproduct;
            double all_locations_error = 0;
            double coarsesum, sandsum, siltsum, claysum, OMsum, coarsefract = 0, sandfract = 0, siltfract = 0, clayfract = 0, OMfract = 0, fineearthsum, allmasssum;
            double normal_OM_error, normal_coarse_error, normal_sand_error, normal_silt_error, normal_clay_error, location_error;
            try
            {
                for (row = 0; row < nr; row++)
                {
                    for (col = 0; col < nc; col++)
                    {
                        //Debug.WriteLine("rc " + row + " " + col + " obsnumber " + obsnumber + " next obsrow= " + observations[obsnumber, 0] + " col " + observations[obsnumber, 1]);
                        if (row == observations[obsnumber, 0] && col == observations[obsnumber, 1])
                        {
                            //in this case, we are in a cell where we also have an observation. Time to compare and calculate an error, first for the soil depth
                            localdepth_error = Math.Pow(Math.Abs(soildepth_m[row, 0] - observations[obsnumber, 2]) / (observations[obsnumber, 2] + soildepth_m[row, 0]), 2);
                            //and now for all other properties, where we need to take a complicated average over all layers:
                            SOM_error_depthproduct = 0; coarse_error_depthproduct = 0; sand_error_depthproduct = 0; silt_error_depthproduct = 0; clay_error_depthproduct = 0;
                            int obshorizon = 0;
                            int lyr = 0;
                            double lyr_end_depth_m = 0;
                            double lyr_begin_depth_m = 0;
                            double hor_end_depth_m = 0;
                            double hor_begin_depth_m = 0;
                            double overlap_m = 0;
                            bool horizonchanged = false;
                            //now calulate errors
                            while (layerthickness_m[row, col, lyr] > 0) // as long as we still have layers left
                            {

                                lyr_end_depth_m += layerthickness_m[row, col, lyr];  //we update how deep this layer ends
                                lyr_begin_depth_m = lyr_end_depth_m - layerthickness_m[row, col, lyr];
                                horizonchanged = false;
                                try
                                {
                                    while (observations[obsnumber, 3 + 6 * obshorizon] > 0 && !(lyr_begin_depth_m > observations[obsnumber, 3 + 6 * obshorizon]))
                                    {
                                        horizonchanged = false;
                                        //Debug.WriteLine(" now depth " + lyr_end_depth_m + " obshorizon " + obshorizon + " compared to obs depth " + observations[obsnumber, (3 + 6 * obshorizon)]);
                                        if (lyr_end_depth_m > observations[obsnumber, (3 + 6 * obshorizon)])
                                        {
                                            overlap_m = layerthickness_m[row, col, lyr] + (observations[obsnumber, (3 + 6 * obshorizon)] - lyr_end_depth_m);
                                        }
                                        else
                                        {
                                            overlap_m = layerthickness_m[row, col, lyr];
                                        }
                                        //Debug.WriteLine(" overlap depth = " + overlap_m);
                                        SOM_error = Math.Abs(((young_SOM_kg[row, col, lyr] + old_SOM_kg[row, col, lyr]) / total_layer_fine_earth_om_mass_kg(row, col, lyr)) - observations[obsnumber, 4 + 6 * obshorizon]);
                                        coarse_error = Math.Abs((texture_kg[row, col, lyr, 0] / total_layer_mineral_earth_mass_kg(row, col, lyr)) - observations[obsnumber, 5 + 6 * obshorizon]);
                                        sand_error = Math.Abs((texture_kg[row, col, lyr, 1] / total_layer_fine_earth_mass_kg(row, col, lyr)) - observations[obsnumber, 6 + 6 * obshorizon]);
                                        silt_error = Math.Abs((texture_kg[row, col, lyr, 2] / total_layer_fine_earth_mass_kg(row, col, lyr)) - observations[obsnumber, 7 + 6 * obshorizon]);
                                        clay_error = Math.Abs(((texture_kg[row, col, lyr, 3] + texture_kg[row, col, lyr, 4]) / total_layer_fine_earth_mass_kg(row, col, lyr)) - observations[obsnumber, 8 + 6 * obshorizon]);
                                        //now normalize and add the errors to the error depth products, but account for the fact that only a fraction of this layer was decsribed in this observed horizon
                                        SOM_error_depthproduct += SOM_error * overlap_m;
                                        coarse_error_depthproduct += coarse_error * overlap_m;
                                        sand_error_depthproduct += sand_error * overlap_m;
                                        silt_error_depthproduct += silt_error * overlap_m;
                                        clay_error_depthproduct += clay_error * overlap_m;

                                        if (lyr_end_depth_m > observations[obsnumber, (3 + 6 * obshorizon)])
                                        {
                                            obshorizon++; horizonchanged = true;
                                            //Debug.WriteLine(" moved to next obshorizon : " + obshorizon);
                                            //Debug.WriteLine(" now depth " + lyr_end_depth_m + " obshorizon " + obshorizon + " compared to obs depth " + observations[obsnumber, (3 + 6 * obshorizon)]);
                                        }
                                        else
                                        {
                                            //Debug.WriteLine(" breaking out, going for next layer "); 
                                            break;
                                        }
                                        //alternative ways to calculate all these errors:
                                        //clay_error_depthproduct += clay_error / observations[obsnumber, 8 + 6 * obshorizon] * overlap_m;  / has the disadvantage that if observations[,] = 0, the error is INF
                                        //clay_error_depthproduct += clay_error / ((((texture_kg[row, col, lyr, 3] + texture_kg[row, col, lyr, 4]) / total_layer_fine_earth_mass_kg(row, col, lyr))/2) 
                                        //the one above divides by the mean of obs and sim, which may still be zero, but then the error was also zero. Not sure what that results in, but possibly still unstable
                                        //Debug.WriteLine(" obshorizon now " + obshorizon + " with depth " + observations[obsnumber, 3 + 6 * obshorizon] + " lyr " + lyr + " begin " + lyr_begin_depth_m + " end " + lyr_end_depth_m);
                                    }
                                }
                                catch { Debug.WriteLine("error - failed during calculation of local errors "); }
                                //Debug.WriteLine(" no more horizons eligible or available after hor " + obshorizon + " lyr now " + lyr + " end depth " + lyr_end_depth_m);
                                if (horizonchanged == false)
                                {
                                    lyr++;
                                    //Debug.WriteLine(" increased layer to " + lyr); 
                                }
                                if (lyr == max_soil_layers) { break; }

                            }
                            //Debug.WriteLine("rc" + row + col + " no more layers left after lyr " + lyr);
                            //we now calculated, normalized and depth_summed all errors. Dividing by depth and adding up is the next step
                            normal_OM_error = SOM_error_depthproduct / lyr_end_depth_m;
                            normal_coarse_error = coarse_error_depthproduct / lyr_end_depth_m;
                            normal_sand_error = sand_error_depthproduct / lyr_end_depth_m;
                            normal_silt_error = silt_error_depthproduct / lyr_end_depth_m;
                            normal_clay_error = clay_error_depthproduct / lyr_end_depth_m;
                            //if there was no  simulated layer at all, we just divided by zero up here, and should replace the NaN with a large value
                            int largereplacementerror = 100;
                            if (Double.IsNaN(localdepth_error)) { localdepth_error = largereplacementerror; }
                            if (Double.IsNaN(normal_OM_error)) { normal_OM_error = largereplacementerror; }
                            if (Double.IsNaN(normal_coarse_error)) { normal_coarse_error = largereplacementerror; }
                            if (Double.IsNaN(normal_sand_error)) { normal_sand_error = largereplacementerror; }
                            if (Double.IsNaN(normal_silt_error)) { normal_silt_error = largereplacementerror; }
                            if (Double.IsNaN(normal_clay_error)) { normal_clay_error = largereplacementerror; }
                            location_error = (localdepth_error + normal_OM_error + normal_coarse_error + normal_sand_error + normal_silt_error + normal_clay_error) / 6;
                            all_locations_error += location_error;
                            Debug.WriteLine(row + " " + col + " " + location_error + "  " + all_locations_error + " " + localdepth_error);
                            totaldepth_error += localdepth_error;

                            double NBW=0;
                            if (bedrock_weathering_active)
                            {
                                if (bedrock_weathering_m[row, col] < 0) //MMS to prevent negative bedrock weathering production
                                {
                                    NBW = 1;
                                }
                                else
                                {
                                    NBW = 0;
                                }
                            }

                            //write this to file for this location
                            
                            if (location_errors_requested)
                            {
                                using (StreamWriter sw = new StreamWriter(localfile, true))
                                {
                                    //sw.Write(run + "," + row + "," + col + "," + location_error + "," + totaldepth_error + "," + normal_OM_error + "," + normal_coarse_error + "," + normal_sand_error + "," + normal_silt_error + "," + normal_clay_error); //MMS_eva
                                    sw.Write(run_number + "," + row + "," + col + "," + location_error + "," + localdepth_error + "," + normal_OM_error + "," + normal_coarse_error + "," + normal_sand_error + "," + normal_silt_error + "," + normal_clay_error + "," + advection_erodibility + "," + potential_creep_kg_m2_y + "," + P0 + "," + k1 + "," + k2 + "," + NBW); //MMS_eva
                                    sw.Write("\r\n");
                                    sw.Close();
                                }
                            }
                            obsnumber++;
                            //Debug.WriteLine("increased obsnumber to " + obsnumber);
                        }
                        else
                        { //do nothing , this is a cell where we have no observations so it gets ignored
                        }
                    }

                }
            }
            catch { Debug.WriteLine("error - failed during calculation of initial errors "); }
            //we now know the sum of normalized errors for all locations. Divide by number of observations (=locations) to compare with errors in the depth-averages for the entire area
            all_locations_error /= obsnumber;
            try
            {
                //the average values of the SOM and texture fractions across ALL rows and cols are calculated in a separate function domain_sum, which takes a peculiar input:
                //a string of all properties separated by comma's. 
                coarsesum = domain_sum($"{0}");
                sandsum = domain_sum($"{1}");
                siltsum = domain_sum($"{2}");
                claysum = domain_sum("3,4");
                OMsum = domain_sum("5,6");
                fineearthsum = domain_sum("1,2,3,4,5,6");
                allmasssum = domain_sum("0,1,2,3,4,5,6");
                coarsefract = coarsesum / allmasssum;
                sandfract = sandsum / fineearthsum;
                siltfract = siltsum / fineearthsum;
                clayfract = claysum / fineearthsum;
                OMfract = OMsum / fineearthsum;
            }
            catch { Debug.WriteLine("  failed during calculation of simulated domain sums"); }
            //the average values of the observations are calculated here
            double OM_obs_depth_sum = 0, coarse_obs_depth_sum = 0, sand_obs_depth_sum = 0, silt_obs_depth_sum = 0, clay_obs_depth_sum = 0, depth_sum = 0;
            double OM_obs_fract = 0, coarse_obs_fract = 0, sand_obs_fract = 0, silt_obs_fract = 0, clay_obs_fract = 0;
            try
            {
                for (i = 0; i < observations.GetLength(0); i++)
                {
                    for (j = 1; j < (observations.GetLength(1) - 3) / 6; j++)
                    {
                        if (observations[i, (j - 1) * 6 + 3] > 0)
                        {   // in other words, if this horizon exists.
                            //Debug.WriteLine(" adding horizon " + j + " from location " + i);
                            OM_obs_depth_sum += observations[i, (j - 1) * 6 + 4] * observations[i, (j - 1) * 6 + 3];
                            coarse_obs_depth_sum += observations[i, (j - 1) * 6 + 5] * observations[i, (j - 1) * 6 + 3];
                            sand_obs_depth_sum += observations[i, (j - 1) * 6 + 6] * observations[i, (j - 1) * 6 + 3];
                            silt_obs_depth_sum += observations[i, (j - 1) * 6 + 7] * observations[i, (j - 1) * 6 + 3];
                            clay_obs_depth_sum += observations[i, (j - 1) * 6 + 8] * observations[i, (j - 1) * 6 + 3];
                            depth_sum += observations[i, (j - 1) * 6 + 3];
                        }
                    }
                }
                Debug.WriteLine(" finished adding observations ");
            }
            catch { Debug.WriteLine(" error - failed during calculation of observed domain sums"); }
            OM_obs_fract = OM_obs_depth_sum / depth_sum;
            coarse_obs_fract = coarse_obs_depth_sum / depth_sum;
            sand_obs_fract = sand_obs_depth_sum / depth_sum;
            silt_obs_fract = silt_obs_depth_sum / depth_sum;
            clay_obs_fract = clay_obs_depth_sum / depth_sum;
            normal_OM_error = Math.Abs(OMfract - OM_obs_fract) / OM_obs_fract;
            normal_coarse_error = Math.Abs(coarsefract - coarse_obs_fract) / coarse_obs_fract;
            normal_sand_error = Math.Abs(sandfract - sand_obs_fract) / sand_obs_fract;
            normal_silt_error = Math.Abs(siltfract - silt_obs_fract) / silt_obs_fract;
            normal_clay_error = Math.Abs(clayfract - clay_obs_fract) / clay_obs_fract;
            double entire_domain_error = (normal_OM_error + normal_coarse_error + normal_sand_error + normal_silt_error + normal_clay_error) / 5;
            /*using (StreamWriter sw = new StreamWriter(globalfile, true))
            {
                sw.Write(run_number + "," + all_locations_error + "," + entire_domain_error + "," + (all_locations_error + entire_domain_error) / 2 + "," + totaldepth_error / observations.GetLength(0) + "," + advection_erodibility + "," + potential_creep_kg + "," + P0 + "," + k1 + "," + k2);
                sw.Write("\r\n");
                sw.Close();
            }
            Debug.WriteLine("calculated and saved errors for run number" + run_number);
            */
            return ((all_locations_error + entire_domain_error) / 2);
        }

        private void calib_update_best_paras()
        {
            //this code updates the recorded set of parameter values that gives the best score for the objective function
            //USERS have to update code here to reflect the parameters they actually vary

            // add/change lines below
            if (version_lux_checkbox.Checked)
            {
                best_parameters[0] = advection_erodibility;
            }
            if (version_Konza_checkbox.Checked)
            {
                //Konza Marte:
                best_parameters[0] = advection_erodibility;
                best_parameters[1] = potential_creep_kg_m2_y;
                best_parameters[2] = P0;
                best_parameters[3] = k1;
                best_parameters[4] = k2;
            }
            if (version_CarboZALF_checkbox.Checked)
            {
                best_parameters[0] = tilc;
            }
            Debug.WriteLine(" updated parameter set for best scored run");
        }

        #endregion

        #region top level code
        private TaskScheduler guiThread; //Store reference of UI Thread for updating UI Text/labels later (slow, use sparingly)
        private void main_loop(object sender, System.EventArgs e)
        {
            //This allows GUI to be responsive so you can move it around
            guiThread = TaskScheduler.FromCurrentSynchronizationContext(); //have reference to main thread (UI thread)
            var options = TaskCreationOptions.LongRunning;
            var StartThread = Task.Factory.StartNew(() =>  //send simulation work on background thread
            {
                main_loop_code(); //start simulation work on background thread
            }, CancellationToken.None, options, TaskScheduler.Default);
        }
        //test commit 1
        private void main_loop_code()
        {
            //use this example for accessing the UI thread to update any GUI labels :
            Task.Factory.StartNew(() => { this.InfoStatusPanel.Text = "Entered main program"; }, CancellationToken.None, TaskCreationOptions.None, guiThread);

            stopwatch = Stopwatch.StartNew();
            try
            {
                //foreach (string dtmfilename in Directory.EnumerateFiles(this.dtm_input_filename_textbox.Text, "*.txt", SearchOption.TopDirectoryOnly)) //"*.asc"
                //{
                string dtmfilename = dtm_input_filename_textbox.Text;
                Debug.WriteLine("Entered LORICA main code with " + dtmfilename);
                string[] separate = dtmfilename.Split('.');
                workdir = separate[0];
                Debug.WriteLine("storing results in " + workdir);
                System.IO.Directory.CreateDirectory(workdir);
                input_data_error = false;

                try { end_time = int.Parse(Number_runs_textbox.Text); }
                catch { input_data_error = true; MessageBox.Show("Invalid number of years"); }
                
                if(Regular_output_checkbox.Checked)
                {
                    try { output_time = int.Parse(Box_years_output.Text); }
                    catch { input_data_error = true; MessageBox.Show("Invalid number of output years"); }
                }
                                                
                try { max_soil_layers = int.Parse(textbox_max_soil_layers.Text); }
                catch { input_data_error = true; MessageBox.Show("Invalid number of soil layers"); }
                try { dz_standard = double.Parse(textbox_layer_thickness.Text); }
                catch { input_data_error = true; MessageBox.Show("Invalid standard thickness of soil layers"); }

                try { ntr = System.Convert.ToInt32(end_time); }     // WVG initialise ntr: number of rows in timeseries matrix   
                catch (OverflowException)
                {
                    MessageBox.Show("number of timesteps is outside the range of the Int32 type.");
                }
                //WVG initialise ntr, nr of timesteps, can be changed to nr of output timesteps
                numfile = 1;
                if (Water_ero_checkbox.Checked)
                {
                    water_ero_active = true;
                }
                if (Tillage_checkbox.Checked)
                {
                    tillage_active = true;
                }
                if (blocks_active_checkbox.Checked)
                {
                    blocks_active = 1;
                }
                if (Landslide_checkbox.Checked)
                {
                    landslide_active = true;
                }
                if (creep_active_checkbox.Checked)
                {
                    creep_active = true;
                }
                if (Biological_weathering_checkbox.Checked)
                {
                    bedrock_weathering_active = true;
                }
                if (Frost_weathering_checkbox.Checked)
                {
                    frost_weathering_active = true;
                }
                if (tilting_active_checkbox.Checked)
                {
                    tilting_active = true;
                }
                if (uplift_active_checkbox.Checked)
                {
                    uplift_active = true;
                }
                if (soil_phys_weath_checkbox.Checked)
                {
                    soil_phys_weath_active = true;
                }
                if (soil_chem_weath_checkbox.Checked)
                {
                    soil_chem_weath_active = true;
                }
                if (soil_bioturb_checkbox.Checked)
                {
                    soil_bioturb_active = true;
                }
                if (soil_clay_transloc_checkbox.Checked)
                {
                    soil_clay_transloc_active = true;
                }
                if (soil_carbon_cycle_checkbox.Checked) //:)
                {
                    soil_carbon_active = true;
                }

                //INPUTS
                //GENERAL INPUTS
                //Entry point for consecutive runs for sensitivity analyses or calibration 
                maxruns = 1;
                int currentlevel = 0;

                if (Calibration_button.Checked == true)
                {
                    int runs_per_level = 0;
                    //CALIB_USER INPUT NEEDED NEXT LINE IN THE CODE :
                    try
                    {
                        user_specified_number_of_calibration_parameters = Convert.ToInt32(num_cal_paras_textbox.Text);
                    }
                    catch
                    {
                        Debug.WriteLine(" problem setting number of parameters for calibration ");
                    }
                    best_error = 99999999999; //or any other absurdly high number
                    best_parameters = new double[user_specified_number_of_calibration_parameters];
                    user_specified_number_of_ratios = calibration_ratios_textbox.Text.Split(';').Length;
                    runs_per_level = Convert.ToInt32(Math.Pow(user_specified_number_of_ratios, user_specified_number_of_calibration_parameters));
                    calib_ratios = new double[user_specified_number_of_calibration_parameters, user_specified_number_of_ratios];
                    original_ratios = new double[user_specified_number_of_ratios];
                    for (int rat = 0; rat < user_specified_number_of_ratios; rat++)
                    {
                        try
                        {
                            original_ratios[rat] = Convert.ToDouble(calibration_ratios_textbox.Text.Split(';')[rat]);
                            for (int par = 0; par < user_specified_number_of_calibration_parameters; par++)
                            {
                                calib_ratios[par, rat] = Convert.ToDouble(calibration_ratios_textbox.Text.Split(';')[rat]);
                            }
                        }
                        catch { Debug.WriteLine(" problem setting original parameter ratios for calibration "); }
                    }
                    calib_calculate_maxruns(user_specified_number_of_calibration_parameters);
                    Debug.WriteLine(" starting " + maxruns + " calibration runs");
                    calib_prepare_report();
                }
                if (Sensitivity_button.Checked == true)
                { //dev needed
                }
                //PARALLEL THREADS
                NumParallelThreads = Convert.ToInt32(uxNumberThreadsUpdown.Value);  //update number of Parallel Threads chosen in GUI		


                for (run_number = 0; run_number < maxruns; run_number++) //Maxruns Loop()
                {



                    //WATER EROSION AND DEPOSITION PARAMETERS
                    if (water_ero_active)
                    {
                        try { m = double.Parse(parameter_m_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter m is not valid"); }                      // Kirkby's m and n factors for increasing
                        try { n = double.Parse(parameter_n_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter n is not valid"); }                   // sheet, wash, overland, gully to river flow
                        try { conv_fac = double.Parse(parameter_conv_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter p is not valid"); }
                        try { advection_erodibility = double.Parse(parameter_K_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter K is not valid"); }
                        try { bio_protection_constant = double.Parse(bio_protection_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { rock_protection_constant = double.Parse(rock_protection_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { constant_selective_transcap = double.Parse(selectivity_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                        try { erosion_threshold_kg = double.Parse(erosion_threshold_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P is not valid"); }
                    }

                    //TILLAGE PARAMETERS
                    if (tillage_active)
                    {
                        try { plough_depth = double.Parse(parameter_ploughing_depth_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter plough depth is not valid"); }
                        try { tilc = double.Parse(parameter_tillage_constant_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tillage constant is not valid"); }
                    }

                    //BLOCK PARAMETERS
                    if (blocks_active == 1)
                    {
                        try { hardlayerelevation_m = Int32.Parse(hardlayerelevation_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { hardlayerthickness_m = Int32.Parse(hardlayerthickness_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }
                        try { hardlayer_weath_contrast = Double.Parse(hardlayerweath_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { hardlayerdensity_kg_m3 = Int32.Parse(hardlayerdensity_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }

                        try { blocksizethreshold_m = Single.Parse(blocksize_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block size threshold is not valid"); }
                        try { blockweatheringratio = Single.Parse(blockweath_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter block weathering fraction is not valid"); }
                    }

                    //CREEP PARAMETER
                    if (creep_active)
                    {
                        try { potential_creep_kg_m2_y = double.Parse(parameter_diffusivity_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter potential_creep_kg_m2_y is not valid"); }
                        try { bioturbation_depth_decay_constant = Convert.ToDouble(bioturbation_depth_decay_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for creep depth dependence (from BIOTURBATION) is not valid"); }
                    }

                    //LANDSLIDE PARAMETERS
                    if (landslide_active)
                    {
                        conv_fac = 4;        // multiple flow conversion factor
                    }

                    //Bio Weathering PARAMETERS
                    if (bedrock_weathering_active)
                    {
                        try { P0 = double.Parse(parameter_P0_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter P0 is not valid"); }
                        try { k1 = double.Parse(parameter_k1_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter k1 is not valid"); }
                        try { k2 = double.Parse(parameter_k2_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter k2 is not valid"); }
                        try { Pa = double.Parse(parameter_Pa_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter Pa is not valid"); }
                    }

                    //Tilting parameters
                    if (tilting_active)
                    {
                        if (radio_tilt_col_zero.Checked) { tilt_location = 0; }
                        if (radio_tilt_row_zero.Checked) { tilt_location = 1; }
                        if (radio_tilt_col_max.Checked) { tilt_location = 2; }
                        if (radio_tilt_row_max.Checked) { tilt_location = 3; }
                        try { tilt_intensity = double.Parse(Tilting_rate_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                    }

                    //Uplift parameters
                    if (uplift_active)
                    {
                        if (radio_lift_row_less_than.Checked) { lift_type = 0; }
                        if (radio_lift_row_more_than.Checked) { lift_type = 1; }
                        if (radio_lift_col_less_than.Checked) { lift_type = 2; }
                        if (radio_lift_row_more_than.Checked) { lift_type = 3; }
                        if (lift_type == 0)
                        {
                            try { lift_location = int.Parse(text_lift_row_less.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 1)
                        {
                            try { lift_location = int.Parse(text_lift_row_more.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 2)
                        {
                            try { lift_location = int.Parse(text_lift_col_less.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        if (lift_type == 3)
                        {
                            try { lift_location = int.Parse(text_lift_col_more.Text); }
                            catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                        }
                        try { lift_intensity = double.Parse(Uplift_rate_textbox.Text); }
                        catch { input_data_error = true; MessageBox.Show("value for parameter tilting rate is not valid"); }
                    }

                    // TREE FALL PARAMETERS
                    if (treefall_checkbox.Checked)
                    {
                        W_m_max = System.Convert.ToDouble(tf_W.Text);
                        D_m_max = System.Convert.ToDouble(tf_D.Text);
                        growth_a_max = System.Convert.ToInt32(tf_growth.Text);
                        age_a_max = System.Convert.ToInt32(tf_age.Text);
                        tf_frequency = System.Convert.ToDouble(tf_freq.Text);
                    }

                    //SOIL PHYSICAL WEATHERING PARAMETERS
                    if (soil_phys_weath_active)
                    {
                        try
                        {
                            physical_weathering_constant = Convert.ToDouble(Physical_weath_C1_textbox.Text);
                            Cone = Convert.ToDouble(physical_weath_constant1.Text);
                            Ctwo = Convert.ToDouble(physical_weath_constant2.Text);
                            //the upper sizes of particle for the different fractions are declared in initialise_soil because they are always needed
                            // Debug.WriteLine("succesfully read parameters for pysical weathering");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for pysical weathering");
                        }
                    }

                    //SOIL CHEMICAL WEATHERING PARAMETERS
                    if (soil_chem_weath_active)
                    {
                        try
                        {
                            chemical_weathering_constant = Convert.ToDouble(chem_weath_rate_constant_textbox.Text);
                            Cthree = Convert.ToDouble(chem_weath_depth_constant_textbox.Text);
                            Cfour = Convert.ToDouble(chem_weath_specific_coefficient_textbox.Text);
                            specific_area[0] = Convert.ToDouble(specific_area_coarse_textbox.Text);
                            specific_area[1] = Convert.ToDouble(specific_area_sand_textbox.Text);
                            specific_area[2] = Convert.ToDouble(specific_area_silt_textbox.Text);
                            specific_area[3] = Convert.ToDouble(specific_area_clay_textbox.Text);
                            specific_area[4] = Convert.ToDouble(specific_area_fine_clay_textbox.Text);
                            neoform_constant = Convert.ToDouble(clay_neoform_constant_textbox.Text);
                            Cfive = Convert.ToDouble(clay_neoform_C1_textbox.Text);
                            Csix = Convert.ToDouble(clay_neoform_C2_textbox.Text);
                            // Debug.WriteLine("succesfully read parameters for chemical weathering");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for chemical weathering");
                        }
                    }

                    //SOIL CLAY DYNAMICS PARAMETERS
                    if (soil_clay_transloc_active)
                    {
                        try
                        {
                            max_eluviation = Convert.ToDouble(maximum_eluviation_textbox.Text);
                            Cclay = Convert.ToDouble(eluviation_coefficient_textbox.Text);
                            // Debug.WriteLine("succesfully read parameters for  clay dynamics");
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for clay dynamics");
                        }
                        if (CT_depth_decay_checkbox.Checked)
                        {
                            try
                            {
                                ct_depthdec = Convert.ToDouble(ct_depth_decay.Text);
                            }
                            catch
                            {
                                input_data_error = true; Debug.WriteLine("problem reading depth decay parameter for clay dynamics");
                            }
                        }
                    }

                    //BIOTURBATION PARAMETERS
                    if (soil_bioturb_active)
                    {
                        try
                        {
                            potential_bioturbation_kg_m2_y = Convert.ToDouble(potential_bioturbation_textbox.Text); // MvdM changed name to match parameter in BT process
                            bioturbation_depth_decay_constant = Convert.ToDouble(bioturbation_depth_decay_textbox.Text);
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for bioturbation");
                        }
                    }

                    //CARBON CYCLE PARAMETERS
                    if (soil_carbon_active)
                    {
                        try
                        {
                            potential_OM_input = Convert.ToDouble(carbon_input_textbox.Text);
                            OM_input_depth_decay_constant = Convert.ToDouble(carbon_depth_decay_textbox.Text);
                            humification_fraction = Convert.ToDouble(carbon_humification_fraction_textbox.Text);
                            potential_young_decomp_rate = Convert.ToDouble(carbon_y_decomp_rate_textbox.Text);
                            potential_old_decomp_rate = Convert.ToDouble(carbon_o_decomp_rate_textbox.Text);
                            young_depth_decay_constant = Convert.ToDouble(carbon_y_depth_decay_textbox.Text);
                            old_CTI_decay_constant = Convert.ToDouble(carbon_o_twi_decay_textbox.Text);
                            old_depth_decay_constant = Convert.ToDouble(carbon_o_depth_decay_textbox.Text);
                            young_CTI_decay_constant = Convert.ToDouble(carbon_y_twi_decay_textbox.Text);
                        }
                        catch
                        {
                            input_data_error = true; Debug.WriteLine("problem reading parameters for carbon cycle");
                        }
                    }

                    if (input_data_error == false)
                    {
                        try
                        {
                            //Debug.WriteLine("reading general values");
                            if (check_space_soildepth.Checked != true)
                            {
                                try { soildepth_value = double.Parse(soildepth_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter soildepth is not valid"); }
                            }
                            if (check_space_landuse.Checked != true && check_time_landuse.Checked != true)
                            {
                                try { landuse_value = int.Parse(landuse_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter landuse is not valid"); }
                            }
                            if (check_space_evap.Checked != true && check_time_evap.Checked != true)
                            {
                                try { evap_value_m = double.Parse(evap_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter evapotranspiration is not valid"); }
                            }
                            if (check_space_infil.Checked != true && check_time_infil.Checked != true)
                            {

                                try { infil_value_m = double.Parse(infil_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter infiltration is not valid"); }
                            }
                            if (check_space_rain.Checked != true && check_time_rain.Checked != true)
                            {

                                try { rain_value_m = double.Parse(rainfall_constant_value_box.Text); }

                                catch { MessageBox.Show("value for parameter rainfall is not valid"); }
                            }

                            if (check_time_T.Checked != true)

                            {
                                try { temp_value_C = int.Parse(temp_constant_value_box.Text); }
                                catch { MessageBox.Show("value for parameter temperature is not valid"); }
                            }
                        }
                        catch { MessageBox.Show("there was a problem reading input values"); input_data_error = true; }


                        try
                        {
                            filename = dtmfilename;             //for directory input
                            dtm_file(filename);                 // from dtm_file(), almost all memory for the model is claimed
                            
                        }
                        catch { Debug.WriteLine(" failed to initialise dtm matrices"); }
                        try { initialise_once(); } // reading input files
                        catch { MessageBox.Show("there was a problem reading input files "); input_data_error = true; }

                        Task.Factory.StartNew(() =>
                        {
                            this.ScenarioStatusPanel.Text = "scen " + (run_number + 1) + "/" + maxruns;
                        }, CancellationToken.None, TaskCreationOptions.None, guiThread);

                        if (input_data_error == false)
                        {
                            
                             try { dtm_file_test(dtmfilename); }              // from dtm_file(), almost all memory for the model is claimed

                            catch { Debug.WriteLine(" failed to reset dtm "); }


                            try { initialize_once_testing(); }  // Reset Memory values instead of Allocating new memory
                            catch { MessageBox.Show("there was a problem reading input files and resetting values "); input_data_error = true; }
                            


                            //CALIB_USER: multiply parameter values with current ratio
                            //Note the correspondence between the formulas. Change only 1 value for additional parameters!
                            


                            if (Calibration_button.Checked == true)
                            {
                                if (version_lux_checkbox.Checked)
                                {
                                    int rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 0)) % user_specified_number_of_ratios);
                                    advection_erodibility *= calib_ratios[0, rat_number];
                                    Debug.WriteLine("First ratio number: " + rat_number + " adv_ero now " + advection_erodibility + " ratio " + calib_ratios[0, rat_number]);
                                }
                                if (version_Konza_checkbox.Checked)
                                {
                                    int rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 0)) % user_specified_number_of_ratios);
                                    advection_erodibility *= calib_ratios[0, rat_number];
                                    rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 1)) % user_specified_number_of_ratios);
                                    potential_creep_kg_m2_y *= calib_ratios[1, rat_number];
                                    rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 2)) % user_specified_number_of_ratios);
                                    P0 *= calib_ratios[2, rat_number];
                                    rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 3)) % user_specified_number_of_ratios);
                                    k1 *= calib_ratios[3, rat_number];
                                    rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 4)) % user_specified_number_of_ratios);
                                    k2 *= calib_ratios[4, rat_number];
                                }
                                if(version_CarboZALF_checkbox.Checked)
                                {
                                    int rat_number = Convert.ToInt32(Math.Floor(run_number / Math.Pow(user_specified_number_of_ratios, 0)) % user_specified_number_of_ratios);
                                    tilc *= calib_ratios[0, rat_number];
                                    Debug.WriteLine("First ratio number: " + rat_number + " tilc now " + tilc + " ratio " + calib_ratios[0, rat_number]);

                                }

                            }

                            timeseries_matrix = new double[System.Convert.ToInt32(end_time), number_of_outputs];
                            Debug.WriteLine("Created timeseries matrix with " + System.Convert.ToInt32(end_time) + " rows and " + number_of_outputs + " columns");
                            if (input_data_error == false)
                            {
                                if (input_data_error == false)
                                {
                                    int count_intervene = 0;
                                    if (checkbox_t_intervene.Checked)
                                    {
                                        t_intervene = int.Parse(textbox_t_intervene.Text);
                                    }
                                    if (t_intervene > 0) { read_soil_elevation_distance_from_output(t_intervene, workdir); }

                                    for (t = t_intervene; t < end_time; t++)
                                    {

                                        try
                                        {

                                            every_timestep();
                                        }
                                        catch
                                        {
                                            Debug.WriteLine("failed to run in timestep " + t);
                                            // Catch for when the model crashes due to unknown reasons. The model will read the latest output and start calculating again from there which I named an intervention). When the crash occurs five times, the model breaks MM
                                            if (count_intervene < 5)
                                            {
                                                count_intervene += 1;
                                                t_intervene = t - (t % output_time);
                                                Debug.WriteLine("intervening at t" + t_intervene);
                                                read_soil_elevation_distance_from_output(t_intervene, workdir);
                                            }
                                            else
                                            {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (input_data_error == true)
                        {
                            MessageBox.Show("input data error - program can not yet run");
                            tabControl1.Visible = true;
                        }

                        if (Calibration_button.Checked == true)
                        {
                            //calculate how good this run was:                          
                            double current_error = -1;
                            if (version_lux_checkbox.Checked)
                            {
                                current_error = calib_objective_function_Lux();
                            }
                            if (version_Konza_checkbox.Checked)
                            {
                                current_error = calib_objective_function_Konza();
                            }
                            if(version_CarboZALF_checkbox.Checked)
                            {
                                current_error = calib_objective_function_CarboZALF();
                            }
                            if (current_error == -1)
                            {
                                Debug.WriteLine(" no error calculated during calibration ");
                            }

                            //store that information along with the parameter values used to achieve it:
                            calib_update_report(current_error);
                            if (current_error < best_error) { best_error = current_error; calib_update_best_paras(); best_run = run_number; }
                            //and check whether one 'level' of calibration has finished. If so, we have to change parameter values
                            Debug.WriteLine("run " + run_number + " number paras " + user_specified_number_of_calibration_parameters + " number ratios " + calibration_ratios_textbox.Text.Split(';').Length);
                            if ((run_number + 1) % Convert.ToInt32(Math.Pow(calibration_ratios_textbox.Text.Split(';').Length, user_specified_number_of_calibration_parameters)) == 0)
                            {
                                //a level of calibration has finished
                                //If it was the last level, we are now done
                                currentlevel++;
                                Debug.WriteLine(" successfully finished a level of calibration runs");
                                if (run_number == maxruns - 1)
                                {
                                    Debug.WriteLine(" successfully finished last level of calibration runs");
                                    calib_finish_report();
                                }
                                else
                                {
                                    Debug.WriteLine(" setting new ratios ");
                                    //CALIB_USER INPUT NEEDED HERE IN CODE
                                    //check whether the best run was on the edge of parameter space or inside, shift to that place and zoom out or in
                                    if (version_lux_checkbox.Checked)
                                    {
                                        calib_shift_and_zoom(0, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_K_textbox.Text));
                                    }
                                    if (version_Konza_checkbox.Checked)
                                    {
                                        calib_shift_and_zoom(0, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_K_textbox.Text));
                                        calib_shift_and_zoom(1, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_diffusivity_textbox.Text));
                                        calib_shift_and_zoom(2, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_P0_textbox.Text));
                                        calib_shift_and_zoom(3, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_k1_textbox.Text));
                                        calib_shift_and_zoom(4, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_k2_textbox.Text));
                                    }
                                    if(version_CarboZALF_checkbox.Checked)
                                    {
                                        calib_shift_and_zoom(0, double.Parse(calibration_ratio_reduction_parameter_textbox.Text), double.Parse(parameter_tillage_constant_textbox.Text));
                                    }

                                }
                            }
                            else
                            {
                                //nothing. Parameter values are adapted with the corresponding ratios to continue calibration above.
                            }
                        }

                    } // exit point for consecutive runs
                } // end try
            }
            catch
            {
                Debug.WriteLine("Error in accessing file " + this.dtm_input_filename_textbox.Text);
            }

        }  //end main

        private void calculate_overwater_landscape_Spitsbergen()
        {
            //to account for a landscape that is isostaically rebounding from below sealevel to above sealevel. 
            //height above sealevel itself is not important, just that the landscape grows over time
            //therefore, Marijn's solution: if (elevation < threshold(t)) , then elevation = nodata
            double minimum_overwater_elevation = (10263 - t) / 218;
            for (row = 0; row < nr; row++)
            {
                for (col = 0; col < nc; col++)
                {

                    if (original_dtm[row, col] != -9999)
                    {

                        if (original_dtm[row, col] > minimum_overwater_elevation && dtm[row, col] == -9999)
                        {
                            // these cases were not over water, but now will be.
                            dtm[row, col] = original_dtm[row, col];
                            // all cases that were already overwater, will stay overwater - no changes there.
                        }
                    }
                    else
                    {
                        // nothing happens because these cells are simply not part of the study area
                    }
                }
            }
        }

        private void every_timestep()    //performs actions in every timestep
        {
            // If a cell should remain at the same fixed elevation (e.g. fixed elevation boundary condition), here the cell can be selected
            if (OSL_checkbox.Checked)
            {
                update_and_bleach_OSL_ages();
            }

            if (CN_checkbox.Checked)
            {
                update_cosmogenic_nuclides();
            }

            if (daily_water.Checked)
            //if (nr > 50 & nc > 100)
            {
                //if (t == t_intervene) { dtm00 = dtm[50, 100]; }

                //// force no-change boundary op de outlet CLORPT
                //dtm[50, 100] = dtm00;

            }

            DateTime geo_start, pedo_start, hydro_start;

            //if (t == 0 | t == 1) { displaysoil(50, 0); }
            int i = 0;
            Task.Factory.StartNew(() =>
            {
                this.TimeStatusPanel.Text = "time " + (t + 1) + "/" + end_time;
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            // Debug.WriteLine("starting calculations - TIME " + t);

            if (Spitsbergen_case_study.Checked)
            { calculate_overwater_landscape_Spitsbergen(); }

            #region hydrological processes
            hydro_start = DateTime.Now;
            if (daily_water.Checked)
            {
                water_balance();

            }
            hydro_t += DateTime.Now - hydro_start;
            #endregion

            #region Vegetation
            // Debug.WriteLine("before vegetation");
            if (daily_water.Checked)
            {
                determine_vegetation_type();
                change_vegetation_parameters();
            }
            if (version_lux_checkbox.Checked)
            {
                soil_litter_cycle();
            }
            #endregion

            #region Geomorphic processes
            geo_start = DateTime.Now;

            //Debug.WriteLine("before WE");
            //displaysoil(0, 0);
            if (water_ero_active)
            {
                initialise_every();
                comb_sort();

                if (daily_water.Checked)
                {
                    calculate_water_ero_sed_daily();
                    soil_update_split_and_combine_layers();
                }
                else
                {
                    //Debug.WriteLine("before annual WE2");
                    findsinks();
                    searchdepressions();
                    define_fillheight_new();
                    if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before erosed"); }
                    //Debug.WriteLine("before annual calc WE2");
                    calculate_water_ero_sed();
                    soil_update_split_and_combine_layers();

                    if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after erosed"); }
                    if (crashed) { Debug.WriteLine("crashed while calculating water erosion"); }
                    
                }
            }

            //Debug.WriteLine("before TF");
            if (treefall_checkbox.Checked)
            {
                bool tf_bool = true;
                if(daily_water.Checked)
                {
                    if (t <= (end_time - 300)) // if there is no tillage
                    {
                        tf_bool = false;
                    }
                }
                if (tf_bool) { calculate_tree_fall(); }
            }

            if (bedrock_weathering_active)
            {
                calculate_bedrock_weathering();
                soil_update_split_and_combine_layers();
            }
            if (creep_active)
            {
                try
                { //Debug.WriteLine("calculating creep");
                    comb_sort();

                    calculate_creep();

                    soil_update_split_and_combine_layers();
                }
                catch { Debug.WriteLine(" failed during creep calculations"); }
            }

            if (blocks_active == 1)
            {
                try
                {
                    hardlayer_breaking();
                    Debug.WriteLine(" broke hard layer");
                    block_weathering();
                    //Debug.WriteLine(" weathered blocks");
                    block_movement();
                    //Debug.WriteLine(" moved blocks");
                    if (t % 1 == 0 | t > 3995)
                    {
                        string outblocks = (workdir + "\\" + "outblocks" + t + ".txt");
                        out_blocks(outblocks);
                        string outopenness = (workdir + "\\" + "openness" + t + ".asc");
                        out_float(outopenness, hardlayeropenness_fraction);
                        if (blocks_active == 1)
                        {
                            Debug.WriteLine("topo control on rolling: " + topoconttoroll + " creep control " + creepconttoroll + " creep control ratio: " + (creepconttoroll / (creepconttoroll + topoconttoroll)));
                            Debug.WriteLine("blocks produced: " + blocksproduced + " rolls: " + blocksrolled + " rolls per block: " + (blocksrolled / blocksproduced));
                        }
                    }
                }
                catch { Debug.WriteLine(" failed during block calculations"); }
            }

            // Debug.WriteLine("before TI");
            //displaysoil(0, 0);
            if (tillage_active)
            {
                comb_sort();
                int tilltime = 0;
                if (check_time_till_fields.Checked) { tilltime = till_record[t]; }
                else { tilltime = 1; }

                // Update tillage depth based on year. MvdM develop for Monte Carlo analysis
                plough_depth = 0.06;
                if (end_time - t < 1470) { plough_depth = 0.115; }
                if (end_time - t < 223) { plough_depth = 0.16; }
                if (end_time - t < 61) { plough_depth = 0.275; }
                if (end_time - t < 31) { plough_depth = 0.20; }
                if (end_time - t == 214) // Shift to entire field ploughing
                {
                    output_time = 10; // set output to every 10 years
                    for (row = 0; row < nr; row++)
                    {
                        for (col = 0; col < nc; col++)
                        {
                            tillfields[row, col] = 1;
                        }
                    }
                }

                if (tilltime == 1)
                {

                    initialise_every_till();
                    calculate_tillage();
                    soil_update_split_and_combine_layers();
                }

            }

            //Debug.WriteLine("after TI");
            //displaysoil(0, 0);
            if (landslide_active)
            {
                Debug.WriteLine("calculating landsliding");
                comb_sort();
                ini_slope();
                calculate_critical_rain();
                calculate_slide();
            }

            geo_t += DateTime.Now - geo_start;

            #endregion

            #region Pedogenic processes

            pedo_start = DateTime.Now;

            // Debug.WriteLine("before PW");
            //displaysoil(0, 0);
            if (soil_phys_weath_active)
            {
                // Debug.WriteLine("calculating soil physical weathering");
                if (Spitsbergen_case_study.Checked == false) { soil_physical_weathering(); }
                else
                {
                    SPITS_soil_physical_weathering();
                    SPITS_aeolian_deposition();
                }
                soil_update_split_and_combine_layers();

            }
            // Debug.WriteLine("before CW");
            //displaysoil(0, 0);
            if (soil_chem_weath_active)
            {
                //Debug.WriteLine("calculating soil chemical weathering");
                soil_chemical_weathering();
                soil_update_split_and_combine_layers();
                if (timeseries.total_average_soilthickness_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[29]] = total_average_soilthickness_m;
                }
                if (timeseries.timeseries_number_soil_thicker_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[30]] = number_soil_thicker_than;
                }
                if (timeseries.timeseries_coarser_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[31]] = number_soil_coarser_than;
                }
                if (timeseries.timeseries_soil_depth_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[32]] = local_soil_depth_m;
                }
                if (timeseries.timeseries_soil_mass_checkbox.Checked)
                {
                    timeseries_matrix[t, timeseries_order[33]] = local_soil_mass_kg;
                }
            }

            // Debug.WriteLine("before CT");
            //displaysoil(0, 0);
            if (soil_clay_transloc_active)
            {
                // Debug.WriteLine("calculating soil clay dynamics ");

                if (Spitsbergen_case_study.Checked == true)
                {
                    soil_silt_translocation(); // Spitsbergen case study
                }
                else
                {
                    if (ct_Jagercikova.Checked == true)
                    {
                        soil_clay_translocation_Jagercikova();
                    }
                    else
                    {
                        soil_clay_translocation();
                    }
                }
                soil_update_split_and_combine_layers();
                if (NA_in_map(dtm) > 0 | NA_in_map(soildepth_m) > 0)
                {
                    Debug.WriteLine("err_ets1");
                }

            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found before soil carbon"); }
            //displaysoil(0, 0);
            if (soil_carbon_active)
            {
                // Debug.WriteLine("calculating carbon dynamics ");
               
                soil_carbon_cycle();
                soil_update_split_and_combine_layers();
                
            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after soil carbon"); }
            if (decalcification_checkbox.Checked)
            {
                //Debug.WriteLine("calculating decalcification");
                soil_decalcification();
            }

            if (soil_bioturb_active)
            {
                for (int row = 0; row < nr; row++)
                {
                    for (int col = 0; col < nc; col++)
                    {
                        update_all_layer_thicknesses(row, col);
                    }
                }
                // Debug.WriteLine("calculating bioturbation");
                soil_bioturbation();
                // if (findnegativetexture()) { Debugger.Break(); }

                soil_update_split_and_combine_layers();
                // if (findnegativetexture()) { Debugger.Break(); }

            }
            if (NA_anywhere_in_soil() == true) { Debug.WriteLine("NA found after soil bioturb"); }

            pedo_t += DateTime.Now - pedo_start;

            #endregion

            #region write output

            // Debug.WriteLine("before output");
            numfile++;

            int t_out = t + 1;
            if ((Final_output_checkbox.Checked && t_out == end_time) || (Regular_output_checkbox.Checked && ((t_out) % output_time == 0)))
            {
                if (t == end_time - 1)
                {

                    Debug.WriteLine("Time balance. Geomorphic processes: {0} min, pedogenic processes: {1} min, hydrologic processes: {2} min, ponding {3} min", geo_t, pedo_t, hydro_t, ponding_t);
                    // Debug.WriteLine("Time balance OSL methods. Long matrix: {0} min. Jagged array: {1} min.", OSL_matrix_t, OSL_JA_t);
                }
                //Debug.WriteLine("Attempting to write outputs");

                // displaysoil(31, 12);
                // Debug.WriteLine("Total catchment mass = " + total_catchment_mass());

                if (daily_water.Checked)
                {
                    Debug.WriteLine("writing daily water");

                    //try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_aridity.asc", aridity_vegetation); }
                    //catch { MessageBox.Show("vegetation has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_infiltration_m.asc", Iy); }
                    catch { MessageBox.Show("infiltration has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_actual_evapotranspiration_m.asc", ETay); }
                    catch { MessageBox.Show("ETa has not been written"); }

                    try
                    {
                        out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_vegetationtype.asc", vegetation_type);
                        for (int row = 0; row < nr; row++)
                        {
                            for (int col = 0; col < nc; col++)
                            {
                                vegetation_type[row, col] = 0; // reset vegetation_type, to give the output per output period
                            }
                        }
                    }
                    catch { MessageBox.Show("vegetation type has not been written"); }
                }

                if (version_lux_checkbox.Checked == true)
                {
                    try
                    {
                        // outputs for case study Luxembourg. Focus on different litter types
                        // young labile OM is hornbeam, old stable OM is beech
                        // Outputs:
                        // SOM stocks entire profile: total, young, old (kg/m2)
                        // top layer: total, old, young (-) 

                        string[] litter_types = { "hornbeam", "beech", "total" };
                        string[] litter_outputs = { "stocks_kgm2", "toplayer_frac" };

                        foreach (string type in litter_types) // loop over different SOM types
                        {
                            // determine which SOM fraction should be considered
                            bool h_bool = false; bool b_bool = false;
                            if (type == "hornbeam") { h_bool = true; }
                            if (type == "beech") { b_bool = true; }
                            if (type == "total") { h_bool = true; b_bool = true; }

                            foreach (string output in litter_outputs)
                            {
                                // determine which layers to consider and what to calculate
                                int numberoflayers = 0;
                                if (output == "stocks_kgm2") { numberoflayers = max_soil_layers; }
                                if (output == "toplayer_frac") { numberoflayers = 1; }

                                double[,] output_litter_map = new double[nr, nc];
                                for (int row = 0; row < nr; row++)
                                {
                                    for (int col = 0; col < nc; col++)
                                    {
                                        double litterstock_kg = 0;
                                        double mineralsoil_toplayer_kg = 0;
                                        if (h_bool) { litterstock_kg += litter_kg[row, col, 0]; }
                                        if (b_bool) { litterstock_kg += litter_kg[row, col, 1]; }

                                        if (output == "toplayer_frac")
                                        {
                                            for (int tex = 0; tex < 5; tex++)
                                            {
                                                mineralsoil_toplayer_kg += texture_kg[row, col, 0, tex];
                                            }
                                        }

                                        if (output == "toplayer_frac") { litterstock_kg /= (mineralsoil_toplayer_kg + litterstock_kg); } // calculate to fraction
                                        if (output == "stocks_kgm2") { litterstock_kg /= (dx * dx); } // calculate to kg/m2
                                        output_litter_map[row, col] = litterstock_kg;
                                    }
                                }
                                try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_litter_" + type + "_" + output + ".asc", output_litter_map); }
                                catch { MessageBox.Show("litter output has not been written"); }
                            }
                        }
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_TPI.asc", tpi); }
                        catch { MessageBox.Show("TPI output has not been written"); }

                        /* CODE BLOCK BELOW WRITES OUT DIFFERENT ORGANIC MATTER MAPS. THIS IS NOT NECESSARY ANYMORE NOW LITTER IS STORED IN ITS OWN MATRIX
                         * 
                        // outputs for case study Luxembourg. Focus on different organic matter types
                        // young labile OM is hornbeam, old stable OM is beech
                        // Outputs:
                        // SOM stocks entire profile: total, young, old (kg/m2)
                        // top layer: total, old, young (-) 

                        string[] SOM_types = { "young", "old", "total" };
                        string[] SOM_outputs = { "stocks_kgm2", "toplayer_frac" };

                        foreach (string type in SOM_types) // loop over different SOM types
                        {
                            // determine which SOM fraction should be considered
                            bool y_bool = false; bool o_bool = false;
                            if (type == "young") { y_bool = true; }
                            if (type == "old") { o_bool = true; }
                            if (type == "total") { y_bool = true; o_bool = true; }

                            foreach (string output in SOM_outputs)
                            {
                                // determine which layers to consider and what to calculate
                                int numberoflayers = 0;
                                if (output == "stocks_kgm2") { numberoflayers = max_soil_layers; }
                                if (output == "toplayer_frac") { numberoflayers = 1; }

                                double[,] output_SOM_map = new double[nr, nc] ;
                                for (int row = 0; row < nr; row++)
                                {
                                    for (int col = 0; col < nc; col++)
                                    {
                                        double SOMstock_kg = 0;
                                        double mineralsoil_kg = 0;
                                        for (int lay = 0; lay < numberoflayers; lay++)
                                        {
                                            if (y_bool) { SOMstock_kg += young_SOM_kg[row, col, lay]; }
                                            if (o_bool) { SOMstock_kg += old_SOM_kg[row, col, lay]; }

                                            if (output == "toplayer_frac")
                                            {
                                                for (int tex = 0; tex < 5; tex++)
                                                {
                                                    mineralsoil_kg += texture_kg[row, col, lay, tex];
                                                }
                                            }
                                        }
                                        if (output == "toplayer_frac") { SOMstock_kg /= (mineralsoil_kg + SOMstock_kg); } // calculate to fraction
                                        if (output == "stocks_kgm2") { SOMstock_kg /= (dx * dx); } // calculate to kg/m2
                                        output_SOM_map[row, col] = SOMstock_kg;
                                    }
                                }
                                try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_SOM_" + type + "_" + output + ".asc", output_SOM_map); }
                                catch { MessageBox.Show("SOM output has not been written"); }
                            }
                        }
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_TPI.asc", tpi); }
                        catch { MessageBox.Show("TPI output has not been written"); }

                        */
                    }
                    catch
                    {
                        Debug.WriteLine("Error in writing litterwater_ outputs for Luxembourg case study");
                    }
                }

                try
                {
                    //Debug.WriteLine("writing all soils");
                    writeallsoils(workdir + "\\" + run_number + "_" + t_out + "_out_allsoils.csv");
                }
                catch
                {
                    Debug.WriteLine("Failed during writing of soils");
                }

                if (Altitude_output_checkbox.Checked)
                {

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dtm.asc", dtm); }
                    catch { MessageBox.Show("dtm has not been written"); }

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dz_soil.asc", dz_soil); }
                    catch { MessageBox.Show("dz_soil has not been written"); }

                    //try { out_double(workdir + "\\" + run_number + "_" + t + "_out_dzero.asc", dz_ero_m); }
                    //catch { MessageBox.Show("dzero has not been written"); }
                    //try { out_double(workdir + "\\" + run_number + "_" + t + "_out_dzsed.asc", dz_sed_m); }
                    //catch { MessageBox.Show("dzsed has not been written"); }
                }
                if (treefall_checkbox.Checked)
                {
                    try
                    {
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dz_treefall.asc", dz_treefall);
                        out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_treefallcount.asc", treefall_count);

                    }
                    catch { MessageBox.Show("treefall has not been written"); }
                }
                if (Soildepth_output_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_soildepth.asc", soildepth_m); }
                    catch { MessageBox.Show("soildepth has not been written"); }
                }
                if (Alt_change_output_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_change.asc", dtmchange_m); }
                    catch { MessageBox.Show("change has not been written"); }
                }

                if (water_output_checkbox.Checked & Water_ero_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing water flow");

                    try
                    {
                        if (daily_water.Checked)
                        {
                            for (int roww = 0; roww < nr; roww++)
                            {
                                for (int colw = 0; colw < nc; colw++)
                                {
                                    waterflow_m3[roww, colw] = OFy_m[roww, colw, 0];
                                }
                            }
                        }
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_out_water.asc", waterflow_m3);
                    }
                    catch { MessageBox.Show("water has not been written"); }
                }
                if (depressions_output_checkbox.Checked)
                {
                    try { out_integer(workdir + "\\" + run_number + "_" + t_out + "_out_depress.asc", depression); }
                    catch { MessageBox.Show("depressions have not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dtmfillA.asc", dtmfill_A); }
                    catch { MessageBox.Show("dfmfill has not been written"); }
                }
                if (diagnostic_output_checkbox.Checked)
                {
                    //try { out_double(workdir + "\\" + t + "_out_sedintrans.asc", sediment_in_transport); }
                    //catch {  MessageBox.Show("sed in trans has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dzero.asc", dz_ero_m); }
                    catch { MessageBox.Show("dzero has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_dzsed.asc", dz_sed_m); }
                    catch { MessageBox.Show("dzsed has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_lakesed.asc", lake_sed_m); }
                    catch { MessageBox.Show("lakesed has not been written"); }
                }

                if (Water_ero_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing water erosion");

                    if (all_process_output_checkbox.Checked)
                    {
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_water_erosion.asc", sum_water_erosion); }
                        catch { MessageBox.Show("water erosion has not been written"); }
                    }
                }
                if (creep_active_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing creep");

                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_creep.asc", creep); }
                    catch { MessageBox.Show("creep has not been written"); }

                }

                if (Tillage_checkbox.Checked)
                {
                    // Debug.WriteLine("before writing tillage erosion");

                    if (all_process_output_checkbox.Checked)
                    {
                        try { out_double(workdir + "\\" + run_number + "_" + t_out + "_out_tillage.asc", sum_tillage); }
                        catch { MessageBox.Show("tillage has not been written"); }
                    }
                }

                if (OSL_checkbox.Checked)
                {
                    try
                    {
                        writeOSLages(workdir + "\\" + run_number + "_" + t_out + "_out_OSL_ages.csv");
                    }
                    catch
                    {
                        Debug.WriteLine("OSl ages have not been written");
                    }
                }
                if (Landslide_checkbox.Checked)
                {
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_crrain.asc", crrain); }
                    catch { MessageBox.Show("crrain has not been written"); }
                    try { out_double(workdir + "\\" + run_number + "_" + t_out + "_ca.asc", camf); }
                    catch { MessageBox.Show("ca has not been written"); }
                }

                if (decalcification_checkbox.Checked)
                {
                    try
                    {
                        double[,] decalcification_depth = new double[nr, nc];
                        for (int rowdec = 0; rowdec < nr; rowdec++)
                        {
                            for (int coldec = 0; coldec < nc; coldec++)
                            {
                                bool decal_written = false;
                                if (dtm[rowdec, coldec] != -9999)
                                {
                                    double depthdec = 0;
                                    int laydec = 0;
                                    while (decal_written == false)
                                    {
                                        if (CO3_kg[rowdec, coldec, laydec] == 0 && (laydec != (max_soil_layers - 1)))
                                        {
                                            if (laydec < (max_soil_layers - 1))
                                            {
                                                laydec++;
                                                depthdec += layerthickness_m[rowdec, coldec, laydec];
                                            }

                                        }
                                        else
                                        {
                                            decalcification_depth[rowdec, coldec] = depthdec;
                                            decal_written = true;
                                        }
                                    }
                                }
                            }
                        }
                        out_double(workdir + "\\" + run_number + "_" + t_out + "_decaldepth.asc", decalcification_depth);
                    }
                    catch
                    {
                        MessageBox.Show("decalcification has not been written");
                    }
                }

                if (profile.radio_pro1_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro1_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_1_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p1_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_1_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro2_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro2_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_2_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p2_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_2_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro3_col.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_dtm_" + run_number + "_" + t_out + ".asc", dtm, false, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, false, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                if (profile.radio_pro3_row.Checked)
                {
                    if (profile.check_altitude_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_dtm_" + run_number + "_" + t_out + ".asc", dtm, true, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_dtm_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                    if (profile.check_waterflow_profile1.Checked)
                    {
                        try { out_profile(workdir + "\\profile_3_water_" + run_number + "_" + t_out + ".asc", waterflow_m3, true, System.Convert.ToInt32(profile.p3_row_col_box.Text)); }
                        catch { MessageBox.Show("profile_3_water_" + run_number + "_" + t_out + ".asc has not been written"); }
                    }
                }
                //Debug.WriteLine("after outputs");

            }

            if (t == end_time - 1)
            {
                Task.Factory.StartNew(() =>
                {
                    this.InfoStatusPanel.Text = " --scenario finished--";
                }, CancellationToken.None, TaskCreationOptions.None, guiThread);
                stopwatch.Stop();
                Debug.WriteLine("Most recent scenario: " + stopwatch.Elapsed);
                //Timeseries output
                if (number_of_outputs > 0) { timeseries_output(); }
            }
            #endregion

        }

        private void comb_sort()      //sorts the data cells in a dtm in order of increasing altitude
        {
            // comb sorting by Wlodek Dobosiewicz in 1980
            // http://en.wikipedia.org/wiki/Comb_sort
            // LORICA adaptation by Arnaud Temme june 2009
            //Debug.WriteLine("sorting. nr " + nr + " nc " + nc + " t " + t);
            /*
            Task.Factory.StartNew(() =>
            {
                this.InfoStatusPanel.Text = "sorting";
            }, CancellationToken.None, TaskCreationOptions.None, guiThread);
            */
            int i = 0;
            double dtm_temp = 0;
            int row_temp = 0, col_temp = 0;
            string rowcol_temp;
            //Debug.WriteLine("sorting. nr " + nr + " nc " + nc + " t " + t);
            if (t == t_intervene)  // only in the first timestep;
            {
                //Debug.WriteLine("normal sorting. nr " + nr + " nc " + nc + " t " + t);
                number_of_data_cells = 0;
                for (int row = 0; row < nr; row++)  // why not do this only in the first timestep? And use the existing one as input in subsequent timesteps?
                {
                    for (int col = 0; col < nc; col++)
                    {
                        if (dtm[row, col] != -9999)
                        {
                            index[i] = dtm[row, col]; row_index[i] = row; col_index[i] = col; rowcol_index[i] = row.ToString() + "." + col.ToString();
                            i++;
                        }
                    }
                }
                number_of_data_cells = i;
            }
            else
            {
                //Debug.WriteLine("alternative sorting. nr " + nr + " nc " + nc + " t " + t);
                for (i = 0; i < number_of_data_cells; i++)
                {
                    index[i] = dtm[row_index[i], col_index[i]];     //merely update the existing index with the adapted altitudes and then sort     
                }
            }
            //displayonscreen(0, 0);
            //Task.Factory.StartNew(() =>
            //{
            //    this.InfoStatusPanel.Text = "data cells: " + number_of_data_cells;
            //}, CancellationToken.None, TaskCreationOptions.None, guiThread);
            //Debug.WriteLine("\n--sorting overview--");
            //Debug.WriteLine("Sorting " + number_of_data_cells + " cells");
            long gap = number_of_data_cells;
            bool swaps;
            long total_swaps = 0;
            //while (gap > 1 && swaps == true)  // in freak? situations, swaps may be false for gap = x, but true for subsequent values of gap
            while (gap > 1)
            {
                if (gap > 1)
                {
                    if (gap == 2) { gap = 1; }
                    gap = Convert.ToInt64(gap / 1.2);
                }
                i = 0;
                swaps = false;
                //this.InfoStatusPanel.Text = "i " + i + " gap " + gap + " tot swaps " + total_swaps;
                //Debug.WriteLine("i " + i + " gap " + gap + " tot swaps " + total_swaps);
                while (i + gap < number_of_data_cells)
                {
                    //if (gap == Convert.ToInt64(number_of_data_cells / 1.2) && i < 10) {Debug.WriteLine("    i " + i + " gap " + gap + " tot swaps " + total_swaps + " alt1 " + index[i] + " (" + row_index[i] + "," + col_index[i] + ") alt2 " + index[i+gap] + " (" + row_index[i+gap] + "," + col_index[i+gap] + ")"); }
                    if (index[i] > index[i + gap])
                    {
                        dtm_temp = index[i]; index[i] = index[i + gap]; index[i + gap] = dtm_temp;
                        row_temp = row_index[i]; row_index[i] = row_index[i + gap]; row_index[i + gap] = row_temp;
                        col_temp = col_index[i]; col_index[i] = col_index[i + gap]; col_index[i + gap] = col_temp;
                        rowcol_temp = rowcol_index[i]; rowcol_index[i] = rowcol_index[i + gap]; rowcol_index[i + gap] = rowcol_temp;
                        swaps = true;
                        total_swaps++;
                    } // end if
                    i++;
                }  // end while
                   //if (gap < 4) { Debug.WriteLine("i " + i + " gap " + gap + " tot swaps " + total_swaps); }
            } //end while
            int sorting_error = 0;
            for (i = 0; i < number_of_data_cells - 1; i++)
            {
                if (index[i] > index[i + 1]) { sorting_error = 1; }
            }
            if (sorting_error == 1)
            {
                Debug.WriteLine(" Sorting error in comb_sort ");
            }
            else
            {
                //Debug.WriteLine(" Sorting test successful ");
            }
        }
        #endregion
    }

}

